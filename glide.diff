diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/.github/ISSUE_TEMPLATE/release-checklist.md updated/vendor/github.com/coreos/fcct/.github/ISSUE_TEMPLATE/release-checklist.md
1,48d0
< Release checklist:
< 
< Tagging:
<  - [ ] Write release notes in NEWS. Get them reviewed and merged
<      - [ ] If doing a branched release, also include a PR to merge the NEWS changes into master
<  - [ ] Ensure your local copy is up to date with the upstream master branch (`git@github.com:coreos/fcct.git`)
<  - [ ] Ensure your working directory is clean (`git clean -fdx`)
<  - [ ] Ensure you can sign commits and any yubikeys/smartcards are plugged in
<  - [ ] Run `./tag_release.sh <vX.Y.z> <git commit hash>`
<  - [ ] Push that tag to GitHub
< 
< Packaging:
<  - [ ] Update the FCCT spec file in [Fedora](https://src.fedoraproject.org/rpms/fedora-coreos-config-transpiler):
<    - Bump the `Version`
<    - Switch the `Release` back to `1.git%{shortcommit}%{?dist}`
<    - Remove any patches obsoleted by the new release
<    - Run `go-mods-to-bundled-provides.py | sort` while inside of the fcct directory you ran `./tag_release` from & copy output into spec file in `# Main package provides` section
<    - Update change log
<  - [ ] Run `spectool -g -S fedora-coreos-config-transpiler.spec`
<  - [ ] Run `kinit your_fas_account@FEDORAPROJECT.ORG`
<  - [ ] Run `fedpkg new-sources tarball-name`
<  - [ ] PR the changes in [Fedora](https://src.fedoraproject.org/rpms/fedora-coreos-config-transpiler)
<  - [ ] Once the PR merges to master, merge master into the other relevant branches (e.g. f30) then push those
<  - [ ] On each of those branches run `fedpkg build`
<  - [ ] Once the builds have finished, submit them to [bodhi](https://bodhi.fedoraproject.org/updates/new), filling in:
<    - `fedora-coreos-config-transpiler` for `Packages`
<    - Selecting the build(s) that just completed, except for the rawhide one (which gets submitted automatically)
<    - Writing brief release notes like "New upstream release. See release notes at `link to NEWS on GH tag`"
<    - Leave `Update name` blank
<    - `Type`, `Severity` and `Suggestion` can be left as `unspecified` unless it is a security release. In that case select `security` which the appropriate severity.
<    - `Stable karma` and `Unstable` karma can be set to `2` and `-1`, respectively.
< 
< GitHub release:
<  - [ ] Wait until the Bodhi update shows "Signed :heavy_check_mark:" in the Metadata box.
<  - [ ] [File a releng ticket](https://pagure.io/releng/new_issue) based on [prior signing tickets](https://pagure.io/releng/issue/9489).
<    - [ ] Update the script and test it locally by dropping the `sigul` lines.
<  - [ ] Ping `mboddu` in Freenode `#fedora-coreos`, linking to the ticket
<  - [ ] Wait for the ticket to be closed
<  - [ ] Download the artifacts and signatures
<  - [ ] Verify the signatures
<  - [ ] Find the new tag in the [GitHub tag list](https://github.com/coreos/fcct/tags) and click the triple dots menu, and create a draft release for it.
<  - [ ] Upload all the release artifacts and their signatures. Copy and paste the release notes from NEWS here as well.
<  - [ ] Publish the release
< 
< Quay release:
<  - [ ] Visit the [Quay tags page](https://quay.io/repository/coreos/fcct?tab=tags) and wait for a versioned tag to appear
<  - [ ] Click the gear next to the tag, select "Add New Tag", enter `release`, and confirm
< 
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/.gitignore updated/vendor/github.com/coreos/fcct/.gitignore
1,2d0
< /bin
< /tmpdocs
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/.travis.yml updated/vendor/github.com/coreos/fcct/.travis.yml
1,12d0
< language: go
< go:
<   - "1.12.x"
< 
< services:
<   - docker
< 
< install: echo nop
< 
< script:
<   - ./test
<   - docker build .
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/Dockerfile updated/vendor/github.com/coreos/fcct/Dockerfile
1,9d0
< FROM golang:latest AS builder
< RUN mkdir /fcct
< COPY . /fcct
< WORKDIR /fcct
< RUN ./build_releases
< 
< FROM scratch
< COPY --from=builder /fcct/bin/releases/fcct-x86_64-unknown-linux-gnu /usr/local/bin/fcct
< ENTRYPOINT ["/usr/local/bin/fcct"]
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/LICENSE updated/vendor/github.com/coreos/fcct/LICENSE
1,202d0
< Apache License
<                            Version 2.0, January 2004
<                         http://www.apache.org/licenses/
< 
<    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
< 
<    1. Definitions.
< 
<       "License" shall mean the terms and conditions for use, reproduction,
<       and distribution as defined by Sections 1 through 9 of this document.
< 
<       "Licensor" shall mean the copyright owner or entity authorized by
<       the copyright owner that is granting the License.
< 
<       "Legal Entity" shall mean the union of the acting entity and all
<       other entities that control, are controlled by, or are under common
<       control with that entity. For the purposes of this definition,
<       "control" means (i) the power, direct or indirect, to cause the
<       direction or management of such entity, whether by contract or
<       otherwise, or (ii) ownership of fifty percent (50%) or more of the
<       outstanding shares, or (iii) beneficial ownership of such entity.
< 
<       "You" (or "Your") shall mean an individual or Legal Entity
<       exercising permissions granted by this License.
< 
<       "Source" form shall mean the preferred form for making modifications,
<       including but not limited to software source code, documentation
<       source, and configuration files.
< 
<       "Object" form shall mean any form resulting from mechanical
<       transformation or translation of a Source form, including but
<       not limited to compiled object code, generated documentation,
<       and conversions to other media types.
< 
<       "Work" shall mean the work of authorship, whether in Source or
<       Object form, made available under the License, as indicated by a
<       copyright notice that is included in or attached to the work
<       (an example is provided in the Appendix below).
< 
<       "Derivative Works" shall mean any work, whether in Source or Object
<       form, that is based on (or derived from) the Work and for which the
<       editorial revisions, annotations, elaborations, or other modifications
<       represent, as a whole, an original work of authorship. For the purposes
<       of this License, Derivative Works shall not include works that remain
<       separable from, or merely link (or bind by name) to the interfaces of,
<       the Work and Derivative Works thereof.
< 
<       "Contribution" shall mean any work of authorship, including
<       the original version of the Work and any modifications or additions
<       to that Work or Derivative Works thereof, that is intentionally
<       submitted to Licensor for inclusion in the Work by the copyright owner
<       or by an individual or Legal Entity authorized to submit on behalf of
<       the copyright owner. For the purposes of this definition, "submitted"
<       means any form of electronic, verbal, or written communication sent
<       to the Licensor or its representatives, including but not limited to
<       communication on electronic mailing lists, source code control systems,
<       and issue tracking systems that are managed by, or on behalf of, the
<       Licensor for the purpose of discussing and improving the Work, but
<       excluding communication that is conspicuously marked or otherwise
<       designated in writing by the copyright owner as "Not a Contribution."
< 
<       "Contributor" shall mean Licensor and any individual or Legal Entity
<       on behalf of whom a Contribution has been received by Licensor and
<       subsequently incorporated within the Work.
< 
<    2. Grant of Copyright License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       copyright license to reproduce, prepare Derivative Works of,
<       publicly display, publicly perform, sublicense, and distribute the
<       Work and such Derivative Works in Source or Object form.
< 
<    3. Grant of Patent License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       (except as stated in this section) patent license to make, have made,
<       use, offer to sell, sell, import, and otherwise transfer the Work,
<       where such license applies only to those patent claims licensable
<       by such Contributor that are necessarily infringed by their
<       Contribution(s) alone or by combination of their Contribution(s)
<       with the Work to which such Contribution(s) was submitted. If You
<       institute patent litigation against any entity (including a
<       cross-claim or counterclaim in a lawsuit) alleging that the Work
<       or a Contribution incorporated within the Work constitutes direct
<       or contributory patent infringement, then any patent licenses
<       granted to You under this License for that Work shall terminate
<       as of the date such litigation is filed.
< 
<    4. Redistribution. You may reproduce and distribute copies of the
<       Work or Derivative Works thereof in any medium, with or without
<       modifications, and in Source or Object form, provided that You
<       meet the following conditions:
< 
<       (a) You must give any other recipients of the Work or
<           Derivative Works a copy of this License; and
< 
<       (b) You must cause any modified files to carry prominent notices
<           stating that You changed the files; and
< 
<       (c) You must retain, in the Source form of any Derivative Works
<           that You distribute, all copyright, patent, trademark, and
<           attribution notices from the Source form of the Work,
<           excluding those notices that do not pertain to any part of
<           the Derivative Works; and
< 
<       (d) If the Work includes a "NOTICE" text file as part of its
<           distribution, then any Derivative Works that You distribute must
<           include a readable copy of the attribution notices contained
<           within such NOTICE file, excluding those notices that do not
<           pertain to any part of the Derivative Works, in at least one
<           of the following places: within a NOTICE text file distributed
<           as part of the Derivative Works; within the Source form or
<           documentation, if provided along with the Derivative Works; or,
<           within a display generated by the Derivative Works, if and
<           wherever such third-party notices normally appear. The contents
<           of the NOTICE file are for informational purposes only and
<           do not modify the License. You may add Your own attribution
<           notices within Derivative Works that You distribute, alongside
<           or as an addendum to the NOTICE text from the Work, provided
<           that such additional attribution notices cannot be construed
<           as modifying the License.
< 
<       You may add Your own copyright statement to Your modifications and
<       may provide additional or different license terms and conditions
<       for use, reproduction, or distribution of Your modifications, or
<       for any such Derivative Works as a whole, provided Your use,
<       reproduction, and distribution of the Work otherwise complies with
<       the conditions stated in this License.
< 
<    5. Submission of Contributions. Unless You explicitly state otherwise,
<       any Contribution intentionally submitted for inclusion in the Work
<       by You to the Licensor shall be under the terms and conditions of
<       this License, without any additional terms or conditions.
<       Notwithstanding the above, nothing herein shall supersede or modify
<       the terms of any separate license agreement you may have executed
<       with Licensor regarding such Contributions.
< 
<    6. Trademarks. This License does not grant permission to use the trade
<       names, trademarks, service marks, or product names of the Licensor,
<       except as required for reasonable and customary use in describing the
<       origin of the Work and reproducing the content of the NOTICE file.
< 
<    7. Disclaimer of Warranty. Unless required by applicable law or
<       agreed to in writing, Licensor provides the Work (and each
<       Contributor provides its Contributions) on an "AS IS" BASIS,
<       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
<       implied, including, without limitation, any warranties or conditions
<       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
<       PARTICULAR PURPOSE. You are solely responsible for determining the
<       appropriateness of using or redistributing the Work and assume any
<       risks associated with Your exercise of permissions under this License.
< 
<    8. Limitation of Liability. In no event and under no legal theory,
<       whether in tort (including negligence), contract, or otherwise,
<       unless required by applicable law (such as deliberate and grossly
<       negligent acts) or agreed to in writing, shall any Contributor be
<       liable to You for damages, including any direct, indirect, special,
<       incidental, or consequential damages of any character arising as a
<       result of this License or out of the use or inability to use the
<       Work (including but not limited to damages for loss of goodwill,
<       work stoppage, computer failure or malfunction, or any and all
<       other commercial damages or losses), even if such Contributor
<       has been advised of the possibility of such damages.
< 
<    9. Accepting Warranty or Additional Liability. While redistributing
<       the Work or Derivative Works thereof, You may choose to offer,
<       and charge a fee for, acceptance of support, warranty, indemnity,
<       or other liability obligations and/or rights consistent with this
<       License. However, in accepting such obligations, You may act only
<       on Your own behalf and on Your sole responsibility, not on behalf
<       of any other Contributor, and only if You agree to indemnify,
<       defend, and hold each Contributor harmless for any liability
<       incurred by, or claims asserted against, such Contributor by reason
<       of your accepting any such warranty or additional liability.
< 
<    END OF TERMS AND CONDITIONS
< 
<    APPENDIX: How to apply the Apache License to your work.
< 
<       To apply the Apache License to your work, attach the following
<       boilerplate notice, with the fields enclosed by brackets "{}"
<       replaced with your own identifying information. (Don't include
<       the brackets!)  The text should be enclosed in the appropriate
<       comment syntax for the file format. We also recommend that a
<       file or class name and description of purpose be included on the
<       same "printed page" as the copyright notice for easier
<       identification within third-party archives.
< 
<    Copyright {yyyy} {name of copyright owner}
< 
<    Licensed under the Apache License, Version 2.0 (the "License");
<    you may not use this file except in compliance with the License.
<    You may obtain a copy of the License at
< 
<        http://www.apache.org/licenses/LICENSE-2.0
< 
<    Unless required by applicable law or agreed to in writing, software
<    distributed under the License is distributed on an "AS IS" BASIS,
<    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<    See the License for the specific language governing permissions and
<    limitations under the License.
< 
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/NEWS updated/vendor/github.com/coreos/fcct/NEWS
1,158d0
< 2020-12-04 FCCT 0.8.0
< 
<   Breaking Changes:
< 
<     - Restructure Go API
< 
<   Features:
< 
<     - Stabilize Fedora CoreOS spec 1.3.0, targeting Ignition spec 3.2.0
<     - Add Fedora CoreOS spec 1.4.0-experimental, targeting Ignition spec
<       3.3.0-experimental
<     - Add RHEL CoreOS spec 0.1.0, targeting Ignition spec 3.2.0
<     - Add RHEL CoreOS spec 0.2.0-experimental, targeting Ignition spec
<       3.3.0-experimental
<     - Add boot_device section for configuring boot device LUKS and mirroring
<       (fcos 1.3.0, rhcos 0.1.0)
< 
<   Bug Fixes:
< 
<     - Fix systemd-fsck@.service dependencies in generated mount units
< 
<   Misc Changes:
< 
<     - Warn if file/dir modes appear to have been specified in decimal
<     - Validate input in translation functions taking Go structs (Go API)
<     - Allow registering external translators (Go API)
<     - Allow specs to derive from other specs (Go API)
< 
<   Docs Changes:
< 
<     - Document Clevis custom and LUKS wipe_volume fields
<     - Add LUKS and mirroring examples
<     - Add password authentication example
< 
< 2020-10-23 FCCT 0.7.0
< 
<   Features:
< 
<     - Stabilize FCC spec 1.2.0, targeting Ignition spec 3.2.0
<     - Add FCC spec 1.3.0-experimental, targeting Ignition spec
<       3.3.0-experimental
<     - Add storage.luks section for creating LUKS2 encrypted volumes
<       (1.2.0)
<     - Add resize field for modifying partition size (1.2.0)
<     - Add should_exist field for deleting users & groups (1.2.0)
<     - Add NoResourceAutoCompression translate option to skip
<       automatic compression (Go API)
< 
<   Docs Changes:
< 
<     - Switch to GitHub Pages
< 
< 
< 2020-05-28 FCCT 0.6.0
< 
<   Features:
< 
<     - Stabilize FCC spec 1.1.0, targeting Ignition spec 3.1.0
<     - Add FCC spec 1.2.0-experimental, targeting Ignition spec
<       3.2.0-experimental
<     - Add inline field to TLS certificate authorities and config merge and
<       replace (1.1.0)
<     - Add local field for embedding contents from local file (1.1.0)
<     - Add storage.trees section for embedding local directory trees (1.1.0)
<     - Auto-select smallest encoding for inline or local contents (1.1.0)
<     - Add http_headers field for specifying HTTP headers on fetch (1.1.0)
< 
<   Bug Fixes:
< 
<     - Include mount options in generated mount units (1.1.0)
<     - Validate uniqueness constraints within FCC sections
<     - Omit empty values from output JSON
<     - Append newline to output
< 
<   Docs Changes:
< 
<     - Document support for CA bundles in Ignition >= 2.3.0
<     - Document support for sha256 resource verification (1.1.0)
<     - Clarify semantics of overwrite and mode fields
< 
< 
< 2020-03-23 FCCT 0.5.0
< 
<   Breaking Changes:
< 
<     - Previously, command-line options could be preceded by a single dash
<       (-strict) or double dash (--strict).  Accept only the double-dash form.
< 
<   Features:
< 
<     - Accept input filename directly on command line, without --input
<     - Add short equivalents of command-line options
< 
<   Bug Fixes:
< 
<     - Fail if unexpected non-option arguments are specified
< 
<   Misc Changes:
< 
<     - Deprecate --input and hide it from --help
<     - Document files[].append[].inline property
<     - Update docs for switch to Fedora signing keys
< 
< 
< 2020-01-24 FCCT 0.4.0
< 
<   Features:
< 
<     - Add mount_options field to filesystem entry
< 
<   Misc Changes:
< 
<     - Add "release" tag to container of latest release
<     - Vendor dependencies
< 
< 
< 2020-01-23 FCCT 0.3.0
< 
<   Features:
< 
<     - Add v1.1.0-experimental spec
<     - Add with_mount_unit field to generate mount unit from filesystem entry
< 
<   Bug Fixes:
< 
<     - Report warnings and errors to stderr, not stdout
<     - Truncate output file before writing
<     - Fix line and column reporting
< 
<   Misc Changes:
< 
<     - Document syntax of inline file contents
<     - Document usage of published container image
< 
< 
< 2019-07-24 FCCT 0.2.0
< 
<   Features:
< 
<     - Add --version flag
<     - Add Dockerfile and build containers automatically on quay.io
< 
<   Bug Fixes:
< 
<     - Fix validation of paths for files and directories
<     - Fix --output flag handling
< 
<   Misc Changes:
< 
<     - Add tests for the examples in the docs
<     - Add travis integration
< 
< 
< 2019-07-10 FCCT 0.1.0
< 
< Initial Release of FCCT. While the golang API is not stable, the Fedora CoreOS
< Configuration language is. Configs written with version 1.0.0 will continue to
< work with future releases of FCCT.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/README.md updated/vendor/github.com/coreos/fcct/README.md
1,55d0
< # Fedora CoreOS Config Transpiler
< 
< The Fedora CoreOS Config Transpiler (FCCT) translates human readable Fedora CoreOS Configs (FCCs)
< into machine readable [Ignition](https://github.com/coreos/ignition) Configs. See the [getting
< started](docs/getting-started.md) guide for how to use FCCT and the [configuration
< specifications](docs/specs.md) for everything FCCs support.
< 
< ### Project Layout
< 
< Internally, FCCT has a versioned `base` component which contains support for
< a particular Ignition spec version, plus distro-independent sugar. New base
< functionality is added only to the experimental base package. Eventually the
< experimental base package is stabilized and a new experimental package
< created. The base component is versioned independently of any particular
< distro, and its versions are not exposed to the user. Client code should
< not need to import anything from `base`.
< 
< Each FCC variant/version pair corresponds to a `config` package, which
< derives either from a `base` package or from another `config` package. New
< functionality is similarly added only to an experimental config version,
< which is eventually stabilized and a new experimental version created.
< (This will often happen when the underlying package is stabilized.) A
< `config` package can contain sugar or validation logic specific to a distro
< (for example, additional properties for configuring etcd).
< 
< Packages outside the FCCT repository can implement additional FCC versions
< by deriving from a `base` or `config` package and registering their
< variant/version pair with `config`.
< 
< `config/`
<   Top-level `TranslateBytes()` function that determines which config version
<   to parse and emit. Clients should typically use this to translate FCCs.
< 
< `config/common/`
<   Common definitions for all spec versions, including translate options
<   structs and error definitions.
< 
< `config/*/vX_Y/`
<   User facing definitions of the spec. Each is derived from another config
<   package or from a base package. Each one defines its own translate
<   functions to be registered in the `config` package. Clients can use
<   these directly if they want to translate a specific spec version.
< 
< `config/util/`
<   Utility code for implementing config packages, including the
<   (un)marshaling helpers. Clients don't need to import this unless they're
<   implementing an out-of-tree config version.
< 
< `base/`
<   Distro-agnostic code targeting individual Ignition spec versions. Clients
<   don't need to import this unless they're implementing an out-of-tree
<   config version.
< 
< `internal/`
<   `main`, non-exported code.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/util/file.go updated/vendor/github.com/coreos/fcct/base/util/file.go
1,146d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package util
< 
< import (
< 	"path/filepath"
< 	"strings"
< 
< 	"github.com/coreos/fcct/config/common"
< )
< 
< func EnsurePathWithinFilesDir(path, filesDir string) error {
< 	absBase, err := filepath.Abs(filesDir)
< 	if err != nil {
< 		return err
< 	}
< 	absPath, err := filepath.Abs(path)
< 	if err != nil {
< 		return err
< 	}
< 	if !strings.HasPrefix(absPath, absBase+string(filepath.Separator)) {
< 		return common.ErrFilesDirEscape
< 	}
< 	return nil
< }
< 
< /// CheckForDecimalMode fails if the specified mode appears to have been
< /// incorrectly specified in decimal instead of octal.
< func CheckForDecimalMode(mode int, directory bool) error {
< 	correctedMode, ok := decimalModeToOctal(mode)
< 	if !ok {
< 		return nil
< 	}
< 	if !isTypicalMode(mode, directory) && isTypicalMode(correctedMode, directory) {
< 		return common.ErrDecimalMode
< 	}
< 	return nil
< }
< 
< /// isTypicalMode returns true if the specified mode is unsurprising.
< /// It returns false for some modes that are unusual but valid in limited
< /// cases.
< func isTypicalMode(mode int, directory bool) bool {
< 	// no permissions is always reasonable (root ignores mode bits)
< 	if mode == 0 {
< 		return true
< 	}
< 
< 	// test user/group/other in reverse order
< 	perms := []int{mode & 0007, (mode & 0070) >> 3, (mode & 0700) >> 6}
< 	hadR := false
< 	hadW := false
< 	hadX := false
< 	for _, perm := range perms {
< 		r := perm&4 != 0
< 		w := perm&2 != 0
< 		x := perm&1 != 0
< 		// more-specific perm must have all the bits of less-specific
< 		// perm (r--rw----)
< 		if !r && hadR || !w && hadW || !x && hadX {
< 			return false
< 		}
< 		// if we have executable permission, it's weird for a
< 		// less-specific perm to have read but not execute (rwxr-----)
< 		if x && hadR && !hadX {
< 			return false
< 		}
< 		// -w- and --x are reasonable in special cases but they're
< 		// uncommon
< 		if (w || x) && !r {
< 			return false
< 		}
< 		hadR = hadR || r
< 		hadW = hadW || w
< 		hadX = hadX || x
< 	}
< 
< 	// must be readable by someone
< 	if !hadR {
< 		return false
< 	}
< 
< 	if directory {
< 		// must be executable by someone
< 		if !hadX {
< 			return false
< 		}
< 		// setuid forbidden
< 		if mode&04000 != 0 {
< 			return false
< 		}
< 		// setgid or sticky must be writable to someone
< 		if mode&03000 != 0 && !hadW {
< 			return false
< 		}
< 	} else {
< 		// setuid or setgid
< 		if mode&06000 != 0 {
< 			// must be executable to someone
< 			if !hadX {
< 				return false
< 			}
< 			// world-writable permission is a bad idea
< 			if mode&2 != 0 {
< 				return false
< 			}
< 		}
< 		// sticky forbidden
< 		if mode&01000 != 0 {
< 			return false
< 		}
< 	}
< 
< 	return true
< }
< 
< /// decimalModeToOctal takes a mode written in decimal and converts it to
< /// octal, returning (0, false) on failure.
< func decimalModeToOctal(mode int) (int, bool) {
< 	if mode < 0 || mode > 7777 {
< 		// out of range
< 		return 0, false
< 	}
< 	ret := 0
< 	for divisor := 1000; divisor > 0; divisor /= 10 {
< 		digit := (mode / divisor) % 10
< 		if digit > 7 {
< 			// digit not available in octal
< 			return 0, false
< 		}
< 		ret = (ret << 3) | digit
< 	}
< 	return ret, true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/util/file_test.go updated/vendor/github.com/coreos/fcct/base/util/file_test.go
1,125d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package util
< 
< import (
< 	"fmt"
< 	"strings"
< 	"testing"
< 
< 	"github.com/stretchr/testify/assert"
< )
< 
< var (
< 	expectedBadDirModes = []int{
< 		500,  // 0764
< 		550,  // 01046
< 		555,  // 01053
< 		700,  // 01274
< 		750,  // 01356
< 		755,  // 01363
< 		770,  // 01402
< 		775,  // 01407
< 		777,  // 01411
< 		1700, // 03244
< 		1750, // 03326
< 		1755, // 03333
< 		1770, // 03352
< 		1775, // 03357
< 		1777, // 03361
< 		2700, // 05214
< 		2750, // 05276
< 		2755, // 05303
< 		2770, // 05322
< 		2775, // 05327
< 		2777, // 05331
< 		3700, // 07164
< 		3750, // 07246
< 		3755, // 07253
< 		3770, // 07272
< 		3775, // 07277
< 		3777, // 07301
< 	}
< 	expectedBadFileModes = []int{
< 		400,  // 0620
< 		440,  // 0670
< 		444,  // 0674
< 		500,  // 0764
< 		550,  // 01046
< 		555,  // 01053
< 		600,  // 01130
< 		640,  // 01200
< 		644,  // 01204
< 		660,  // 01224
< 		664,  // 01230
< 		666,  // 01232
< 		700,  // 01274
< 		750,  // 01356
< 		755,  // 01363
< 		770,  // 01402
< 		775,  // 01407
< 		777,  // 01411
< 		2500, // 04704
< 		2550, // 04766
< 		2555, // 04773
< 		2700, // 05214
< 		2750, // 05276
< 		2755, // 05303
< 		2770, // 05322
< 		2775, // 05327
< 		4500, // 010624
< 		4550, // 010706
< 		4555, // 010713
< 		4700, // 011134
< 		4750, // 011216
< 		4755, // 011223
< 		4770, // 011242
< 		4775, // 011247
< 		6500, // 014544
< 		6550, // 014626
< 		6555, // 014633
< 		6700, // 015054
< 		6750, // 015136
< 		6755, // 015143
< 		6770, // 015162
< 		6775, // 015167
< 	}
< )
< 
< func TestCheckForDecimalMode(t *testing.T) {
< 	// test decimal to octal conversion
< 	for i := -1; i < 10001; i++ {
< 		iStr := fmt.Sprintf("%d", i)
< 		result, ok := decimalModeToOctal(i)
< 		assert.Equal(t, i >= 0 && i <= 7777 && !strings.ContainsAny(iStr, "89"), ok, "converting %d to octal returned incorrect ok", i)
< 		if ok {
< 			assert.Equal(t, iStr, fmt.Sprintf("%o", result), "converting %d to octal failed", i)
< 		}
< 	}
< 
< 	// check the checker against a hardcoded list
< 	var badDirModes []int
< 	var badFileModes []int
< 	for i := -1; i <= 10000; i++ {
< 		if CheckForDecimalMode(i, true) != nil {
< 			badDirModes = append(badDirModes, i)
< 		}
< 		if CheckForDecimalMode(i, false) != nil {
< 			badFileModes = append(badFileModes, i)
< 		}
< 	}
< 	assert.Equal(t, expectedBadDirModes, badDirModes, "bad set of decimal directory modes")
< 	assert.Equal(t, expectedBadFileModes, badFileModes, "bad set of decimal file modes")
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/util/merge.go updated/vendor/github.com/coreos/fcct/base/util/merge.go
1,61d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package util
< 
< import (
< 	"fmt"
< 
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/merge"
< )
< 
< // MergeTranslatedConfigs merges a parent and child config and returns the
< // result.  It also generates and returns the merged TranslationSet by
< // mapping the parent/child TranslationSets through the merge transcript.
< func MergeTranslatedConfigs(parent interface{}, parentTranslations translate.TranslationSet, child interface{}, childTranslations translate.TranslationSet) (interface{}, translate.TranslationSet) {
< 	// mappings:
< 	//   left:  parent or child translate.TranslationSet
< 	//   right: merge.Transcript
< 
< 	// merge configs
< 	result, right := merge.MergeStructTranscribe(parent, child)
< 
< 	// merge left and right mappings into new TranslationSet
< 	if parentTranslations.FromTag != childTranslations.FromTag || parentTranslations.ToTag != childTranslations.ToTag {
< 		panic(fmt.Sprintf("mismatched translation tags, %s != %s || %s != %s", parentTranslations.FromTag, childTranslations.FromTag, parentTranslations.ToTag, childTranslations.ToTag))
< 	}
< 	ts := translate.NewTranslationSet(parentTranslations.FromTag, parentTranslations.ToTag)
< 	for _, rightEntry := range right.Mappings {
< 		var left *translate.TranslationSet
< 		switch rightEntry.From.Tag {
< 		case merge.TAG_PARENT:
< 			left = &parentTranslations
< 		case merge.TAG_CHILD:
< 			left = &childTranslations
< 		default:
< 			panic("unexpected mapping tag " + rightEntry.From.Tag)
< 		}
< 		leftEntry, ok := left.Set[rightEntry.From.String()]
< 		if !ok {
< 			// the right mapping is more comprehensive than the
< 			// left mapping
< 			continue
< 		}
< 		rightEntry.To.Tag = leftEntry.To.Tag
< 		ts.AddTranslation(leftEntry.From, rightEntry.To)
< 	}
< 	return result, ts
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/util/merge_test.go updated/vendor/github.com/coreos/fcct/base/util/merge_test.go
1,156d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package util
< 
< import (
< 	"testing"
< 
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	// config version doesn't matter; just pick one
< 	"github.com/coreos/ignition/v2/config/v3_0/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // TestMergeTranslatedConfigs tests merging two Ignition configs and their
< // corresponding translations.
< func TestMergeTranslatedConfigs(t *testing.T) {
< 	tests := []struct {
< 		parent             types.Config
< 		parentTranslations translate.TranslationSet
< 		child              types.Config
< 		childTranslations  translate.TranslationSet
< 		merged             types.Config
< 		mergedTranslations translate.TranslationSet
< 	}{
< 		{
< 			parent: types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.0.0",
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Name:     "aardvark.service",
< 							Enabled:  util.BoolToPtr(true),
< 							Contents: util.StrToPtr("antelope"),
< 						},
< 						{
< 							Name:     "caribou.service",
< 							Contents: util.StrToPtr("caribou"),
< 						},
< 						{
< 							Name:     "elephant.service",
< 							Contents: util.StrToPtr("elephant"),
< 						},
< 					},
< 				},
< 			},
< 			parentTranslations: makeTranslationSet([]translate.Translation{
< 				// parent key duplicated in child, should be clobbered
< 				{path.New("in", "bad", 1), path.New("out", "systemd", "units", 0, "name")},
< 				// parent field overridden in child, should be clobbered
< 				{path.New("in", "bad", 2), path.New("out", "systemd", "units", 0, "contents")},
< 				// parent field not overridden in child
< 				{path.New("in", "good", 1), path.New("out", "systemd", "units", 0, "enabled")},
< 				// parent key not specified in child
< 				{path.New("in", "good", 2), path.New("out", "systemd", "units", 1, "name")},
< 				// parent field not specified in child
< 				{path.New("in", "good", 3), path.New("out", "systemd", "units", 1, "contents")},
< 				// other fields omitted from translation set
< 			}),
< 			child: types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.0.0",
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Name:     "bear.service",
< 							Enabled:  util.BoolToPtr(true),
< 							Contents: util.StrToPtr("bear"),
< 						},
< 						{
< 							Name:     "aardvark.service",
< 							Contents: util.StrToPtr("aardvark"),
< 						},
< 					},
< 				},
< 			},
< 			childTranslations: makeTranslationSet([]translate.Translation{
< 				// child key not mentioned in parent
< 				{path.New("in", "good", 11), path.New("out", "systemd", "units", 0, "name")},
< 				// child field not mentioned in parent
< 				{path.New("in", "good", 12), path.New("out", "systemd", "units", 0, "contents")},
< 				// parent key duplicated in child
< 				{path.New("in", "good", 13), path.New("out", "systemd", "units", 1, "name")},
< 				// parent field overridden in child
< 				{path.New("in", "good", 14), path.New("out", "systemd", "units", 1, "contents")},
< 				// other fields omitted from translation set
< 			}),
< 			merged: types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.0.0",
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Name:     "aardvark.service",
< 							Enabled:  util.BoolToPtr(true),
< 							Contents: util.StrToPtr("aardvark"),
< 						},
< 						{
< 							Name:     "caribou.service",
< 							Contents: util.StrToPtr("caribou"),
< 						},
< 						{
< 							Name:     "elephant.service",
< 							Contents: util.StrToPtr("elephant"),
< 						},
< 						{
< 							Name:     "bear.service",
< 							Enabled:  util.BoolToPtr(true),
< 							Contents: util.StrToPtr("bear"),
< 						},
< 					},
< 				},
< 			},
< 			mergedTranslations: makeTranslationSet([]translate.Translation{
< 				{path.New("in", "good", 13), path.New("out", "systemd", "units", 0, "name")},
< 				{path.New("in", "good", 1), path.New("out", "systemd", "units", 0, "enabled")},
< 				{path.New("in", "good", 14), path.New("out", "systemd", "units", 0, "contents")},
< 				{path.New("in", "good", 2), path.New("out", "systemd", "units", 1, "name")},
< 				{path.New("in", "good", 3), path.New("out", "systemd", "units", 1, "contents")},
< 				{path.New("in", "good", 11), path.New("out", "systemd", "units", 3, "name")},
< 				{path.New("in", "good", 12), path.New("out", "systemd", "units", 3, "contents")},
< 			}),
< 		},
< 	}
< 	for i, test := range tests {
< 		c, ts := MergeTranslatedConfigs(test.parent, test.parentTranslations, test.child, test.childTranslations)
< 		assert.Equal(t, test.merged, c, "#%d: bad config", i)
< 		assert.Equal(t, test.mergedTranslations, ts, "#%d: bad translations", i)
< 	}
< }
< 
< func makeTranslationSet(translations []translate.Translation) translate.TranslationSet {
< 	ts := translate.NewTranslationSet(translations[0].From.Tag, translations[0].To.Tag)
< 	for _, t := range translations {
< 		ts.AddTranslation(t.From, t.To)
< 	}
< 	return ts
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/util/test.go updated/vendor/github.com/coreos/fcct/base/util/test.go
1,45d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package util
< 
< import (
< 	"fmt"
< 	"testing"
< 
< 	"github.com/coreos/fcct/translate"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // helper functions for writing tests
< 
< // VerifyTranslations ensures all the translations are identity, unless they
< // match a listed one, and verifies that all the listed ones exist.
< func VerifyTranslations(t *testing.T, set translate.TranslationSet, exceptions []translate.Translation, format string, args ...interface{}) {
< 	message := fmt.Sprintf(format, args...)
< 	exceptionSet := translate.NewTranslationSet(set.FromTag, set.ToTag)
< 	for _, ex := range exceptions {
< 		exceptionSet.AddTranslation(ex.From, ex.To)
< 		if tr, ok := set.Set[ex.To.String()]; ok {
< 			assert.Equal(t, ex, tr, "%s: non-identity translation with unexpected From", message)
< 		} else {
< 			t.Errorf("%s: missing non-identity translation %v", message, ex)
< 		}
< 	}
< 	for key, translation := range set.Set {
< 		if _, ok := exceptionSet.Set[key]; !ok {
< 			assert.Equal(t, translation.From.Path, translation.To.Path, "%s: translation is not identity", message)
< 		}
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/util/url.go updated/vendor/github.com/coreos/fcct/base/util/url.go
1,67d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package util
< 
< import (
< 	"bytes"
< 	"compress/gzip"
< 	"encoding/base64"
< 	"net/url"
< 
< 	"github.com/vincent-petithory/dataurl"
< )
< 
< func MakeDataURL(contents []byte, currentCompression *string, allowCompression bool) (uri string, gzipped bool, err error) {
< 	// try three different encodings, and select the smallest one
< 
< 	// URL-escaped, useful for ASCII text
< 	opaque := "," + dataurl.Escape(contents)
< 
< 	// Base64-encoded, useful for small or incompressible binary data
< 	b64 := ";base64," + base64.StdEncoding.EncodeToString(contents)
< 	if len(b64) < len(opaque) {
< 		opaque = b64
< 	}
< 
< 	// Base64-encoded gzipped, useful for compressible data.  If the
< 	// user already enabled compression, don't compress again.
< 	// We don't try base64-encoded URL-escaped because gzipped data is
< 	// binary and URL escaping is unlikely to be efficient.
< 	if (currentCompression == nil || *currentCompression == "") && allowCompression {
< 		var buf bytes.Buffer
< 		var compressor *gzip.Writer
< 		if compressor, err = gzip.NewWriterLevel(&buf, gzip.BestCompression); err != nil {
< 			return
< 		}
< 		if _, err = compressor.Write(contents); err != nil {
< 			return
< 		}
< 		if err = compressor.Close(); err != nil {
< 			return
< 		}
< 		gz := ";base64," + base64.StdEncoding.EncodeToString(buf.Bytes())
< 		// Account for space needed by "compression": "gzip".
< 		if len(gz)+25 < len(opaque) {
< 			opaque = gz
< 			gzipped = true
< 		}
< 	}
< 
< 	uri = (&url.URL{
< 		Scheme: "data",
< 		Opaque: opaque,
< 	}).String()
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_1/schema.go updated/vendor/github.com/coreos/fcct/base/v0_1/schema.go
1,205d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_1
< 
< type CaReference struct {
< 	Source       string       `yaml:"source"`
< 	Verification Verification `yaml:"verification"`
< }
< 
< type Config struct {
< 	Version  string   `yaml:"version"`
< 	Variant  string   `yaml:"variant"`
< 	Ignition Ignition `yaml:"ignition"`
< 	Passwd   Passwd   `yaml:"passwd"`
< 	Storage  Storage  `yaml:"storage"`
< 	Systemd  Systemd  `yaml:"systemd"`
< }
< 
< type ConfigReference struct {
< 	Source       *string      `yaml:"source"`
< 	Verification Verification `yaml:"verification"`
< }
< 
< type Device string
< 
< type Directory struct {
< 	Group     NodeGroup `yaml:"group"`
< 	Overwrite *bool     `yaml:"overwrite"`
< 	Path      string    `yaml:"path"`
< 	User      NodeUser  `yaml:"user"`
< 	Mode      *int      `yaml:"mode"`
< }
< 
< type Disk struct {
< 	Device     string      `yaml:"device"`
< 	Partitions []Partition `yaml:"partitions"`
< 	WipeTable  *bool       `yaml:"wipe_table"`
< }
< 
< type Dropin struct {
< 	Contents *string `yaml:"contents"`
< 	Name     string  `yaml:"name"`
< }
< 
< type File struct {
< 	Group     NodeGroup      `yaml:"group"`
< 	Overwrite *bool          `yaml:"overwrite"`
< 	Path      string         `yaml:"path"`
< 	User      NodeUser       `yaml:"user"`
< 	Append    []FileContents `yaml:"append"`
< 	Contents  FileContents   `yaml:"contents"`
< 	Mode      *int           `yaml:"mode"`
< }
< 
< type FileContents struct {
< 	Compression  *string      `yaml:"compression"`
< 	Source       *string      `yaml:"source"`
< 	Inline       *string      `yaml:"inline"` // Added, not in ignition spec
< 	Verification Verification `yaml:"verification"`
< }
< 
< type Filesystem struct {
< 	Device         string             `yaml:"device"`
< 	Format         *string            `yaml:"format"`
< 	Label          *string            `yaml:"label"`
< 	Options        []FilesystemOption `yaml:"options"`
< 	Path           *string            `yaml:"path"`
< 	UUID           *string            `yaml:"uuid"`
< 	WipeFilesystem *bool              `yaml:"wipe_filesystem"`
< }
< 
< type FilesystemOption string
< 
< type Group string
< 
< type Ignition struct {
< 	Config   IgnitionConfig `yaml:"config"`
< 	Security Security       `yaml:"security"`
< 	Timeouts Timeouts       `yaml:"timeouts"`
< }
< 
< type IgnitionConfig struct {
< 	Merge   []ConfigReference `yaml:"merge"`
< 	Replace ConfigReference   `yaml:"replace"`
< }
< 
< type Link struct {
< 	Group     NodeGroup `yaml:"group"`
< 	Overwrite *bool     `yaml:"overwrite"`
< 	Path      string    `yaml:"path"`
< 	User      NodeUser  `yaml:"user"`
< 	Hard      *bool     `yaml:"hard"`
< 	Target    string    `yaml:"target"`
< }
< 
< type NodeGroup struct {
< 	ID   *int    `yaml:"id"`
< 	Name *string `yaml:"name"`
< }
< 
< type NodeUser struct {
< 	ID   *int    `yaml:"id"`
< 	Name *string `yaml:"name"`
< }
< 
< type Partition struct {
< 	GUID               *string `yaml:"guid"`
< 	Label              *string `yaml:"label"`
< 	Number             int     `yaml:"number"`
< 	ShouldExist        *bool   `yaml:"should_exist"`
< 	SizeMiB            *int    `yaml:"size_mib"`
< 	StartMiB           *int    `yaml:"start_mib"`
< 	TypeGUID           *string `yaml:"type_guid"`
< 	WipePartitionEntry *bool   `yaml:"wipe_partition_entry"`
< }
< 
< type Passwd struct {
< 	Groups []PasswdGroup `yaml:"groups"`
< 	Users  []PasswdUser  `yaml:"users"`
< }
< 
< type PasswdGroup struct {
< 	Gid          *int    `yaml:"gid"`
< 	Name         string  `yaml:"name"`
< 	PasswordHash *string `yaml:"password_hash"`
< 	System       *bool   `yaml:"system"`
< }
< 
< type PasswdUser struct {
< 	Gecos             *string            `yaml:"gecos"`
< 	Groups            []Group            `yaml:"groups"`
< 	HomeDir           *string            `yaml:"home_dir"`
< 	Name              string             `yaml:"name"`
< 	NoCreateHome      *bool              `yaml:"no_create_home"`
< 	NoLogInit         *bool              `yaml:"no_log_init"`
< 	NoUserGroup       *bool              `yaml:"no_user_group"`
< 	PasswordHash      *string            `yaml:"password_hash"`
< 	PrimaryGroup      *string            `yaml:"primary_group"`
< 	SSHAuthorizedKeys []SSHAuthorizedKey `yaml:"ssh_authorized_keys"`
< 	Shell             *string            `yaml:"shell"`
< 	System            *bool              `yaml:"system"`
< 	UID               *int               `yaml:"uid"`
< }
< 
< type Raid struct {
< 	Devices []Device     `yaml:"devices"`
< 	Level   string       `yaml:"level"`
< 	Name    string       `yaml:"name"`
< 	Options []RaidOption `yaml:"options"`
< 	Spares  *int         `yaml:"spares"`
< }
< 
< type RaidOption string
< 
< type SSHAuthorizedKey string
< 
< type Security struct {
< 	TLS TLS `yaml:"tls"`
< }
< 
< type Storage struct {
< 	Directories []Directory  `yaml:"directories"`
< 	Disks       []Disk       `yaml:"disks"`
< 	Files       []File       `yaml:"files"`
< 	Filesystems []Filesystem `yaml:"filesystems"`
< 	Links       []Link       `yaml:"links"`
< 	Raid        []Raid       `yaml:"raid"`
< }
< 
< type Systemd struct {
< 	Units []Unit `yaml:"units"`
< }
< 
< type TLS struct {
< 	CertificateAuthorities []CaReference `yaml:"certificate_authorities"`
< }
< 
< type Timeouts struct {
< 	HTTPResponseHeaders *int `yaml:"http_response_headers"`
< 	HTTPTotal           *int `yaml:"http_total"`
< }
< 
< type Unit struct {
< 	Contents *string  `yaml:"contents"`
< 	Dropins  []Dropin `yaml:"dropins"`
< 	Enabled  *bool    `yaml:"enabled"`
< 	Mask     *bool    `yaml:"mask"`
< 	Name     string   `yaml:"name"`
< }
< 
< type Verification struct {
< 	Hash *string `yaml:"hash"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_1/translate.go updated/vendor/github.com/coreos/fcct/base/v0_1/translate.go
1,113d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_1
< 
< import (
< 	"net/url"
< 
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/v3_0/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/vincent-petithory/dataurl"
< )
< 
< // ToIgn3_0Unvalidated translates the config to an Ignition config. It also returns the set of translations
< // it did so paths in the resultant config can be tracked back to their source in the source config.
< // No config validation is performed on input or output.
< func (c Config) ToIgn3_0Unvalidated(options common.TranslateOptions) (types.Config, translate.TranslationSet, report.Report) {
< 	ret := types.Config{}
< 
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateIgnition)
< 	tr.AddCustomTranslator(translateFile)
< 	tr.AddCustomTranslator(translateDirectory)
< 	tr.AddCustomTranslator(translateLink)
< 
< 	tm, r := translate.Prefixed(tr, "ignition", &c.Ignition, &ret.Ignition)
< 	translate.MergeP(tr, tm, &r, "passwd", &c.Passwd, &ret.Passwd)
< 	translate.MergeP(tr, tm, &r, "storage", &c.Storage, &ret.Storage)
< 	translate.MergeP(tr, tm, &r, "systemd", &c.Systemd, &ret.Systemd)
< 
< 	if r.IsFatal() {
< 		return types.Config{}, translate.TranslationSet{}, r
< 	}
< 	return ret, tm, r
< }
< 
< func translateIgnition(from Ignition, options common.TranslateOptions) (to types.Ignition, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	to.Version = types.MaxVersion.String()
< 	tm, r = translate.Prefixed(tr, "config", &from.Config, &to.Config)
< 	translate.MergeP(tr, tm, &r, "security", &from.Security, &to.Security)
< 	translate.MergeP(tr, tm, &r, "timeouts", &from.Timeouts, &to.Timeouts)
< 	return
< }
< 
< func translateFile(from File, options common.TranslateOptions) (to types.File, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateFileContents)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	translate.MergeP(tr, tm, &r, "append", &from.Append, &to.Append)
< 	translate.MergeP(tr, tm, &r, "contents", &from.Contents, &to.Contents)
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	to.Mode = from.Mode
< 	tm.AddIdentity("overwrite", "path", "mode")
< 	return
< }
< 
< func translateFileContents(from FileContents, options common.TranslateOptions) (to types.FileContents, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "verification", &from.Verification, &to.Verification)
< 	to.Source = from.Source
< 	to.Compression = from.Compression
< 	tm.AddIdentity("source", "compression")
< 	if from.Inline != nil {
< 		src := (&url.URL{
< 			Scheme: "data",
< 			Opaque: "," + dataurl.EscapeString(*from.Inline),
< 		}).String()
< 		to.Source = &src
< 		tm.AddTranslation(path.New("yaml", "inline"), path.New("json", "source"))
< 	}
< 	return
< }
< 
< func translateDirectory(from Directory, options common.TranslateOptions) (to types.Directory, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	to.Mode = from.Mode
< 	tm.AddIdentity("overwrite", "path", "mode")
< 	return
< }
< 
< func translateLink(from Link, options common.TranslateOptions) (to types.Link, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	to.Target = from.Target
< 	to.Hard = from.Hard
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	tm.AddIdentity("target", "hard", "overwrite", "path")
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_1/translate_test.go updated/vendor/github.com/coreos/fcct/base/v0_1/translate_test.go
1,291d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_1
< 
< import (
< 	"testing"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_0/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // Most of this is covered by the Ignition translator generic tests, so just test the custom bits
< 
< // TestTranslateFile tests translating the ct storage.files.[i] entries to ignition storage.files.[i] entries.
< func TestTranslateFile(t *testing.T) {
< 	tests := []struct {
< 		in         File
< 		out        types.File
< 		exceptions []translate.Translation
< 	}{
< 		{
< 			File{},
< 			types.File{},
< 			nil,
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			File{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Mode: util.IntToPtr(420),
< 				Append: []FileContents{
< 					{
< 						Source:      util.StrToPtr("http://example/com"),
< 						Compression: util.StrToPtr("gzip"),
< 						Verification: Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					{
< 						Inline:      util.StrToPtr("hello"),
< 						Compression: util.StrToPtr("gzip"),
< 						Verification: Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 				},
< 				Overwrite: util.BoolToPtr(true),
< 				Contents: FileContents{
< 					Source:      util.StrToPtr("http://example/com"),
< 					Compression: util.StrToPtr("gzip"),
< 					Verification: Verification{
< 						Hash: util.StrToPtr("this isn't validated"),
< 					},
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Mode: util.IntToPtr(420),
< 					Append: []types.FileContents{
< 						{
< 							Source:      util.StrToPtr("http://example/com"),
< 							Compression: util.StrToPtr("gzip"),
< 							Verification: types.Verification{
< 								Hash: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						{
< 							Source:      util.StrToPtr("data:,hello"),
< 							Compression: util.StrToPtr("gzip"),
< 							Verification: types.Verification{
< 								Hash: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 					},
< 					Contents: types.FileContents{
< 						Source:      util.StrToPtr("http://example/com"),
< 						Compression: util.StrToPtr("gzip"),
< 						Verification: types.Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "append", 1, "inline"),
< 					To:   path.New("json", "append", 1, "source"),
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, translations, r := translateFile(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 		baseutil.VerifyTranslations(t, translations, test.exceptions, "#%d", i)
< 	}
< }
< 
< // TestTranslateDirectory tests translating the ct storage.directories.[i] entries to ignition storage.directories.[i] entires.
< func TestTranslateDirectory(t *testing.T) {
< 	tests := []struct {
< 		in  Directory
< 		out types.Directory
< 	}{
< 		{
< 			Directory{},
< 			types.Directory{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Directory{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Mode:      util.IntToPtr(420),
< 				Overwrite: util.BoolToPtr(true),
< 			},
< 			types.Directory{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				DirectoryEmbedded1: types.DirectoryEmbedded1{
< 					Mode: util.IntToPtr(420),
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, _, r := translateDirectory(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateLink tests translating the ct storage.links.[i] entries to ignition storage.links.[i] entires.
< func TestTranslateLink(t *testing.T) {
< 	tests := []struct {
< 		in  Link
< 		out types.Link
< 	}{
< 		{
< 			Link{},
< 			types.Link{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Link{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Overwrite: util.BoolToPtr(true),
< 				Target:    "/bar",
< 				Hard:      util.BoolToPtr(false),
< 			},
< 			types.Link{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				LinkEmbedded1: types.LinkEmbedded1{
< 					Target: "/bar",
< 					Hard:   util.BoolToPtr(false),
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, _, r := translateLink(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateIgnition tests translating the ct config.ignition to the ignition config.ignition section.
< // It ensure that the version is set as well.
< func TestTranslateIgnition(t *testing.T) {
< 	tests := []struct {
< 		in  Ignition
< 		out types.Ignition
< 	}{
< 		{
< 			Ignition{},
< 			types.Ignition{
< 				Version: "3.0.0",
< 			},
< 		},
< 	}
< 	for i, test := range tests {
< 		actual, _, r := translateIgnition(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestToIgn3_0 tests the config.ToIgn3_0 function ensuring it will generate a valid config even when empty. Not much else is
< // tested since it uses the Ignition translation code which has it's own set of tests.
< func TestToIgn3_0(t *testing.T) {
< 	tests := []struct {
< 		in  Config
< 		out types.Config
< 	}{
< 		{
< 			Config{},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.0.0",
< 				},
< 			},
< 		},
< 	}
< 	for i, test := range tests {
< 		actual, _, r := test.in.ToIgn3_0Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_1/validate.go updated/vendor/github.com/coreos/fcct/base/v0_1/validate.go
1,44d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_1
< 
< import (
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (f FileContents) Validate(c path.ContextPath) (r report.Report) {
< 	if f.Inline != nil && f.Source != nil {
< 		r.AddOnError(c.Append("inline"), common.ErrTooManyResourceSources)
< 	}
< 	return
< }
< 
< func (d Directory) Validate(c path.ContextPath) (r report.Report) {
< 	if d.Mode != nil {
< 		r.AddOnWarn(c.Append("mode"), baseutil.CheckForDecimalMode(*d.Mode, true))
< 	}
< 	return
< }
< 
< func (f File) Validate(c path.ContextPath) (r report.Report) {
< 	if f.Mode != nil {
< 		r.AddOnWarn(c.Append("mode"), baseutil.CheckForDecimalMode(*f.Mode, false))
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_1/validate_test.go updated/vendor/github.com/coreos/fcct/base/v0_1/validate_test.go
1,138d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_1
< 
< import (
< 	"testing"
< 
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // TestValidateFileContents tests that multiple sources (i.e. urls and inline) are not allowed but zero or one sources are
< func TestValidateFileContents(t *testing.T) {
< 	tests := []struct {
< 		in  FileContents
< 		out error
< 	}{
< 		{},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			FileContents{
< 				Source:      util.StrToPtr("http://example/com"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 		},
< 		{
< 			FileContents{
< 				Inline:      util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 		},
< 		{
< 			FileContents{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Inline:      util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		// hardcode inline for now since that's the only place errors occur. Move into the
< 		// test struct once there's more than one place
< 		expected.AddOnError(path.New("yaml", "inline"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
< 
< func TestValidateMode(t *testing.T) {
< 	fileTests := []struct {
< 		in  File
< 		out error
< 	}{
< 		{
< 			in:  File{},
< 			out: nil,
< 		},
< 		{
< 			in: File{
< 				Mode: util.IntToPtr(0600),
< 			},
< 			out: nil,
< 		},
< 		{
< 			in: File{
< 				Mode: util.IntToPtr(600),
< 			},
< 			out: common.ErrDecimalMode,
< 		},
< 	}
< 
< 	for i, test := range fileTests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnWarn(path.New("yaml", "mode"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< 
< 	dirTests := []struct {
< 		in  Directory
< 		out error
< 	}{
< 		{
< 			in:  Directory{},
< 			out: nil,
< 		},
< 		{
< 			in: Directory{
< 				Mode: util.IntToPtr(01770),
< 			},
< 			out: nil,
< 		},
< 		{
< 			in: Directory{
< 				Mode: util.IntToPtr(1770),
< 			},
< 			out: common.ErrDecimalMode,
< 		},
< 	}
< 
< 	for i, test := range dirTests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnWarn(path.New("yaml", "mode"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_2/schema.go updated/vendor/github.com/coreos/fcct/base/v0_2/schema.go
1,219d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_2
< 
< type Config struct {
< 	Version  string   `yaml:"version"`
< 	Variant  string   `yaml:"variant"`
< 	Ignition Ignition `yaml:"ignition"`
< 	Passwd   Passwd   `yaml:"passwd"`
< 	Storage  Storage  `yaml:"storage"`
< 	Systemd  Systemd  `yaml:"systemd"`
< }
< 
< type Device string
< 
< type Directory struct {
< 	Group     NodeGroup `yaml:"group"`
< 	Overwrite *bool     `yaml:"overwrite"`
< 	Path      string    `yaml:"path"`
< 	User      NodeUser  `yaml:"user"`
< 	Mode      *int      `yaml:"mode"`
< }
< 
< type Disk struct {
< 	Device     string      `yaml:"device"`
< 	Partitions []Partition `yaml:"partitions"`
< 	WipeTable  *bool       `yaml:"wipe_table"`
< }
< 
< type Dropin struct {
< 	Contents *string `yaml:"contents"`
< 	Name     string  `yaml:"name"`
< }
< 
< type File struct {
< 	Group     NodeGroup  `yaml:"group"`
< 	Overwrite *bool      `yaml:"overwrite"`
< 	Path      string     `yaml:"path"`
< 	User      NodeUser   `yaml:"user"`
< 	Append    []Resource `yaml:"append"`
< 	Contents  Resource   `yaml:"contents"`
< 	Mode      *int       `yaml:"mode"`
< }
< 
< type Filesystem struct {
< 	Device         string   `yaml:"device"`
< 	Format         *string  `yaml:"format"`
< 	Label          *string  `yaml:"label"`
< 	MountOptions   []string `yaml:"mount_options"`
< 	Options        []string `yaml:"options"`
< 	Path           *string  `yaml:"path"`
< 	UUID           *string  `yaml:"uuid"`
< 	WipeFilesystem *bool    `yaml:"wipe_filesystem"`
< 	WithMountUnit  *bool    `yaml:"with_mount_unit" fcct:"auto_skip"` // Added, not in Ignition spec
< }
< 
< type FilesystemOption string
< 
< type Group string
< 
< type HTTPHeader struct {
< 	Name  string  `yaml:"name"`
< 	Value *string `yaml:"value"`
< }
< 
< type HTTPHeaders []HTTPHeader
< 
< type Ignition struct {
< 	Config   IgnitionConfig `yaml:"config"`
< 	Proxy    Proxy          `yaml:"proxy"`
< 	Security Security       `yaml:"security"`
< 	Timeouts Timeouts       `yaml:"timeouts"`
< }
< 
< type IgnitionConfig struct {
< 	Merge   []Resource `yaml:"merge"`
< 	Replace Resource   `yaml:"replace"`
< }
< 
< type Link struct {
< 	Group     NodeGroup `yaml:"group"`
< 	Overwrite *bool     `yaml:"overwrite"`
< 	Path      string    `yaml:"path"`
< 	User      NodeUser  `yaml:"user"`
< 	Hard      *bool     `yaml:"hard"`
< 	Target    string    `yaml:"target"`
< }
< 
< type NodeGroup struct {
< 	ID   *int    `yaml:"id"`
< 	Name *string `yaml:"name"`
< }
< 
< type NodeUser struct {
< 	ID   *int    `yaml:"id"`
< 	Name *string `yaml:"name"`
< }
< 
< type Partition struct {
< 	GUID               *string `yaml:"guid"`
< 	Label              *string `yaml:"label"`
< 	Number             int     `yaml:"number"`
< 	ShouldExist        *bool   `yaml:"should_exist"`
< 	SizeMiB            *int    `yaml:"size_mib"`
< 	StartMiB           *int    `yaml:"start_mib"`
< 	TypeGUID           *string `yaml:"type_guid"`
< 	WipePartitionEntry *bool   `yaml:"wipe_partition_entry"`
< }
< 
< type Passwd struct {
< 	Groups []PasswdGroup `yaml:"groups"`
< 	Users  []PasswdUser  `yaml:"users"`
< }
< 
< type PasswdGroup struct {
< 	Gid          *int    `yaml:"gid"`
< 	Name         string  `yaml:"name"`
< 	PasswordHash *string `yaml:"password_hash"`
< 	System       *bool   `yaml:"system"`
< }
< 
< type PasswdUser struct {
< 	Gecos             *string            `yaml:"gecos"`
< 	Groups            []Group            `yaml:"groups"`
< 	HomeDir           *string            `yaml:"home_dir"`
< 	Name              string             `yaml:"name"`
< 	NoCreateHome      *bool              `yaml:"no_create_home"`
< 	NoLogInit         *bool              `yaml:"no_log_init"`
< 	NoUserGroup       *bool              `yaml:"no_user_group"`
< 	PasswordHash      *string            `yaml:"password_hash"`
< 	PrimaryGroup      *string            `yaml:"primary_group"`
< 	SSHAuthorizedKeys []SSHAuthorizedKey `yaml:"ssh_authorized_keys"`
< 	Shell             *string            `yaml:"shell"`
< 	System            *bool              `yaml:"system"`
< 	UID               *int               `yaml:"uid"`
< }
< 
< type Proxy struct {
< 	HTTPProxy  *string  `yaml:"http_proxy"`
< 	HTTPSProxy *string  `yaml:"https_proxy"`
< 	NoProxy    []string `yaml:"no_proxy"`
< }
< 
< type Raid struct {
< 	Devices []Device     `yaml:"devices"`
< 	Level   string       `yaml:"level"`
< 	Name    string       `yaml:"name"`
< 	Options []RaidOption `yaml:"options"`
< 	Spares  *int         `yaml:"spares"`
< }
< 
< type RaidOption string
< 
< type Resource struct {
< 	Compression  *string      `yaml:"compression"`
< 	HTTPHeaders  HTTPHeaders  `yaml:"http_headers"`
< 	Source       *string      `yaml:"source"`
< 	Inline       *string      `yaml:"inline"` // Added, not in ignition spec
< 	Local        *string      `yaml:"local"`  // Added, not in ignition spec
< 	Verification Verification `yaml:"verification"`
< }
< 
< type SSHAuthorizedKey string
< 
< type Security struct {
< 	TLS TLS `yaml:"tls"`
< }
< 
< type Storage struct {
< 	Directories []Directory  `yaml:"directories"`
< 	Disks       []Disk       `yaml:"disks"`
< 	Files       []File       `yaml:"files"`
< 	Filesystems []Filesystem `yaml:"filesystems"`
< 	Links       []Link       `yaml:"links"`
< 	Raid        []Raid       `yaml:"raid"`
< 	Trees       []Tree       `yaml:"trees" fcct:"auto_skip"` // Added, not in ignition spec
< }
< 
< type Systemd struct {
< 	Units []Unit `yaml:"units"`
< }
< 
< type TLS struct {
< 	CertificateAuthorities []Resource `yaml:"certificate_authorities"`
< }
< 
< type Timeouts struct {
< 	HTTPResponseHeaders *int `yaml:"http_response_headers"`
< 	HTTPTotal           *int `yaml:"http_total"`
< }
< 
< type Tree struct {
< 	Local string  `yaml:"local"`
< 	Path  *string `yaml:"path"`
< }
< 
< type Unit struct {
< 	Contents *string  `yaml:"contents"`
< 	Dropins  []Dropin `yaml:"dropins"`
< 	Enabled  *bool    `yaml:"enabled"`
< 	Mask     *bool    `yaml:"mask"`
< 	Name     string   `yaml:"name"`
< }
< 
< type Verification struct {
< 	Hash *string `yaml:"hash"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_2/translate.go updated/vendor/github.com/coreos/fcct/base/v0_2/translate.go
1,373d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_2
< 
< import (
< 	"io/ioutil"
< 	"os"
< 	"path/filepath"
< 	"strings"
< 	"text/template"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/go-systemd/unit"
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_1/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< var (
< 	mountUnitTemplate = template.Must(template.New("unit").Parse(`# Generated by FCCT
< [Unit]
< Before=local-fs.target
< Requires=systemd-fsck@{{.EscapedDevice}}.service
< After=systemd-fsck@{{.EscapedDevice}}.service
< 
< [Mount]
< Where={{.Path}}
< What={{.Device}}
< Type={{.Format}}
< {{- if .MountOptions }}
< Options=
<   {{- range $i, $opt := .MountOptions }}
<     {{- if $i }},{{ end }}
<     {{- $opt }}
<   {{- end }}
< {{- end }}
< 
< [Install]
< RequiredBy=local-fs.target`))
< )
< 
< // ToIgn3_1Unvalidated translates the config to an Ignition config. It also returns the set of translations
< // it did so paths in the resultant config can be tracked back to their source in the source config.
< // No config validation is performed on input or output.
< func (c Config) ToIgn3_1Unvalidated(options common.TranslateOptions) (types.Config, translate.TranslationSet, report.Report) {
< 	ret := types.Config{}
< 
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateIgnition)
< 	tr.AddCustomTranslator(translateFile)
< 	tr.AddCustomTranslator(translateDirectory)
< 	tr.AddCustomTranslator(translateLink)
< 
< 	tm, r := translate.Prefixed(tr, "ignition", &c.Ignition, &ret.Ignition)
< 	translate.MergeP(tr, tm, &r, "passwd", &c.Passwd, &ret.Passwd)
< 	translate.MergeP(tr, tm, &r, "storage", &c.Storage, &ret.Storage)
< 	translate.MergeP(tr, tm, &r, "systemd", &c.Systemd, &ret.Systemd)
< 
< 	c.addMountUnits(&ret, &tm)
< 
< 	tm2, r2 := c.processTrees(&ret, options)
< 	tm.Merge(tm2)
< 	r.Merge(r2)
< 
< 	if r.IsFatal() {
< 		return types.Config{}, translate.TranslationSet{}, r
< 	}
< 	return ret, tm, r
< }
< 
< func translateIgnition(from Ignition, options common.TranslateOptions) (to types.Ignition, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateResource)
< 	to.Version = types.MaxVersion.String()
< 	tm, r = translate.Prefixed(tr, "config", &from.Config, &to.Config)
< 	translate.MergeP(tr, tm, &r, "proxy", &from.Proxy, &to.Proxy)
< 	translate.MergeP(tr, tm, &r, "security", &from.Security, &to.Security)
< 	translate.MergeP(tr, tm, &r, "timeouts", &from.Timeouts, &to.Timeouts)
< 	return
< }
< 
< func translateFile(from File, options common.TranslateOptions) (to types.File, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateResource)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	translate.MergeP(tr, tm, &r, "append", &from.Append, &to.Append)
< 	translate.MergeP(tr, tm, &r, "contents", &from.Contents, &to.Contents)
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	to.Mode = from.Mode
< 	tm.AddIdentity("overwrite", "path", "mode")
< 	return
< }
< 
< func translateResource(from Resource, options common.TranslateOptions) (to types.Resource, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "verification", &from.Verification, &to.Verification)
< 	translate.MergeP(tr, tm, &r, "httpHeaders", &from.HTTPHeaders, &to.HTTPHeaders)
< 	to.Source = from.Source
< 	to.Compression = from.Compression
< 	tm.AddIdentity("source", "compression")
< 
< 	if from.Local != nil {
< 		c := path.New("yaml", "local")
< 
< 		if options.FilesDir == "" {
< 			r.AddOnError(c, common.ErrNoFilesDir)
< 			return
< 		}
< 
< 		// calculate file path within FilesDir and check for
< 		// path traversal
< 		filePath := filepath.Join(options.FilesDir, *from.Local)
< 		if err := baseutil.EnsurePathWithinFilesDir(filePath, options.FilesDir); err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 
< 		contents, err := ioutil.ReadFile(filePath)
< 		if err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 
< 		src, gzipped, err := baseutil.MakeDataURL(contents, to.Compression, !options.NoResourceAutoCompression)
< 		if err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 		to.Source = &src
< 		tm.AddTranslation(c, path.New("json", "source"))
< 		if gzipped {
< 			to.Compression = util.StrToPtr("gzip")
< 			tm.AddTranslation(c, path.New("json", "compression"))
< 		}
< 	}
< 
< 	if from.Inline != nil {
< 		c := path.New("yaml", "inline")
< 
< 		src, gzipped, err := baseutil.MakeDataURL([]byte(*from.Inline), to.Compression, !options.NoResourceAutoCompression)
< 		if err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 		to.Source = &src
< 		tm.AddTranslation(c, path.New("json", "source"))
< 		if gzipped {
< 			to.Compression = util.StrToPtr("gzip")
< 			tm.AddTranslation(c, path.New("json", "compression"))
< 		}
< 	}
< 	return
< }
< 
< func translateDirectory(from Directory, options common.TranslateOptions) (to types.Directory, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	to.Mode = from.Mode
< 	tm.AddIdentity("overwrite", "path", "mode")
< 	return
< }
< 
< func translateLink(from Link, options common.TranslateOptions) (to types.Link, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	to.Target = from.Target
< 	to.Hard = from.Hard
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	tm.AddIdentity("target", "hard", "overwrite", "path")
< 	return
< }
< 
< func (c Config) processTrees(ret *types.Config, options common.TranslateOptions) (translate.TranslationSet, report.Report) {
< 	ts := translate.NewTranslationSet("yaml", "json")
< 	var r report.Report
< 	if len(c.Storage.Trees) == 0 {
< 		return ts, r
< 	}
< 	t := newNodeTracker(ret)
< 
< 	for i, tree := range c.Storage.Trees {
< 		yamlPath := path.New("yaml", "storage", "trees", i)
< 		if options.FilesDir == "" {
< 			r.AddOnError(yamlPath, common.ErrNoFilesDir)
< 			return ts, r
< 		}
< 
< 		// calculate base path within FilesDir and check for
< 		// path traversal
< 		srcBaseDir := filepath.Join(options.FilesDir, tree.Local)
< 		if err := baseutil.EnsurePathWithinFilesDir(srcBaseDir, options.FilesDir); err != nil {
< 			r.AddOnError(yamlPath, err)
< 			continue
< 		}
< 		info, err := os.Stat(srcBaseDir)
< 		if err != nil {
< 			r.AddOnError(yamlPath, err)
< 			continue
< 		}
< 		if !info.IsDir() {
< 			r.AddOnError(yamlPath, common.ErrTreeNotDirectory)
< 			continue
< 		}
< 		destBaseDir := "/"
< 		if tree.Path != nil && *tree.Path != "" {
< 			destBaseDir = *tree.Path
< 		}
< 
< 		walkTree(yamlPath, tree, &ts, &r, t, srcBaseDir, destBaseDir, options)
< 	}
< 	return ts, r
< }
< 
< func walkTree(yamlPath path.ContextPath, tree Tree, ts *translate.TranslationSet, r *report.Report, t *nodeTracker, srcBaseDir, destBaseDir string, options common.TranslateOptions) {
< 	// The strategy for errors within WalkFunc is to add an error to
< 	// the report and return nil, so walking continues but translation
< 	// will fail afterward.
< 	err := filepath.Walk(srcBaseDir, func(srcPath string, info os.FileInfo, err error) error {
< 		if err != nil {
< 			r.AddOnError(yamlPath, err)
< 			return nil
< 		}
< 		relPath, err := filepath.Rel(srcBaseDir, srcPath)
< 		if err != nil {
< 			r.AddOnError(yamlPath, err)
< 			return nil
< 		}
< 		destPath := filepath.Join(destBaseDir, relPath)
< 
< 		if info.Mode().IsDir() {
< 			return nil
< 		} else if info.Mode().IsRegular() {
< 			i, file := t.GetFile(destPath)
< 			if file != nil {
< 				if file.Contents.Source != nil && *file.Contents.Source != "" {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 			} else {
< 				if t.Exists(destPath) {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 				i, file = t.AddFile(types.File{
< 					Node: types.Node{
< 						Path: destPath,
< 					},
< 				})
< 				ts.AddFromCommonSource(yamlPath, path.New("json", "storage", "files", i), file)
< 			}
< 			contents, err := ioutil.ReadFile(srcPath)
< 			if err != nil {
< 				r.AddOnError(yamlPath, err)
< 				return nil
< 			}
< 			url, gzipped, err := baseutil.MakeDataURL(contents, file.Contents.Compression, !options.NoResourceAutoCompression)
< 			if err != nil {
< 				r.AddOnError(yamlPath, err)
< 				return nil
< 			}
< 			file.Contents.Source = util.StrToPtr(url)
< 			ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "contents", "source"))
< 			if gzipped {
< 				file.Contents.Compression = util.StrToPtr("gzip")
< 				ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "contents", "compression"))
< 			}
< 			if file.Mode == nil {
< 				mode := 0644
< 				if info.Mode()&0111 != 0 {
< 					mode = 0755
< 				}
< 				file.Mode = &mode
< 				ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "mode"))
< 			}
< 		} else if info.Mode()&os.ModeType == os.ModeSymlink {
< 			i, link := t.GetLink(destPath)
< 			if link != nil {
< 				if link.Target != "" {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 			} else {
< 				if t.Exists(destPath) {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 				i, link = t.AddLink(types.Link{
< 					Node: types.Node{
< 						Path: destPath,
< 					},
< 				})
< 				ts.AddFromCommonSource(yamlPath, path.New("json", "storage", "links", i), link)
< 			}
< 			link.Target, err = os.Readlink(srcPath)
< 			if err != nil {
< 				r.AddOnError(yamlPath, err)
< 				return nil
< 			}
< 			ts.AddTranslation(yamlPath, path.New("json", "storage", "links", i, "target"))
< 		} else {
< 			r.AddOnError(yamlPath, common.ErrFileType)
< 			return nil
< 		}
< 		return nil
< 	})
< 	r.AddOnError(yamlPath, err)
< }
< 
< func (c Config) addMountUnits(config *types.Config, ts *translate.TranslationSet) {
< 	if len(c.Storage.Filesystems) == 0 {
< 		return
< 	}
< 	var rendered types.Config
< 	renderedTranslations := translate.NewTranslationSet("yaml", "json")
< 	for i, fs := range c.Storage.Filesystems {
< 		if fs.WithMountUnit == nil || !*fs.WithMountUnit {
< 			continue
< 		}
< 		fromPath := path.New("yaml", "storage", "filesystems", i, "with_mount_unit")
< 		newUnit := mountUnitFromFS(fs)
< 		unitPath := path.New("json", "systemd", "units", len(rendered.Systemd.Units))
< 		rendered.Systemd.Units = append(rendered.Systemd.Units, newUnit)
< 		renderedTranslations.AddFromCommonSource(fromPath, unitPath, newUnit)
< 	}
< 	retConfig, retTranslations := baseutil.MergeTranslatedConfigs(rendered, renderedTranslations, *config, *ts)
< 	*config = retConfig.(types.Config)
< 	*ts = retTranslations
< }
< 
< func mountUnitFromFS(fs Filesystem) types.Unit {
< 	context := struct {
< 		*Filesystem
< 		EscapedDevice string
< 	}{
< 		Filesystem:    &fs,
< 		EscapedDevice: unit.UnitNamePathEscape(fs.Device),
< 	}
< 	contents := strings.Builder{}
< 	err := mountUnitTemplate.Execute(&contents, context)
< 	if err != nil {
< 		panic(err)
< 	}
< 	// unchecked deref of path ok, fs would fail validation otherwise
< 	unitName := unit.UnitNamePathEscape(*fs.Path) + ".mount"
< 	return types.Unit{
< 		Name:     unitName,
< 		Enabled:  util.BoolToPtr(true),
< 		Contents: util.StrToPtr(contents.String()),
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_2/translate_test.go updated/vendor/github.com/coreos/fcct/base/v0_2/translate_test.go
1,1358d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_2
< 
< import (
< 	"io/ioutil"
< 	"net"
< 	"os"
< 	"path/filepath"
< 	"strings"
< 	"testing"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_1/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // Most of this is covered by the Ignition translator generic tests, so just test the custom bits
< 
< // TestTranslateFile tests translating the ct storage.files.[i] entries to ignition storage.files.[i] entries.
< func TestTranslateFile(t *testing.T) {
< 	zzz := "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"
< 	zzz_gz := "data:;base64,H4sIAAAAAAAC/6oajAAQAAD//5tA8d+VAAAA"
< 	random := "\xc0\x9cl\x01\x89i\xa5\xbfW\xe4\x1b\xf4J_\xb79P\xa3#\xa7"
< 	random_b64 := "data:;base64,wJxsAYlppb9X5Bv0Sl+3OVCjI6c="
< 
< 	filesDir, err := ioutil.TempDir("", "translate-test-")
< 	if err != nil {
< 		t.Error(err)
< 		return
< 	}
< 	defer os.RemoveAll(filesDir)
< 	fileContents := map[string]string{
< 		"file-1": "file contents\n",
< 		"file-2": zzz,
< 		"file-3": random,
< 	}
< 	for name, contents := range fileContents {
< 		err := ioutil.WriteFile(filepath.Join(filesDir, name), []byte(contents), 0644)
< 		if err != nil {
< 			t.Error(err)
< 			return
< 		}
< 	}
< 
< 	tests := []struct {
< 		in         File
< 		out        types.File
< 		exceptions []translate.Translation
< 		report     string
< 		options    common.TranslateOptions
< 	}{
< 		{
< 			File{},
< 			types.File{},
< 			nil,
< 			"",
< 			common.TranslateOptions{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			File{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Mode: util.IntToPtr(420),
< 				Append: []Resource{
< 					{
< 						Source:      util.StrToPtr("http://example/com"),
< 						Compression: util.StrToPtr("gzip"),
< 						HTTPHeaders: HTTPHeaders{
< 							HTTPHeader{
< 								Name:  "Header",
< 								Value: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						Verification: Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					{
< 						Inline:      util.StrToPtr("hello"),
< 						Compression: util.StrToPtr("gzip"),
< 						HTTPHeaders: HTTPHeaders{
< 							HTTPHeader{
< 								Name:  "Header",
< 								Value: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						Verification: Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					{
< 						Local: util.StrToPtr("file-1"),
< 					},
< 				},
< 				Overwrite: util.BoolToPtr(true),
< 				Contents: Resource{
< 					Source:      util.StrToPtr("http://example/com"),
< 					Compression: util.StrToPtr("gzip"),
< 					HTTPHeaders: HTTPHeaders{
< 						HTTPHeader{
< 							Name:  "Header",
< 							Value: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					Verification: Verification{
< 						Hash: util.StrToPtr("this isn't validated"),
< 					},
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Mode: util.IntToPtr(420),
< 					Append: []types.Resource{
< 						{
< 							Source:      util.StrToPtr("http://example/com"),
< 							Compression: util.StrToPtr("gzip"),
< 							HTTPHeaders: types.HTTPHeaders{
< 								types.HTTPHeader{
< 									Name:  "Header",
< 									Value: util.StrToPtr("this isn't validated"),
< 								},
< 							},
< 							Verification: types.Verification{
< 								Hash: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						{
< 							Source:      util.StrToPtr("data:,hello"),
< 							Compression: util.StrToPtr("gzip"),
< 							HTTPHeaders: types.HTTPHeaders{
< 								types.HTTPHeader{
< 									Name:  "Header",
< 									Value: util.StrToPtr("this isn't validated"),
< 								},
< 							},
< 							Verification: types.Verification{
< 								Hash: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						{
< 							Source: util.StrToPtr("data:,file%20contents%0A"),
< 						},
< 					},
< 					Contents: types.Resource{
< 						Source:      util.StrToPtr("http://example/com"),
< 						Compression: util.StrToPtr("gzip"),
< 						HTTPHeaders: types.HTTPHeaders{
< 							types.HTTPHeader{
< 								Name:  "Header",
< 								Value: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						Verification: types.Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "append", 1, "inline"),
< 					To:   path.New("json", "append", 1, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 2, "local"),
< 					To:   path.New("json", "append", 2, "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// inline file contents
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					// String is too short for auto gzip compression
< 					Inline: util.StrToPtr("xyzzy"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source: util.StrToPtr("data:,xyzzy"),
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{},
< 		},
< 		// local file contents
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("file-1"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source: util.StrToPtr("data:,file%20contents%0A"),
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "local"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// filesDir not specified
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("file-1"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 			},
< 			[]translate.Translation{},
< 			"error at $.contents.local: " + common.ErrNoFilesDir.Error() + "\n",
< 			common.TranslateOptions{},
< 		},
< 		// attempted directory traversal
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("../file-1"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 			},
< 			[]translate.Translation{},
< 			"error at $.contents.local: " + common.ErrFilesDirEscape.Error() + "\n",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// attempted inclusion of nonexistent file
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("file-missing"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 			},
< 			[]translate.Translation{},
< 			"error at $.contents.local: open " + filepath.Join(filesDir, "file-missing") + ": no such file or directory\n",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// inline and local automatic file encoding
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					// gzip
< 					Inline: util.StrToPtr(zzz),
< 				},
< 				Append: []Resource{
< 					{
< 						// gzip
< 						Local: util.StrToPtr("file-2"),
< 					},
< 					{
< 						// base64
< 						Inline: util.StrToPtr(random),
< 					},
< 					{
< 						// base64
< 						Local: util.StrToPtr("file-3"),
< 					},
< 					{
< 						// URL-escaped
< 						Inline:      util.StrToPtr(zzz),
< 						Compression: util.StrToPtr("invalid"),
< 					},
< 					{
< 						// URL-escaped
< 						Local:       util.StrToPtr("file-2"),
< 						Compression: util.StrToPtr("invalid"),
< 					},
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source:      util.StrToPtr(zzz_gz),
< 						Compression: util.StrToPtr("gzip"),
< 					},
< 					Append: []types.Resource{
< 						{
< 							Source:      util.StrToPtr(zzz_gz),
< 							Compression: util.StrToPtr("gzip"),
< 						},
< 						{
< 							Source: util.StrToPtr(random_b64),
< 						},
< 						{
< 							Source: util.StrToPtr(random_b64),
< 						},
< 						{
< 							Source:      util.StrToPtr("data:," + zzz),
< 							Compression: util.StrToPtr("invalid"),
< 						},
< 						{
< 							Source:      util.StrToPtr("data:," + zzz),
< 							Compression: util.StrToPtr("invalid"),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "compression"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 0, "local"),
< 					To:   path.New("json", "append", 0, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 0, "local"),
< 					To:   path.New("json", "append", 0, "compression"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 1, "inline"),
< 					To:   path.New("json", "append", 1, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 2, "local"),
< 					To:   path.New("json", "append", 2, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 3, "inline"),
< 					To:   path.New("json", "append", 3, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 4, "local"),
< 					To:   path.New("json", "append", 4, "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// Test disable automatic gzip compression
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Inline: util.StrToPtr(zzz),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source: util.StrToPtr("data:," + zzz),
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				NoResourceAutoCompression: true,
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, translations, r := translateFile(test.in, test.options)
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, test.report, r.String(), "#%d: bad report", i)
< 		baseutil.VerifyTranslations(t, translations, test.exceptions, "#%d", i)
< 	}
< }
< 
< // TestTranslateDirectory tests translating the ct storage.directories.[i] entries to ignition storage.directories.[i] entires.
< func TestTranslateDirectory(t *testing.T) {
< 	tests := []struct {
< 		in  Directory
< 		out types.Directory
< 	}{
< 		{
< 			Directory{},
< 			types.Directory{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Directory{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Mode:      util.IntToPtr(420),
< 				Overwrite: util.BoolToPtr(true),
< 			},
< 			types.Directory{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				DirectoryEmbedded1: types.DirectoryEmbedded1{
< 					Mode: util.IntToPtr(420),
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, _, r := translateDirectory(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateLink tests translating the ct storage.links.[i] entries to ignition storage.links.[i] entires.
< func TestTranslateLink(t *testing.T) {
< 	tests := []struct {
< 		in  Link
< 		out types.Link
< 	}{
< 		{
< 			Link{},
< 			types.Link{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Link{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Overwrite: util.BoolToPtr(true),
< 				Target:    "/bar",
< 				Hard:      util.BoolToPtr(false),
< 			},
< 			types.Link{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				LinkEmbedded1: types.LinkEmbedded1{
< 					Target: "/bar",
< 					Hard:   util.BoolToPtr(false),
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, _, r := translateLink(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateFilesystem tests translating the fcct storage.filesystems.[i] entries to ignition storage.filesystems.[i] entries.
< func TestTranslateFilesystem(t *testing.T) {
< 	tests := []struct {
< 		in  Filesystem
< 		out types.Filesystem
< 	}{
< 		{
< 			Filesystem{},
< 			types.Filesystem{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Filesystem{
< 				Device:         "/foo",
< 				Format:         util.StrToPtr("/bar"),
< 				Label:          util.StrToPtr("/baz"),
< 				MountOptions:   []string{"yes", "no", "maybe"},
< 				Options:        []string{"foo", "foo", "bar"},
< 				Path:           util.StrToPtr("/quux"),
< 				UUID:           util.StrToPtr("1234"),
< 				WipeFilesystem: util.BoolToPtr(true),
< 				WithMountUnit:  util.BoolToPtr(true),
< 			},
< 			types.Filesystem{
< 				Device:         "/foo",
< 				Format:         util.StrToPtr("/bar"),
< 				Label:          util.StrToPtr("/baz"),
< 				MountOptions:   []types.MountOption{"yes", "no", "maybe"},
< 				Options:        []types.FilesystemOption{"foo", "foo", "bar"},
< 				Path:           util.StrToPtr("/quux"),
< 				UUID:           util.StrToPtr("1234"),
< 				WipeFilesystem: util.BoolToPtr(true),
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		// Filesystem doesn't have a custom translator, so embed in a
< 		// complete config
< 		in := Config{
< 			Storage: Storage{
< 				Filesystems: []Filesystem{test.in},
< 			},
< 		}
< 		expected := []types.Filesystem{test.out}
< 		actual, _, r := in.ToIgn3_1Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, expected, actual.Storage.Filesystems, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateMountUnit tests the FCCT storage.filesystems.[i].with_mount_unit flag.
< func TestTranslateMountUnit(t *testing.T) {
< 	tests := []struct {
< 		in  Config
< 		out types.Config
< 	}{
< 		// local mount with options, overridden enabled flag
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/disk/by-label/foo",
< 							Format:        util.StrToPtr("ext4"),
< 							MountOptions:  []string{"ro", "noatime"},
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 				Systemd: Systemd{
< 					Units: []Unit{
< 						{
< 							Name:    "var-lib-containers.mount",
< 							Enabled: util.BoolToPtr(false),
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.1.0",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:       "/dev/disk/by-label/foo",
< 							Format:       util.StrToPtr("ext4"),
< 							MountOptions: []types.MountOption{"ro", "noatime"},
< 							Path:         util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled: util.BoolToPtr(false),
< 							Contents: util.StrToPtr(`# Generated by FCCT
< [Unit]
< Before=local-fs.target
< Requires=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< After=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< 
< [Mount]
< Where=/var/lib/containers
< What=/dev/disk/by-label/foo
< Type=ext4
< Options=ro,noatime
< 
< [Install]
< RequiredBy=local-fs.target`),
< 							Name: "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 		// local mount, no options
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/disk/by-label/foo",
< 							Format:        util.StrToPtr("ext4"),
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.1.0",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device: "/dev/disk/by-label/foo",
< 							Format: util.StrToPtr("ext4"),
< 							Path:   util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled: util.BoolToPtr(true),
< 							Contents: util.StrToPtr(`# Generated by FCCT
< [Unit]
< Before=local-fs.target
< Requires=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< After=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< 
< [Mount]
< Where=/var/lib/containers
< What=/dev/disk/by-label/foo
< Type=ext4
< 
< [Install]
< RequiredBy=local-fs.target`),
< 							Name: "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 		// overridden mount unit
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/disk/by-label/foo",
< 							Format:        util.StrToPtr("ext4"),
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 				Systemd: Systemd{
< 					Units: []Unit{
< 						{
< 							Name:     "var-lib-containers.mount",
< 							Contents: util.StrToPtr("[Service]\nExecStart=/bin/false\n"),
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.1.0",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device: "/dev/disk/by-label/foo",
< 							Format: util.StrToPtr("ext4"),
< 							Path:   util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled:  util.BoolToPtr(true),
< 							Contents: util.StrToPtr("[Service]\nExecStart=/bin/false\n"),
< 							Name:     "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		out, _, r := test.in.ToIgn3_1Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, test.out, out, "#%d: bad output", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: expected empty report", i)
< 	}
< }
< 
< // TestTranslateTree tests translating the FCC storage.trees.[i] entries to ignition storage.files.[i] entries.
< func TestTranslateTree(t *testing.T) {
< 	tests := []struct {
< 		options    *common.TranslateOptions // defaulted if not specified
< 		dirDirs    map[string]os.FileMode   // relative path -> mode
< 		dirFiles   map[string]os.FileMode   // relative path -> mode
< 		dirLinks   map[string]string        // relative path -> target
< 		dirSockets []string                 // relative path
< 		inTrees    []Tree
< 		inFiles    []File
< 		inDirs     []Directory
< 		inLinks    []Link
< 		outFiles   []types.File
< 		outLinks   []types.Link
< 		report     string
< 	}{
< 		// smoke test
< 		{},
< 		// basic functionality
< 		{
< 			dirFiles: map[string]os.FileMode{
< 				"tree/executable":            0700,
< 				"tree/file":                  0600,
< 				"tree/overridden":            0644,
< 				"tree/overridden-executable": 0700,
< 				"tree/subdir/file":           0644,
< 				// compressed contents
< 				"tree/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/file": 0644,
< 				"tree2/file": 0600,
< 			},
< 			dirLinks: map[string]string{
< 				"tree/subdir/bad-link":        "../nonexistent",
< 				"tree/subdir/link":            "../file",
< 				"tree/subdir/overridden-link": "../file",
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 				{
< 					Local: "tree2",
< 					Path:  util.StrToPtr("/etc"),
< 				},
< 			},
< 			inFiles: []File{
< 				{
< 					Path: "/overridden",
< 					Mode: util.IntToPtr(0600),
< 					User: NodeUser{
< 						Name: util.StrToPtr("bovik"),
< 					},
< 				},
< 				{
< 					Path: "/overridden-executable",
< 					Mode: util.IntToPtr(0600),
< 					User: NodeUser{
< 						Name: util.StrToPtr("bovik"),
< 					},
< 				},
< 			},
< 			inLinks: []Link{
< 				{
< 					Path: "/subdir/overridden-link",
< 					User: NodeUser{
< 						Name: util.StrToPtr("bovik"),
< 					},
< 				},
< 			},
< 			outFiles: []types.File{
< 				{
< 					Node: types.Node{
< 						Path: "/overridden",
< 						User: types.NodeUser{
< 							Name: util.StrToPtr("bovik"),
< 						},
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Foverridden"),
< 						},
< 						Mode: util.IntToPtr(0600),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/overridden-executable",
< 						User: types.NodeUser{
< 							Name: util.StrToPtr("bovik"),
< 						},
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Foverridden-executable"),
< 						},
< 						Mode: util.IntToPtr(0600),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/executable",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Fexecutable"),
< 						},
< 						Mode: util.IntToPtr(0755),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Ffile"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Fsubdir%2Ffile"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source:      util.StrToPtr("data:;base64,H4sIAAAAAAAC/yopSk3VLy5NSsksIptKy8xJBQQAAP//gkRzjkgAAAA="),
< 							Compression: util.StrToPtr("gzip"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/etc/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree2%2Ffile"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 			},
< 			outLinks: []types.Link{
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/overridden-link",
< 						User: types.NodeUser{
< 							Name: util.StrToPtr("bovik"),
< 						},
< 					},
< 					LinkEmbedded1: types.LinkEmbedded1{
< 						Target: "../file",
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/bad-link",
< 					},
< 					LinkEmbedded1: types.LinkEmbedded1{
< 						Target: "../nonexistent",
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/link",
< 					},
< 					LinkEmbedded1: types.LinkEmbedded1{
< 						Target: "../file",
< 					},
< 				},
< 			},
< 		},
< 		// collisions
< 		{
< 			dirFiles: map[string]os.FileMode{
< 				"tree0/file":         0600,
< 				"tree1/directory":    0600,
< 				"tree2/link":         0600,
< 				"tree3/file-partial": 0600, // should be okay
< 				"tree4/link-partial": 0600,
< 				"tree5/tree-file":    0600, // set up for tree/tree collision
< 				"tree6/tree-file":    0600,
< 				"tree15/tree-link":   0600,
< 			},
< 			dirLinks: map[string]string{
< 				"tree7/file":          "file",
< 				"tree8/directory":     "file",
< 				"tree9/link":          "file",
< 				"tree10/file-partial": "file",
< 				"tree11/link-partial": "file", // should be okay
< 				"tree12/tree-file":    "file",
< 				"tree13/tree-link":    "file", // set up for tree/tree collision
< 				"tree14/tree-link":    "file",
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree0",
< 				},
< 				{
< 					Local: "tree1",
< 				},
< 				{
< 					Local: "tree2",
< 				},
< 				{
< 					Local: "tree3",
< 				},
< 				{
< 					Local: "tree4",
< 				},
< 				{
< 					Local: "tree5",
< 				},
< 				{
< 					Local: "tree6",
< 				},
< 				{
< 					Local: "tree7",
< 				},
< 				{
< 					Local: "tree8",
< 				},
< 				{
< 					Local: "tree9",
< 				},
< 				{
< 					Local: "tree10",
< 				},
< 				{
< 					Local: "tree11",
< 				},
< 				{
< 					Local: "tree12",
< 				},
< 				{
< 					Local: "tree13",
< 				},
< 				{
< 					Local: "tree14",
< 				},
< 				{
< 					Local: "tree15",
< 				},
< 			},
< 			inFiles: []File{
< 				{
< 					Path: "/file",
< 					Contents: Resource{
< 						Source: util.StrToPtr("data:,foo"),
< 					},
< 				},
< 				{
< 					Path: "/file-partial",
< 				},
< 			},
< 			inDirs: []Directory{
< 				{
< 					Path: "/directory",
< 				},
< 			},
< 			inLinks: []Link{
< 				{
< 					Path:   "/link",
< 					Target: "file",
< 				},
< 				{
< 					Path: "/link-partial",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.1: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.2: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.4: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.6: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.7: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.8: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.9: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.10: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.12: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.14: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.15: " + common.ErrNodeExists.Error() + "\n",
< 		},
< 		// files-dir escape
< 		{
< 			inTrees: []Tree{
< 				{
< 					Local: "../escape",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrFilesDirEscape.Error() + "\n",
< 		},
< 		// no files-dir
< 		{
< 			options: &common.TranslateOptions{},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrNoFilesDir.Error() + "\n",
< 		},
< 		// non-file/dir/symlink in directory tree
< 		{
< 			dirSockets: []string{
< 				"tree/socket",
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrFileType.Error() + "\n",
< 		},
< 		// unreadable file
< 		{
< 			dirDirs: map[string]os.FileMode{
< 				"tree/subdir": 0000,
< 				"tree2":       0000,
< 			},
< 			dirFiles: map[string]os.FileMode{
< 				"tree/file": 0000,
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 				{
< 					Local: "tree2",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: open %FilesDir%/tree/file: permission denied\n" +
< 				"error at $.storage.trees.0: open %FilesDir%/tree/subdir: permission denied\n" +
< 				"error at $.storage.trees.1: open %FilesDir%/tree2: permission denied\n",
< 		},
< 		// local is not a directory
< 		{
< 			dirFiles: map[string]os.FileMode{
< 				"tree": 0600,
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 				{
< 					Local: "nonexistent",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrTreeNotDirectory.Error() + "\n" +
< 				"error at $.storage.trees.1: stat %FilesDir%/nonexistent: no such file or directory\n",
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		filesDir, err := ioutil.TempDir("", "translate-test-")
< 		if err != nil {
< 			t.Error(err)
< 			return
< 		}
< 		defer os.RemoveAll(filesDir)
< 		for path, mode := range test.dirDirs {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(absPath, 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			if err := os.Chmod(absPath, mode); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 		}
< 		for path, mode := range test.dirFiles {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			if err := ioutil.WriteFile(absPath, []byte(path), mode); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 		}
< 		for path, target := range test.dirLinks {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			if err := os.Symlink(target, absPath); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 		}
< 		for _, path := range test.dirSockets {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			listener, err := net.ListenUnix("unix", &net.UnixAddr{
< 				Name: absPath,
< 				Net:  "unix",
< 			})
< 			if err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			defer listener.Close()
< 		}
< 
< 		config := Config{
< 			Storage: Storage{
< 				Files:       test.inFiles,
< 				Directories: test.inDirs,
< 				Links:       test.inLinks,
< 				Trees:       test.inTrees,
< 			},
< 		}
< 		options := common.TranslateOptions{
< 			FilesDir: filesDir,
< 		}
< 		if test.options != nil {
< 			options = *test.options
< 		}
< 		actual, _, r := config.ToIgn3_1Unvalidated(options)
< 
< 		expectedReport := strings.ReplaceAll(test.report, "%FilesDir%", filesDir)
< 		assert.Equal(t, expectedReport, r.String(), "#%d: bad report", i)
< 		if expectedReport != "" {
< 			continue
< 		}
< 
< 		assert.Equal(t, test.outFiles, actual.Storage.Files, "#%d: files mismatch", i)
< 		assert.Equal(t, []types.Directory(nil), actual.Storage.Directories, "#%d: directories mismatch", i)
< 		assert.Equal(t, test.outLinks, actual.Storage.Links, "#%d: links mismatch", i)
< 	}
< }
< 
< // TestTranslateIgnition tests translating the ct config.ignition to the ignition config.ignition section.
< // It ensure that the version is set as well.
< func TestTranslateIgnition(t *testing.T) {
< 	tests := []struct {
< 		in  Ignition
< 		out types.Ignition
< 	}{
< 		{
< 			Ignition{},
< 			types.Ignition{
< 				Version: "3.1.0",
< 			},
< 		},
< 		{
< 			Ignition{
< 				Config: IgnitionConfig{
< 					Merge: []Resource{
< 						{
< 							Inline: util.StrToPtr("xyzzy"),
< 						},
< 					},
< 					Replace: Resource{
< 						Inline: util.StrToPtr("xyzzy"),
< 					},
< 				},
< 			},
< 			types.Ignition{
< 				Version: "3.1.0",
< 				Config: types.IgnitionConfig{
< 					Merge: []types.Resource{
< 						{
< 							Source: util.StrToPtr("data:,xyzzy"),
< 						},
< 					},
< 					Replace: types.Resource{
< 						Source: util.StrToPtr("data:,xyzzy"),
< 					},
< 				},
< 			},
< 		},
< 		{
< 			Ignition{
< 				Proxy: Proxy{
< 					HTTPProxy: util.StrToPtr("https://example.com:8080"),
< 					NoProxy:   []string{"example.com"},
< 				},
< 			},
< 			types.Ignition{
< 				Version: "3.1.0",
< 				Proxy: types.Proxy{
< 					HTTPProxy: util.StrToPtr("https://example.com:8080"),
< 					NoProxy:   []types.NoProxyItem{types.NoProxyItem("example.com")},
< 				},
< 			},
< 		},
< 		{
< 			Ignition{
< 				Security: Security{
< 					TLS: TLS{
< 						CertificateAuthorities: []Resource{
< 							{
< 								Inline: util.StrToPtr("xyzzy"),
< 							},
< 						},
< 					},
< 				},
< 			},
< 			types.Ignition{
< 				Version: "3.1.0",
< 				Security: types.Security{
< 					TLS: types.TLS{
< 						CertificateAuthorities: []types.Resource{
< 							{
< 								Source: util.StrToPtr("data:,xyzzy"),
< 							},
< 						},
< 					},
< 				},
< 			},
< 		},
< 	}
< 	for i, test := range tests {
< 		actual, _, r := translateIgnition(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestToIgn3_1 tests the config.ToIgn3_1 function ensuring it will generate a valid config even when empty. Not much else is
< // tested since it uses the Ignition translation code which has it's own set of tests.
< func TestToIgn3_1(t *testing.T) {
< 	tests := []struct {
< 		in  Config
< 		out types.Config
< 	}{
< 		{
< 			Config{},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.1.0",
< 				},
< 			},
< 		},
< 	}
< 	for i, test := range tests {
< 		actual, _, r := test.in.ToIgn3_1Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_2/util.go updated/vendor/github.com/coreos/fcct/base/v0_2/util.go
1,125d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_2
< 
< import (
< 	"github.com/coreos/ignition/v2/config/v3_1/types"
< )
< 
< type nodeTracker struct {
< 	files   *[]types.File
< 	fileMap map[string]int
< 
< 	dirs   *[]types.Directory
< 	dirMap map[string]int
< 
< 	links   *[]types.Link
< 	linkMap map[string]int
< }
< 
< func newNodeTracker(c *types.Config) *nodeTracker {
< 	t := nodeTracker{
< 		files:   &c.Storage.Files,
< 		fileMap: make(map[string]int, len(c.Storage.Files)),
< 
< 		dirs:   &c.Storage.Directories,
< 		dirMap: make(map[string]int, len(c.Storage.Directories)),
< 
< 		links:   &c.Storage.Links,
< 		linkMap: make(map[string]int, len(c.Storage.Links)),
< 	}
< 	for i, n := range *t.files {
< 		t.fileMap[n.Path] = i
< 	}
< 	for i, n := range *t.dirs {
< 		t.dirMap[n.Path] = i
< 	}
< 	for i, n := range *t.links {
< 		t.linkMap[n.Path] = i
< 	}
< 	return &t
< }
< 
< func (t *nodeTracker) Exists(path string) bool {
< 	for _, m := range []map[string]int{t.fileMap, t.dirMap, t.linkMap} {
< 		if _, ok := m[path]; ok {
< 			return true
< 		}
< 	}
< 	return false
< }
< 
< func (t *nodeTracker) GetFile(path string) (int, *types.File) {
< 	if i, ok := t.fileMap[path]; ok {
< 		return i, &(*t.files)[i]
< 	} else {
< 		return 0, nil
< 	}
< }
< 
< func (t *nodeTracker) AddFile(f types.File) (int, *types.File) {
< 	if f.Path == "" {
< 		panic("File path missing")
< 	}
< 	if _, ok := t.fileMap[f.Path]; ok {
< 		panic("Adding already existing file")
< 	}
< 	i := len(*t.files)
< 	*t.files = append(*t.files, f)
< 	t.fileMap[f.Path] = i
< 	return i, &(*t.files)[i]
< }
< 
< func (t *nodeTracker) GetDir(path string) (int, *types.Directory) {
< 	if i, ok := t.dirMap[path]; ok {
< 		return i, &(*t.dirs)[i]
< 	} else {
< 		return 0, nil
< 	}
< }
< 
< func (t *nodeTracker) AddDir(d types.Directory) (int, *types.Directory) {
< 	if d.Path == "" {
< 		panic("Directory path missing")
< 	}
< 	if _, ok := t.dirMap[d.Path]; ok {
< 		panic("Adding already existing directory")
< 	}
< 	i := len(*t.dirs)
< 	*t.dirs = append(*t.dirs, d)
< 	t.dirMap[d.Path] = i
< 	return i, &(*t.dirs)[i]
< }
< 
< func (t *nodeTracker) GetLink(path string) (int, *types.Link) {
< 	if i, ok := t.linkMap[path]; ok {
< 		return i, &(*t.links)[i]
< 	} else {
< 		return 0, nil
< 	}
< }
< 
< func (t *nodeTracker) AddLink(l types.Link) (int, *types.Link) {
< 	if l.Path == "" {
< 		panic("Link path missing")
< 	}
< 	if _, ok := t.linkMap[l.Path]; ok {
< 		panic("Adding already existing link")
< 	}
< 	i := len(*t.links)
< 	*t.links = append(*t.links, l)
< 	t.linkMap[l.Path] = i
< 	return i, &(*t.links)[i]
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_2/validate.go updated/vendor/github.com/coreos/fcct/base/v0_2/validate.go
1,78d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_2
< 
< import (
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (rs Resource) Validate(c path.ContextPath) (r report.Report) {
< 	var field string
< 	sources := 0
< 	if rs.Local != nil {
< 		sources++
< 		field = "local"
< 	}
< 	if rs.Inline != nil {
< 		sources++
< 		field = "inline"
< 	}
< 	if rs.Source != nil {
< 		sources++
< 		field = "source"
< 	}
< 	if sources > 1 {
< 		r.AddOnError(c.Append(field), common.ErrTooManyResourceSources)
< 	}
< 	return
< }
< 
< func (fs Filesystem) Validate(c path.ContextPath) (r report.Report) {
< 	if fs.WithMountUnit == nil || !*fs.WithMountUnit {
< 		return
< 	}
< 	if fs.Path == nil || *fs.Path == "" {
< 		r.AddOnError(c.Append("path"), common.ErrMountUnitNoPath)
< 	}
< 	if fs.Format == nil || *fs.Format == "" {
< 		r.AddOnError(c.Append("format"), common.ErrMountUnitNoFormat)
< 	}
< 	return
< }
< 
< func (d Directory) Validate(c path.ContextPath) (r report.Report) {
< 	if d.Mode != nil {
< 		r.AddOnWarn(c.Append("mode"), baseutil.CheckForDecimalMode(*d.Mode, true))
< 	}
< 	return
< }
< 
< func (f File) Validate(c path.ContextPath) (r report.Report) {
< 	if f.Mode != nil {
< 		r.AddOnWarn(c.Append("mode"), baseutil.CheckForDecimalMode(*f.Mode, false))
< 	}
< 	return
< }
< 
< func (t Tree) Validate(c path.ContextPath) (r report.Report) {
< 	if t.Local == "" {
< 		r.AddOnError(c, common.ErrTreeNoLocal)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_2/validate_test.go updated/vendor/github.com/coreos/fcct/base/v0_2/validate_test.go
1,214d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_2
< 
< import (
< 	"testing"
< 
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // TestValidateResource tests that multiple sources (i.e. urls and inline) are not allowed but zero or one sources are
< func TestValidateResource(t *testing.T) {
< 	tests := []struct {
< 		in      Resource
< 		out     error
< 		errPath path.ContextPath
< 	}{
< 		{},
< 		// source specified
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Resource{
< 				Source:      util.StrToPtr("http://example/com"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// inline specified
< 		{
< 			Resource{
< 				Inline:      util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// local specified
< 		{
< 			Resource{
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// source + inline, invalid
< 		{
< 			Resource{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Inline:      util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "source"),
< 		},
< 		// source + local, invalid
< 		{
< 			Resource{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "source"),
< 		},
< 		// inline + local, invalid
< 		{
< 			Resource{
< 				Inline:      util.StrToPtr("hello"),
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "inline"),
< 		},
< 		// source + inline + local, invalid
< 		{
< 			Resource{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Inline:      util.StrToPtr("hello"),
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "source"),
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnError(test.errPath, test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
< 
< func TestValidateTree(t *testing.T) {
< 	tests := []struct {
< 		in  Tree
< 		out error
< 	}{
< 		{
< 			in:  Tree{},
< 			out: common.ErrTreeNoLocal,
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnError(path.New("yaml"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
< 
< func TestValidateMode(t *testing.T) {
< 	fileTests := []struct {
< 		in  File
< 		out error
< 	}{
< 		{
< 			in:  File{},
< 			out: nil,
< 		},
< 		{
< 			in: File{
< 				Mode: util.IntToPtr(0600),
< 			},
< 			out: nil,
< 		},
< 		{
< 			in: File{
< 				Mode: util.IntToPtr(600),
< 			},
< 			out: common.ErrDecimalMode,
< 		},
< 	}
< 
< 	for i, test := range fileTests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnWarn(path.New("yaml", "mode"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< 
< 	dirTests := []struct {
< 		in  Directory
< 		out error
< 	}{
< 		{
< 			in:  Directory{},
< 			out: nil,
< 		},
< 		{
< 			in: Directory{
< 				Mode: util.IntToPtr(01770),
< 			},
< 			out: nil,
< 		},
< 		{
< 			in: Directory{
< 				Mode: util.IntToPtr(1770),
< 			},
< 			out: common.ErrDecimalMode,
< 		},
< 	}
< 
< 	for i, test := range dirTests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnWarn(path.New("yaml", "mode"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_3/schema.go updated/vendor/github.com/coreos/fcct/base/v0_3/schema.go
1,254d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_3
< 
< type Clevis struct {
< 	Custom    *Custom `yaml:"custom"`
< 	Tang      []Tang  `yaml:"tang"`
< 	Threshold *int    `yaml:"threshold"`
< 	Tpm2      *bool   `yaml:"tpm2"`
< }
< 
< type Config struct {
< 	Version  string   `yaml:"version"`
< 	Variant  string   `yaml:"variant"`
< 	Ignition Ignition `yaml:"ignition"`
< 	Passwd   Passwd   `yaml:"passwd"`
< 	Storage  Storage  `yaml:"storage"`
< 	Systemd  Systemd  `yaml:"systemd"`
< }
< 
< type Custom struct {
< 	Config       string `yaml:"config"`
< 	NeedsNetwork *bool  `yaml:"needs_network"`
< 	Pin          string `yaml:"pin"`
< }
< 
< type Device string
< 
< type Directory struct {
< 	Group     NodeGroup `yaml:"group"`
< 	Overwrite *bool     `yaml:"overwrite"`
< 	Path      string    `yaml:"path"`
< 	User      NodeUser  `yaml:"user"`
< 	Mode      *int      `yaml:"mode"`
< }
< 
< type Disk struct {
< 	Device     string      `yaml:"device"`
< 	Partitions []Partition `yaml:"partitions"`
< 	WipeTable  *bool       `yaml:"wipe_table"`
< }
< 
< type Dropin struct {
< 	Contents *string `yaml:"contents"`
< 	Name     string  `yaml:"name"`
< }
< 
< type File struct {
< 	Group     NodeGroup  `yaml:"group"`
< 	Overwrite *bool      `yaml:"overwrite"`
< 	Path      string     `yaml:"path"`
< 	User      NodeUser   `yaml:"user"`
< 	Append    []Resource `yaml:"append"`
< 	Contents  Resource   `yaml:"contents"`
< 	Mode      *int       `yaml:"mode"`
< }
< 
< type Filesystem struct {
< 	Device         string   `yaml:"device"`
< 	Format         *string  `yaml:"format"`
< 	Label          *string  `yaml:"label"`
< 	MountOptions   []string `yaml:"mount_options"`
< 	Options        []string `yaml:"options"`
< 	Path           *string  `yaml:"path"`
< 	UUID           *string  `yaml:"uuid"`
< 	WipeFilesystem *bool    `yaml:"wipe_filesystem"`
< 	WithMountUnit  *bool    `yaml:"with_mount_unit" fcct:"auto_skip"` // Added, not in Ignition spec
< }
< 
< type FilesystemOption string
< 
< type Group string
< 
< type HTTPHeader struct {
< 	Name  string  `yaml:"name"`
< 	Value *string `yaml:"value"`
< }
< 
< type HTTPHeaders []HTTPHeader
< 
< type Ignition struct {
< 	Config   IgnitionConfig `yaml:"config"`
< 	Proxy    Proxy          `yaml:"proxy"`
< 	Security Security       `yaml:"security"`
< 	Timeouts Timeouts       `yaml:"timeouts"`
< }
< 
< type IgnitionConfig struct {
< 	Merge   []Resource `yaml:"merge"`
< 	Replace Resource   `yaml:"replace"`
< }
< 
< type Link struct {
< 	Group     NodeGroup `yaml:"group"`
< 	Overwrite *bool     `yaml:"overwrite"`
< 	Path      string    `yaml:"path"`
< 	User      NodeUser  `yaml:"user"`
< 	Hard      *bool     `yaml:"hard"`
< 	Target    string    `yaml:"target"`
< }
< 
< type Luks struct {
< 	Clevis     *Clevis      `yaml:"clevis"`
< 	Device     *string      `yaml:"device"`
< 	KeyFile    Resource     `yaml:"key_file"`
< 	Label      *string      `yaml:"label"`
< 	Name       string       `yaml:"name"`
< 	Options    []LuksOption `yaml:"options"`
< 	UUID       *string      `yaml:"uuid"`
< 	WipeVolume *bool        `yaml:"wipe_volume"`
< }
< 
< type LuksOption string
< 
< type NodeGroup struct {
< 	ID   *int    `yaml:"id"`
< 	Name *string `yaml:"name"`
< }
< 
< type NodeUser struct {
< 	ID   *int    `yaml:"id"`
< 	Name *string `yaml:"name"`
< }
< 
< type Partition struct {
< 	GUID               *string `yaml:"guid"`
< 	Label              *string `yaml:"label"`
< 	Number             int     `yaml:"number"`
< 	Resize             *bool   `yaml:"resize"`
< 	ShouldExist        *bool   `yaml:"should_exist"`
< 	SizeMiB            *int    `yaml:"size_mib"`
< 	StartMiB           *int    `yaml:"start_mib"`
< 	TypeGUID           *string `yaml:"type_guid"`
< 	WipePartitionEntry *bool   `yaml:"wipe_partition_entry"`
< }
< 
< type Passwd struct {
< 	Groups []PasswdGroup `yaml:"groups"`
< 	Users  []PasswdUser  `yaml:"users"`
< }
< 
< type PasswdGroup struct {
< 	Gid          *int    `yaml:"gid"`
< 	Name         string  `yaml:"name"`
< 	PasswordHash *string `yaml:"password_hash"`
< 	ShouldExist  *bool   `yaml:"should_exist"`
< 	System       *bool   `yaml:"system"`
< }
< 
< type PasswdUser struct {
< 	Gecos             *string            `yaml:"gecos"`
< 	Groups            []Group            `yaml:"groups"`
< 	HomeDir           *string            `yaml:"home_dir"`
< 	Name              string             `yaml:"name"`
< 	NoCreateHome      *bool              `yaml:"no_create_home"`
< 	NoLogInit         *bool              `yaml:"no_log_init"`
< 	NoUserGroup       *bool              `yaml:"no_user_group"`
< 	PasswordHash      *string            `yaml:"password_hash"`
< 	PrimaryGroup      *string            `yaml:"primary_group"`
< 	ShouldExist       *bool              `yaml:"should_exist"`
< 	SSHAuthorizedKeys []SSHAuthorizedKey `yaml:"ssh_authorized_keys"`
< 	Shell             *string            `yaml:"shell"`
< 	System            *bool              `yaml:"system"`
< 	UID               *int               `yaml:"uid"`
< }
< 
< type Proxy struct {
< 	HTTPProxy  *string  `yaml:"http_proxy"`
< 	HTTPSProxy *string  `yaml:"https_proxy"`
< 	NoProxy    []string `yaml:"no_proxy"`
< }
< 
< type Raid struct {
< 	Devices []Device     `yaml:"devices"`
< 	Level   string       `yaml:"level"`
< 	Name    string       `yaml:"name"`
< 	Options []RaidOption `yaml:"options"`
< 	Spares  *int         `yaml:"spares"`
< }
< 
< type RaidOption string
< 
< type Resource struct {
< 	Compression  *string      `yaml:"compression"`
< 	HTTPHeaders  HTTPHeaders  `yaml:"http_headers"`
< 	Source       *string      `yaml:"source"`
< 	Inline       *string      `yaml:"inline"` // Added, not in ignition spec
< 	Local        *string      `yaml:"local"`  // Added, not in ignition spec
< 	Verification Verification `yaml:"verification"`
< }
< 
< type SSHAuthorizedKey string
< 
< type Security struct {
< 	TLS TLS `yaml:"tls"`
< }
< 
< type Storage struct {
< 	Directories []Directory  `yaml:"directories"`
< 	Disks       []Disk       `yaml:"disks"`
< 	Files       []File       `yaml:"files"`
< 	Filesystems []Filesystem `yaml:"filesystems"`
< 	Links       []Link       `yaml:"links"`
< 	Luks        []Luks       `yaml:"luks"`
< 	Raid        []Raid       `yaml:"raid"`
< 	Trees       []Tree       `yaml:"trees" fcct:"auto_skip"` // Added, not in ignition spec
< }
< 
< type Systemd struct {
< 	Units []Unit `yaml:"units"`
< }
< 
< type Tang struct {
< 	Thumbprint *string `yaml:"thumbprint"`
< 	URL        string  `yaml:"url"`
< }
< 
< type TLS struct {
< 	CertificateAuthorities []Resource `yaml:"certificate_authorities"`
< }
< 
< type Timeouts struct {
< 	HTTPResponseHeaders *int `yaml:"http_response_headers"`
< 	HTTPTotal           *int `yaml:"http_total"`
< }
< 
< type Tree struct {
< 	Local string  `yaml:"local"`
< 	Path  *string `yaml:"path"`
< }
< 
< type Unit struct {
< 	Contents *string  `yaml:"contents"`
< 	Dropins  []Dropin `yaml:"dropins"`
< 	Enabled  *bool    `yaml:"enabled"`
< 	Mask     *bool    `yaml:"mask"`
< 	Name     string   `yaml:"name"`
< }
< 
< type Verification struct {
< 	Hash *string `yaml:"hash"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_3/translate.go updated/vendor/github.com/coreos/fcct/base/v0_3/translate.go
1,400d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_3
< 
< import (
< 	"fmt"
< 	"io/ioutil"
< 	"os"
< 	"path/filepath"
< 	"strings"
< 	"text/template"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/go-systemd/unit"
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_2/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< var (
< 	mountUnitTemplate = template.Must(template.New("unit").Parse(`# Generated by FCCT
< [Unit]
< {{- if .Remote }}
< Before=remote-fs.target
< DefaultDependencies=no
< {{- else }}
< Before=local-fs.target
< {{- end }}
< Requires=systemd-fsck@{{.EscapedDevice}}.service
< After=systemd-fsck@{{.EscapedDevice}}.service
< 
< [Mount]
< Where={{.Path}}
< What={{.Device}}
< Type={{.Format}}
< {{- if .MountOptions }}
< Options=
<   {{- range $i, $opt := .MountOptions }}
<     {{- if $i }},{{ end }}
<     {{- $opt }}
<   {{- end }}
< {{- end }}
< 
< [Install]
< {{- if .Remote }}
< RequiredBy=remote-fs.target
< {{- else }}
< RequiredBy=local-fs.target
< {{- end }}`))
< )
< 
< // ToIgn3_2Unvalidated translates the config to an Ignition config. It also returns the set of translations
< // it did so paths in the resultant config can be tracked back to their source in the source config.
< // No config validation is performed on input or output.
< func (c Config) ToIgn3_2Unvalidated(options common.TranslateOptions) (types.Config, translate.TranslationSet, report.Report) {
< 	ret := types.Config{}
< 
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateIgnition)
< 	tr.AddCustomTranslator(translateFile)
< 	tr.AddCustomTranslator(translateDirectory)
< 	tr.AddCustomTranslator(translateLink)
< 	tr.AddCustomTranslator(translateResource)
< 
< 	tm, r := translate.Prefixed(tr, "ignition", &c.Ignition, &ret.Ignition)
< 	translate.MergeP(tr, tm, &r, "passwd", &c.Passwd, &ret.Passwd)
< 	translate.MergeP(tr, tm, &r, "storage", &c.Storage, &ret.Storage)
< 	translate.MergeP(tr, tm, &r, "systemd", &c.Systemd, &ret.Systemd)
< 
< 	c.addMountUnits(&ret, &tm)
< 
< 	tm2, r2 := c.processTrees(&ret, options)
< 	tm.Merge(tm2)
< 	r.Merge(r2)
< 
< 	if r.IsFatal() {
< 		return types.Config{}, translate.TranslationSet{}, r
< 	}
< 	return ret, tm, r
< }
< 
< func translateIgnition(from Ignition, options common.TranslateOptions) (to types.Ignition, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateResource)
< 	to.Version = types.MaxVersion.String()
< 	tm, r = translate.Prefixed(tr, "config", &from.Config, &to.Config)
< 	translate.MergeP(tr, tm, &r, "proxy", &from.Proxy, &to.Proxy)
< 	translate.MergeP(tr, tm, &r, "security", &from.Security, &to.Security)
< 	translate.MergeP(tr, tm, &r, "timeouts", &from.Timeouts, &to.Timeouts)
< 	return
< }
< 
< func translateFile(from File, options common.TranslateOptions) (to types.File, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateResource)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	translate.MergeP(tr, tm, &r, "append", &from.Append, &to.Append)
< 	translate.MergeP(tr, tm, &r, "contents", &from.Contents, &to.Contents)
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	to.Mode = from.Mode
< 	tm.AddIdentity("overwrite", "path", "mode")
< 	return
< }
< 
< func translateResource(from Resource, options common.TranslateOptions) (to types.Resource, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "verification", &from.Verification, &to.Verification)
< 	translate.MergeP(tr, tm, &r, "httpHeaders", &from.HTTPHeaders, &to.HTTPHeaders)
< 	to.Source = from.Source
< 	to.Compression = from.Compression
< 	tm.AddIdentity("source", "compression")
< 
< 	if from.Local != nil {
< 		c := path.New("yaml", "local")
< 
< 		if options.FilesDir == "" {
< 			r.AddOnError(c, common.ErrNoFilesDir)
< 			return
< 		}
< 
< 		// calculate file path within FilesDir and check for
< 		// path traversal
< 		filePath := filepath.Join(options.FilesDir, *from.Local)
< 		if err := baseutil.EnsurePathWithinFilesDir(filePath, options.FilesDir); err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 
< 		contents, err := ioutil.ReadFile(filePath)
< 		if err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 
< 		src, gzipped, err := baseutil.MakeDataURL(contents, to.Compression, !options.NoResourceAutoCompression)
< 		if err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 		to.Source = &src
< 		tm.AddTranslation(c, path.New("json", "source"))
< 		if gzipped {
< 			to.Compression = util.StrToPtr("gzip")
< 			tm.AddTranslation(c, path.New("json", "compression"))
< 		}
< 	}
< 
< 	if from.Inline != nil {
< 		c := path.New("yaml", "inline")
< 
< 		src, gzipped, err := baseutil.MakeDataURL([]byte(*from.Inline), to.Compression, !options.NoResourceAutoCompression)
< 		if err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 		to.Source = &src
< 		tm.AddTranslation(c, path.New("json", "source"))
< 		if gzipped {
< 			to.Compression = util.StrToPtr("gzip")
< 			tm.AddTranslation(c, path.New("json", "compression"))
< 		}
< 	}
< 	return
< }
< 
< func translateDirectory(from Directory, options common.TranslateOptions) (to types.Directory, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	to.Mode = from.Mode
< 	tm.AddIdentity("overwrite", "path", "mode")
< 	return
< }
< 
< func translateLink(from Link, options common.TranslateOptions) (to types.Link, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	to.Target = from.Target
< 	to.Hard = from.Hard
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	tm.AddIdentity("target", "hard", "overwrite", "path")
< 	return
< }
< 
< func (c Config) processTrees(ret *types.Config, options common.TranslateOptions) (translate.TranslationSet, report.Report) {
< 	ts := translate.NewTranslationSet("yaml", "json")
< 	var r report.Report
< 	if len(c.Storage.Trees) == 0 {
< 		return ts, r
< 	}
< 	t := newNodeTracker(ret)
< 
< 	for i, tree := range c.Storage.Trees {
< 		yamlPath := path.New("yaml", "storage", "trees", i)
< 		if options.FilesDir == "" {
< 			r.AddOnError(yamlPath, common.ErrNoFilesDir)
< 			return ts, r
< 		}
< 
< 		// calculate base path within FilesDir and check for
< 		// path traversal
< 		srcBaseDir := filepath.Join(options.FilesDir, tree.Local)
< 		if err := baseutil.EnsurePathWithinFilesDir(srcBaseDir, options.FilesDir); err != nil {
< 			r.AddOnError(yamlPath, err)
< 			continue
< 		}
< 		info, err := os.Stat(srcBaseDir)
< 		if err != nil {
< 			r.AddOnError(yamlPath, err)
< 			continue
< 		}
< 		if !info.IsDir() {
< 			r.AddOnError(yamlPath, common.ErrTreeNotDirectory)
< 			continue
< 		}
< 		destBaseDir := "/"
< 		if tree.Path != nil && *tree.Path != "" {
< 			destBaseDir = *tree.Path
< 		}
< 
< 		walkTree(yamlPath, tree, &ts, &r, t, srcBaseDir, destBaseDir, options)
< 	}
< 	return ts, r
< }
< 
< func walkTree(yamlPath path.ContextPath, tree Tree, ts *translate.TranslationSet, r *report.Report, t *nodeTracker, srcBaseDir, destBaseDir string, options common.TranslateOptions) {
< 	// The strategy for errors within WalkFunc is to add an error to
< 	// the report and return nil, so walking continues but translation
< 	// will fail afterward.
< 	err := filepath.Walk(srcBaseDir, func(srcPath string, info os.FileInfo, err error) error {
< 		if err != nil {
< 			r.AddOnError(yamlPath, err)
< 			return nil
< 		}
< 		relPath, err := filepath.Rel(srcBaseDir, srcPath)
< 		if err != nil {
< 			r.AddOnError(yamlPath, err)
< 			return nil
< 		}
< 		destPath := filepath.Join(destBaseDir, relPath)
< 
< 		if info.Mode().IsDir() {
< 			return nil
< 		} else if info.Mode().IsRegular() {
< 			i, file := t.GetFile(destPath)
< 			if file != nil {
< 				if file.Contents.Source != nil && *file.Contents.Source != "" {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 			} else {
< 				if t.Exists(destPath) {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 				i, file = t.AddFile(types.File{
< 					Node: types.Node{
< 						Path: destPath,
< 					},
< 				})
< 				ts.AddFromCommonSource(yamlPath, path.New("json", "storage", "files", i), file)
< 			}
< 			contents, err := ioutil.ReadFile(srcPath)
< 			if err != nil {
< 				r.AddOnError(yamlPath, err)
< 				return nil
< 			}
< 			url, gzipped, err := baseutil.MakeDataURL(contents, file.Contents.Compression, !options.NoResourceAutoCompression)
< 			if err != nil {
< 				r.AddOnError(yamlPath, err)
< 				return nil
< 			}
< 			file.Contents.Source = util.StrToPtr(url)
< 			ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "contents", "source"))
< 			if gzipped {
< 				file.Contents.Compression = util.StrToPtr("gzip")
< 				ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "contents", "compression"))
< 			}
< 			if file.Mode == nil {
< 				mode := 0644
< 				if info.Mode()&0111 != 0 {
< 					mode = 0755
< 				}
< 				file.Mode = &mode
< 				ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "mode"))
< 			}
< 		} else if info.Mode()&os.ModeType == os.ModeSymlink {
< 			i, link := t.GetLink(destPath)
< 			if link != nil {
< 				if link.Target != "" {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 			} else {
< 				if t.Exists(destPath) {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 				i, link = t.AddLink(types.Link{
< 					Node: types.Node{
< 						Path: destPath,
< 					},
< 				})
< 				ts.AddFromCommonSource(yamlPath, path.New("json", "storage", "links", i), link)
< 			}
< 			link.Target, err = os.Readlink(srcPath)
< 			if err != nil {
< 				r.AddOnError(yamlPath, err)
< 				return nil
< 			}
< 			ts.AddTranslation(yamlPath, path.New("json", "storage", "links", i, "target"))
< 		} else {
< 			r.AddOnError(yamlPath, common.ErrFileType)
< 			return nil
< 		}
< 		return nil
< 	})
< 	r.AddOnError(yamlPath, err)
< }
< 
< func (c Config) addMountUnits(config *types.Config, ts *translate.TranslationSet) {
< 	if len(c.Storage.Filesystems) == 0 {
< 		return
< 	}
< 	var rendered types.Config
< 	renderedTranslations := translate.NewTranslationSet("yaml", "json")
< 	for i, fs := range c.Storage.Filesystems {
< 		if fs.WithMountUnit == nil || !*fs.WithMountUnit {
< 			continue
< 		}
< 		fromPath := path.New("yaml", "storage", "filesystems", i, "with_mount_unit")
< 		remote := false
< 		// check filesystems targeting /dev/mapper devices against LUKS to determine if a
< 		// remote mount is needed
< 		if strings.HasPrefix(fs.Device, "/dev/mapper/") || strings.HasPrefix(fs.Device, "/dev/disk/by-id/dm-name-") {
< 			for _, luks := range c.Storage.Luks {
< 				// LUKS devices are opened with their name specified
< 				if fs.Device == fmt.Sprintf("/dev/mapper/%s", luks.Name) || fs.Device == fmt.Sprintf("/dev/disk/by-id/dm-name-%s", luks.Name) {
< 					if luks.Clevis != nil && len(luks.Clevis.Tang) > 0 {
< 						remote = true
< 						break
< 					}
< 				}
< 			}
< 		}
< 		newUnit := mountUnitFromFS(fs, remote)
< 		unitPath := path.New("json", "systemd", "units", len(rendered.Systemd.Units))
< 		rendered.Systemd.Units = append(rendered.Systemd.Units, newUnit)
< 		renderedTranslations.AddFromCommonSource(fromPath, unitPath, newUnit)
< 	}
< 	retConfig, retTranslations := baseutil.MergeTranslatedConfigs(rendered, renderedTranslations, *config, *ts)
< 	*config = retConfig.(types.Config)
< 	*ts = retTranslations
< }
< 
< func mountUnitFromFS(fs Filesystem, remote bool) types.Unit {
< 	context := struct {
< 		*Filesystem
< 		EscapedDevice string
< 		Remote        bool
< 	}{
< 		Filesystem:    &fs,
< 		EscapedDevice: unit.UnitNamePathEscape(fs.Device),
< 		Remote:        remote,
< 	}
< 	contents := strings.Builder{}
< 	err := mountUnitTemplate.Execute(&contents, context)
< 	if err != nil {
< 		panic(err)
< 	}
< 	// unchecked deref of path ok, fs would fail validation otherwise
< 	unitName := unit.UnitNamePathEscape(*fs.Path) + ".mount"
< 	return types.Unit{
< 		Name:     unitName,
< 		Enabled:  util.BoolToPtr(true),
< 		Contents: util.StrToPtr(contents.String()),
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_3/translate_test.go updated/vendor/github.com/coreos/fcct/base/v0_3/translate_test.go
1,1438d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_3
< 
< import (
< 	"io/ioutil"
< 	"net"
< 	"os"
< 	"path/filepath"
< 	"strings"
< 	"testing"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_2/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // Most of this is covered by the Ignition translator generic tests, so just test the custom bits
< 
< // TestTranslateFile tests translating the ct storage.files.[i] entries to ignition storage.files.[i] entries.
< func TestTranslateFile(t *testing.T) {
< 	zzz := "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"
< 	zzz_gz := "data:;base64,H4sIAAAAAAAC/6oajAAQAAD//5tA8d+VAAAA"
< 	random := "\xc0\x9cl\x01\x89i\xa5\xbfW\xe4\x1b\xf4J_\xb79P\xa3#\xa7"
< 	random_b64 := "data:;base64,wJxsAYlppb9X5Bv0Sl+3OVCjI6c="
< 
< 	filesDir, err := ioutil.TempDir("", "translate-test-")
< 	if err != nil {
< 		t.Error(err)
< 		return
< 	}
< 	defer os.RemoveAll(filesDir)
< 	fileContents := map[string]string{
< 		"file-1": "file contents\n",
< 		"file-2": zzz,
< 		"file-3": random,
< 	}
< 	for name, contents := range fileContents {
< 		err := ioutil.WriteFile(filepath.Join(filesDir, name), []byte(contents), 0644)
< 		if err != nil {
< 			t.Error(err)
< 			return
< 		}
< 	}
< 
< 	tests := []struct {
< 		in         File
< 		out        types.File
< 		exceptions []translate.Translation
< 		report     string
< 		options    common.TranslateOptions
< 	}{
< 		{
< 			File{},
< 			types.File{},
< 			nil,
< 			"",
< 			common.TranslateOptions{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			File{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Mode: util.IntToPtr(420),
< 				Append: []Resource{
< 					{
< 						Source:      util.StrToPtr("http://example/com"),
< 						Compression: util.StrToPtr("gzip"),
< 						HTTPHeaders: HTTPHeaders{
< 							HTTPHeader{
< 								Name:  "Header",
< 								Value: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						Verification: Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					{
< 						Inline:      util.StrToPtr("hello"),
< 						Compression: util.StrToPtr("gzip"),
< 						HTTPHeaders: HTTPHeaders{
< 							HTTPHeader{
< 								Name:  "Header",
< 								Value: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						Verification: Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					{
< 						Local: util.StrToPtr("file-1"),
< 					},
< 				},
< 				Overwrite: util.BoolToPtr(true),
< 				Contents: Resource{
< 					Source:      util.StrToPtr("http://example/com"),
< 					Compression: util.StrToPtr("gzip"),
< 					HTTPHeaders: HTTPHeaders{
< 						HTTPHeader{
< 							Name:  "Header",
< 							Value: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					Verification: Verification{
< 						Hash: util.StrToPtr("this isn't validated"),
< 					},
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Mode: util.IntToPtr(420),
< 					Append: []types.Resource{
< 						{
< 							Source:      util.StrToPtr("http://example/com"),
< 							Compression: util.StrToPtr("gzip"),
< 							HTTPHeaders: types.HTTPHeaders{
< 								types.HTTPHeader{
< 									Name:  "Header",
< 									Value: util.StrToPtr("this isn't validated"),
< 								},
< 							},
< 							Verification: types.Verification{
< 								Hash: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						{
< 							Source:      util.StrToPtr("data:,hello"),
< 							Compression: util.StrToPtr("gzip"),
< 							HTTPHeaders: types.HTTPHeaders{
< 								types.HTTPHeader{
< 									Name:  "Header",
< 									Value: util.StrToPtr("this isn't validated"),
< 								},
< 							},
< 							Verification: types.Verification{
< 								Hash: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						{
< 							Source: util.StrToPtr("data:,file%20contents%0A"),
< 						},
< 					},
< 					Contents: types.Resource{
< 						Source:      util.StrToPtr("http://example/com"),
< 						Compression: util.StrToPtr("gzip"),
< 						HTTPHeaders: types.HTTPHeaders{
< 							types.HTTPHeader{
< 								Name:  "Header",
< 								Value: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						Verification: types.Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "append", 1, "inline"),
< 					To:   path.New("json", "append", 1, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 2, "local"),
< 					To:   path.New("json", "append", 2, "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// inline file contents
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					// String is too short for auto gzip compression
< 					Inline: util.StrToPtr("xyzzy"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source: util.StrToPtr("data:,xyzzy"),
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{},
< 		},
< 		// local file contents
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("file-1"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source: util.StrToPtr("data:,file%20contents%0A"),
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "local"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// filesDir not specified
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("file-1"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 			},
< 			[]translate.Translation{},
< 			"error at $.contents.local: " + common.ErrNoFilesDir.Error() + "\n",
< 			common.TranslateOptions{},
< 		},
< 		// attempted directory traversal
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("../file-1"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 			},
< 			[]translate.Translation{},
< 			"error at $.contents.local: " + common.ErrFilesDirEscape.Error() + "\n",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// attempted inclusion of nonexistent file
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("file-missing"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 			},
< 			[]translate.Translation{},
< 			"error at $.contents.local: open " + filepath.Join(filesDir, "file-missing") + ": no such file or directory\n",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// inline and local automatic file encoding
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					// gzip
< 					Inline: util.StrToPtr(zzz),
< 				},
< 				Append: []Resource{
< 					{
< 						// gzip
< 						Local: util.StrToPtr("file-2"),
< 					},
< 					{
< 						// base64
< 						Inline: util.StrToPtr(random),
< 					},
< 					{
< 						// base64
< 						Local: util.StrToPtr("file-3"),
< 					},
< 					{
< 						// URL-escaped
< 						Inline:      util.StrToPtr(zzz),
< 						Compression: util.StrToPtr("invalid"),
< 					},
< 					{
< 						// URL-escaped
< 						Local:       util.StrToPtr("file-2"),
< 						Compression: util.StrToPtr("invalid"),
< 					},
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source:      util.StrToPtr(zzz_gz),
< 						Compression: util.StrToPtr("gzip"),
< 					},
< 					Append: []types.Resource{
< 						{
< 							Source:      util.StrToPtr(zzz_gz),
< 							Compression: util.StrToPtr("gzip"),
< 						},
< 						{
< 							Source: util.StrToPtr(random_b64),
< 						},
< 						{
< 							Source: util.StrToPtr(random_b64),
< 						},
< 						{
< 							Source:      util.StrToPtr("data:," + zzz),
< 							Compression: util.StrToPtr("invalid"),
< 						},
< 						{
< 							Source:      util.StrToPtr("data:," + zzz),
< 							Compression: util.StrToPtr("invalid"),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "compression"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 0, "local"),
< 					To:   path.New("json", "append", 0, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 0, "local"),
< 					To:   path.New("json", "append", 0, "compression"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 1, "inline"),
< 					To:   path.New("json", "append", 1, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 2, "local"),
< 					To:   path.New("json", "append", 2, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 3, "inline"),
< 					To:   path.New("json", "append", 3, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 4, "local"),
< 					To:   path.New("json", "append", 4, "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// Test disable automatic gzip compression
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Inline: util.StrToPtr(zzz),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source: util.StrToPtr("data:," + zzz),
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				NoResourceAutoCompression: true,
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, translations, r := translateFile(test.in, test.options)
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, test.report, r.String(), "#%d: bad report", i)
< 		baseutil.VerifyTranslations(t, translations, test.exceptions, "#%d", i)
< 	}
< }
< 
< // TestTranslateDirectory tests translating the ct storage.directories.[i] entries to ignition storage.directories.[i] entires.
< func TestTranslateDirectory(t *testing.T) {
< 	tests := []struct {
< 		in  Directory
< 		out types.Directory
< 	}{
< 		{
< 			Directory{},
< 			types.Directory{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Directory{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Mode:      util.IntToPtr(420),
< 				Overwrite: util.BoolToPtr(true),
< 			},
< 			types.Directory{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				DirectoryEmbedded1: types.DirectoryEmbedded1{
< 					Mode: util.IntToPtr(420),
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, _, r := translateDirectory(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateLink tests translating the ct storage.links.[i] entries to ignition storage.links.[i] entires.
< func TestTranslateLink(t *testing.T) {
< 	tests := []struct {
< 		in  Link
< 		out types.Link
< 	}{
< 		{
< 			Link{},
< 			types.Link{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Link{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Overwrite: util.BoolToPtr(true),
< 				Target:    "/bar",
< 				Hard:      util.BoolToPtr(false),
< 			},
< 			types.Link{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				LinkEmbedded1: types.LinkEmbedded1{
< 					Target: "/bar",
< 					Hard:   util.BoolToPtr(false),
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, _, r := translateLink(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateFilesystem tests translating the fcct storage.filesystems.[i] entries to ignition storage.filesystems.[i] entries.
< func TestTranslateFilesystem(t *testing.T) {
< 	tests := []struct {
< 		in  Filesystem
< 		out types.Filesystem
< 	}{
< 		{
< 			Filesystem{},
< 			types.Filesystem{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Filesystem{
< 				Device:         "/foo",
< 				Format:         util.StrToPtr("/bar"),
< 				Label:          util.StrToPtr("/baz"),
< 				MountOptions:   []string{"yes", "no", "maybe"},
< 				Options:        []string{"foo", "foo", "bar"},
< 				Path:           util.StrToPtr("/quux"),
< 				UUID:           util.StrToPtr("1234"),
< 				WipeFilesystem: util.BoolToPtr(true),
< 				WithMountUnit:  util.BoolToPtr(true),
< 			},
< 			types.Filesystem{
< 				Device:         "/foo",
< 				Format:         util.StrToPtr("/bar"),
< 				Label:          util.StrToPtr("/baz"),
< 				MountOptions:   []types.MountOption{"yes", "no", "maybe"},
< 				Options:        []types.FilesystemOption{"foo", "foo", "bar"},
< 				Path:           util.StrToPtr("/quux"),
< 				UUID:           util.StrToPtr("1234"),
< 				WipeFilesystem: util.BoolToPtr(true),
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		// Filesystem doesn't have a custom translator, so embed in a
< 		// complete config
< 		in := Config{
< 			Storage: Storage{
< 				Filesystems: []Filesystem{test.in},
< 			},
< 		}
< 		expected := []types.Filesystem{test.out}
< 		actual, _, r := in.ToIgn3_2Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, expected, actual.Storage.Filesystems, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateMountUnit tests the FCCT storage.filesystems.[i].with_mount_unit flag.
< func TestTranslateMountUnit(t *testing.T) {
< 	tests := []struct {
< 		in  Config
< 		out types.Config
< 	}{
< 		// local mount with options, overridden enabled flag
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/disk/by-label/foo",
< 							Format:        util.StrToPtr("ext4"),
< 							MountOptions:  []string{"ro", "noatime"},
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 				Systemd: Systemd{
< 					Units: []Unit{
< 						{
< 							Name:    "var-lib-containers.mount",
< 							Enabled: util.BoolToPtr(false),
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:       "/dev/disk/by-label/foo",
< 							Format:       util.StrToPtr("ext4"),
< 							MountOptions: []types.MountOption{"ro", "noatime"},
< 							Path:         util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled: util.BoolToPtr(false),
< 							Contents: util.StrToPtr(`# Generated by FCCT
< [Unit]
< Before=local-fs.target
< Requires=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< After=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< 
< [Mount]
< Where=/var/lib/containers
< What=/dev/disk/by-label/foo
< Type=ext4
< Options=ro,noatime
< 
< [Install]
< RequiredBy=local-fs.target`),
< 							Name: "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 		// remote mount with options
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/mapper/foo-bar",
< 							Format:        util.StrToPtr("ext4"),
< 							MountOptions:  []string{"ro", "noatime"},
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 					Luks: []Luks{
< 						{
< 							Name:   "foo-bar",
< 							Device: util.StrToPtr("/dev/bar"),
< 							Clevis: &Clevis{
< 								Tang: []Tang{
< 									{
< 										URL: "http://example.com",
< 									},
< 								},
< 							},
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:       "/dev/mapper/foo-bar",
< 							Format:       util.StrToPtr("ext4"),
< 							MountOptions: []types.MountOption{"ro", "noatime"},
< 							Path:         util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Name:   "foo-bar",
< 							Device: util.StrToPtr("/dev/bar"),
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{
< 									{
< 										URL: "http://example.com",
< 									},
< 								},
< 							},
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled: util.BoolToPtr(true),
< 							Contents: util.StrToPtr(`# Generated by FCCT
< [Unit]
< Before=remote-fs.target
< DefaultDependencies=no
< Requires=systemd-fsck@dev-mapper-foo\x2dbar.service
< After=systemd-fsck@dev-mapper-foo\x2dbar.service
< 
< [Mount]
< Where=/var/lib/containers
< What=/dev/mapper/foo-bar
< Type=ext4
< Options=ro,noatime
< 
< [Install]
< RequiredBy=remote-fs.target`),
< 							Name: "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 		// local mount, no options
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/disk/by-label/foo",
< 							Format:        util.StrToPtr("ext4"),
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device: "/dev/disk/by-label/foo",
< 							Format: util.StrToPtr("ext4"),
< 							Path:   util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled: util.BoolToPtr(true),
< 							Contents: util.StrToPtr(`# Generated by FCCT
< [Unit]
< Before=local-fs.target
< Requires=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< After=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< 
< [Mount]
< Where=/var/lib/containers
< What=/dev/disk/by-label/foo
< Type=ext4
< 
< [Install]
< RequiredBy=local-fs.target`),
< 							Name: "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 		// overridden mount unit
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/disk/by-label/foo",
< 							Format:        util.StrToPtr("ext4"),
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 				Systemd: Systemd{
< 					Units: []Unit{
< 						{
< 							Name:     "var-lib-containers.mount",
< 							Contents: util.StrToPtr("[Service]\nExecStart=/bin/false\n"),
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device: "/dev/disk/by-label/foo",
< 							Format: util.StrToPtr("ext4"),
< 							Path:   util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled:  util.BoolToPtr(true),
< 							Contents: util.StrToPtr("[Service]\nExecStart=/bin/false\n"),
< 							Name:     "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		out, _, r := test.in.ToIgn3_2Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, test.out, out, "#%d: bad output", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: expected empty report", i)
< 	}
< }
< 
< // TestTranslateTree tests translating the FCC storage.trees.[i] entries to ignition storage.files.[i] entries.
< func TestTranslateTree(t *testing.T) {
< 	tests := []struct {
< 		options    *common.TranslateOptions // defaulted if not specified
< 		dirDirs    map[string]os.FileMode   // relative path -> mode
< 		dirFiles   map[string]os.FileMode   // relative path -> mode
< 		dirLinks   map[string]string        // relative path -> target
< 		dirSockets []string                 // relative path
< 		inTrees    []Tree
< 		inFiles    []File
< 		inDirs     []Directory
< 		inLinks    []Link
< 		outFiles   []types.File
< 		outLinks   []types.Link
< 		report     string
< 	}{
< 		// smoke test
< 		{},
< 		// basic functionality
< 		{
< 			dirFiles: map[string]os.FileMode{
< 				"tree/executable":            0700,
< 				"tree/file":                  0600,
< 				"tree/overridden":            0644,
< 				"tree/overridden-executable": 0700,
< 				"tree/subdir/file":           0644,
< 				// compressed contents
< 				"tree/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/file": 0644,
< 				"tree2/file": 0600,
< 			},
< 			dirLinks: map[string]string{
< 				"tree/subdir/bad-link":        "../nonexistent",
< 				"tree/subdir/link":            "../file",
< 				"tree/subdir/overridden-link": "../file",
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 				{
< 					Local: "tree2",
< 					Path:  util.StrToPtr("/etc"),
< 				},
< 			},
< 			inFiles: []File{
< 				{
< 					Path: "/overridden",
< 					Mode: util.IntToPtr(0600),
< 					User: NodeUser{
< 						Name: util.StrToPtr("bovik"),
< 					},
< 				},
< 				{
< 					Path: "/overridden-executable",
< 					Mode: util.IntToPtr(0600),
< 					User: NodeUser{
< 						Name: util.StrToPtr("bovik"),
< 					},
< 				},
< 			},
< 			inLinks: []Link{
< 				{
< 					Path: "/subdir/overridden-link",
< 					User: NodeUser{
< 						Name: util.StrToPtr("bovik"),
< 					},
< 				},
< 			},
< 			outFiles: []types.File{
< 				{
< 					Node: types.Node{
< 						Path: "/overridden",
< 						User: types.NodeUser{
< 							Name: util.StrToPtr("bovik"),
< 						},
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Foverridden"),
< 						},
< 						Mode: util.IntToPtr(0600),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/overridden-executable",
< 						User: types.NodeUser{
< 							Name: util.StrToPtr("bovik"),
< 						},
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Foverridden-executable"),
< 						},
< 						Mode: util.IntToPtr(0600),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/executable",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Fexecutable"),
< 						},
< 						Mode: util.IntToPtr(0755),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Ffile"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Fsubdir%2Ffile"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source:      util.StrToPtr("data:;base64,H4sIAAAAAAAC/yopSk3VLy5NSsksIptKy8xJBQQAAP//gkRzjkgAAAA="),
< 							Compression: util.StrToPtr("gzip"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/etc/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree2%2Ffile"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 			},
< 			outLinks: []types.Link{
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/overridden-link",
< 						User: types.NodeUser{
< 							Name: util.StrToPtr("bovik"),
< 						},
< 					},
< 					LinkEmbedded1: types.LinkEmbedded1{
< 						Target: "../file",
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/bad-link",
< 					},
< 					LinkEmbedded1: types.LinkEmbedded1{
< 						Target: "../nonexistent",
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/link",
< 					},
< 					LinkEmbedded1: types.LinkEmbedded1{
< 						Target: "../file",
< 					},
< 				},
< 			},
< 		},
< 		// collisions
< 		{
< 			dirFiles: map[string]os.FileMode{
< 				"tree0/file":         0600,
< 				"tree1/directory":    0600,
< 				"tree2/link":         0600,
< 				"tree3/file-partial": 0600, // should be okay
< 				"tree4/link-partial": 0600,
< 				"tree5/tree-file":    0600, // set up for tree/tree collision
< 				"tree6/tree-file":    0600,
< 				"tree15/tree-link":   0600,
< 			},
< 			dirLinks: map[string]string{
< 				"tree7/file":          "file",
< 				"tree8/directory":     "file",
< 				"tree9/link":          "file",
< 				"tree10/file-partial": "file",
< 				"tree11/link-partial": "file", // should be okay
< 				"tree12/tree-file":    "file",
< 				"tree13/tree-link":    "file", // set up for tree/tree collision
< 				"tree14/tree-link":    "file",
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree0",
< 				},
< 				{
< 					Local: "tree1",
< 				},
< 				{
< 					Local: "tree2",
< 				},
< 				{
< 					Local: "tree3",
< 				},
< 				{
< 					Local: "tree4",
< 				},
< 				{
< 					Local: "tree5",
< 				},
< 				{
< 					Local: "tree6",
< 				},
< 				{
< 					Local: "tree7",
< 				},
< 				{
< 					Local: "tree8",
< 				},
< 				{
< 					Local: "tree9",
< 				},
< 				{
< 					Local: "tree10",
< 				},
< 				{
< 					Local: "tree11",
< 				},
< 				{
< 					Local: "tree12",
< 				},
< 				{
< 					Local: "tree13",
< 				},
< 				{
< 					Local: "tree14",
< 				},
< 				{
< 					Local: "tree15",
< 				},
< 			},
< 			inFiles: []File{
< 				{
< 					Path: "/file",
< 					Contents: Resource{
< 						Source: util.StrToPtr("data:,foo"),
< 					},
< 				},
< 				{
< 					Path: "/file-partial",
< 				},
< 			},
< 			inDirs: []Directory{
< 				{
< 					Path: "/directory",
< 				},
< 			},
< 			inLinks: []Link{
< 				{
< 					Path:   "/link",
< 					Target: "file",
< 				},
< 				{
< 					Path: "/link-partial",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.1: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.2: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.4: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.6: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.7: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.8: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.9: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.10: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.12: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.14: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.15: " + common.ErrNodeExists.Error() + "\n",
< 		},
< 		// files-dir escape
< 		{
< 			inTrees: []Tree{
< 				{
< 					Local: "../escape",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrFilesDirEscape.Error() + "\n",
< 		},
< 		// no files-dir
< 		{
< 			options: &common.TranslateOptions{},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrNoFilesDir.Error() + "\n",
< 		},
< 		// non-file/dir/symlink in directory tree
< 		{
< 			dirSockets: []string{
< 				"tree/socket",
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrFileType.Error() + "\n",
< 		},
< 		// unreadable file
< 		{
< 			dirDirs: map[string]os.FileMode{
< 				"tree/subdir": 0000,
< 				"tree2":       0000,
< 			},
< 			dirFiles: map[string]os.FileMode{
< 				"tree/file": 0000,
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 				{
< 					Local: "tree2",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: open %FilesDir%/tree/file: permission denied\n" +
< 				"error at $.storage.trees.0: open %FilesDir%/tree/subdir: permission denied\n" +
< 				"error at $.storage.trees.1: open %FilesDir%/tree2: permission denied\n",
< 		},
< 		// local is not a directory
< 		{
< 			dirFiles: map[string]os.FileMode{
< 				"tree": 0600,
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 				{
< 					Local: "nonexistent",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrTreeNotDirectory.Error() + "\n" +
< 				"error at $.storage.trees.1: stat %FilesDir%/nonexistent: no such file or directory\n",
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		filesDir, err := ioutil.TempDir("", "translate-test-")
< 		if err != nil {
< 			t.Error(err)
< 			return
< 		}
< 		defer os.RemoveAll(filesDir)
< 		for path, mode := range test.dirDirs {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(absPath, 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			if err := os.Chmod(absPath, mode); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 		}
< 		for path, mode := range test.dirFiles {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			if err := ioutil.WriteFile(absPath, []byte(path), mode); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 		}
< 		for path, target := range test.dirLinks {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			if err := os.Symlink(target, absPath); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 		}
< 		for _, path := range test.dirSockets {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			listener, err := net.ListenUnix("unix", &net.UnixAddr{
< 				Name: absPath,
< 				Net:  "unix",
< 			})
< 			if err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			defer listener.Close()
< 		}
< 
< 		config := Config{
< 			Storage: Storage{
< 				Files:       test.inFiles,
< 				Directories: test.inDirs,
< 				Links:       test.inLinks,
< 				Trees:       test.inTrees,
< 			},
< 		}
< 		options := common.TranslateOptions{
< 			FilesDir: filesDir,
< 		}
< 		if test.options != nil {
< 			options = *test.options
< 		}
< 		actual, _, r := config.ToIgn3_2Unvalidated(options)
< 
< 		expectedReport := strings.ReplaceAll(test.report, "%FilesDir%", filesDir)
< 		assert.Equal(t, expectedReport, r.String(), "#%d: bad report", i)
< 		if expectedReport != "" {
< 			continue
< 		}
< 
< 		assert.Equal(t, test.outFiles, actual.Storage.Files, "#%d: files mismatch", i)
< 		assert.Equal(t, []types.Directory(nil), actual.Storage.Directories, "#%d: directories mismatch", i)
< 		assert.Equal(t, test.outLinks, actual.Storage.Links, "#%d: links mismatch", i)
< 	}
< }
< 
< // TestTranslateIgnition tests translating the ct config.ignition to the ignition config.ignition section.
< // It ensure that the version is set as well.
< func TestTranslateIgnition(t *testing.T) {
< 	tests := []struct {
< 		in  Ignition
< 		out types.Ignition
< 	}{
< 		{
< 			Ignition{},
< 			types.Ignition{
< 				Version: "3.2.0",
< 			},
< 		},
< 		{
< 			Ignition{
< 				Config: IgnitionConfig{
< 					Merge: []Resource{
< 						{
< 							Inline: util.StrToPtr("xyzzy"),
< 						},
< 					},
< 					Replace: Resource{
< 						Inline: util.StrToPtr("xyzzy"),
< 					},
< 				},
< 			},
< 			types.Ignition{
< 				Version: "3.2.0",
< 				Config: types.IgnitionConfig{
< 					Merge: []types.Resource{
< 						{
< 							Source: util.StrToPtr("data:,xyzzy"),
< 						},
< 					},
< 					Replace: types.Resource{
< 						Source: util.StrToPtr("data:,xyzzy"),
< 					},
< 				},
< 			},
< 		},
< 		{
< 			Ignition{
< 				Proxy: Proxy{
< 					HTTPProxy: util.StrToPtr("https://example.com:8080"),
< 					NoProxy:   []string{"example.com"},
< 				},
< 			},
< 			types.Ignition{
< 				Version: "3.2.0",
< 				Proxy: types.Proxy{
< 					HTTPProxy: util.StrToPtr("https://example.com:8080"),
< 					NoProxy:   []types.NoProxyItem{types.NoProxyItem("example.com")},
< 				},
< 			},
< 		},
< 		{
< 			Ignition{
< 				Security: Security{
< 					TLS: TLS{
< 						CertificateAuthorities: []Resource{
< 							{
< 								Inline: util.StrToPtr("xyzzy"),
< 							},
< 						},
< 					},
< 				},
< 			},
< 			types.Ignition{
< 				Version: "3.2.0",
< 				Security: types.Security{
< 					TLS: types.TLS{
< 						CertificateAuthorities: []types.Resource{
< 							{
< 								Source: util.StrToPtr("data:,xyzzy"),
< 							},
< 						},
< 					},
< 				},
< 			},
< 		},
< 	}
< 	for i, test := range tests {
< 		actual, _, r := translateIgnition(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestToIgn3_2 tests the config.ToIgn3_2 function ensuring it will generate a valid config even when empty. Not much else is
< // tested since it uses the Ignition translation code which has it's own set of tests.
< func TestToIgn3_2(t *testing.T) {
< 	tests := []struct {
< 		in  Config
< 		out types.Config
< 	}{
< 		{
< 			Config{},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 			},
< 		},
< 	}
< 	for i, test := range tests {
< 		actual, _, r := test.in.ToIgn3_2Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_3/util.go updated/vendor/github.com/coreos/fcct/base/v0_3/util.go
1,125d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_3
< 
< import (
< 	"github.com/coreos/ignition/v2/config/v3_2/types"
< )
< 
< type nodeTracker struct {
< 	files   *[]types.File
< 	fileMap map[string]int
< 
< 	dirs   *[]types.Directory
< 	dirMap map[string]int
< 
< 	links   *[]types.Link
< 	linkMap map[string]int
< }
< 
< func newNodeTracker(c *types.Config) *nodeTracker {
< 	t := nodeTracker{
< 		files:   &c.Storage.Files,
< 		fileMap: make(map[string]int, len(c.Storage.Files)),
< 
< 		dirs:   &c.Storage.Directories,
< 		dirMap: make(map[string]int, len(c.Storage.Directories)),
< 
< 		links:   &c.Storage.Links,
< 		linkMap: make(map[string]int, len(c.Storage.Links)),
< 	}
< 	for i, n := range *t.files {
< 		t.fileMap[n.Path] = i
< 	}
< 	for i, n := range *t.dirs {
< 		t.dirMap[n.Path] = i
< 	}
< 	for i, n := range *t.links {
< 		t.linkMap[n.Path] = i
< 	}
< 	return &t
< }
< 
< func (t *nodeTracker) Exists(path string) bool {
< 	for _, m := range []map[string]int{t.fileMap, t.dirMap, t.linkMap} {
< 		if _, ok := m[path]; ok {
< 			return true
< 		}
< 	}
< 	return false
< }
< 
< func (t *nodeTracker) GetFile(path string) (int, *types.File) {
< 	if i, ok := t.fileMap[path]; ok {
< 		return i, &(*t.files)[i]
< 	} else {
< 		return 0, nil
< 	}
< }
< 
< func (t *nodeTracker) AddFile(f types.File) (int, *types.File) {
< 	if f.Path == "" {
< 		panic("File path missing")
< 	}
< 	if _, ok := t.fileMap[f.Path]; ok {
< 		panic("Adding already existing file")
< 	}
< 	i := len(*t.files)
< 	*t.files = append(*t.files, f)
< 	t.fileMap[f.Path] = i
< 	return i, &(*t.files)[i]
< }
< 
< func (t *nodeTracker) GetDir(path string) (int, *types.Directory) {
< 	if i, ok := t.dirMap[path]; ok {
< 		return i, &(*t.dirs)[i]
< 	} else {
< 		return 0, nil
< 	}
< }
< 
< func (t *nodeTracker) AddDir(d types.Directory) (int, *types.Directory) {
< 	if d.Path == "" {
< 		panic("Directory path missing")
< 	}
< 	if _, ok := t.dirMap[d.Path]; ok {
< 		panic("Adding already existing directory")
< 	}
< 	i := len(*t.dirs)
< 	*t.dirs = append(*t.dirs, d)
< 	t.dirMap[d.Path] = i
< 	return i, &(*t.dirs)[i]
< }
< 
< func (t *nodeTracker) GetLink(path string) (int, *types.Link) {
< 	if i, ok := t.linkMap[path]; ok {
< 		return i, &(*t.links)[i]
< 	} else {
< 		return 0, nil
< 	}
< }
< 
< func (t *nodeTracker) AddLink(l types.Link) (int, *types.Link) {
< 	if l.Path == "" {
< 		panic("Link path missing")
< 	}
< 	if _, ok := t.linkMap[l.Path]; ok {
< 		panic("Adding already existing link")
< 	}
< 	i := len(*t.links)
< 	*t.links = append(*t.links, l)
< 	t.linkMap[l.Path] = i
< 	return i, &(*t.links)[i]
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_3/validate.go updated/vendor/github.com/coreos/fcct/base/v0_3/validate.go
1,78d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_3
< 
< import (
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (rs Resource) Validate(c path.ContextPath) (r report.Report) {
< 	var field string
< 	sources := 0
< 	if rs.Local != nil {
< 		sources++
< 		field = "local"
< 	}
< 	if rs.Inline != nil {
< 		sources++
< 		field = "inline"
< 	}
< 	if rs.Source != nil {
< 		sources++
< 		field = "source"
< 	}
< 	if sources > 1 {
< 		r.AddOnError(c.Append(field), common.ErrTooManyResourceSources)
< 	}
< 	return
< }
< 
< func (fs Filesystem) Validate(c path.ContextPath) (r report.Report) {
< 	if fs.WithMountUnit == nil || !*fs.WithMountUnit {
< 		return
< 	}
< 	if fs.Path == nil || *fs.Path == "" {
< 		r.AddOnError(c.Append("path"), common.ErrMountUnitNoPath)
< 	}
< 	if fs.Format == nil || *fs.Format == "" {
< 		r.AddOnError(c.Append("format"), common.ErrMountUnitNoFormat)
< 	}
< 	return
< }
< 
< func (d Directory) Validate(c path.ContextPath) (r report.Report) {
< 	if d.Mode != nil {
< 		r.AddOnWarn(c.Append("mode"), baseutil.CheckForDecimalMode(*d.Mode, true))
< 	}
< 	return
< }
< 
< func (f File) Validate(c path.ContextPath) (r report.Report) {
< 	if f.Mode != nil {
< 		r.AddOnWarn(c.Append("mode"), baseutil.CheckForDecimalMode(*f.Mode, false))
< 	}
< 	return
< }
< 
< func (t Tree) Validate(c path.ContextPath) (r report.Report) {
< 	if t.Local == "" {
< 		r.AddOnError(c, common.ErrTreeNoLocal)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_3/validate_test.go updated/vendor/github.com/coreos/fcct/base/v0_3/validate_test.go
1,214d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_3
< 
< import (
< 	"testing"
< 
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // TestValidateResource tests that multiple sources (i.e. urls and inline) are not allowed but zero or one sources are
< func TestValidateResource(t *testing.T) {
< 	tests := []struct {
< 		in      Resource
< 		out     error
< 		errPath path.ContextPath
< 	}{
< 		{},
< 		// source specified
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Resource{
< 				Source:      util.StrToPtr("http://example/com"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// inline specified
< 		{
< 			Resource{
< 				Inline:      util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// local specified
< 		{
< 			Resource{
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// source + inline, invalid
< 		{
< 			Resource{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Inline:      util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "source"),
< 		},
< 		// source + local, invalid
< 		{
< 			Resource{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "source"),
< 		},
< 		// inline + local, invalid
< 		{
< 			Resource{
< 				Inline:      util.StrToPtr("hello"),
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "inline"),
< 		},
< 		// source + inline + local, invalid
< 		{
< 			Resource{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Inline:      util.StrToPtr("hello"),
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "source"),
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnError(test.errPath, test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
< 
< func TestValidateTree(t *testing.T) {
< 	tests := []struct {
< 		in  Tree
< 		out error
< 	}{
< 		{
< 			in:  Tree{},
< 			out: common.ErrTreeNoLocal,
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnError(path.New("yaml"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
< 
< func TestValidateMode(t *testing.T) {
< 	fileTests := []struct {
< 		in  File
< 		out error
< 	}{
< 		{
< 			in:  File{},
< 			out: nil,
< 		},
< 		{
< 			in: File{
< 				Mode: util.IntToPtr(0600),
< 			},
< 			out: nil,
< 		},
< 		{
< 			in: File{
< 				Mode: util.IntToPtr(600),
< 			},
< 			out: common.ErrDecimalMode,
< 		},
< 	}
< 
< 	for i, test := range fileTests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnWarn(path.New("yaml", "mode"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< 
< 	dirTests := []struct {
< 		in  Directory
< 		out error
< 	}{
< 		{
< 			in:  Directory{},
< 			out: nil,
< 		},
< 		{
< 			in: Directory{
< 				Mode: util.IntToPtr(01770),
< 			},
< 			out: nil,
< 		},
< 		{
< 			in: Directory{
< 				Mode: util.IntToPtr(1770),
< 			},
< 			out: common.ErrDecimalMode,
< 		},
< 	}
< 
< 	for i, test := range dirTests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnWarn(path.New("yaml", "mode"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_4_exp/schema.go updated/vendor/github.com/coreos/fcct/base/v0_4_exp/schema.go
1,254d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_4_exp
< 
< type Clevis struct {
< 	Custom    *Custom `yaml:"custom"`
< 	Tang      []Tang  `yaml:"tang"`
< 	Threshold *int    `yaml:"threshold"`
< 	Tpm2      *bool   `yaml:"tpm2"`
< }
< 
< type Config struct {
< 	Version  string   `yaml:"version"`
< 	Variant  string   `yaml:"variant"`
< 	Ignition Ignition `yaml:"ignition"`
< 	Passwd   Passwd   `yaml:"passwd"`
< 	Storage  Storage  `yaml:"storage"`
< 	Systemd  Systemd  `yaml:"systemd"`
< }
< 
< type Custom struct {
< 	Config       string `yaml:"config"`
< 	NeedsNetwork *bool  `yaml:"needs_network"`
< 	Pin          string `yaml:"pin"`
< }
< 
< type Device string
< 
< type Directory struct {
< 	Group     NodeGroup `yaml:"group"`
< 	Overwrite *bool     `yaml:"overwrite"`
< 	Path      string    `yaml:"path"`
< 	User      NodeUser  `yaml:"user"`
< 	Mode      *int      `yaml:"mode"`
< }
< 
< type Disk struct {
< 	Device     string      `yaml:"device"`
< 	Partitions []Partition `yaml:"partitions"`
< 	WipeTable  *bool       `yaml:"wipe_table"`
< }
< 
< type Dropin struct {
< 	Contents *string `yaml:"contents"`
< 	Name     string  `yaml:"name"`
< }
< 
< type File struct {
< 	Group     NodeGroup  `yaml:"group"`
< 	Overwrite *bool      `yaml:"overwrite"`
< 	Path      string     `yaml:"path"`
< 	User      NodeUser   `yaml:"user"`
< 	Append    []Resource `yaml:"append"`
< 	Contents  Resource   `yaml:"contents"`
< 	Mode      *int       `yaml:"mode"`
< }
< 
< type Filesystem struct {
< 	Device         string   `yaml:"device"`
< 	Format         *string  `yaml:"format"`
< 	Label          *string  `yaml:"label"`
< 	MountOptions   []string `yaml:"mount_options"`
< 	Options        []string `yaml:"options"`
< 	Path           *string  `yaml:"path"`
< 	UUID           *string  `yaml:"uuid"`
< 	WipeFilesystem *bool    `yaml:"wipe_filesystem"`
< 	WithMountUnit  *bool    `yaml:"with_mount_unit" fcct:"auto_skip"` // Added, not in Ignition spec
< }
< 
< type FilesystemOption string
< 
< type Group string
< 
< type HTTPHeader struct {
< 	Name  string  `yaml:"name"`
< 	Value *string `yaml:"value"`
< }
< 
< type HTTPHeaders []HTTPHeader
< 
< type Ignition struct {
< 	Config   IgnitionConfig `yaml:"config"`
< 	Proxy    Proxy          `yaml:"proxy"`
< 	Security Security       `yaml:"security"`
< 	Timeouts Timeouts       `yaml:"timeouts"`
< }
< 
< type IgnitionConfig struct {
< 	Merge   []Resource `yaml:"merge"`
< 	Replace Resource   `yaml:"replace"`
< }
< 
< type Link struct {
< 	Group     NodeGroup `yaml:"group"`
< 	Overwrite *bool     `yaml:"overwrite"`
< 	Path      string    `yaml:"path"`
< 	User      NodeUser  `yaml:"user"`
< 	Hard      *bool     `yaml:"hard"`
< 	Target    string    `yaml:"target"`
< }
< 
< type Luks struct {
< 	Clevis     *Clevis      `yaml:"clevis"`
< 	Device     *string      `yaml:"device"`
< 	KeyFile    Resource     `yaml:"key_file"`
< 	Label      *string      `yaml:"label"`
< 	Name       string       `yaml:"name"`
< 	Options    []LuksOption `yaml:"options"`
< 	UUID       *string      `yaml:"uuid"`
< 	WipeVolume *bool        `yaml:"wipe_volume"`
< }
< 
< type LuksOption string
< 
< type NodeGroup struct {
< 	ID   *int    `yaml:"id"`
< 	Name *string `yaml:"name"`
< }
< 
< type NodeUser struct {
< 	ID   *int    `yaml:"id"`
< 	Name *string `yaml:"name"`
< }
< 
< type Partition struct {
< 	GUID               *string `yaml:"guid"`
< 	Label              *string `yaml:"label"`
< 	Number             int     `yaml:"number"`
< 	Resize             *bool   `yaml:"resize"`
< 	ShouldExist        *bool   `yaml:"should_exist"`
< 	SizeMiB            *int    `yaml:"size_mib"`
< 	StartMiB           *int    `yaml:"start_mib"`
< 	TypeGUID           *string `yaml:"type_guid"`
< 	WipePartitionEntry *bool   `yaml:"wipe_partition_entry"`
< }
< 
< type Passwd struct {
< 	Groups []PasswdGroup `yaml:"groups"`
< 	Users  []PasswdUser  `yaml:"users"`
< }
< 
< type PasswdGroup struct {
< 	Gid          *int    `yaml:"gid"`
< 	Name         string  `yaml:"name"`
< 	PasswordHash *string `yaml:"password_hash"`
< 	ShouldExist  *bool   `yaml:"should_exist"`
< 	System       *bool   `yaml:"system"`
< }
< 
< type PasswdUser struct {
< 	Gecos             *string            `yaml:"gecos"`
< 	Groups            []Group            `yaml:"groups"`
< 	HomeDir           *string            `yaml:"home_dir"`
< 	Name              string             `yaml:"name"`
< 	NoCreateHome      *bool              `yaml:"no_create_home"`
< 	NoLogInit         *bool              `yaml:"no_log_init"`
< 	NoUserGroup       *bool              `yaml:"no_user_group"`
< 	PasswordHash      *string            `yaml:"password_hash"`
< 	PrimaryGroup      *string            `yaml:"primary_group"`
< 	ShouldExist       *bool              `yaml:"should_exist"`
< 	SSHAuthorizedKeys []SSHAuthorizedKey `yaml:"ssh_authorized_keys"`
< 	Shell             *string            `yaml:"shell"`
< 	System            *bool              `yaml:"system"`
< 	UID               *int               `yaml:"uid"`
< }
< 
< type Proxy struct {
< 	HTTPProxy  *string  `yaml:"http_proxy"`
< 	HTTPSProxy *string  `yaml:"https_proxy"`
< 	NoProxy    []string `yaml:"no_proxy"`
< }
< 
< type Raid struct {
< 	Devices []Device     `yaml:"devices"`
< 	Level   string       `yaml:"level"`
< 	Name    string       `yaml:"name"`
< 	Options []RaidOption `yaml:"options"`
< 	Spares  *int         `yaml:"spares"`
< }
< 
< type RaidOption string
< 
< type Resource struct {
< 	Compression  *string      `yaml:"compression"`
< 	HTTPHeaders  HTTPHeaders  `yaml:"http_headers"`
< 	Source       *string      `yaml:"source"`
< 	Inline       *string      `yaml:"inline"` // Added, not in ignition spec
< 	Local        *string      `yaml:"local"`  // Added, not in ignition spec
< 	Verification Verification `yaml:"verification"`
< }
< 
< type SSHAuthorizedKey string
< 
< type Security struct {
< 	TLS TLS `yaml:"tls"`
< }
< 
< type Storage struct {
< 	Directories []Directory  `yaml:"directories"`
< 	Disks       []Disk       `yaml:"disks"`
< 	Files       []File       `yaml:"files"`
< 	Filesystems []Filesystem `yaml:"filesystems"`
< 	Links       []Link       `yaml:"links"`
< 	Luks        []Luks       `yaml:"luks"`
< 	Raid        []Raid       `yaml:"raid"`
< 	Trees       []Tree       `yaml:"trees" fcct:"auto_skip"` // Added, not in ignition spec
< }
< 
< type Systemd struct {
< 	Units []Unit `yaml:"units"`
< }
< 
< type Tang struct {
< 	Thumbprint *string `yaml:"thumbprint"`
< 	URL        string  `yaml:"url"`
< }
< 
< type TLS struct {
< 	CertificateAuthorities []Resource `yaml:"certificate_authorities"`
< }
< 
< type Timeouts struct {
< 	HTTPResponseHeaders *int `yaml:"http_response_headers"`
< 	HTTPTotal           *int `yaml:"http_total"`
< }
< 
< type Tree struct {
< 	Local string  `yaml:"local"`
< 	Path  *string `yaml:"path"`
< }
< 
< type Unit struct {
< 	Contents *string  `yaml:"contents"`
< 	Dropins  []Dropin `yaml:"dropins"`
< 	Enabled  *bool    `yaml:"enabled"`
< 	Mask     *bool    `yaml:"mask"`
< 	Name     string   `yaml:"name"`
< }
< 
< type Verification struct {
< 	Hash *string `yaml:"hash"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_4_exp/translate.go updated/vendor/github.com/coreos/fcct/base/v0_4_exp/translate.go
1,400d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_4_exp
< 
< import (
< 	"fmt"
< 	"io/ioutil"
< 	"os"
< 	"path/filepath"
< 	"strings"
< 	"text/template"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/go-systemd/unit"
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_3_experimental/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< var (
< 	mountUnitTemplate = template.Must(template.New("unit").Parse(`# Generated by FCCT
< [Unit]
< {{- if .Remote }}
< Before=remote-fs.target
< DefaultDependencies=no
< {{- else }}
< Before=local-fs.target
< {{- end }}
< Requires=systemd-fsck@{{.EscapedDevice}}.service
< After=systemd-fsck@{{.EscapedDevice}}.service
< 
< [Mount]
< Where={{.Path}}
< What={{.Device}}
< Type={{.Format}}
< {{- if .MountOptions }}
< Options=
<   {{- range $i, $opt := .MountOptions }}
<     {{- if $i }},{{ end }}
<     {{- $opt }}
<   {{- end }}
< {{- end }}
< 
< [Install]
< {{- if .Remote }}
< RequiredBy=remote-fs.target
< {{- else }}
< RequiredBy=local-fs.target
< {{- end }}`))
< )
< 
< // ToIgn3_3Unvalidated translates the config to an Ignition config. It also returns the set of translations
< // it did so paths in the resultant config can be tracked back to their source in the source config.
< // No config validation is performed on input or output.
< func (c Config) ToIgn3_3Unvalidated(options common.TranslateOptions) (types.Config, translate.TranslationSet, report.Report) {
< 	ret := types.Config{}
< 
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateIgnition)
< 	tr.AddCustomTranslator(translateFile)
< 	tr.AddCustomTranslator(translateDirectory)
< 	tr.AddCustomTranslator(translateLink)
< 	tr.AddCustomTranslator(translateResource)
< 
< 	tm, r := translate.Prefixed(tr, "ignition", &c.Ignition, &ret.Ignition)
< 	translate.MergeP(tr, tm, &r, "passwd", &c.Passwd, &ret.Passwd)
< 	translate.MergeP(tr, tm, &r, "storage", &c.Storage, &ret.Storage)
< 	translate.MergeP(tr, tm, &r, "systemd", &c.Systemd, &ret.Systemd)
< 
< 	c.addMountUnits(&ret, &tm)
< 
< 	tm2, r2 := c.processTrees(&ret, options)
< 	tm.Merge(tm2)
< 	r.Merge(r2)
< 
< 	if r.IsFatal() {
< 		return types.Config{}, translate.TranslationSet{}, r
< 	}
< 	return ret, tm, r
< }
< 
< func translateIgnition(from Ignition, options common.TranslateOptions) (to types.Ignition, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateResource)
< 	to.Version = types.MaxVersion.String()
< 	tm, r = translate.Prefixed(tr, "config", &from.Config, &to.Config)
< 	translate.MergeP(tr, tm, &r, "proxy", &from.Proxy, &to.Proxy)
< 	translate.MergeP(tr, tm, &r, "security", &from.Security, &to.Security)
< 	translate.MergeP(tr, tm, &r, "timeouts", &from.Timeouts, &to.Timeouts)
< 	return
< }
< 
< func translateFile(from File, options common.TranslateOptions) (to types.File, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tr.AddCustomTranslator(translateResource)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	translate.MergeP(tr, tm, &r, "append", &from.Append, &to.Append)
< 	translate.MergeP(tr, tm, &r, "contents", &from.Contents, &to.Contents)
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	to.Mode = from.Mode
< 	tm.AddIdentity("overwrite", "path", "mode")
< 	return
< }
< 
< func translateResource(from Resource, options common.TranslateOptions) (to types.Resource, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "verification", &from.Verification, &to.Verification)
< 	translate.MergeP(tr, tm, &r, "httpHeaders", &from.HTTPHeaders, &to.HTTPHeaders)
< 	to.Source = from.Source
< 	to.Compression = from.Compression
< 	tm.AddIdentity("source", "compression")
< 
< 	if from.Local != nil {
< 		c := path.New("yaml", "local")
< 
< 		if options.FilesDir == "" {
< 			r.AddOnError(c, common.ErrNoFilesDir)
< 			return
< 		}
< 
< 		// calculate file path within FilesDir and check for
< 		// path traversal
< 		filePath := filepath.Join(options.FilesDir, *from.Local)
< 		if err := baseutil.EnsurePathWithinFilesDir(filePath, options.FilesDir); err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 
< 		contents, err := ioutil.ReadFile(filePath)
< 		if err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 
< 		src, gzipped, err := baseutil.MakeDataURL(contents, to.Compression, !options.NoResourceAutoCompression)
< 		if err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 		to.Source = &src
< 		tm.AddTranslation(c, path.New("json", "source"))
< 		if gzipped {
< 			to.Compression = util.StrToPtr("gzip")
< 			tm.AddTranslation(c, path.New("json", "compression"))
< 		}
< 	}
< 
< 	if from.Inline != nil {
< 		c := path.New("yaml", "inline")
< 
< 		src, gzipped, err := baseutil.MakeDataURL([]byte(*from.Inline), to.Compression, !options.NoResourceAutoCompression)
< 		if err != nil {
< 			r.AddOnError(c, err)
< 			return
< 		}
< 		to.Source = &src
< 		tm.AddTranslation(c, path.New("json", "source"))
< 		if gzipped {
< 			to.Compression = util.StrToPtr("gzip")
< 			tm.AddTranslation(c, path.New("json", "compression"))
< 		}
< 	}
< 	return
< }
< 
< func translateDirectory(from Directory, options common.TranslateOptions) (to types.Directory, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	to.Mode = from.Mode
< 	tm.AddIdentity("overwrite", "path", "mode")
< 	return
< }
< 
< func translateLink(from Link, options common.TranslateOptions) (to types.Link, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
< 	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
< 	to.Target = from.Target
< 	to.Hard = from.Hard
< 	to.Overwrite = from.Overwrite
< 	to.Path = from.Path
< 	tm.AddIdentity("target", "hard", "overwrite", "path")
< 	return
< }
< 
< func (c Config) processTrees(ret *types.Config, options common.TranslateOptions) (translate.TranslationSet, report.Report) {
< 	ts := translate.NewTranslationSet("yaml", "json")
< 	var r report.Report
< 	if len(c.Storage.Trees) == 0 {
< 		return ts, r
< 	}
< 	t := newNodeTracker(ret)
< 
< 	for i, tree := range c.Storage.Trees {
< 		yamlPath := path.New("yaml", "storage", "trees", i)
< 		if options.FilesDir == "" {
< 			r.AddOnError(yamlPath, common.ErrNoFilesDir)
< 			return ts, r
< 		}
< 
< 		// calculate base path within FilesDir and check for
< 		// path traversal
< 		srcBaseDir := filepath.Join(options.FilesDir, tree.Local)
< 		if err := baseutil.EnsurePathWithinFilesDir(srcBaseDir, options.FilesDir); err != nil {
< 			r.AddOnError(yamlPath, err)
< 			continue
< 		}
< 		info, err := os.Stat(srcBaseDir)
< 		if err != nil {
< 			r.AddOnError(yamlPath, err)
< 			continue
< 		}
< 		if !info.IsDir() {
< 			r.AddOnError(yamlPath, common.ErrTreeNotDirectory)
< 			continue
< 		}
< 		destBaseDir := "/"
< 		if tree.Path != nil && *tree.Path != "" {
< 			destBaseDir = *tree.Path
< 		}
< 
< 		walkTree(yamlPath, tree, &ts, &r, t, srcBaseDir, destBaseDir, options)
< 	}
< 	return ts, r
< }
< 
< func walkTree(yamlPath path.ContextPath, tree Tree, ts *translate.TranslationSet, r *report.Report, t *nodeTracker, srcBaseDir, destBaseDir string, options common.TranslateOptions) {
< 	// The strategy for errors within WalkFunc is to add an error to
< 	// the report and return nil, so walking continues but translation
< 	// will fail afterward.
< 	err := filepath.Walk(srcBaseDir, func(srcPath string, info os.FileInfo, err error) error {
< 		if err != nil {
< 			r.AddOnError(yamlPath, err)
< 			return nil
< 		}
< 		relPath, err := filepath.Rel(srcBaseDir, srcPath)
< 		if err != nil {
< 			r.AddOnError(yamlPath, err)
< 			return nil
< 		}
< 		destPath := filepath.Join(destBaseDir, relPath)
< 
< 		if info.Mode().IsDir() {
< 			return nil
< 		} else if info.Mode().IsRegular() {
< 			i, file := t.GetFile(destPath)
< 			if file != nil {
< 				if file.Contents.Source != nil && *file.Contents.Source != "" {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 			} else {
< 				if t.Exists(destPath) {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 				i, file = t.AddFile(types.File{
< 					Node: types.Node{
< 						Path: destPath,
< 					},
< 				})
< 				ts.AddFromCommonSource(yamlPath, path.New("json", "storage", "files", i), file)
< 			}
< 			contents, err := ioutil.ReadFile(srcPath)
< 			if err != nil {
< 				r.AddOnError(yamlPath, err)
< 				return nil
< 			}
< 			url, gzipped, err := baseutil.MakeDataURL(contents, file.Contents.Compression, !options.NoResourceAutoCompression)
< 			if err != nil {
< 				r.AddOnError(yamlPath, err)
< 				return nil
< 			}
< 			file.Contents.Source = util.StrToPtr(url)
< 			ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "contents", "source"))
< 			if gzipped {
< 				file.Contents.Compression = util.StrToPtr("gzip")
< 				ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "contents", "compression"))
< 			}
< 			if file.Mode == nil {
< 				mode := 0644
< 				if info.Mode()&0111 != 0 {
< 					mode = 0755
< 				}
< 				file.Mode = &mode
< 				ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "mode"))
< 			}
< 		} else if info.Mode()&os.ModeType == os.ModeSymlink {
< 			i, link := t.GetLink(destPath)
< 			if link != nil {
< 				if link.Target != "" {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 			} else {
< 				if t.Exists(destPath) {
< 					r.AddOnError(yamlPath, common.ErrNodeExists)
< 					return nil
< 				}
< 				i, link = t.AddLink(types.Link{
< 					Node: types.Node{
< 						Path: destPath,
< 					},
< 				})
< 				ts.AddFromCommonSource(yamlPath, path.New("json", "storage", "links", i), link)
< 			}
< 			link.Target, err = os.Readlink(srcPath)
< 			if err != nil {
< 				r.AddOnError(yamlPath, err)
< 				return nil
< 			}
< 			ts.AddTranslation(yamlPath, path.New("json", "storage", "links", i, "target"))
< 		} else {
< 			r.AddOnError(yamlPath, common.ErrFileType)
< 			return nil
< 		}
< 		return nil
< 	})
< 	r.AddOnError(yamlPath, err)
< }
< 
< func (c Config) addMountUnits(config *types.Config, ts *translate.TranslationSet) {
< 	if len(c.Storage.Filesystems) == 0 {
< 		return
< 	}
< 	var rendered types.Config
< 	renderedTranslations := translate.NewTranslationSet("yaml", "json")
< 	for i, fs := range c.Storage.Filesystems {
< 		if fs.WithMountUnit == nil || !*fs.WithMountUnit {
< 			continue
< 		}
< 		fromPath := path.New("yaml", "storage", "filesystems", i, "with_mount_unit")
< 		remote := false
< 		// check filesystems targeting /dev/mapper devices against LUKS to determine if a
< 		// remote mount is needed
< 		if strings.HasPrefix(fs.Device, "/dev/mapper/") || strings.HasPrefix(fs.Device, "/dev/disk/by-id/dm-name-") {
< 			for _, luks := range c.Storage.Luks {
< 				// LUKS devices are opened with their name specified
< 				if fs.Device == fmt.Sprintf("/dev/mapper/%s", luks.Name) || fs.Device == fmt.Sprintf("/dev/disk/by-id/dm-name-%s", luks.Name) {
< 					if luks.Clevis != nil && len(luks.Clevis.Tang) > 0 {
< 						remote = true
< 						break
< 					}
< 				}
< 			}
< 		}
< 		newUnit := mountUnitFromFS(fs, remote)
< 		unitPath := path.New("json", "systemd", "units", len(rendered.Systemd.Units))
< 		rendered.Systemd.Units = append(rendered.Systemd.Units, newUnit)
< 		renderedTranslations.AddFromCommonSource(fromPath, unitPath, newUnit)
< 	}
< 	retConfig, retTranslations := baseutil.MergeTranslatedConfigs(rendered, renderedTranslations, *config, *ts)
< 	*config = retConfig.(types.Config)
< 	*ts = retTranslations
< }
< 
< func mountUnitFromFS(fs Filesystem, remote bool) types.Unit {
< 	context := struct {
< 		*Filesystem
< 		EscapedDevice string
< 		Remote        bool
< 	}{
< 		Filesystem:    &fs,
< 		EscapedDevice: unit.UnitNamePathEscape(fs.Device),
< 		Remote:        remote,
< 	}
< 	contents := strings.Builder{}
< 	err := mountUnitTemplate.Execute(&contents, context)
< 	if err != nil {
< 		panic(err)
< 	}
< 	// unchecked deref of path ok, fs would fail validation otherwise
< 	unitName := unit.UnitNamePathEscape(*fs.Path) + ".mount"
< 	return types.Unit{
< 		Name:     unitName,
< 		Enabled:  util.BoolToPtr(true),
< 		Contents: util.StrToPtr(contents.String()),
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_4_exp/translate_test.go updated/vendor/github.com/coreos/fcct/base/v0_4_exp/translate_test.go
1,1438d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_4_exp
< 
< import (
< 	"io/ioutil"
< 	"net"
< 	"os"
< 	"path/filepath"
< 	"strings"
< 	"testing"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_3_experimental/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // Most of this is covered by the Ignition translator generic tests, so just test the custom bits
< 
< // TestTranslateFile tests translating the ct storage.files.[i] entries to ignition storage.files.[i] entries.
< func TestTranslateFile(t *testing.T) {
< 	zzz := "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"
< 	zzz_gz := "data:;base64,H4sIAAAAAAAC/6oajAAQAAD//5tA8d+VAAAA"
< 	random := "\xc0\x9cl\x01\x89i\xa5\xbfW\xe4\x1b\xf4J_\xb79P\xa3#\xa7"
< 	random_b64 := "data:;base64,wJxsAYlppb9X5Bv0Sl+3OVCjI6c="
< 
< 	filesDir, err := ioutil.TempDir("", "translate-test-")
< 	if err != nil {
< 		t.Error(err)
< 		return
< 	}
< 	defer os.RemoveAll(filesDir)
< 	fileContents := map[string]string{
< 		"file-1": "file contents\n",
< 		"file-2": zzz,
< 		"file-3": random,
< 	}
< 	for name, contents := range fileContents {
< 		err := ioutil.WriteFile(filepath.Join(filesDir, name), []byte(contents), 0644)
< 		if err != nil {
< 			t.Error(err)
< 			return
< 		}
< 	}
< 
< 	tests := []struct {
< 		in         File
< 		out        types.File
< 		exceptions []translate.Translation
< 		report     string
< 		options    common.TranslateOptions
< 	}{
< 		{
< 			File{},
< 			types.File{},
< 			nil,
< 			"",
< 			common.TranslateOptions{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			File{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Mode: util.IntToPtr(420),
< 				Append: []Resource{
< 					{
< 						Source:      util.StrToPtr("http://example/com"),
< 						Compression: util.StrToPtr("gzip"),
< 						HTTPHeaders: HTTPHeaders{
< 							HTTPHeader{
< 								Name:  "Header",
< 								Value: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						Verification: Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					{
< 						Inline:      util.StrToPtr("hello"),
< 						Compression: util.StrToPtr("gzip"),
< 						HTTPHeaders: HTTPHeaders{
< 							HTTPHeader{
< 								Name:  "Header",
< 								Value: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						Verification: Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					{
< 						Local: util.StrToPtr("file-1"),
< 					},
< 				},
< 				Overwrite: util.BoolToPtr(true),
< 				Contents: Resource{
< 					Source:      util.StrToPtr("http://example/com"),
< 					Compression: util.StrToPtr("gzip"),
< 					HTTPHeaders: HTTPHeaders{
< 						HTTPHeader{
< 							Name:  "Header",
< 							Value: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 					Verification: Verification{
< 						Hash: util.StrToPtr("this isn't validated"),
< 					},
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Mode: util.IntToPtr(420),
< 					Append: []types.Resource{
< 						{
< 							Source:      util.StrToPtr("http://example/com"),
< 							Compression: util.StrToPtr("gzip"),
< 							HTTPHeaders: types.HTTPHeaders{
< 								types.HTTPHeader{
< 									Name:  "Header",
< 									Value: util.StrToPtr("this isn't validated"),
< 								},
< 							},
< 							Verification: types.Verification{
< 								Hash: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						{
< 							Source:      util.StrToPtr("data:,hello"),
< 							Compression: util.StrToPtr("gzip"),
< 							HTTPHeaders: types.HTTPHeaders{
< 								types.HTTPHeader{
< 									Name:  "Header",
< 									Value: util.StrToPtr("this isn't validated"),
< 								},
< 							},
< 							Verification: types.Verification{
< 								Hash: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						{
< 							Source: util.StrToPtr("data:,file%20contents%0A"),
< 						},
< 					},
< 					Contents: types.Resource{
< 						Source:      util.StrToPtr("http://example/com"),
< 						Compression: util.StrToPtr("gzip"),
< 						HTTPHeaders: types.HTTPHeaders{
< 							types.HTTPHeader{
< 								Name:  "Header",
< 								Value: util.StrToPtr("this isn't validated"),
< 							},
< 						},
< 						Verification: types.Verification{
< 							Hash: util.StrToPtr("this isn't validated"),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "append", 1, "inline"),
< 					To:   path.New("json", "append", 1, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 2, "local"),
< 					To:   path.New("json", "append", 2, "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// inline file contents
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					// String is too short for auto gzip compression
< 					Inline: util.StrToPtr("xyzzy"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source: util.StrToPtr("data:,xyzzy"),
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{},
< 		},
< 		// local file contents
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("file-1"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source: util.StrToPtr("data:,file%20contents%0A"),
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "local"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// filesDir not specified
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("file-1"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 			},
< 			[]translate.Translation{},
< 			"error at $.contents.local: " + common.ErrNoFilesDir.Error() + "\n",
< 			common.TranslateOptions{},
< 		},
< 		// attempted directory traversal
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("../file-1"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 			},
< 			[]translate.Translation{},
< 			"error at $.contents.local: " + common.ErrFilesDirEscape.Error() + "\n",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// attempted inclusion of nonexistent file
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Local: util.StrToPtr("file-missing"),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 			},
< 			[]translate.Translation{},
< 			"error at $.contents.local: open " + filepath.Join(filesDir, "file-missing") + ": no such file or directory\n",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// inline and local automatic file encoding
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					// gzip
< 					Inline: util.StrToPtr(zzz),
< 				},
< 				Append: []Resource{
< 					{
< 						// gzip
< 						Local: util.StrToPtr("file-2"),
< 					},
< 					{
< 						// base64
< 						Inline: util.StrToPtr(random),
< 					},
< 					{
< 						// base64
< 						Local: util.StrToPtr("file-3"),
< 					},
< 					{
< 						// URL-escaped
< 						Inline:      util.StrToPtr(zzz),
< 						Compression: util.StrToPtr("invalid"),
< 					},
< 					{
< 						// URL-escaped
< 						Local:       util.StrToPtr("file-2"),
< 						Compression: util.StrToPtr("invalid"),
< 					},
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source:      util.StrToPtr(zzz_gz),
< 						Compression: util.StrToPtr("gzip"),
< 					},
< 					Append: []types.Resource{
< 						{
< 							Source:      util.StrToPtr(zzz_gz),
< 							Compression: util.StrToPtr("gzip"),
< 						},
< 						{
< 							Source: util.StrToPtr(random_b64),
< 						},
< 						{
< 							Source: util.StrToPtr(random_b64),
< 						},
< 						{
< 							Source:      util.StrToPtr("data:," + zzz),
< 							Compression: util.StrToPtr("invalid"),
< 						},
< 						{
< 							Source:      util.StrToPtr("data:," + zzz),
< 							Compression: util.StrToPtr("invalid"),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "compression"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 0, "local"),
< 					To:   path.New("json", "append", 0, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 0, "local"),
< 					To:   path.New("json", "append", 0, "compression"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 1, "inline"),
< 					To:   path.New("json", "append", 1, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 2, "local"),
< 					To:   path.New("json", "append", 2, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 3, "inline"),
< 					To:   path.New("json", "append", 3, "source"),
< 				},
< 				{
< 					From: path.New("yaml", "append", 4, "local"),
< 					To:   path.New("json", "append", 4, "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				FilesDir: filesDir,
< 			},
< 		},
< 		// Test disable automatic gzip compression
< 		{
< 			File{
< 				Path: "/foo",
< 				Contents: Resource{
< 					Inline: util.StrToPtr(zzz),
< 				},
< 			},
< 			types.File{
< 				Node: types.Node{
< 					Path: "/foo",
< 				},
< 				FileEmbedded1: types.FileEmbedded1{
< 					Contents: types.Resource{
< 						Source: util.StrToPtr("data:," + zzz),
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{
< 					From: path.New("yaml", "contents", "inline"),
< 					To:   path.New("json", "contents", "source"),
< 				},
< 			},
< 			"",
< 			common.TranslateOptions{
< 				NoResourceAutoCompression: true,
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, translations, r := translateFile(test.in, test.options)
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, test.report, r.String(), "#%d: bad report", i)
< 		baseutil.VerifyTranslations(t, translations, test.exceptions, "#%d", i)
< 	}
< }
< 
< // TestTranslateDirectory tests translating the ct storage.directories.[i] entries to ignition storage.directories.[i] entires.
< func TestTranslateDirectory(t *testing.T) {
< 	tests := []struct {
< 		in  Directory
< 		out types.Directory
< 	}{
< 		{
< 			Directory{},
< 			types.Directory{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Directory{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Mode:      util.IntToPtr(420),
< 				Overwrite: util.BoolToPtr(true),
< 			},
< 			types.Directory{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				DirectoryEmbedded1: types.DirectoryEmbedded1{
< 					Mode: util.IntToPtr(420),
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, _, r := translateDirectory(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateLink tests translating the ct storage.links.[i] entries to ignition storage.links.[i] entires.
< func TestTranslateLink(t *testing.T) {
< 	tests := []struct {
< 		in  Link
< 		out types.Link
< 	}{
< 		{
< 			Link{},
< 			types.Link{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Link{
< 				Path: "/foo",
< 				Group: NodeGroup{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("foobar"),
< 				},
< 				User: NodeUser{
< 					ID:   util.IntToPtr(1),
< 					Name: util.StrToPtr("bazquux"),
< 				},
< 				Overwrite: util.BoolToPtr(true),
< 				Target:    "/bar",
< 				Hard:      util.BoolToPtr(false),
< 			},
< 			types.Link{
< 				Node: types.Node{
< 					Path: "/foo",
< 					Group: types.NodeGroup{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("foobar"),
< 					},
< 					User: types.NodeUser{
< 						ID:   util.IntToPtr(1),
< 						Name: util.StrToPtr("bazquux"),
< 					},
< 					Overwrite: util.BoolToPtr(true),
< 				},
< 				LinkEmbedded1: types.LinkEmbedded1{
< 					Target: "/bar",
< 					Hard:   util.BoolToPtr(false),
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual, _, r := translateLink(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateFilesystem tests translating the fcct storage.filesystems.[i] entries to ignition storage.filesystems.[i] entries.
< func TestTranslateFilesystem(t *testing.T) {
< 	tests := []struct {
< 		in  Filesystem
< 		out types.Filesystem
< 	}{
< 		{
< 			Filesystem{},
< 			types.Filesystem{},
< 		},
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Filesystem{
< 				Device:         "/foo",
< 				Format:         util.StrToPtr("/bar"),
< 				Label:          util.StrToPtr("/baz"),
< 				MountOptions:   []string{"yes", "no", "maybe"},
< 				Options:        []string{"foo", "foo", "bar"},
< 				Path:           util.StrToPtr("/quux"),
< 				UUID:           util.StrToPtr("1234"),
< 				WipeFilesystem: util.BoolToPtr(true),
< 				WithMountUnit:  util.BoolToPtr(true),
< 			},
< 			types.Filesystem{
< 				Device:         "/foo",
< 				Format:         util.StrToPtr("/bar"),
< 				Label:          util.StrToPtr("/baz"),
< 				MountOptions:   []types.MountOption{"yes", "no", "maybe"},
< 				Options:        []types.FilesystemOption{"foo", "foo", "bar"},
< 				Path:           util.StrToPtr("/quux"),
< 				UUID:           util.StrToPtr("1234"),
< 				WipeFilesystem: util.BoolToPtr(true),
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		// Filesystem doesn't have a custom translator, so embed in a
< 		// complete config
< 		in := Config{
< 			Storage: Storage{
< 				Filesystems: []Filesystem{test.in},
< 			},
< 		}
< 		expected := []types.Filesystem{test.out}
< 		actual, _, r := in.ToIgn3_3Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, expected, actual.Storage.Filesystems, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestTranslateMountUnit tests the FCCT storage.filesystems.[i].with_mount_unit flag.
< func TestTranslateMountUnit(t *testing.T) {
< 	tests := []struct {
< 		in  Config
< 		out types.Config
< 	}{
< 		// local mount with options, overridden enabled flag
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/disk/by-label/foo",
< 							Format:        util.StrToPtr("ext4"),
< 							MountOptions:  []string{"ro", "noatime"},
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 				Systemd: Systemd{
< 					Units: []Unit{
< 						{
< 							Name:    "var-lib-containers.mount",
< 							Enabled: util.BoolToPtr(false),
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:       "/dev/disk/by-label/foo",
< 							Format:       util.StrToPtr("ext4"),
< 							MountOptions: []types.MountOption{"ro", "noatime"},
< 							Path:         util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled: util.BoolToPtr(false),
< 							Contents: util.StrToPtr(`# Generated by FCCT
< [Unit]
< Before=local-fs.target
< Requires=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< After=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< 
< [Mount]
< Where=/var/lib/containers
< What=/dev/disk/by-label/foo
< Type=ext4
< Options=ro,noatime
< 
< [Install]
< RequiredBy=local-fs.target`),
< 							Name: "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 		// remote mount with options
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/mapper/foo-bar",
< 							Format:        util.StrToPtr("ext4"),
< 							MountOptions:  []string{"ro", "noatime"},
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 					Luks: []Luks{
< 						{
< 							Name:   "foo-bar",
< 							Device: util.StrToPtr("/dev/bar"),
< 							Clevis: &Clevis{
< 								Tang: []Tang{
< 									{
< 										URL: "http://example.com",
< 									},
< 								},
< 							},
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:       "/dev/mapper/foo-bar",
< 							Format:       util.StrToPtr("ext4"),
< 							MountOptions: []types.MountOption{"ro", "noatime"},
< 							Path:         util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Name:   "foo-bar",
< 							Device: util.StrToPtr("/dev/bar"),
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{
< 									{
< 										URL: "http://example.com",
< 									},
< 								},
< 							},
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled: util.BoolToPtr(true),
< 							Contents: util.StrToPtr(`# Generated by FCCT
< [Unit]
< Before=remote-fs.target
< DefaultDependencies=no
< Requires=systemd-fsck@dev-mapper-foo\x2dbar.service
< After=systemd-fsck@dev-mapper-foo\x2dbar.service
< 
< [Mount]
< Where=/var/lib/containers
< What=/dev/mapper/foo-bar
< Type=ext4
< Options=ro,noatime
< 
< [Install]
< RequiredBy=remote-fs.target`),
< 							Name: "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 		// local mount, no options
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/disk/by-label/foo",
< 							Format:        util.StrToPtr("ext4"),
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device: "/dev/disk/by-label/foo",
< 							Format: util.StrToPtr("ext4"),
< 							Path:   util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled: util.BoolToPtr(true),
< 							Contents: util.StrToPtr(`# Generated by FCCT
< [Unit]
< Before=local-fs.target
< Requires=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< After=systemd-fsck@dev-disk-by\x2dlabel-foo.service
< 
< [Mount]
< Where=/var/lib/containers
< What=/dev/disk/by-label/foo
< Type=ext4
< 
< [Install]
< RequiredBy=local-fs.target`),
< 							Name: "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 		// overridden mount unit
< 		{
< 			Config{
< 				Storage: Storage{
< 					Filesystems: []Filesystem{
< 						{
< 							Device:        "/dev/disk/by-label/foo",
< 							Format:        util.StrToPtr("ext4"),
< 							Path:          util.StrToPtr("/var/lib/containers"),
< 							WithMountUnit: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 				Systemd: Systemd{
< 					Units: []Unit{
< 						{
< 							Name:     "var-lib-containers.mount",
< 							Contents: util.StrToPtr("[Service]\nExecStart=/bin/false\n"),
< 						},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device: "/dev/disk/by-label/foo",
< 							Format: util.StrToPtr("ext4"),
< 							Path:   util.StrToPtr("/var/lib/containers"),
< 						},
< 					},
< 				},
< 				Systemd: types.Systemd{
< 					Units: []types.Unit{
< 						{
< 							Enabled:  util.BoolToPtr(true),
< 							Contents: util.StrToPtr("[Service]\nExecStart=/bin/false\n"),
< 							Name:     "var-lib-containers.mount",
< 						},
< 					},
< 				},
< 			},
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		out, _, r := test.in.ToIgn3_3Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, test.out, out, "#%d: bad output", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: expected empty report", i)
< 	}
< }
< 
< // TestTranslateTree tests translating the FCC storage.trees.[i] entries to ignition storage.files.[i] entries.
< func TestTranslateTree(t *testing.T) {
< 	tests := []struct {
< 		options    *common.TranslateOptions // defaulted if not specified
< 		dirDirs    map[string]os.FileMode   // relative path -> mode
< 		dirFiles   map[string]os.FileMode   // relative path -> mode
< 		dirLinks   map[string]string        // relative path -> target
< 		dirSockets []string                 // relative path
< 		inTrees    []Tree
< 		inFiles    []File
< 		inDirs     []Directory
< 		inLinks    []Link
< 		outFiles   []types.File
< 		outLinks   []types.Link
< 		report     string
< 	}{
< 		// smoke test
< 		{},
< 		// basic functionality
< 		{
< 			dirFiles: map[string]os.FileMode{
< 				"tree/executable":            0700,
< 				"tree/file":                  0600,
< 				"tree/overridden":            0644,
< 				"tree/overridden-executable": 0700,
< 				"tree/subdir/file":           0644,
< 				// compressed contents
< 				"tree/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/file": 0644,
< 				"tree2/file": 0600,
< 			},
< 			dirLinks: map[string]string{
< 				"tree/subdir/bad-link":        "../nonexistent",
< 				"tree/subdir/link":            "../file",
< 				"tree/subdir/overridden-link": "../file",
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 				{
< 					Local: "tree2",
< 					Path:  util.StrToPtr("/etc"),
< 				},
< 			},
< 			inFiles: []File{
< 				{
< 					Path: "/overridden",
< 					Mode: util.IntToPtr(0600),
< 					User: NodeUser{
< 						Name: util.StrToPtr("bovik"),
< 					},
< 				},
< 				{
< 					Path: "/overridden-executable",
< 					Mode: util.IntToPtr(0600),
< 					User: NodeUser{
< 						Name: util.StrToPtr("bovik"),
< 					},
< 				},
< 			},
< 			inLinks: []Link{
< 				{
< 					Path: "/subdir/overridden-link",
< 					User: NodeUser{
< 						Name: util.StrToPtr("bovik"),
< 					},
< 				},
< 			},
< 			outFiles: []types.File{
< 				{
< 					Node: types.Node{
< 						Path: "/overridden",
< 						User: types.NodeUser{
< 							Name: util.StrToPtr("bovik"),
< 						},
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Foverridden"),
< 						},
< 						Mode: util.IntToPtr(0600),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/overridden-executable",
< 						User: types.NodeUser{
< 							Name: util.StrToPtr("bovik"),
< 						},
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Foverridden-executable"),
< 						},
< 						Mode: util.IntToPtr(0600),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/executable",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Fexecutable"),
< 						},
< 						Mode: util.IntToPtr(0755),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Ffile"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree%2Fsubdir%2Ffile"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/subdir/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source:      util.StrToPtr("data:;base64,H4sIAAAAAAAC/yopSk3VLy5NSsksIptKy8xJBQQAAP//gkRzjkgAAAA="),
< 							Compression: util.StrToPtr("gzip"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/etc/file",
< 					},
< 					FileEmbedded1: types.FileEmbedded1{
< 						Contents: types.Resource{
< 							Source: util.StrToPtr("data:,tree2%2Ffile"),
< 						},
< 						Mode: util.IntToPtr(0644),
< 					},
< 				},
< 			},
< 			outLinks: []types.Link{
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/overridden-link",
< 						User: types.NodeUser{
< 							Name: util.StrToPtr("bovik"),
< 						},
< 					},
< 					LinkEmbedded1: types.LinkEmbedded1{
< 						Target: "../file",
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/bad-link",
< 					},
< 					LinkEmbedded1: types.LinkEmbedded1{
< 						Target: "../nonexistent",
< 					},
< 				},
< 				{
< 					Node: types.Node{
< 						Path: "/subdir/link",
< 					},
< 					LinkEmbedded1: types.LinkEmbedded1{
< 						Target: "../file",
< 					},
< 				},
< 			},
< 		},
< 		// collisions
< 		{
< 			dirFiles: map[string]os.FileMode{
< 				"tree0/file":         0600,
< 				"tree1/directory":    0600,
< 				"tree2/link":         0600,
< 				"tree3/file-partial": 0600, // should be okay
< 				"tree4/link-partial": 0600,
< 				"tree5/tree-file":    0600, // set up for tree/tree collision
< 				"tree6/tree-file":    0600,
< 				"tree15/tree-link":   0600,
< 			},
< 			dirLinks: map[string]string{
< 				"tree7/file":          "file",
< 				"tree8/directory":     "file",
< 				"tree9/link":          "file",
< 				"tree10/file-partial": "file",
< 				"tree11/link-partial": "file", // should be okay
< 				"tree12/tree-file":    "file",
< 				"tree13/tree-link":    "file", // set up for tree/tree collision
< 				"tree14/tree-link":    "file",
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree0",
< 				},
< 				{
< 					Local: "tree1",
< 				},
< 				{
< 					Local: "tree2",
< 				},
< 				{
< 					Local: "tree3",
< 				},
< 				{
< 					Local: "tree4",
< 				},
< 				{
< 					Local: "tree5",
< 				},
< 				{
< 					Local: "tree6",
< 				},
< 				{
< 					Local: "tree7",
< 				},
< 				{
< 					Local: "tree8",
< 				},
< 				{
< 					Local: "tree9",
< 				},
< 				{
< 					Local: "tree10",
< 				},
< 				{
< 					Local: "tree11",
< 				},
< 				{
< 					Local: "tree12",
< 				},
< 				{
< 					Local: "tree13",
< 				},
< 				{
< 					Local: "tree14",
< 				},
< 				{
< 					Local: "tree15",
< 				},
< 			},
< 			inFiles: []File{
< 				{
< 					Path: "/file",
< 					Contents: Resource{
< 						Source: util.StrToPtr("data:,foo"),
< 					},
< 				},
< 				{
< 					Path: "/file-partial",
< 				},
< 			},
< 			inDirs: []Directory{
< 				{
< 					Path: "/directory",
< 				},
< 			},
< 			inLinks: []Link{
< 				{
< 					Path:   "/link",
< 					Target: "file",
< 				},
< 				{
< 					Path: "/link-partial",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.1: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.2: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.4: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.6: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.7: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.8: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.9: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.10: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.12: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.14: " + common.ErrNodeExists.Error() + "\n" +
< 				"error at $.storage.trees.15: " + common.ErrNodeExists.Error() + "\n",
< 		},
< 		// files-dir escape
< 		{
< 			inTrees: []Tree{
< 				{
< 					Local: "../escape",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrFilesDirEscape.Error() + "\n",
< 		},
< 		// no files-dir
< 		{
< 			options: &common.TranslateOptions{},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrNoFilesDir.Error() + "\n",
< 		},
< 		// non-file/dir/symlink in directory tree
< 		{
< 			dirSockets: []string{
< 				"tree/socket",
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrFileType.Error() + "\n",
< 		},
< 		// unreadable file
< 		{
< 			dirDirs: map[string]os.FileMode{
< 				"tree/subdir": 0000,
< 				"tree2":       0000,
< 			},
< 			dirFiles: map[string]os.FileMode{
< 				"tree/file": 0000,
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 				{
< 					Local: "tree2",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: open %FilesDir%/tree/file: permission denied\n" +
< 				"error at $.storage.trees.0: open %FilesDir%/tree/subdir: permission denied\n" +
< 				"error at $.storage.trees.1: open %FilesDir%/tree2: permission denied\n",
< 		},
< 		// local is not a directory
< 		{
< 			dirFiles: map[string]os.FileMode{
< 				"tree": 0600,
< 			},
< 			inTrees: []Tree{
< 				{
< 					Local: "tree",
< 				},
< 				{
< 					Local: "nonexistent",
< 				},
< 			},
< 			report: "error at $.storage.trees.0: " + common.ErrTreeNotDirectory.Error() + "\n" +
< 				"error at $.storage.trees.1: stat %FilesDir%/nonexistent: no such file or directory\n",
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		filesDir, err := ioutil.TempDir("", "translate-test-")
< 		if err != nil {
< 			t.Error(err)
< 			return
< 		}
< 		defer os.RemoveAll(filesDir)
< 		for path, mode := range test.dirDirs {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(absPath, 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			if err := os.Chmod(absPath, mode); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 		}
< 		for path, mode := range test.dirFiles {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			if err := ioutil.WriteFile(absPath, []byte(path), mode); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 		}
< 		for path, target := range test.dirLinks {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			if err := os.Symlink(target, absPath); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 		}
< 		for _, path := range test.dirSockets {
< 			absPath := filepath.Join(filesDir, path)
< 			if err := os.MkdirAll(filepath.Dir(absPath), 0755); err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			listener, err := net.ListenUnix("unix", &net.UnixAddr{
< 				Name: absPath,
< 				Net:  "unix",
< 			})
< 			if err != nil {
< 				t.Error(err)
< 				return
< 			}
< 			defer listener.Close()
< 		}
< 
< 		config := Config{
< 			Storage: Storage{
< 				Files:       test.inFiles,
< 				Directories: test.inDirs,
< 				Links:       test.inLinks,
< 				Trees:       test.inTrees,
< 			},
< 		}
< 		options := common.TranslateOptions{
< 			FilesDir: filesDir,
< 		}
< 		if test.options != nil {
< 			options = *test.options
< 		}
< 		actual, _, r := config.ToIgn3_3Unvalidated(options)
< 
< 		expectedReport := strings.ReplaceAll(test.report, "%FilesDir%", filesDir)
< 		assert.Equal(t, expectedReport, r.String(), "#%d: bad report", i)
< 		if expectedReport != "" {
< 			continue
< 		}
< 
< 		assert.Equal(t, test.outFiles, actual.Storage.Files, "#%d: files mismatch", i)
< 		assert.Equal(t, []types.Directory(nil), actual.Storage.Directories, "#%d: directories mismatch", i)
< 		assert.Equal(t, test.outLinks, actual.Storage.Links, "#%d: links mismatch", i)
< 	}
< }
< 
< // TestTranslateIgnition tests translating the ct config.ignition to the ignition config.ignition section.
< // It ensure that the version is set as well.
< func TestTranslateIgnition(t *testing.T) {
< 	tests := []struct {
< 		in  Ignition
< 		out types.Ignition
< 	}{
< 		{
< 			Ignition{},
< 			types.Ignition{
< 				Version: "3.3.0-experimental",
< 			},
< 		},
< 		{
< 			Ignition{
< 				Config: IgnitionConfig{
< 					Merge: []Resource{
< 						{
< 							Inline: util.StrToPtr("xyzzy"),
< 						},
< 					},
< 					Replace: Resource{
< 						Inline: util.StrToPtr("xyzzy"),
< 					},
< 				},
< 			},
< 			types.Ignition{
< 				Version: "3.3.0-experimental",
< 				Config: types.IgnitionConfig{
< 					Merge: []types.Resource{
< 						{
< 							Source: util.StrToPtr("data:,xyzzy"),
< 						},
< 					},
< 					Replace: types.Resource{
< 						Source: util.StrToPtr("data:,xyzzy"),
< 					},
< 				},
< 			},
< 		},
< 		{
< 			Ignition{
< 				Proxy: Proxy{
< 					HTTPProxy: util.StrToPtr("https://example.com:8080"),
< 					NoProxy:   []string{"example.com"},
< 				},
< 			},
< 			types.Ignition{
< 				Version: "3.3.0-experimental",
< 				Proxy: types.Proxy{
< 					HTTPProxy: util.StrToPtr("https://example.com:8080"),
< 					NoProxy:   []types.NoProxyItem{types.NoProxyItem("example.com")},
< 				},
< 			},
< 		},
< 		{
< 			Ignition{
< 				Security: Security{
< 					TLS: TLS{
< 						CertificateAuthorities: []Resource{
< 							{
< 								Inline: util.StrToPtr("xyzzy"),
< 							},
< 						},
< 					},
< 				},
< 			},
< 			types.Ignition{
< 				Version: "3.3.0-experimental",
< 				Security: types.Security{
< 					TLS: types.TLS{
< 						CertificateAuthorities: []types.Resource{
< 							{
< 								Source: util.StrToPtr("data:,xyzzy"),
< 							},
< 						},
< 					},
< 				},
< 			},
< 		},
< 	}
< 	for i, test := range tests {
< 		actual, _, r := translateIgnition(test.in, common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
< 
< // TestToIgn3_3 tests the config.ToIgn3_3 function ensuring it will generate a valid config even when empty. Not much else is
< // tested since it uses the Ignition translation code which has it's own set of tests.
< func TestToIgn3_3(t *testing.T) {
< 	tests := []struct {
< 		in  Config
< 		out types.Config
< 	}{
< 		{
< 			Config{},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 			},
< 		},
< 	}
< 	for i, test := range tests {
< 		actual, _, r := test.in.ToIgn3_3Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_4_exp/util.go updated/vendor/github.com/coreos/fcct/base/v0_4_exp/util.go
1,125d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_4_exp
< 
< import (
< 	"github.com/coreos/ignition/v2/config/v3_3_experimental/types"
< )
< 
< type nodeTracker struct {
< 	files   *[]types.File
< 	fileMap map[string]int
< 
< 	dirs   *[]types.Directory
< 	dirMap map[string]int
< 
< 	links   *[]types.Link
< 	linkMap map[string]int
< }
< 
< func newNodeTracker(c *types.Config) *nodeTracker {
< 	t := nodeTracker{
< 		files:   &c.Storage.Files,
< 		fileMap: make(map[string]int, len(c.Storage.Files)),
< 
< 		dirs:   &c.Storage.Directories,
< 		dirMap: make(map[string]int, len(c.Storage.Directories)),
< 
< 		links:   &c.Storage.Links,
< 		linkMap: make(map[string]int, len(c.Storage.Links)),
< 	}
< 	for i, n := range *t.files {
< 		t.fileMap[n.Path] = i
< 	}
< 	for i, n := range *t.dirs {
< 		t.dirMap[n.Path] = i
< 	}
< 	for i, n := range *t.links {
< 		t.linkMap[n.Path] = i
< 	}
< 	return &t
< }
< 
< func (t *nodeTracker) Exists(path string) bool {
< 	for _, m := range []map[string]int{t.fileMap, t.dirMap, t.linkMap} {
< 		if _, ok := m[path]; ok {
< 			return true
< 		}
< 	}
< 	return false
< }
< 
< func (t *nodeTracker) GetFile(path string) (int, *types.File) {
< 	if i, ok := t.fileMap[path]; ok {
< 		return i, &(*t.files)[i]
< 	} else {
< 		return 0, nil
< 	}
< }
< 
< func (t *nodeTracker) AddFile(f types.File) (int, *types.File) {
< 	if f.Path == "" {
< 		panic("File path missing")
< 	}
< 	if _, ok := t.fileMap[f.Path]; ok {
< 		panic("Adding already existing file")
< 	}
< 	i := len(*t.files)
< 	*t.files = append(*t.files, f)
< 	t.fileMap[f.Path] = i
< 	return i, &(*t.files)[i]
< }
< 
< func (t *nodeTracker) GetDir(path string) (int, *types.Directory) {
< 	if i, ok := t.dirMap[path]; ok {
< 		return i, &(*t.dirs)[i]
< 	} else {
< 		return 0, nil
< 	}
< }
< 
< func (t *nodeTracker) AddDir(d types.Directory) (int, *types.Directory) {
< 	if d.Path == "" {
< 		panic("Directory path missing")
< 	}
< 	if _, ok := t.dirMap[d.Path]; ok {
< 		panic("Adding already existing directory")
< 	}
< 	i := len(*t.dirs)
< 	*t.dirs = append(*t.dirs, d)
< 	t.dirMap[d.Path] = i
< 	return i, &(*t.dirs)[i]
< }
< 
< func (t *nodeTracker) GetLink(path string) (int, *types.Link) {
< 	if i, ok := t.linkMap[path]; ok {
< 		return i, &(*t.links)[i]
< 	} else {
< 		return 0, nil
< 	}
< }
< 
< func (t *nodeTracker) AddLink(l types.Link) (int, *types.Link) {
< 	if l.Path == "" {
< 		panic("Link path missing")
< 	}
< 	if _, ok := t.linkMap[l.Path]; ok {
< 		panic("Adding already existing link")
< 	}
< 	i := len(*t.links)
< 	*t.links = append(*t.links, l)
< 	t.linkMap[l.Path] = i
< 	return i, &(*t.links)[i]
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_4_exp/validate.go updated/vendor/github.com/coreos/fcct/base/v0_4_exp/validate.go
1,78d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_4_exp
< 
< import (
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (rs Resource) Validate(c path.ContextPath) (r report.Report) {
< 	var field string
< 	sources := 0
< 	if rs.Local != nil {
< 		sources++
< 		field = "local"
< 	}
< 	if rs.Inline != nil {
< 		sources++
< 		field = "inline"
< 	}
< 	if rs.Source != nil {
< 		sources++
< 		field = "source"
< 	}
< 	if sources > 1 {
< 		r.AddOnError(c.Append(field), common.ErrTooManyResourceSources)
< 	}
< 	return
< }
< 
< func (fs Filesystem) Validate(c path.ContextPath) (r report.Report) {
< 	if fs.WithMountUnit == nil || !*fs.WithMountUnit {
< 		return
< 	}
< 	if fs.Path == nil || *fs.Path == "" {
< 		r.AddOnError(c.Append("path"), common.ErrMountUnitNoPath)
< 	}
< 	if fs.Format == nil || *fs.Format == "" {
< 		r.AddOnError(c.Append("format"), common.ErrMountUnitNoFormat)
< 	}
< 	return
< }
< 
< func (d Directory) Validate(c path.ContextPath) (r report.Report) {
< 	if d.Mode != nil {
< 		r.AddOnWarn(c.Append("mode"), baseutil.CheckForDecimalMode(*d.Mode, true))
< 	}
< 	return
< }
< 
< func (f File) Validate(c path.ContextPath) (r report.Report) {
< 	if f.Mode != nil {
< 		r.AddOnWarn(c.Append("mode"), baseutil.CheckForDecimalMode(*f.Mode, false))
< 	}
< 	return
< }
< 
< func (t Tree) Validate(c path.ContextPath) (r report.Report) {
< 	if t.Local == "" {
< 		r.AddOnError(c, common.ErrTreeNoLocal)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/base/v0_4_exp/validate_test.go updated/vendor/github.com/coreos/fcct/base/v0_4_exp/validate_test.go
1,214d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_4_exp
< 
< import (
< 	"testing"
< 
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // TestValidateResource tests that multiple sources (i.e. urls and inline) are not allowed but zero or one sources are
< func TestValidateResource(t *testing.T) {
< 	tests := []struct {
< 		in      Resource
< 		out     error
< 		errPath path.ContextPath
< 	}{
< 		{},
< 		// source specified
< 		{
< 			// contains invalid (by the validator's definition) combinations of fields,
< 			// but the translator doesn't care and we can check they all get translated at once
< 			Resource{
< 				Source:      util.StrToPtr("http://example/com"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// inline specified
< 		{
< 			Resource{
< 				Inline:      util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// local specified
< 		{
< 			Resource{
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// source + inline, invalid
< 		{
< 			Resource{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Inline:      util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "source"),
< 		},
< 		// source + local, invalid
< 		{
< 			Resource{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "source"),
< 		},
< 		// inline + local, invalid
< 		{
< 			Resource{
< 				Inline:      util.StrToPtr("hello"),
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "inline"),
< 		},
< 		// source + inline + local, invalid
< 		{
< 			Resource{
< 				Source:      util.StrToPtr("data:,hello"),
< 				Inline:      util.StrToPtr("hello"),
< 				Local:       util.StrToPtr("hello"),
< 				Compression: util.StrToPtr("gzip"),
< 				Verification: Verification{
< 					Hash: util.StrToPtr("this isn't validated"),
< 				},
< 			},
< 			common.ErrTooManyResourceSources,
< 			path.New("yaml", "source"),
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnError(test.errPath, test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
< 
< func TestValidateTree(t *testing.T) {
< 	tests := []struct {
< 		in  Tree
< 		out error
< 	}{
< 		{
< 			in:  Tree{},
< 			out: common.ErrTreeNoLocal,
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnError(path.New("yaml"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
< 
< func TestValidateMode(t *testing.T) {
< 	fileTests := []struct {
< 		in  File
< 		out error
< 	}{
< 		{
< 			in:  File{},
< 			out: nil,
< 		},
< 		{
< 			in: File{
< 				Mode: util.IntToPtr(0600),
< 			},
< 			out: nil,
< 		},
< 		{
< 			in: File{
< 				Mode: util.IntToPtr(600),
< 			},
< 			out: common.ErrDecimalMode,
< 		},
< 	}
< 
< 	for i, test := range fileTests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnWarn(path.New("yaml", "mode"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< 
< 	dirTests := []struct {
< 		in  Directory
< 		out error
< 	}{
< 		{
< 			in:  Directory{},
< 			out: nil,
< 		},
< 		{
< 			in: Directory{
< 				Mode: util.IntToPtr(01770),
< 			},
< 			out: nil,
< 		},
< 		{
< 			in: Directory{
< 				Mode: util.IntToPtr(1770),
< 			},
< 			out: common.ErrDecimalMode,
< 		},
< 	}
< 
< 	for i, test := range dirTests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnWarn(path.New("yaml", "mode"), test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/build updated/vendor/github.com/coreos/fcct/build
1,19d0
< #!/usr/bin/env bash
< 
< set -eu
< 
< export GO111MODULE=on
< export GOFLAGS=-mod=vendor
< export CGO_ENABLED=0
< version=$(git describe --dirty --always)
< LDFLAGS="-w -X github.com/coreos/fcct/internal/version.Raw=$version"
< 
< NAME=fcct
< 
< eval $(go env)
< if [ -z ${BIN_PATH+a} ]; then
< 	BIN_PATH=${PWD}/bin/${GOARCH}
< fi
< 
< echo "Building $NAME..."
< go build -o ${BIN_PATH}/${NAME} -ldflags "$LDFLAGS" internal/main.go
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/build_releases updated/vendor/github.com/coreos/fcct/build_releases
1,36d0
< #!/usr/bin/env bash
< 
< set -euo pipefail
< 
< export GO111MODULE=on
< export GOFLAGS=-mod=vendor
< export CGO_ENABLED=0
< version=$(git describe --dirty --always)
< LDFLAGS="-w -X github.com/coreos/fcct/internal/version.Raw=$version"
< 
< eval $(go env)
< if [ -z ${BIN_PATH+a} ]; then
< 	export BIN_PATH=${PWD}/bin/releases/
< fi
< 
< build_release() {
<     export NAME="fcct-${1}"
<     echo "building ${NAME}"
<     go build -o ${BIN_PATH}/${NAME} -ldflags "$LDFLAGS" internal/main.go
< }
< 
< export GOOS=linux
< export GOARCH=amd64
< build_release x86_64-unknown-linux-gnu
< 
< export GOOS=darwin
< export GOARCH=amd64
< build_release x86_64-apple-darwin
< 
< export GOOS=windows
< export GOARCH=amd64
< build_release x86_64-pc-windows-gnu.exe
< 
< export GOOS=linux
< export GOARCH=arm64
< build_release aarch64-unknown-linux-gnu
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/common/common.go updated/vendor/github.com/coreos/fcct/config/common/common.go
1,26d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package common
< 
< type TranslateOptions struct {
< 	FilesDir                  string // allow embedding local files relative to this directory
< 	NoResourceAutoCompression bool   // skip automatic compression of inline/local resources
< }
< 
< type TranslateBytesOptions struct {
< 	TranslateOptions
< 	Pretty bool
< 	Strict bool
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/common/errors.go updated/vendor/github.com/coreos/fcct/config/common/errors.go
1,49d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package common
< 
< import (
< 	"errors"
< )
< 
< var (
< 	// common field parsing
< 	ErrNoVariant      = errors.New("error parsing variant; must be specified")
< 	ErrInvalidVersion = errors.New("error parsing version; must be a valid semver")
< 
< 	// high-level errors for fatal reports
< 	ErrInvalidSourceConfig    = errors.New("source config is invalid")
< 	ErrInvalidGeneratedConfig = errors.New("config generated was invalid")
< 
< 	// resources and trees
< 	ErrTooManyResourceSources = errors.New("only one of the following can be set: inline, local, source")
< 	ErrFilesDirEscape         = errors.New("local file path traverses outside the files directory")
< 	ErrFileType               = errors.New("trees may only contain files, directories, and symlinks")
< 	ErrNodeExists             = errors.New("matching filesystem node has existing contents or different type")
< 	ErrNoFilesDir             = errors.New("local file paths are relative to a files directory that must be specified with -d/--files-dir")
< 	ErrTreeNotDirectory       = errors.New("root of tree must be a directory")
< 	ErrTreeNoLocal            = errors.New("local is required")
< 
< 	// filesystem nodes
< 	ErrDecimalMode = errors.New("unreasonable mode would be reasonable if specified in octal; remember to add a leading zero")
< 
< 	// mount units
< 	ErrMountUnitNoPath   = errors.New("path is required if with_mount_unit is true")
< 	ErrMountUnitNoFormat = errors.New("format is required if with_mount_unit is true")
< 
< 	// boot device
< 	ErrUnknownBootDeviceLayout = errors.New("layout must be one of: aarch64, ppc64le, x86_64")
< 	ErrTooFewMirrorDevices     = errors.New("mirroring requires at least two devices")
< )
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/config.go updated/vendor/github.com/coreos/fcct/config/config.go
1,103d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package config
< 
< import (
< 	"fmt"
< 
< 	"github.com/coreos/fcct/config/common"
< 	fcos1_0 "github.com/coreos/fcct/config/fcos/v1_0"
< 	fcos1_1 "github.com/coreos/fcct/config/fcos/v1_1"
< 	fcos1_2 "github.com/coreos/fcct/config/fcos/v1_2"
< 	fcos1_3 "github.com/coreos/fcct/config/fcos/v1_3"
< 	fcos1_4_exp "github.com/coreos/fcct/config/fcos/v1_4_exp"
< 	rhcos0_1 "github.com/coreos/fcct/config/rhcos/v0_1"
< 	rhcos0_2_exp "github.com/coreos/fcct/config/rhcos/v0_2_exp"
< 
< 	"github.com/coreos/go-semver/semver"
< 	"github.com/coreos/vcontext/report"
< 	"gopkg.in/yaml.v3"
< )
< 
< var (
< 	registry = map[string]translator{}
< )
< 
< /// Fields that must be included in the root struct of every spec version.
< type commonFields struct {
< 	Version string `yaml:"version"`
< 	Variant string `yaml:"variant"`
< }
< 
< func init() {
< 	RegisterTranslator("fcos", "1.0.0", fcos1_0.ToIgn3_0Bytes)
< 	RegisterTranslator("fcos", "1.1.0", fcos1_1.ToIgn3_1Bytes)
< 	RegisterTranslator("fcos", "1.2.0", fcos1_2.ToIgn3_2Bytes)
< 	RegisterTranslator("fcos", "1.3.0", fcos1_3.ToIgn3_2Bytes)
< 	RegisterTranslator("fcos", "1.4.0-experimental", fcos1_4_exp.ToIgn3_3Bytes)
< 	RegisterTranslator("rhcos", "0.1.0", rhcos0_1.ToIgn3_2Bytes)
< 	RegisterTranslator("rhcos", "0.2.0-experimental", rhcos0_2_exp.ToIgn3_3Bytes)
< }
< 
< /// RegisterTranslator registers a translator for the specified variant and
< /// version to be available for use by TranslateBytes.  This is only needed
< /// by users implementing their own translators outside the FCCT package.
< func RegisterTranslator(variant, version string, trans translator) {
< 	key := fmt.Sprintf("%s+%s", variant, version)
< 	if _, ok := registry[key]; ok {
< 		panic("tried to reregister existing translator")
< 	}
< 	registry[key] = trans
< }
< 
< func getTranslator(variant string, version semver.Version) (translator, error) {
< 	t, ok := registry[fmt.Sprintf("%s+%s", variant, version.String())]
< 	if !ok {
< 		return nil, fmt.Errorf("No translator exists for variant %s with version %s", variant, version.String())
< 	}
< 	return t, nil
< }
< 
< // translators take a raw config and translate it to a raw Ignition config. The report returned should include any
< // errors, warnings, etc and may or may not be fatal. If report is fatal, or other errors are encountered while translating
< // translators should return an error.
< type translator func([]byte, common.TranslateBytesOptions) ([]byte, report.Report, error)
< 
< // TranslateBytes wraps all of the individual TranslateBytes functions in a switch that determines the correct one to call.
< // TranslateBytes returns an error if the report had fatal errors or if other errors occured during translation.
< func TranslateBytes(input []byte, options common.TranslateBytesOptions) ([]byte, report.Report, error) {
< 	// first determine version. This will ignore most fields, so don't use strict
< 	ver := commonFields{}
< 	if err := yaml.Unmarshal(input, &ver); err != nil {
< 		return nil, report.Report{}, fmt.Errorf("Error unmarshaling yaml: %v", err)
< 	}
< 
< 	if ver.Variant == "" {
< 		return nil, report.Report{}, common.ErrNoVariant
< 	}
< 
< 	tmp, err := semver.NewVersion(ver.Version)
< 	if err != nil {
< 		return nil, report.Report{}, common.ErrInvalidVersion
< 	}
< 	version := *tmp
< 
< 	translator, err := getTranslator(ver.Variant, version)
< 	if err != nil {
< 		return nil, report.Report{}, err
< 	}
< 
< 	return translator(input, options)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_0/schema.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_0/schema.go
1,23d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_0
< 
< import (
< 	base "github.com/coreos/fcct/base/v0_1"
< )
< 
< type Config struct {
< 	base.Config `yaml:",inline"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_0/translate.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_0/translate.go
1,39d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_0
< 
< import (
< 	"github.com/coreos/fcct/config/common"
< 	cutil "github.com/coreos/fcct/config/util"
< 
< 	"github.com/coreos/ignition/v2/config/v3_0/types"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // ToIgn3_0 translates the config to an Ignition config.  It returns a
< // report of any errors or warnings in the source and resultant config.  If
< // the report has fatal errors or it encounters other problems translating,
< // an error is returned.
< func (c Config) ToIgn3_0(options common.TranslateOptions) (types.Config, report.Report, error) {
< 	cfg, r, err := cutil.Translate(c, "ToIgn3_0Unvalidated", options)
< 	return cfg.(types.Config), r, err
< }
< 
< // ToIgn3_0Bytes translates from a v1.0 fcc to a v3.0.0 Ignition config. It returns a report of any errors or
< // warnings in the source and resultant config. If the report has fatal errors or it encounters other problems
< // translating, an error is returned.
< func ToIgn3_0Bytes(input []byte, options common.TranslateBytesOptions) ([]byte, report.Report, error) {
< 	return cutil.TranslateBytes(input, &Config{}, "ToIgn3_0", options)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_1/schema.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_1/schema.go
1,23d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_1
< 
< import (
< 	base "github.com/coreos/fcct/base/v0_2"
< )
< 
< type Config struct {
< 	base.Config `yaml:",inline"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_1/translate.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_1/translate.go
1,39d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_1
< 
< import (
< 	"github.com/coreos/fcct/config/common"
< 	cutil "github.com/coreos/fcct/config/util"
< 
< 	"github.com/coreos/ignition/v2/config/v3_1/types"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // ToIgn3_1 translates the config to an Ignition config.  It returns a
< // report of any errors or warnings in the source and resultant config.  If
< // the report has fatal errors or it encounters other problems translating,
< // an error is returned.
< func (c Config) ToIgn3_1(options common.TranslateOptions) (types.Config, report.Report, error) {
< 	cfg, r, err := cutil.Translate(c, "ToIgn3_1Unvalidated", options)
< 	return cfg.(types.Config), r, err
< }
< 
< // ToIgn3_1Bytes translates from a v1.1 fcc to a v3.1.0 Ignition config. It returns a report of any errors or
< // warnings in the source and resultant config. If the report has fatal errors or it encounters other problems
< // translating, an error is returned.
< func ToIgn3_1Bytes(input []byte, options common.TranslateBytesOptions) ([]byte, report.Report, error) {
< 	return cutil.TranslateBytes(input, &Config{}, "ToIgn3_1", options)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_2/schema.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_2/schema.go
1,23d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_2
< 
< import (
< 	base "github.com/coreos/fcct/base/v0_3"
< )
< 
< type Config struct {
< 	base.Config `yaml:",inline"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_2/translate.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_2/translate.go
1,39d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_2
< 
< import (
< 	"github.com/coreos/fcct/config/common"
< 	cutil "github.com/coreos/fcct/config/util"
< 
< 	"github.com/coreos/ignition/v2/config/v3_2/types"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // ToIgn3_2 translates the config to an Ignition config.  It returns a
< // report of any errors or warnings in the source and resultant config.  If
< // the report has fatal errors or it encounters other problems translating,
< // an error is returned.
< func (c Config) ToIgn3_2(options common.TranslateOptions) (types.Config, report.Report, error) {
< 	cfg, r, err := cutil.Translate(c, "ToIgn3_2Unvalidated", options)
< 	return cfg.(types.Config), r, err
< }
< 
< // ToIgn3_2Bytes translates from a v1.2 fcc to a v3.2.0 Ignition config. It returns a report of any errors or
< // warnings in the source and resultant config. If the report has fatal errors or it encounters other problems
< // translating, an error is returned.
< func ToIgn3_2Bytes(input []byte, options common.TranslateBytesOptions) ([]byte, report.Report, error) {
< 	return cutil.TranslateBytes(input, &Config{}, "ToIgn3_2", options)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_3/schema.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_3/schema.go
1,40d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_3
< 
< import (
< 	base "github.com/coreos/fcct/base/v0_3"
< )
< 
< type Config struct {
< 	base.Config `yaml:",inline"`
< 	BootDevice  BootDevice `yaml:"boot_device"`
< }
< 
< type BootDevice struct {
< 	Layout *string          `yaml:"layout"`
< 	Luks   BootDeviceLuks   `yaml:"luks"`
< 	Mirror BootDeviceMirror `yaml:"mirror"`
< }
< 
< type BootDeviceLuks struct {
< 	Tang      []base.Tang `yaml:"tang"`
< 	Threshold *int        `yaml:"threshold"`
< 	Tpm2      *bool       `yaml:"tpm2"`
< }
< 
< type BootDeviceMirror struct {
< 	Devices []string `yaml:"devices"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_3/translate.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_3/translate.go
1,254d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_3
< 
< import (
< 	"fmt"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 	cutil "github.com/coreos/fcct/config/util"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_2/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< const (
< 	biosTypeGuid = "21686148-6449-6E6F-744E-656564454649"
< 	prepTypeGuid = "9E1A2D38-C612-4316-AA26-8B49521E5A8B"
< 	espTypeGuid  = "C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
< 
< 	// The partition layout implemented in this file replicates
< 	// the layout of the OS image defined in:
< 	// https://github.com/coreos/coreos-assembler/blob/master/src/create_disk.sh
< 	//
< 	// Exception: we don't try to skip unused partition numbers,
< 	// because specifying a partition number would prevent child
< 	// configs from overriding partition fields using the partition
< 	// label as the lookup key.
< 	//
< 	// It's not critical that we match that layout exactly; the hard
< 	// constraints are:
< 	//   - The desugared partition cannot be smaller than the one it
< 	//     replicates
< 	//   - The new BIOS-BOOT partition (and maybe the PReP one?) must be
< 	//     at the same offset as the original
< 	//
< 	// Do not change these constants!  New partition layouts must be
< 	// encoded into new layout templates.
< 	biosV1SizeMiB = 1
< 	prepV1SizeMiB = 4
< 	espV1SizeMiB  = 127
< 	bootV1SizeMiB = 384
< )
< 
< // ToIgn3_2Unvalidated translates the config to an Ignition config.  It also
< // returns the set of translations it did so paths in the resultant config
< // can be tracked back to their source in the source config.  No config
< // validation is performed on input or output.
< func (c Config) ToIgn3_2Unvalidated(options common.TranslateOptions) (types.Config, translate.TranslationSet, report.Report) {
< 	ret, ts, r := c.Config.ToIgn3_2Unvalidated(options)
< 	r.Merge(c.processBootDevice(&ret, &ts, options))
< 	return ret, ts, r
< }
< 
< // ToIgn3_2 translates the config to an Ignition config.  It returns a
< // report of any errors or warnings in the source and resultant config.  If
< // the report has fatal errors or it encounters other problems translating,
< // an error is returned.
< func (c Config) ToIgn3_2(options common.TranslateOptions) (types.Config, report.Report, error) {
< 	cfg, r, err := cutil.Translate(c, "ToIgn3_2Unvalidated", options)
< 	return cfg.(types.Config), r, err
< }
< 
< // ToIgn3_2Bytes translates from a v1.3 fcc to a v3.2.0 Ignition config. It returns a report of any errors or
< // warnings in the source and resultant config. If the report has fatal errors or it encounters other problems
< // translating, an error is returned.
< func ToIgn3_2Bytes(input []byte, options common.TranslateBytesOptions) ([]byte, report.Report, error) {
< 	return cutil.TranslateBytes(input, &Config{}, "ToIgn3_2", options)
< }
< 
< func (c Config) processBootDevice(config *types.Config, ts *translate.TranslationSet, options common.TranslateOptions) report.Report {
< 	var rendered types.Config
< 	renderedTranslations := translate.NewTranslationSet("yaml", "json")
< 	var r report.Report
< 
< 	// check for high-level features
< 	wantLuks := (c.BootDevice.Luks.Tpm2 != nil && *c.BootDevice.Luks.Tpm2) || len(c.BootDevice.Luks.Tang) > 0
< 	wantMirror := len(c.BootDevice.Mirror.Devices) > 0
< 	if !wantLuks && !wantMirror {
< 		return r
< 	}
< 
< 	// compute layout rendering options
< 	var wantBIOSPart bool
< 	var wantPRePPart bool
< 	layout := c.BootDevice.Layout
< 	switch {
< 	case layout == nil || *layout == "x86_64":
< 		wantBIOSPart = true
< 	case *layout == "aarch64":
< 		// neither BIOS or PReP
< 	case *layout == "ppc64le":
< 		wantPRePPart = true
< 	default:
< 		// should have failed validation
< 		panic("unknown layout")
< 	}
< 
< 	// mirrored root disk
< 	if wantMirror {
< 		// partition disks
< 		for i, device := range c.BootDevice.Mirror.Devices {
< 			labelIndex := len(rendered.Storage.Disks) + 1
< 			disk := types.Disk{
< 				Device:    device,
< 				WipeTable: util.BoolToPtr(true),
< 			}
< 			if wantBIOSPart {
< 				disk.Partitions = append(disk.Partitions, types.Partition{
< 					Label:    util.StrToPtr(fmt.Sprintf("bios-%d", labelIndex)),
< 					SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 					TypeGUID: util.StrToPtr(biosTypeGuid),
< 				})
< 			}
< 			if wantPRePPart {
< 				disk.Partitions = append(disk.Partitions, types.Partition{
< 					Label:    util.StrToPtr(fmt.Sprintf("prep-%d", labelIndex)),
< 					SizeMiB:  util.IntToPtr(prepV1SizeMiB),
< 					TypeGUID: util.StrToPtr(prepTypeGuid),
< 				})
< 			}
< 			disk.Partitions = append(disk.Partitions, types.Partition{
< 				Label:    util.StrToPtr(fmt.Sprintf("esp-%d", labelIndex)),
< 				SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 				TypeGUID: util.StrToPtr(espTypeGuid),
< 			}, types.Partition{
< 				Label:   util.StrToPtr(fmt.Sprintf("boot-%d", labelIndex)),
< 				SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 			}, types.Partition{
< 				Label: util.StrToPtr(fmt.Sprintf("root-%d", labelIndex)),
< 			})
< 			renderedTranslations.AddFromCommonSource(path.New("yaml", "boot_device", "mirror", "devices", i), path.New("json", "storage", "disks", len(rendered.Storage.Disks)), disk)
< 			rendered.Storage.Disks = append(rendered.Storage.Disks, disk)
< 		}
< 
< 		// create RAIDs
< 		raidDevices := func(labelPrefix string) []types.Device {
< 			count := len(rendered.Storage.Disks)
< 			ret := make([]types.Device, count)
< 			for i := 0; i < count; i++ {
< 				ret[i] = types.Device(fmt.Sprintf("/dev/disk/by-partlabel/%s-%d", labelPrefix, i+1))
< 			}
< 			return ret
< 		}
< 		rendered.Storage.Raid = []types.Raid{{
< 			Devices: raidDevices("esp"),
< 			Level:   "raid1",
< 			Name:    "md-esp",
< 			// put the RAID superblock at the end of the
< 			// partition to avoid confusing UEFI
< 			Options: []types.RaidOption{"--metadata=1.0"},
< 		}, {
< 			Devices: raidDevices("boot"),
< 			Level:   "raid1",
< 			Name:    "md-boot",
< 			// put the RAID superblock at the end of the
< 			// partition so BIOS GRUB doesn't need to
< 			// understand RAID
< 			Options: []types.RaidOption{"--metadata=1.0"},
< 		}, {
< 			Devices: raidDevices("root"),
< 			Level:   "raid1",
< 			Name:    "md-root",
< 		}}
< 		renderedTranslations.AddFromCommonSource(path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid"), rendered.Storage.Raid)
< 
< 		// create filesystems, except for root
< 		rendered.Storage.Filesystems = []types.Filesystem{{
< 			Device:         "/dev/md/md-esp",
< 			Format:         util.StrToPtr("vfat"),
< 			Label:          util.StrToPtr("EFI-SYSTEM"),
< 			WipeFilesystem: util.BoolToPtr(true),
< 		}, {
< 			Device:         "/dev/md/md-boot",
< 			Format:         util.StrToPtr("ext4"),
< 			Label:          util.StrToPtr("boot"),
< 			WipeFilesystem: util.BoolToPtr(true),
< 		}}
< 		renderedTranslations.AddFromCommonSource(path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems"), rendered.Storage.Filesystems)
< 	}
< 
< 	// encrypted root partition
< 	if wantLuks {
< 		luksDevice := "/dev/disk/by-partlabel/root"
< 		if wantMirror {
< 			luksDevice = "/dev/md/md-root"
< 		}
< 		clevis, ts2, r2 := translateBootDeviceLuks(c.BootDevice.Luks, options)
< 		rendered.Storage.Luks = []types.Luks{{
< 			Clevis:     &clevis,
< 			Device:     &luksDevice,
< 			Label:      util.StrToPtr("luks-root"),
< 			Name:       "root",
< 			WipeVolume: util.BoolToPtr(true),
< 		}}
< 		lpath := path.New("yaml", "boot_device", "luks")
< 		rpath := path.New("json", "storage", "luks", 0)
< 		renderedTranslations.Merge(ts2.PrefixPaths(lpath, rpath.Append("clevis")))
< 		for _, f := range []string{"device", "label", "name", "wipeVolume"} {
< 			renderedTranslations.AddTranslation(lpath, rpath.Append(f))
< 		}
< 		r.Merge(r2)
< 	}
< 
< 	// create root filesystem
< 	var rootDevice string
< 	switch {
< 	case wantLuks:
< 		// LUKS, or LUKS on RAID
< 		rootDevice = "/dev/mapper/root"
< 	case wantMirror:
< 		// RAID without LUKS
< 		rootDevice = "/dev/md/md-root"
< 	default:
< 		panic("can't happen")
< 	}
< 	rootFilesystem := types.Filesystem{
< 		Device:         rootDevice,
< 		Format:         util.StrToPtr("xfs"),
< 		Label:          util.StrToPtr("root"),
< 		WipeFilesystem: util.BoolToPtr(true),
< 	}
< 	renderedTranslations.AddFromCommonSource(path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", len(rendered.Storage.Filesystems)), rootFilesystem)
< 	rendered.Storage.Filesystems = append(rendered.Storage.Filesystems, rootFilesystem)
< 
< 	// merge with translated config
< 	retConfig, retTranslations := baseutil.MergeTranslatedConfigs(rendered, renderedTranslations, *config, *ts)
< 	*config = retConfig.(types.Config)
< 	*ts = retTranslations
< 	return r
< }
< 
< func translateBootDeviceLuks(from BootDeviceLuks, options common.TranslateOptions) (to types.Clevis, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "tang", &from.Tang, &to.Tang)
< 	translate.MergeP(tr, tm, &r, "threshold", &from.Threshold, &to.Threshold)
< 	translate.MergeP(tr, tm, &r, "tpm2", &from.Tpm2, &to.Tpm2)
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_3/translate_test.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_3/translate_test.go
1,1159d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_3
< 
< import (
< 	"testing"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	base "github.com/coreos/fcct/base/v0_3"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_2/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // Most of this is covered by the Ignition translator generic tests, so just test the custom bits
< 
< // TestTranslateBootDevice tests translating the FCC boot_device section.
< func TestTranslateBootDevice(t *testing.T) {
< 	tests := []struct {
< 		in         Config
< 		out        types.Config
< 		exceptions []translate.Translation
< 	}{
< 		// empty config
< 		{
< 			Config{},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 			},
< 			[]translate.Translation{},
< 		},
< 		// LUKS, x86_64
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/disk/by-partlabel/root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 			},
< 		},
< 		// 3-disk mirror, x86_64
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb", "/dev/vdc"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-1"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-1"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-2"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-2"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdc",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-3"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-3"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-3"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-3"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 								"/dev/disk/by-partlabel/esp-3",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 								"/dev/disk/by-partlabel/boot-3",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 								"/dev/disk/by-partlabel/root-3",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 		// 3-disk mirror + LUKS, x86_64
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb", "/dev/vdc"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-1"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-1"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-2"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-2"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdc",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-3"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-3"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-3"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-3"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 								"/dev/disk/by-partlabel/esp-3",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 								"/dev/disk/by-partlabel/boot-3",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 								"/dev/disk/by-partlabel/root-3",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/md/md-root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 		// 2-disk mirror + LUKS, aarch64
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Layout: util.StrToPtr("aarch64"),
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-1"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-2"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/md/md-root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 		// 2-disk mirror + LUKS, ppc64le
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Layout: util.StrToPtr("ppc64le"),
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("prep-1"),
< 									SizeMiB:  util.IntToPtr(prepV1SizeMiB),
< 									TypeGUID: util.StrToPtr(prepTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-1"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("prep-2"),
< 									SizeMiB:  util.IntToPtr(prepV1SizeMiB),
< 									TypeGUID: util.StrToPtr(prepTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-2"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/md/md-root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 		// 2-disk mirror + LUKS with overridden root partition size
< 		// and filesystem type, x86_64
< 		{
< 			Config{
< 				Config: base.Config{
< 					Storage: base.Storage{
< 						Disks: []base.Disk{
< 							{
< 								Device: "/dev/vda",
< 								Partitions: []base.Partition{
< 									{
< 										Label:   util.StrToPtr("root-1"),
< 										SizeMiB: util.IntToPtr(8192),
< 									},
< 								},
< 							},
< 							{
< 								Device: "/dev/vdb",
< 								Partitions: []base.Partition{
< 									{
< 										Label:   util.StrToPtr("root-2"),
< 										SizeMiB: util.IntToPtr(8192),
< 									},
< 								},
< 							},
< 						},
< 						Filesystems: []base.Filesystem{
< 							{
< 								Device: "/dev/mapper/root",
< 								Format: util.StrToPtr("ext4"),
< 							},
< 						},
< 					},
< 				},
< 				BootDevice: BootDevice{
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.2.0",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-1"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label:   util.StrToPtr("root-1"),
< 									SizeMiB: util.IntToPtr(8192),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-2"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label:   util.StrToPtr("root-2"),
< 									SizeMiB: util.IntToPtr(8192),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/md/md-root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "storage", "disks", 0, "partitions", 0, "label"), path.New("json", "storage", "disks", 0, "partitions", 3, "label")},
< 				{path.New("yaml", "storage", "disks", 0, "partitions", 0, "size_mib"), path.New("json", "storage", "disks", 0, "partitions", 3, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "storage", "disks", 1, "partitions", 0, "label"), path.New("json", "storage", "disks", 1, "partitions", 3, "label")},
< 				{path.New("yaml", "storage", "disks", 1, "partitions", 0, "size_mib"), path.New("json", "storage", "disks", 1, "partitions", 3, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "storage", "filesystems", 0, "device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "storage", "filesystems", 0, "format"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 	}
< 
< 	// The partition sizes of existing layouts must never change, but
< 	// we use the constants in tests for clarity.  Ensure no one has
< 	// changed them.
< 	assert.Equal(t, biosV1SizeMiB, 1)
< 	assert.Equal(t, prepV1SizeMiB, 4)
< 	assert.Equal(t, espV1SizeMiB, 127)
< 	assert.Equal(t, bootV1SizeMiB, 384)
< 
< 	for i, test := range tests {
< 		actual, translations, r := test.in.ToIgn3_2Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 		baseutil.VerifyTranslations(t, translations, test.exceptions, "#%d", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_3/validate.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_3/validate.go
1,41d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_3
< 
< import (
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d BootDevice) Validate(c path.ContextPath) (r report.Report) {
< 	if d.Layout != nil {
< 		switch *d.Layout {
< 		case "aarch64", "ppc64le", "x86_64":
< 		default:
< 			r.AddOnError(c.Append("layout"), common.ErrUnknownBootDeviceLayout)
< 		}
< 	}
< 	r.Merge(d.Mirror.Validate(c.Append("mirror")))
< 	return
< }
< 
< func (m BootDeviceMirror) Validate(c path.ContextPath) (r report.Report) {
< 	if len(m.Devices) == 1 {
< 		r.AddOnError(c.Append("devices"), common.ErrTooFewMirrorDevices)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_3/validate_test.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_3/validate_test.go
1,87d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_3
< 
< import (
< 	"testing"
< 
< 	base "github.com/coreos/fcct/base/v0_3"
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // TestValidateBootDevice tests boot device validation
< func TestValidateBootDevice(t *testing.T) {
< 	tests := []struct {
< 		in      BootDevice
< 		out     error
< 		errPath path.ContextPath
< 	}{
< 		// empty config
< 		{
< 			BootDevice{},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// complete config
< 		{
< 			BootDevice{
< 				Layout: util.StrToPtr("x86_64"),
< 				Luks: BootDeviceLuks{
< 					Tang: []base.Tang{{
< 						URL:        "https://example.com/",
< 						Thumbprint: util.StrToPtr("x"),
< 					}},
< 					Threshold: util.IntToPtr(2),
< 					Tpm2:      util.BoolToPtr(true),
< 				},
< 				Mirror: BootDeviceMirror{
< 					Devices: []string{"/dev/vda", "/dev/vdb"},
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// invalid layout
< 		{
< 			BootDevice{
< 				Layout: util.StrToPtr("sparc"),
< 			},
< 			common.ErrUnknownBootDeviceLayout,
< 			path.New("yaml", "layout"),
< 		},
< 		// only one mirror device
< 		{
< 			BootDevice{
< 				Mirror: BootDeviceMirror{
< 					Devices: []string{"/dev/vda"},
< 				},
< 			},
< 			common.ErrTooFewMirrorDevices,
< 			path.New("yaml", "mirror", "devices"),
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnError(test.errPath, test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad validation report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/schema.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/schema.go
1,40d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_4_exp
< 
< import (
< 	base "github.com/coreos/fcct/base/v0_4_exp"
< )
< 
< type Config struct {
< 	base.Config `yaml:",inline"`
< 	BootDevice  BootDevice `yaml:"boot_device"`
< }
< 
< type BootDevice struct {
< 	Layout *string          `yaml:"layout"`
< 	Luks   BootDeviceLuks   `yaml:"luks"`
< 	Mirror BootDeviceMirror `yaml:"mirror"`
< }
< 
< type BootDeviceLuks struct {
< 	Tang      []base.Tang `yaml:"tang"`
< 	Threshold *int        `yaml:"threshold"`
< 	Tpm2      *bool       `yaml:"tpm2"`
< }
< 
< type BootDeviceMirror struct {
< 	Devices []string `yaml:"devices"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/translate.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/translate.go
1,254d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_4_exp
< 
< import (
< 	"fmt"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	"github.com/coreos/fcct/config/common"
< 	cutil "github.com/coreos/fcct/config/util"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_3_experimental/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< const (
< 	biosTypeGuid = "21686148-6449-6E6F-744E-656564454649"
< 	prepTypeGuid = "9E1A2D38-C612-4316-AA26-8B49521E5A8B"
< 	espTypeGuid  = "C12A7328-F81F-11D2-BA4B-00A0C93EC93B"
< 
< 	// The partition layout implemented in this file replicates
< 	// the layout of the OS image defined in:
< 	// https://github.com/coreos/coreos-assembler/blob/master/src/create_disk.sh
< 	//
< 	// Exception: we don't try to skip unused partition numbers,
< 	// because specifying a partition number would prevent child
< 	// configs from overriding partition fields using the partition
< 	// label as the lookup key.
< 	//
< 	// It's not critical that we match that layout exactly; the hard
< 	// constraints are:
< 	//   - The desugared partition cannot be smaller than the one it
< 	//     replicates
< 	//   - The new BIOS-BOOT partition (and maybe the PReP one?) must be
< 	//     at the same offset as the original
< 	//
< 	// Do not change these constants!  New partition layouts must be
< 	// encoded into new layout templates.
< 	biosV1SizeMiB = 1
< 	prepV1SizeMiB = 4
< 	espV1SizeMiB  = 127
< 	bootV1SizeMiB = 384
< )
< 
< // ToIgn3_3Unvalidated translates the config to an Ignition config.  It also
< // returns the set of translations it did so paths in the resultant config
< // can be tracked back to their source in the source config.  No config
< // validation is performed on input or output.
< func (c Config) ToIgn3_3Unvalidated(options common.TranslateOptions) (types.Config, translate.TranslationSet, report.Report) {
< 	ret, ts, r := c.Config.ToIgn3_3Unvalidated(options)
< 	r.Merge(c.processBootDevice(&ret, &ts, options))
< 	return ret, ts, r
< }
< 
< // ToIgn3_3 translates the config to an Ignition config.  It returns a
< // report of any errors or warnings in the source and resultant config.  If
< // the report has fatal errors or it encounters other problems translating,
< // an error is returned.
< func (c Config) ToIgn3_3(options common.TranslateOptions) (types.Config, report.Report, error) {
< 	cfg, r, err := cutil.Translate(c, "ToIgn3_3Unvalidated", options)
< 	return cfg.(types.Config), r, err
< }
< 
< // ToIgn3_3Bytes translates from a v1.4 fcc to a v3.3.0 Ignition config. It returns a report of any errors or
< // warnings in the source and resultant config. If the report has fatal errors or it encounters other problems
< // translating, an error is returned.
< func ToIgn3_3Bytes(input []byte, options common.TranslateBytesOptions) ([]byte, report.Report, error) {
< 	return cutil.TranslateBytes(input, &Config{}, "ToIgn3_3", options)
< }
< 
< func (c Config) processBootDevice(config *types.Config, ts *translate.TranslationSet, options common.TranslateOptions) report.Report {
< 	var rendered types.Config
< 	renderedTranslations := translate.NewTranslationSet("yaml", "json")
< 	var r report.Report
< 
< 	// check for high-level features
< 	wantLuks := (c.BootDevice.Luks.Tpm2 != nil && *c.BootDevice.Luks.Tpm2) || len(c.BootDevice.Luks.Tang) > 0
< 	wantMirror := len(c.BootDevice.Mirror.Devices) > 0
< 	if !wantLuks && !wantMirror {
< 		return r
< 	}
< 
< 	// compute layout rendering options
< 	var wantBIOSPart bool
< 	var wantPRePPart bool
< 	layout := c.BootDevice.Layout
< 	switch {
< 	case layout == nil || *layout == "x86_64":
< 		wantBIOSPart = true
< 	case *layout == "aarch64":
< 		// neither BIOS or PReP
< 	case *layout == "ppc64le":
< 		wantPRePPart = true
< 	default:
< 		// should have failed validation
< 		panic("unknown layout")
< 	}
< 
< 	// mirrored root disk
< 	if wantMirror {
< 		// partition disks
< 		for i, device := range c.BootDevice.Mirror.Devices {
< 			labelIndex := len(rendered.Storage.Disks) + 1
< 			disk := types.Disk{
< 				Device:    device,
< 				WipeTable: util.BoolToPtr(true),
< 			}
< 			if wantBIOSPart {
< 				disk.Partitions = append(disk.Partitions, types.Partition{
< 					Label:    util.StrToPtr(fmt.Sprintf("bios-%d", labelIndex)),
< 					SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 					TypeGUID: util.StrToPtr(biosTypeGuid),
< 				})
< 			}
< 			if wantPRePPart {
< 				disk.Partitions = append(disk.Partitions, types.Partition{
< 					Label:    util.StrToPtr(fmt.Sprintf("prep-%d", labelIndex)),
< 					SizeMiB:  util.IntToPtr(prepV1SizeMiB),
< 					TypeGUID: util.StrToPtr(prepTypeGuid),
< 				})
< 			}
< 			disk.Partitions = append(disk.Partitions, types.Partition{
< 				Label:    util.StrToPtr(fmt.Sprintf("esp-%d", labelIndex)),
< 				SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 				TypeGUID: util.StrToPtr(espTypeGuid),
< 			}, types.Partition{
< 				Label:   util.StrToPtr(fmt.Sprintf("boot-%d", labelIndex)),
< 				SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 			}, types.Partition{
< 				Label: util.StrToPtr(fmt.Sprintf("root-%d", labelIndex)),
< 			})
< 			renderedTranslations.AddFromCommonSource(path.New("yaml", "boot_device", "mirror", "devices", i), path.New("json", "storage", "disks", len(rendered.Storage.Disks)), disk)
< 			rendered.Storage.Disks = append(rendered.Storage.Disks, disk)
< 		}
< 
< 		// create RAIDs
< 		raidDevices := func(labelPrefix string) []types.Device {
< 			count := len(rendered.Storage.Disks)
< 			ret := make([]types.Device, count)
< 			for i := 0; i < count; i++ {
< 				ret[i] = types.Device(fmt.Sprintf("/dev/disk/by-partlabel/%s-%d", labelPrefix, i+1))
< 			}
< 			return ret
< 		}
< 		rendered.Storage.Raid = []types.Raid{{
< 			Devices: raidDevices("esp"),
< 			Level:   "raid1",
< 			Name:    "md-esp",
< 			// put the RAID superblock at the end of the
< 			// partition to avoid confusing UEFI
< 			Options: []types.RaidOption{"--metadata=1.0"},
< 		}, {
< 			Devices: raidDevices("boot"),
< 			Level:   "raid1",
< 			Name:    "md-boot",
< 			// put the RAID superblock at the end of the
< 			// partition so BIOS GRUB doesn't need to
< 			// understand RAID
< 			Options: []types.RaidOption{"--metadata=1.0"},
< 		}, {
< 			Devices: raidDevices("root"),
< 			Level:   "raid1",
< 			Name:    "md-root",
< 		}}
< 		renderedTranslations.AddFromCommonSource(path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid"), rendered.Storage.Raid)
< 
< 		// create filesystems, except for root
< 		rendered.Storage.Filesystems = []types.Filesystem{{
< 			Device:         "/dev/md/md-esp",
< 			Format:         util.StrToPtr("vfat"),
< 			Label:          util.StrToPtr("EFI-SYSTEM"),
< 			WipeFilesystem: util.BoolToPtr(true),
< 		}, {
< 			Device:         "/dev/md/md-boot",
< 			Format:         util.StrToPtr("ext4"),
< 			Label:          util.StrToPtr("boot"),
< 			WipeFilesystem: util.BoolToPtr(true),
< 		}}
< 		renderedTranslations.AddFromCommonSource(path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems"), rendered.Storage.Filesystems)
< 	}
< 
< 	// encrypted root partition
< 	if wantLuks {
< 		luksDevice := "/dev/disk/by-partlabel/root"
< 		if wantMirror {
< 			luksDevice = "/dev/md/md-root"
< 		}
< 		clevis, ts2, r2 := translateBootDeviceLuks(c.BootDevice.Luks, options)
< 		rendered.Storage.Luks = []types.Luks{{
< 			Clevis:     &clevis,
< 			Device:     &luksDevice,
< 			Label:      util.StrToPtr("luks-root"),
< 			Name:       "root",
< 			WipeVolume: util.BoolToPtr(true),
< 		}}
< 		lpath := path.New("yaml", "boot_device", "luks")
< 		rpath := path.New("json", "storage", "luks", 0)
< 		renderedTranslations.Merge(ts2.PrefixPaths(lpath, rpath.Append("clevis")))
< 		for _, f := range []string{"device", "label", "name", "wipeVolume"} {
< 			renderedTranslations.AddTranslation(lpath, rpath.Append(f))
< 		}
< 		r.Merge(r2)
< 	}
< 
< 	// create root filesystem
< 	var rootDevice string
< 	switch {
< 	case wantLuks:
< 		// LUKS, or LUKS on RAID
< 		rootDevice = "/dev/mapper/root"
< 	case wantMirror:
< 		// RAID without LUKS
< 		rootDevice = "/dev/md/md-root"
< 	default:
< 		panic("can't happen")
< 	}
< 	rootFilesystem := types.Filesystem{
< 		Device:         rootDevice,
< 		Format:         util.StrToPtr("xfs"),
< 		Label:          util.StrToPtr("root"),
< 		WipeFilesystem: util.BoolToPtr(true),
< 	}
< 	renderedTranslations.AddFromCommonSource(path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", len(rendered.Storage.Filesystems)), rootFilesystem)
< 	rendered.Storage.Filesystems = append(rendered.Storage.Filesystems, rootFilesystem)
< 
< 	// merge with translated config
< 	retConfig, retTranslations := baseutil.MergeTranslatedConfigs(rendered, renderedTranslations, *config, *ts)
< 	*config = retConfig.(types.Config)
< 	*ts = retTranslations
< 	return r
< }
< 
< func translateBootDeviceLuks(from BootDeviceLuks, options common.TranslateOptions) (to types.Clevis, tm translate.TranslationSet, r report.Report) {
< 	tr := translate.NewTranslator("yaml", "json", options)
< 	tm, r = translate.Prefixed(tr, "tang", &from.Tang, &to.Tang)
< 	translate.MergeP(tr, tm, &r, "threshold", &from.Threshold, &to.Threshold)
< 	translate.MergeP(tr, tm, &r, "tpm2", &from.Tpm2, &to.Tpm2)
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/translate_test.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/translate_test.go
1,1159d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_4_exp
< 
< import (
< 	"testing"
< 
< 	baseutil "github.com/coreos/fcct/base/util"
< 	base "github.com/coreos/fcct/base/v0_4_exp"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/ignition/v2/config/v3_3_experimental/types"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // Most of this is covered by the Ignition translator generic tests, so just test the custom bits
< 
< // TestTranslateBootDevice tests translating the FCC boot_device section.
< func TestTranslateBootDevice(t *testing.T) {
< 	tests := []struct {
< 		in         Config
< 		out        types.Config
< 		exceptions []translate.Translation
< 	}{
< 		// empty config
< 		{
< 			Config{},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 			},
< 			[]translate.Translation{},
< 		},
< 		// LUKS, x86_64
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/disk/by-partlabel/root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 			},
< 		},
< 		// 3-disk mirror, x86_64
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb", "/dev/vdc"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-1"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-1"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-2"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-2"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdc",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-3"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-3"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-3"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-3"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 								"/dev/disk/by-partlabel/esp-3",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 								"/dev/disk/by-partlabel/boot-3",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 								"/dev/disk/by-partlabel/root-3",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 		// 3-disk mirror + LUKS, x86_64
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb", "/dev/vdc"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-1"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-1"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-2"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-2"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdc",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-3"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-3"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-3"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-3"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 								"/dev/disk/by-partlabel/esp-3",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 								"/dev/disk/by-partlabel/boot-3",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 								"/dev/disk/by-partlabel/root-3",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/md/md-root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 2), path.New("json", "storage", "disks", 2, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 2)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 		// 2-disk mirror + LUKS, aarch64
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Layout: util.StrToPtr("aarch64"),
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-1"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-2"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/md/md-root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 		// 2-disk mirror + LUKS, ppc64le
< 		{
< 			Config{
< 				BootDevice: BootDevice{
< 					Layout: util.StrToPtr("ppc64le"),
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("prep-1"),
< 									SizeMiB:  util.IntToPtr(prepV1SizeMiB),
< 									TypeGUID: util.StrToPtr(prepTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-1"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("prep-2"),
< 									SizeMiB:  util.IntToPtr(prepV1SizeMiB),
< 									TypeGUID: util.StrToPtr(prepTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label: util.StrToPtr("root-2"),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/md/md-root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("xfs"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 3, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 		// 2-disk mirror + LUKS with overridden root partition size
< 		// and filesystem type, x86_64
< 		{
< 			Config{
< 				Config: base.Config{
< 					Storage: base.Storage{
< 						Disks: []base.Disk{
< 							{
< 								Device: "/dev/vda",
< 								Partitions: []base.Partition{
< 									{
< 										Label:   util.StrToPtr("root-1"),
< 										SizeMiB: util.IntToPtr(8192),
< 									},
< 								},
< 							},
< 							{
< 								Device: "/dev/vdb",
< 								Partitions: []base.Partition{
< 									{
< 										Label:   util.StrToPtr("root-2"),
< 										SizeMiB: util.IntToPtr(8192),
< 									},
< 								},
< 							},
< 						},
< 						Filesystems: []base.Filesystem{
< 							{
< 								Device: "/dev/mapper/root",
< 								Format: util.StrToPtr("ext4"),
< 							},
< 						},
< 					},
< 				},
< 				BootDevice: BootDevice{
< 					Luks: BootDeviceLuks{
< 						Tang: []base.Tang{{
< 							URL:        "https://example.com/",
< 							Thumbprint: util.StrToPtr("z"),
< 						}},
< 						Threshold: util.IntToPtr(2),
< 						Tpm2:      util.BoolToPtr(true),
< 					},
< 					Mirror: BootDeviceMirror{
< 						Devices: []string{"/dev/vda", "/dev/vdb"},
< 					},
< 				},
< 			},
< 			types.Config{
< 				Ignition: types.Ignition{
< 					Version: "3.3.0-experimental",
< 				},
< 				Storage: types.Storage{
< 					Disks: []types.Disk{
< 						{
< 							Device: "/dev/vda",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-1"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-1"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-1"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label:   util.StrToPtr("root-1"),
< 									SizeMiB: util.IntToPtr(8192),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 						{
< 							Device: "/dev/vdb",
< 							Partitions: []types.Partition{
< 								{
< 									Label:    util.StrToPtr("bios-2"),
< 									SizeMiB:  util.IntToPtr(biosV1SizeMiB),
< 									TypeGUID: util.StrToPtr(biosTypeGuid),
< 								},
< 								{
< 									Label:    util.StrToPtr("esp-2"),
< 									SizeMiB:  util.IntToPtr(espV1SizeMiB),
< 									TypeGUID: util.StrToPtr(espTypeGuid),
< 								},
< 								{
< 									Label:   util.StrToPtr("boot-2"),
< 									SizeMiB: util.IntToPtr(bootV1SizeMiB),
< 								},
< 								{
< 									Label:   util.StrToPtr("root-2"),
< 									SizeMiB: util.IntToPtr(8192),
< 								},
< 							},
< 							WipeTable: util.BoolToPtr(true),
< 						},
< 					},
< 					Raid: []types.Raid{
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/esp-1",
< 								"/dev/disk/by-partlabel/esp-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-esp",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/boot-1",
< 								"/dev/disk/by-partlabel/boot-2",
< 							},
< 							Level:   "raid1",
< 							Name:    "md-boot",
< 							Options: []types.RaidOption{"--metadata=1.0"},
< 						},
< 						{
< 							Devices: []types.Device{
< 								"/dev/disk/by-partlabel/root-1",
< 								"/dev/disk/by-partlabel/root-2",
< 							},
< 							Level: "raid1",
< 							Name:  "md-root",
< 						},
< 					},
< 					Luks: []types.Luks{
< 						{
< 							Clevis: &types.Clevis{
< 								Tang: []types.Tang{{
< 									URL:        "https://example.com/",
< 									Thumbprint: util.StrToPtr("z"),
< 								}},
< 								Threshold: util.IntToPtr(2),
< 								Tpm2:      util.BoolToPtr(true),
< 							},
< 							Device:     util.StrToPtr("/dev/md/md-root"),
< 							Label:      util.StrToPtr("luks-root"),
< 							Name:       "root",
< 							WipeVolume: util.BoolToPtr(true),
< 						},
< 					},
< 					Filesystems: []types.Filesystem{
< 						{
< 							Device:         "/dev/md/md-esp",
< 							Format:         util.StrToPtr("vfat"),
< 							Label:          util.StrToPtr("EFI-SYSTEM"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/md/md-boot",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("boot"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						}, {
< 							Device:         "/dev/mapper/root",
< 							Format:         util.StrToPtr("ext4"),
< 							Label:          util.StrToPtr("root"),
< 							WipeFilesystem: util.BoolToPtr(true),
< 						},
< 					},
< 				},
< 			},
< 			[]translate.Translation{
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "storage", "disks", 0, "partitions", 0, "label"), path.New("json", "storage", "disks", 0, "partitions", 3, "label")},
< 				{path.New("yaml", "storage", "disks", 0, "partitions", 0, "size_mib"), path.New("json", "storage", "disks", 0, "partitions", 3, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 0), path.New("json", "storage", "disks", 0, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 0, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 1, "typeGuid")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "label")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "partitions", 2, "sizeMiB")},
< 				{path.New("yaml", "storage", "disks", 1, "partitions", 0, "label"), path.New("json", "storage", "disks", 1, "partitions", 3, "label")},
< 				{path.New("yaml", "storage", "disks", 1, "partitions", 0, "size_mib"), path.New("json", "storage", "disks", 1, "partitions", 3, "sizeMiB")},
< 				{path.New("yaml", "boot_device", "mirror", "devices", 1), path.New("json", "storage", "disks", 1, "wipeTable")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 0, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "name")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 1, "options", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 0)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "devices", 1)},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "level")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "raid", 2, "name")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "url"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "url")},
< 				{path.New("yaml", "boot_device", "luks", "tang", 0, "thumbprint"), path.New("json", "storage", "luks", 0, "clevis", "tang", 0, "thumbprint")},
< 				{path.New("yaml", "boot_device", "luks", "threshold"), path.New("json", "storage", "luks", 0, "clevis", "threshold")},
< 				{path.New("yaml", "boot_device", "luks", "tpm2"), path.New("json", "storage", "luks", 0, "clevis", "tpm2")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "device")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "label")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "name")},
< 				{path.New("yaml", "boot_device", "luks"), path.New("json", "storage", "luks", 0, "wipeVolume")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 0, "wipeFilesystem")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "device")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "format")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "label")},
< 				{path.New("yaml", "boot_device", "mirror"), path.New("json", "storage", "filesystems", 1, "wipeFilesystem")},
< 				{path.New("yaml", "storage", "filesystems", 0, "device"), path.New("json", "storage", "filesystems", 2, "device")},
< 				{path.New("yaml", "storage", "filesystems", 0, "format"), path.New("json", "storage", "filesystems", 2, "format")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "label")},
< 				{path.New("yaml", "boot_device"), path.New("json", "storage", "filesystems", 2, "wipeFilesystem")},
< 			},
< 		},
< 	}
< 
< 	// The partition sizes of existing layouts must never change, but
< 	// we use the constants in tests for clarity.  Ensure no one has
< 	// changed them.
< 	assert.Equal(t, biosV1SizeMiB, 1)
< 	assert.Equal(t, prepV1SizeMiB, 4)
< 	assert.Equal(t, espV1SizeMiB, 127)
< 	assert.Equal(t, bootV1SizeMiB, 384)
< 
< 	for i, test := range tests {
< 		actual, translations, r := test.in.ToIgn3_3Unvalidated(common.TranslateOptions{})
< 		assert.Equal(t, test.out, actual, "#%d: translation mismatch", i)
< 		assert.Equal(t, report.Report{}, r, "#%d: non-empty report", i)
< 		baseutil.VerifyTranslations(t, translations, test.exceptions, "#%d", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/validate.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/validate.go
1,41d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_4_exp
< 
< import (
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d BootDevice) Validate(c path.ContextPath) (r report.Report) {
< 	if d.Layout != nil {
< 		switch *d.Layout {
< 		case "aarch64", "ppc64le", "x86_64":
< 		default:
< 			r.AddOnError(c.Append("layout"), common.ErrUnknownBootDeviceLayout)
< 		}
< 	}
< 	r.Merge(d.Mirror.Validate(c.Append("mirror")))
< 	return
< }
< 
< func (m BootDeviceMirror) Validate(c path.ContextPath) (r report.Report) {
< 	if len(m.Devices) == 1 {
< 		r.AddOnError(c.Append("devices"), common.ErrTooFewMirrorDevices)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/validate_test.go updated/vendor/github.com/coreos/fcct/config/fcos/v1_4_exp/validate_test.go
1,87d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v1_4_exp
< 
< import (
< 	"testing"
< 
< 	base "github.com/coreos/fcct/base/v0_4_exp"
< 	"github.com/coreos/fcct/config/common"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< // TestValidateBootDevice tests boot device validation
< func TestValidateBootDevice(t *testing.T) {
< 	tests := []struct {
< 		in      BootDevice
< 		out     error
< 		errPath path.ContextPath
< 	}{
< 		// empty config
< 		{
< 			BootDevice{},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// complete config
< 		{
< 			BootDevice{
< 				Layout: util.StrToPtr("x86_64"),
< 				Luks: BootDeviceLuks{
< 					Tang: []base.Tang{{
< 						URL:        "https://example.com/",
< 						Thumbprint: util.StrToPtr("x"),
< 					}},
< 					Threshold: util.IntToPtr(2),
< 					Tpm2:      util.BoolToPtr(true),
< 				},
< 				Mirror: BootDeviceMirror{
< 					Devices: []string{"/dev/vda", "/dev/vdb"},
< 				},
< 			},
< 			nil,
< 			path.New("yaml"),
< 		},
< 		// invalid layout
< 		{
< 			BootDevice{
< 				Layout: util.StrToPtr("sparc"),
< 			},
< 			common.ErrUnknownBootDeviceLayout,
< 			path.New("yaml", "layout"),
< 		},
< 		// only one mirror device
< 		{
< 			BootDevice{
< 				Mirror: BootDeviceMirror{
< 					Devices: []string{"/dev/vda"},
< 				},
< 			},
< 			common.ErrTooFewMirrorDevices,
< 			path.New("yaml", "mirror", "devices"),
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		actual := test.in.Validate(path.New("yaml"))
< 		expected := report.Report{}
< 		expected.AddOnError(test.errPath, test.out)
< 		assert.Equal(t, expected, actual, "#%d: bad validation report", i)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/rhcos/v0_1/schema.go updated/vendor/github.com/coreos/fcct/config/rhcos/v0_1/schema.go
1,23d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_1
< 
< import (
< 	fcos "github.com/coreos/fcct/config/fcos/v1_3"
< )
< 
< type Config struct {
< 	fcos.Config `yaml:",inline"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/rhcos/v0_1/translate.go updated/vendor/github.com/coreos/fcct/config/rhcos/v0_1/translate.go
1,39d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_1
< 
< import (
< 	"github.com/coreos/fcct/config/common"
< 	cutil "github.com/coreos/fcct/config/util"
< 
< 	"github.com/coreos/ignition/v2/config/v3_2/types"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // ToIgn3_2 translates the config to an Ignition config.  It returns a
< // report of any errors or warnings in the source and resultant config.  If
< // the report has fatal errors or it encounters other problems translating,
< // an error is returned.
< func (c Config) ToIgn3_2(options common.TranslateOptions) (types.Config, report.Report, error) {
< 	cfg, r, err := cutil.Translate(c, "ToIgn3_2Unvalidated", options)
< 	return cfg.(types.Config), r, err
< }
< 
< // ToIgn3_2Bytes translates from a v0.1 rcc to a v3.2.0 Ignition config. It returns a report of any errors or
< // warnings in the source and resultant config. If the report has fatal errors or it encounters other problems
< // translating, an error is returned.
< func ToIgn3_2Bytes(input []byte, options common.TranslateBytesOptions) ([]byte, report.Report, error) {
< 	return cutil.TranslateBytes(input, &Config{}, "ToIgn3_2", options)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/rhcos/v0_2_exp/schema.go updated/vendor/github.com/coreos/fcct/config/rhcos/v0_2_exp/schema.go
1,23d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_2_exp
< 
< import (
< 	fcos "github.com/coreos/fcct/config/fcos/v1_4_exp"
< )
< 
< type Config struct {
< 	fcos.Config `yaml:",inline"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/rhcos/v0_2_exp/translate.go updated/vendor/github.com/coreos/fcct/config/rhcos/v0_2_exp/translate.go
1,39d0
< // Copyright 2020 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package v0_2_exp
< 
< import (
< 	"github.com/coreos/fcct/config/common"
< 	cutil "github.com/coreos/fcct/config/util"
< 
< 	"github.com/coreos/ignition/v2/config/v3_3_experimental/types"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // ToIgn3_3 translates the config to an Ignition config.  It returns a
< // report of any errors or warnings in the source and resultant config.  If
< // the report has fatal errors or it encounters other problems translating,
< // an error is returned.
< func (c Config) ToIgn3_3(options common.TranslateOptions) (types.Config, report.Report, error) {
< 	cfg, r, err := cutil.Translate(c, "ToIgn3_3Unvalidated", options)
< 	return cfg.(types.Config), r, err
< }
< 
< // ToIgn3_3Bytes translates from a v0.2 rcc to a v3.3.0 Ignition config. It returns a report of any errors or
< // warnings in the source and resultant config. If the report has fatal errors or it encounters other problems
< // translating, an error is returned.
< func ToIgn3_3Bytes(input []byte, options common.TranslateBytesOptions) ([]byte, report.Report, error) {
< 	return cutil.TranslateBytes(input, &Config{}, "ToIgn3_3", options)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/util/util.go updated/vendor/github.com/coreos/fcct/config/util/util.go
1,177d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package util
< 
< import (
< 	"bytes"
< 	"reflect"
< 	"regexp"
< 	"strings"
< 
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/translate"
< 
< 	"github.com/clarketm/json"
< 	ignvalidate "github.com/coreos/ignition/v2/config/validate"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/coreos/vcontext/tree"
< 	"github.com/coreos/vcontext/validate"
< 	vyaml "github.com/coreos/vcontext/yaml"
< 	"gopkg.in/yaml.v3"
< )
< 
< var (
< 	snakeRe = regexp.MustCompile("([A-Z])")
< )
< 
< // Misc helpers
< 
< // Translate translates cfg to the corresponding Ignition config version
< // using the named translation method on cfg, and returns the marshaled
< // Ignition config.  It returns a report of any errors or warnings in the
< // source and resultant config.  If the report has fatal errors or it
< // encounters other problems translating, an error is returned.
< func Translate(cfg interface{}, translateMethod string, options common.TranslateOptions) (interface{}, report.Report, error) {
< 	// Get method, and zero return value for error returns.
< 	method := reflect.ValueOf(cfg).MethodByName(translateMethod)
< 	zeroValue := reflect.Zero(method.Type().Out(0)).Interface()
< 
< 	// Validate the input.
< 	r := validate.Validate(cfg, "yaml")
< 	if r.IsFatal() {
< 		return zeroValue, r, common.ErrInvalidSourceConfig
< 	}
< 
< 	// Perform the translation.
< 	translateRet := method.Call([]reflect.Value{reflect.ValueOf(options)})
< 	final := translateRet[0].Interface()
< 	translations := translateRet[1].Interface().(translate.TranslationSet)
< 	translateReport := translateRet[2].Interface().(report.Report)
< 	r.Merge(translateReport)
< 	if r.IsFatal() {
< 		return zeroValue, r, common.ErrInvalidSourceConfig
< 	}
< 
< 	// Check for invalid duplicated keys.
< 	dupsReport := validate.ValidateCustom(final, "json", ignvalidate.ValidateDups)
< 	translateReportPaths(&dupsReport, translations)
< 	r.Merge(dupsReport)
< 
< 	// Validate JSON semantics.
< 	jsonReport := validate.Validate(final, "json")
< 	translateReportPaths(&jsonReport, translations)
< 	r.Merge(jsonReport)
< 
< 	if r.IsFatal() {
< 		return zeroValue, r, common.ErrInvalidGeneratedConfig
< 	}
< 	return final, r, nil
< }
< 
< // TranslateBytes unmarshals the FCC specified in input into the struct
< // pointed to by container, translates it to the corresponding Ignition
< // config version using the named translation method, and returns the
< // marshaled Ignition config.  It returns a report of any errors or warnings
< // in the source and resultant config.  If the report has fatal errors or it
< // encounters other problems translating, an error is returned.
< func TranslateBytes(input []byte, container interface{}, translateMethod string, options common.TranslateBytesOptions) ([]byte, report.Report, error) {
< 	cfg := container
< 
< 	// Unmarshal the YAML.
< 	contextTree, err := unmarshal(input, cfg, options.Strict)
< 	if err != nil {
< 		return nil, report.Report{}, err
< 	}
< 
< 	// Check for unused keys.
< 	unusedKeyCheck := func(v reflect.Value, c path.ContextPath) report.Report {
< 		return ignvalidate.ValidateUnusedKeys(v, c, contextTree)
< 	}
< 	r := validate.ValidateCustom(cfg, "yaml", unusedKeyCheck)
< 	r.Correlate(contextTree)
< 	if r.IsFatal() {
< 		return nil, r, common.ErrInvalidSourceConfig
< 	}
< 
< 	// Perform the translation.
< 	translateRet := reflect.ValueOf(cfg).MethodByName(translateMethod).Call([]reflect.Value{reflect.ValueOf(options.TranslateOptions)})
< 	final := translateRet[0].Interface()
< 	translateReport := translateRet[1].Interface().(report.Report)
< 	errVal := translateRet[2]
< 	translateReport.Correlate(contextTree)
< 	r.Merge(translateReport)
< 	if !errVal.IsNil() {
< 		return nil, r, errVal.Interface().(error)
< 	}
< 	if r.IsFatal() {
< 		return nil, r, common.ErrInvalidSourceConfig
< 	}
< 
< 	// Marshal the JSON.
< 	outbytes, err := marshal(final, options.Pretty)
< 	return outbytes, r, err
< }
< 
< // unmarshal unmarshals the data to "to" and also returns a context tree for the source. If strict
< // is set it errors out on unused keys.
< func unmarshal(data []byte, to interface{}, strict bool) (tree.Node, error) {
< 	dec := yaml.NewDecoder(bytes.NewReader(data))
< 	dec.KnownFields(strict)
< 	if err := dec.Decode(to); err != nil {
< 		return nil, err
< 	}
< 	return vyaml.UnmarshalToContext(data)
< }
< 
< // marshal is a wrapper for marshaling to json with or without pretty-printing the output
< func marshal(from interface{}, pretty bool) ([]byte, error) {
< 	if pretty {
< 		return json.MarshalIndent(from, "", "  ")
< 	}
< 	return json.Marshal(from)
< }
< 
< // snakePath converts a path.ContextPath with camelCase elements and returns the
< // same path but with snake_case elements instead
< func snakePath(p path.ContextPath) path.ContextPath {
< 	ret := path.New(p.Tag)
< 	for _, part := range p.Path {
< 		if str, ok := part.(string); ok {
< 			ret = ret.Append(snake(str))
< 		} else {
< 			ret = ret.Append(part)
< 		}
< 	}
< 	return ret
< }
< 
< // snake converts from camelCase (not CamelCase) to snake_case
< func snake(in string) string {
< 	return strings.ToLower(snakeRe.ReplaceAllString(in, "_$1"))
< }
< 
< // translateReportPaths takes a report from a camelCase json document and a set of translations rules,
< // applies those rules and converts all camelCase to snake_case.
< func translateReportPaths(r *report.Report, ts translate.TranslationSet) {
< 	for i, ent := range r.Entries {
< 		context := ent.Context
< 		if t, ok := ts.Set[context.String()]; ok {
< 			context = t.From
< 		}
< 		context = snakePath(context)
< 		r.Entries[i].Context = context
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/config/util/util_test.go updated/vendor/github.com/coreos/fcct/config/util/util_test.go
1,50d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package util
< 
< import (
< 	"testing"
< )
< 
< func TestSnake(t *testing.T) {
< 	tests := []struct {
< 		in  string
< 		out string
< 	}{
< 		{},
< 		{
< 			"foo",
< 			"foo",
< 		},
< 		{
< 			"snakeCase",
< 			"snake_case",
< 		},
< 		{
< 			"longSnakeCase",
< 			"long_snake_case",
< 		},
< 		{
< 			"snake_already",
< 			"snake_already",
< 		},
< 	}
< 
< 	for i, test := range tests {
< 		if snake(test.in) != test.out {
< 			t.Errorf("#%d: expected %q got %q", i, test.out, snake(test.in))
< 		}
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/_config.yml updated/vendor/github.com/coreos/fcct/docs/_config.yml
1,39d0
< title: coreos/fcct
< description: Fedora CoreOS Config Transpiler documentation
< baseurl: "/fcct"
< url: "https://coreos.github.io"
< # Comment above and use below for local development
< # url: "http://localhost:4000"
< permalink: /:title/
< 
< remote_theme: coreos/just-the-docs
< plugins:
<   - jekyll-remote-theme
< 
< color_scheme: coreos
< 
< # Aux links for the upper right navigation
< aux_links:
<   "FCCT on GitHub":
<     - "https://github.com/coreos/fcct"
< 
< footer_content: "Copyright &copy; <a href=\"https://www.redhat.com\">Red Hat, Inc.</a> and <a href=\"https://github.com/coreos\">others</a>."
< 
< # Footer last edited timestamp
< last_edit_timestamp: true
< last_edit_time_format: "%b %e %Y at %I:%M %p"
< 
< # Footer "Edit this page on GitHub" link text
< gh_edit_link: true
< gh_edit_link_text: "Edit this page on GitHub"
< gh_edit_repository: "https://github.com/coreos/fcct"
< gh_edit_branch: "master"
< gh_edit_view_mode: "tree"
< 
< compress_html:
<   clippings: all
<   comments: all
<   endings: all
<   startings: []
<   blanklines: false
<   profile: false
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/_sass/color_schemes/coreos.scss updated/vendor/github.com/coreos/fcct/docs/_sass/color_schemes/coreos.scss
1d0
< $link-color: #53a3da;
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/config-fcos-v1_0.md updated/vendor/github.com/coreos/fcct/docs/config-fcos-v1_0.md
1,134d0
< ---
< layout: default
< title: Fedora CoreOS v1.0.0
< parent: Configuration specifications
< nav_order: 49
< ---
< 
< # Fedora CoreOS Specification v1.0.0
< 
< The Fedora CoreOS configuration is a YAML document conforming to the following specification, with **_italicized_** entries being optional:
< 
< * **variant** (string): used to differentiate configs for different operating systems. Must be `fcos` for this specification.
< * **version** (string): the semantic version of the spec for this document. This document is for version `1.0.0` and generates Ignition configs with version `3.0.0`.
< * **ignition** (object): metadata about the configuration itself.
<   * **_config_** (objects): options related to the configuration.
<     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
<       * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is `sha512`.
<     * **_replace_** (object): the config that will replace the current.
<       * **source** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is `sha512`.
<   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
<     * **_http_response_headers_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
<     * **_http_total_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
<   * **_security_** (object): options relating to network security.
<     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
<       * **_certificate_authorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`.
<         * **source** (string): the URL of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified.
<         * **_verification_** (object): options related to the verification of the certificate.
<           * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is sha512.
< * **_storage_** (object): describes the desired state of the system's storage devices.
<   * **_disks_** (list of objects): the list of disks to be configured and their options. Every entry must have a unique `device`.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_wipe_table_** (boolean): whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact.
<     * **_partitions_** (list of objects): the list of partitions and their configuration for this particular disk. Every partition must have a unique `number`, or if 0 is specified, a unique `label`.
<       * **_label_** (string): the PARTLABEL for the partition.
<       * **_number_** (integer): the partition number, which dictates it's position in the partition table (one-indexed). If zero, use the next available partition slot.
<       * **_size_mib_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
<       * **_start_mib_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
<       * **_type_guid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
<       * **_guid_** (string): the GPT unique partition GUID.
<       * **_wipe_partition_entry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
<       * **_should_exist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
<   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
<     * **name** (string): the name to use for the resulting md device.
<     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
<     * **devices** (list of strings): the list of devices (referenced by their absolute path) in the array.
<     * **_spares_** (integer): the number of spares (if applicable) in the array.
<     * **_options_** (list of strings): any additional options to be passed to mdadm.
<   * **_filesystems_** (list of objects): the list of filesystems to be configured. `path`, `device`, and `format` all need to be specified. Every filesystem must have a unique `device`.
<     * **path** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
<     * **_wipe_filesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_label_** (string): the label of the filesystem.
<     * **_uuid_** (string): the uuid of the filesystem.
<     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
<   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
<     * **path** (string): the absolute path to the file.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
<     * **_contents_** (object): options related to the contents of the file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created. Mutually exclusive with `inline`.
<       * **_inline_** (string): the contents of the file. Mutually exclusive with `source`.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is `sha512`.
<     * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline`.
<       * **_inline_** (string): the contents to append. Mutually exclusive with `source`.
<       * **_verification_** (object): options related to the verification of the appended contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is `sha512`.
<     * **_mode_** (integer): the file's permission mode. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
<     * **_user_** (object): specifies the file's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the directory.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
<     * **_mode_** (integer): the directory's permission mode. If not specified, the permission mode for directories defaults to 0755 or the mode of an existing directory if `overwrite` is false and a directory already exists at the path.
<     * **_user_** (object): specifies the directory's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the link
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
<     * **_user_** (object): specifies the symbolic link's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<     * **target** (string): the target path of the link
<     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
< * **_systemd_** (object): describes the desired state of the systemd units.
<   * **_units_** (list of objects): the list of systemd units.
<     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service"). Every unit must have a unique `name`.
<     * **_enabled_** (boolean): whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section.
<     * **_mask_** (boolean): whether or not the service shall be masked. When true, the service is masked by symlinking it to `/dev/null`.
<     * **_contents_** (string): the contents of the unit.
<     * **_dropins_** (list of objects): the list of drop-ins for the unit. Every drop-in must have a unique `name`.
<       * **name** (string): the name of the drop-in. This must be suffixed with ".conf".
<       * **_contents_** (string): the contents of the drop-in.
< * **_passwd_** (object): describes the desired additions to the passwd database.
<   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
<     * **name** (string): the username for the account.
<     * **_password_hash_** (string): the hashed password for the account.
<     * **_ssh_authorized_keys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
<     * **_uid_** (integer): the user ID of the account.
<     * **_gecos_** (string): the GECOS field of the account.
<     * **_home_dir_** (string): the home directory of the account.
<     * **_no_create_home_** (boolean): whether or not to create the user's home directory. This only has an effect if the account doesn't exist yet.
<     * **_primary_group_** (string): the name of the primary group of the account.
<     * **_groups_** (list of strings): the list of supplementary groups of the account.
<     * **_no_user_group_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
<     * **_no_log_init_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
<     * **_shell_** (string): the login shell of the new account.
<     * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
<   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
<     * **name** (string): the name of the group.
<     * **_gid_** (integer): the group ID of the new group.
<     * **_password_hash_** (string): the hashed password of the new group.
<     * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
< 
< [part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
< [rfc2397]: https://tools.ietf.org/html/rfc2397
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/config-fcos-v1_1.md updated/vendor/github.com/coreos/fcct/docs/config-fcos-v1_1.md
1,167d0
< ---
< layout: default
< title: Fedora CoreOS v1.1.0
< parent: Configuration specifications
< nav_order: 48
< ---
< 
< # Fedora CoreOS Specification v1.1.0
< 
< The Fedora CoreOS configuration is a YAML document conforming to the following specification, with **_italicized_** entries being optional:
< 
< * **variant** (string): used to differentiate configs for different operating systems. Must be `fcos` for this specification.
< * **version** (string): the semantic version of the spec for this document. This document is for version `1.1.0` and generates Ignition configs with version `3.1.0`.
< * **ignition** (object): metadata about the configuration itself.
<   * **_config_** (objects): options related to the configuration.
<     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_replace_** (object): the config that will replace the current.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
<     * **_http_response_headers_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
<     * **_http_total_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
<   * **_security_** (object): options relating to network security.
<     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
<       * **_certificate_authorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`, `inline`, or `local`.
<         * **_source_** (string): the URL of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<         * **_inline_** (string): the contents of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `local`.
<         * **_local_** (string): a local path to the contents of the certificate bundle (in PEM format), relative to the directory specified by the `--files-dir` command-line argument. With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `inline`.
<         * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<           * **name** (string): the header name.
<           * **_value_** (string): the header contents.
<         * **_verification_** (object): options related to the verification of the certificate.
<           * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
<     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
<     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
<     * **_noProxy_** (list of strings): specifies a list of strings to hosts that should be excluded from proxying. Each value is represented by an `IP address prefix (1.2.3.4)`, `an IP address prefix in CIDR notation (1.2.3.4/8)`, `a domain name`, or `a special DNS label (*)`. An IP address prefix and domain name can also include a literal port number `(1.2.3.4:80)`. A domain name matches that name and all subdomains. A domain name with a leading `.` matches subdomains only. For example `foo.com` matches `foo.com` and `bar.foo.com`; `.y.com` matches `x.y.com` but not `y.com`. A single asterisk `(*)` indicates that no proxying should be done.
< * **_storage_** (object): describes the desired state of the system's storage devices.
<   * **_disks_** (list of objects): the list of disks to be configured and their options. Every entry must have a unique `device`.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_wipe_table_** (boolean): whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact.
<     * **_partitions_** (list of objects): the list of partitions and their configuration for this particular disk. Every partition must have a unique `number`, or if 0 is specified, a unique `label`.
<       * **_label_** (string): the PARTLABEL for the partition.
<       * **_number_** (integer): the partition number, which dictates it's position in the partition table (one-indexed). If zero, use the next available partition slot.
<       * **_size_mib_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
<       * **_start_mib_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
<       * **_type_guid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
<       * **_guid_** (string): the GPT unique partition GUID.
<       * **_wipe_partition_entry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
<       * **_should_exist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
<   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
<     * **name** (string): the name to use for the resulting md device.
<     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
<     * **devices** (list of strings): the list of devices (referenced by their absolute path) in the array.
<     * **_spares_** (integer): the number of spares (if applicable) in the array.
<     * **_options_** (list of strings): any additional options to be passed to mdadm.
<   * **_filesystems_** (list of objects): the list of filesystems to be configured. `path`, `device`, and `format` all need to be specified. Every filesystem must have a unique `device`.
<     * **path** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
<     * **_wipe_filesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_label_** (string): the label of the filesystem.
<     * **_uuid_** (string): the uuid of the filesystem.
<     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
<     * **_mount_options_** (list of strings): any special options to be passed to the mount command.
<     * **_with_mount_unit_** (bool): Whether to generate a generic mount unit for this filesystem as well. If a more specific unit is needed, a custom one can be specified in the `systemd.units` section. The unit will be named with the [escaped][systemd-escape] version of the `path`.
<   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
<     * **path** (string): the absolute path to the file.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
<     * **_contents_** (object): options related to the contents of the file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents to append. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents to append, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the appended contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_mode_** (integer): the file's permission mode. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
<     * **_user_** (object): specifies the file's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the directory.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
<     * **_mode_** (integer): the directory's permission mode. If not specified, the permission mode for directories defaults to 0755 or the mode of an existing directory if `overwrite` is false and a directory already exists at the path.
<     * **_user_** (object): specifies the directory's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the link
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
<     * **_user_** (object): specifies the symbolic link's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<     * **target** (string): the target path of the link
<     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
<   * **_trees_** (list of objects): a list of local directory trees to be embedded in the config. Ownership is not preserved. File modes are set to 0755 if the local file is executable or 0644 otherwise. Attributes of files, directories, and symlinks can be overridden by creating a corresponding entry in the `files`, `directories`, or `links` section; such `files` entries must omit `contents` and such `links` entries must omit `target`.
<     * **local** (string): the base of the local directory tree, relative to the directory specified by the `--files-dir` command-line argument.
<     * **_path_** (string): the path of the tree within the target system. Defaults to `/`.
< * **_systemd_** (object): describes the desired state of the systemd units.
<   * **_units_** (list of objects): the list of systemd units.
<     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service"). Every unit must have a unique `name`.
<     * **_enabled_** (boolean): whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section.
<     * **_mask_** (boolean): whether or not the service shall be masked. When true, the service is masked by symlinking it to `/dev/null`.
<     * **_contents_** (string): the contents of the unit.
<     * **_dropins_** (list of objects): the list of drop-ins for the unit. Every drop-in must have a unique `name`.
<       * **name** (string): the name of the drop-in. This must be suffixed with ".conf".
<       * **_contents_** (string): the contents of the drop-in.
< * **_passwd_** (object): describes the desired additions to the passwd database.
<   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
<     * **name** (string): the username for the account.
<     * **_password_hash_** (string): the hashed password for the account.
<     * **_ssh_authorized_keys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
<     * **_uid_** (integer): the user ID of the account.
<     * **_gecos_** (string): the GECOS field of the account.
<     * **_home_dir_** (string): the home directory of the account.
<     * **_no_create_home_** (boolean): whether or not to create the user's home directory. This only has an effect if the account doesn't exist yet.
<     * **_primary_group_** (string): the name of the primary group of the account.
<     * **_groups_** (list of strings): the list of supplementary groups of the account.
<     * **_no_user_group_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
<     * **_no_log_init_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
<     * **_shell_** (string): the login shell of the new account.
<     * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
<   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
<     * **name** (string): the name of the group.
<     * **_gid_** (integer): the group ID of the new group.
<     * **_password_hash_** (string): the hashed password of the new group.
<     * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
< 
< [part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
< [rfc2397]: https://tools.ietf.org/html/rfc2397
< [systemd-escape]: https://www.freedesktop.org/software/systemd/man/systemd-escape.html
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/config-fcos-v1_2.md updated/vendor/github.com/coreos/fcct/docs/config-fcos-v1_2.md
1,194d0
< ---
< layout: default
< title: Fedora CoreOS v1.2.0
< parent: Configuration specifications
< nav_order: 47
< ---
< 
< # Fedora CoreOS Specification v1.2.0
< 
< The Fedora CoreOS configuration is a YAML document conforming to the following specification, with **_italicized_** entries being optional:
< 
< * **variant** (string): used to differentiate configs for different operating systems. Must be `fcos` for this specification.
< * **version** (string): the semantic version of the spec for this document. This document is for version `1.2.0` and generates Ignition configs with version `3.2.0`.
< * **ignition** (object): metadata about the configuration itself.
<   * **_config_** (objects): options related to the configuration.
<     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_replace_** (object): the config that will replace the current.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
<     * **_http_response_headers_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
<     * **_http_total_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
<   * **_security_** (object): options relating to network security.
<     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
<       * **_certificate_authorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`, `inline`, or `local`.
<         * **_source_** (string): the URL of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<         * **_inline_** (string): the contents of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `local`.
<         * **_local_** (string): a local path to the contents of the certificate bundle (in PEM format), relative to the directory specified by the `--files-dir` command-line argument. With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `inline`.
<         * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<           * **name** (string): the header name.
<           * **_value_** (string): the header contents.
<         * **_verification_** (object): options related to the verification of the certificate.
<           * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
<     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
<     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
<     * **_noProxy_** (list of strings): specifies a list of strings to hosts that should be excluded from proxying. Each value is represented by an `IP address prefix (1.2.3.4)`, `an IP address prefix in CIDR notation (1.2.3.4/8)`, `a domain name`, or `a special DNS label (*)`. An IP address prefix and domain name can also include a literal port number `(1.2.3.4:80)`. A domain name matches that name and all subdomains. A domain name with a leading `.` matches subdomains only. For example `foo.com` matches `foo.com` and `bar.foo.com`; `.y.com` matches `x.y.com` but not `y.com`. A single asterisk `(*)` indicates that no proxying should be done.
< * **_storage_** (object): describes the desired state of the system's storage devices.
<   * **_disks_** (list of objects): the list of disks to be configured and their options. Every entry must have a unique `device`.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_wipe_table_** (boolean): whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact.
<     * **_partitions_** (list of objects): the list of partitions and their configuration for this particular disk. Every partition must have a unique `number`, or if 0 is specified, a unique `label`.
<       * **_label_** (string): the PARTLABEL for the partition.
<       * **_number_** (integer): the partition number, which dictates it's position in the partition table (one-indexed). If zero, use the next available partition slot.
<       * **_size_mib_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
<       * **_start_mib_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
<       * **_type_guid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
<       * **_guid_** (string): the GPT unique partition GUID.
<       * **_wipe_partition_entry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
<       * **_should_exist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
<   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
<     * **name** (string): the name to use for the resulting md device.
<     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
<     * **devices** (list of strings): the list of devices (referenced by their absolute path) in the array.
<     * **_spares_** (integer): the number of spares (if applicable) in the array.
<     * **_options_** (list of strings): any additional options to be passed to mdadm.
<   * **_filesystems_** (list of objects): the list of filesystems to be configured. `path`, `device`, and `format` all need to be specified. Every filesystem must have a unique `device`.
<     * **path** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
<     * **_wipe_filesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_label_** (string): the label of the filesystem.
<     * **_uuid_** (string): the uuid of the filesystem.
<     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
<     * **_mount_options_** (list of strings): any special options to be passed to the mount command.
<     * **_with_mount_unit_** (bool): Whether to generate a generic mount unit for this filesystem as well. If a more specific unit is needed, a custom one can be specified in the `systemd.units` section. The unit will be named with the [escaped][systemd-escape] version of the `path`. If your filesystem is located on a Tang-backed LUKS device, the unit will automatically require network access if you specify the device as `/dev/mapper/<device-name>` or `/dev/disk/by-id/dm-name-<device-name>`.
<   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
<     * **path** (string): the absolute path to the file.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
<     * **_contents_** (object): options related to the contents of the file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents to append. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents to append, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the appended contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_mode_** (integer): the file's permission mode. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
<     * **_user_** (object): specifies the file's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the directory.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
<     * **_mode_** (integer): the directory's permission mode. If not specified, the permission mode for directories defaults to 0755 or the mode of an existing directory if `overwrite` is false and a directory already exists at the path.
<     * **_user_** (object): specifies the directory's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the link
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
<     * **_user_** (object): specifies the symbolic link's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<     * **target** (string): the target path of the link
<     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
<  * **_luks_** (list of objects): the list of luks devices to be created. Every device must have a unique `name`.
<     * **name** (string): the name of the luks device.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_key_file_** (string): options related to the contents of the key file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the key file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the key file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the key file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_label_** (string): the label of the luks device.
<     * **_uuid_** (string): the uuid of the luks device.
<     * **_options_** (list of strings): any additional options to be passed to the cryptsetup utility.
<     * **_wipe_volume_** (boolean): whether or not to wipe the device before volume creation, see [the Ignition documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_clevis_** (object): describes the clevis configuration for the luks device.
<       * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
<         * **url** (string): url of the tang server.
<         * **thumbprint** (string): thumbprint of a trusted signing key.
<       * **_tpm2_** (bool): whether or not to use a tpm2 device.
<       * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device.
<       * **_custom_** (object): overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
<         * **pin** (string): the clevis pin.
<         * **config** (string): the clevis configuration JSON.
<         * **_needs_network_** (bool): whether or not the device requires networking.
<   * **_trees_** (list of objects): a list of local directory trees to be embedded in the config. Ownership is not preserved. File modes are set to 0755 if the local file is executable or 0644 otherwise. Attributes of files, directories, and symlinks can be overridden by creating a corresponding entry in the `files`, `directories`, or `links` section; such `files` entries must omit `contents` and such `links` entries must omit `target`.
<     * **local** (string): the base of the local directory tree, relative to the directory specified by the `--files-dir` command-line argument.
<     * **_path_** (string): the path of the tree within the target system. Defaults to `/`.
< * **_systemd_** (object): describes the desired state of the systemd units.
<   * **_units_** (list of objects): the list of systemd units.
<     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service"). Every unit must have a unique `name`.
<     * **_enabled_** (boolean): whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section.
<     * **_mask_** (boolean): whether or not the service shall be masked. When true, the service is masked by symlinking it to `/dev/null`.
<     * **_contents_** (string): the contents of the unit.
<     * **_dropins_** (list of objects): the list of drop-ins for the unit. Every drop-in must have a unique `name`.
<       * **name** (string): the name of the drop-in. This must be suffixed with ".conf".
<       * **_contents_** (string): the contents of the drop-in.
< * **_passwd_** (object): describes the desired additions to the passwd database.
<   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
<     * **name** (string): the username for the account.
<     * **_password_hash_** (string): the hashed password for the account.
<     * **_ssh_authorized_keys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
<     * **_uid_** (integer): the user ID of the account.
<     * **_gecos_** (string): the GECOS field of the account.
<     * **_home_dir_** (string): the home directory of the account.
<     * **_no_create_home_** (boolean): whether or not to create the user's home directory. This only has an effect if the account doesn't exist yet.
<     * **_primary_group_** (string): the name of the primary group of the account.
<     * **_groups_** (list of strings): the list of supplementary groups of the account.
<     * **_no_user_group_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
<     * **_no_log_init_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
<     * **_shell_** (string): the login shell of the new account.
<     * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
<   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
<     * **name** (string): the name of the group.
<     * **_gid_** (integer): the group ID of the new group.
<     * **_password_hash_** (string): the hashed password of the new group.
<     * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
< 
< [part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
< [rfc2397]: https://tools.ietf.org/html/rfc2397
< [systemd-escape]: https://www.freedesktop.org/software/systemd/man/systemd-escape.html
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/config-fcos-v1_3.md updated/vendor/github.com/coreos/fcct/docs/config-fcos-v1_3.md
1,204d0
< ---
< layout: default
< title: Fedora CoreOS v1.3.0
< parent: Configuration specifications
< nav_order: 46
< ---
< 
< # Fedora CoreOS Specification v1.3.0
< 
< The Fedora CoreOS configuration is a YAML document conforming to the following specification, with **_italicized_** entries being optional:
< 
< * **variant** (string): used to differentiate configs for different operating systems. Must be `fcos` for this specification.
< * **version** (string): the semantic version of the spec for this document. This document is for version `1.3.0` and generates Ignition configs with version `3.2.0`.
< * **ignition** (object): metadata about the configuration itself.
<   * **_config_** (objects): options related to the configuration.
<     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_replace_** (object): the config that will replace the current.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
<     * **_http_response_headers_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
<     * **_http_total_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
<   * **_security_** (object): options relating to network security.
<     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
<       * **_certificate_authorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`, `inline`, or `local`.
<         * **_source_** (string): the URL of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<         * **_inline_** (string): the contents of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `local`.
<         * **_local_** (string): a local path to the contents of the certificate bundle (in PEM format), relative to the directory specified by the `--files-dir` command-line argument. With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `inline`.
<         * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<           * **name** (string): the header name.
<           * **_value_** (string): the header contents.
<         * **_verification_** (object): options related to the verification of the certificate.
<           * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
<     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
<     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
<     * **_noProxy_** (list of strings): specifies a list of strings to hosts that should be excluded from proxying. Each value is represented by an `IP address prefix (1.2.3.4)`, `an IP address prefix in CIDR notation (1.2.3.4/8)`, `a domain name`, or `a special DNS label (*)`. An IP address prefix and domain name can also include a literal port number `(1.2.3.4:80)`. A domain name matches that name and all subdomains. A domain name with a leading `.` matches subdomains only. For example `foo.com` matches `foo.com` and `bar.foo.com`; `.y.com` matches `x.y.com` but not `y.com`. A single asterisk `(*)` indicates that no proxying should be done.
< * **_storage_** (object): describes the desired state of the system's storage devices.
<   * **_disks_** (list of objects): the list of disks to be configured and their options. Every entry must have a unique `device`.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_wipe_table_** (boolean): whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact.
<     * **_partitions_** (list of objects): the list of partitions and their configuration for this particular disk. Every partition must have a unique `number`, or if 0 is specified, a unique `label`.
<       * **_label_** (string): the PARTLABEL for the partition.
<       * **_number_** (integer): the partition number, which dictates it's position in the partition table (one-indexed). If zero, use the next available partition slot.
<       * **_size_mib_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
<       * **_start_mib_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
<       * **_type_guid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
<       * **_guid_** (string): the GPT unique partition GUID.
<       * **_wipe_partition_entry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
<       * **_should_exist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
<   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
<     * **name** (string): the name to use for the resulting md device.
<     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
<     * **devices** (list of strings): the list of devices (referenced by their absolute path) in the array.
<     * **_spares_** (integer): the number of spares (if applicable) in the array.
<     * **_options_** (list of strings): any additional options to be passed to mdadm.
<   * **_filesystems_** (list of objects): the list of filesystems to be configured. `path`, `device`, and `format` all need to be specified. Every filesystem must have a unique `device`.
<     * **path** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
<     * **_wipe_filesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_label_** (string): the label of the filesystem.
<     * **_uuid_** (string): the uuid of the filesystem.
<     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
<     * **_mount_options_** (list of strings): any special options to be passed to the mount command.
<     * **_with_mount_unit_** (bool): Whether to generate a generic mount unit for this filesystem as well. If a more specific unit is needed, a custom one can be specified in the `systemd.units` section. The unit will be named with the [escaped][systemd-escape] version of the `path`. If your filesystem is located on a Tang-backed LUKS device, the unit will automatically require network access if you specify the device as `/dev/mapper/<device-name>` or `/dev/disk/by-id/dm-name-<device-name>`.
<   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
<     * **path** (string): the absolute path to the file.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
<     * **_contents_** (object): options related to the contents of the file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents to append. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents to append, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the appended contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_mode_** (integer): the file's permission mode. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
<     * **_user_** (object): specifies the file's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the directory.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
<     * **_mode_** (integer): the directory's permission mode. If not specified, the permission mode for directories defaults to 0755 or the mode of an existing directory if `overwrite` is false and a directory already exists at the path.
<     * **_user_** (object): specifies the directory's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the link
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
<     * **_user_** (object): specifies the symbolic link's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<     * **target** (string): the target path of the link
<     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
<  * **_luks_** (list of objects): the list of luks devices to be created. Every device must have a unique `name`.
<     * **name** (string): the name of the luks device.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_key_file_** (string): options related to the contents of the key file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the key file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the key file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the key file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_label_** (string): the label of the luks device.
<     * **_uuid_** (string): the uuid of the luks device.
<     * **_options_** (list of strings): any additional options to be passed to the cryptsetup utility.
<     * **_wipe_volume_** (boolean): whether or not to wipe the device before volume creation, see [the Ignition documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_clevis_** (object): describes the clevis configuration for the luks device.
<       * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
<         * **url** (string): url of the tang server.
<         * **thumbprint** (string): thumbprint of a trusted signing key.
<       * **_tpm2_** (bool): whether or not to use a tpm2 device.
<       * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device.
<       * **_custom_** (object): overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
<         * **pin** (string): the clevis pin.
<         * **config** (string): the clevis configuration JSON.
<         * **_needs_network_** (bool): whether or not the device requires networking.
<   * **_trees_** (list of objects): a list of local directory trees to be embedded in the config. Ownership is not preserved. File modes are set to 0755 if the local file is executable or 0644 otherwise. Attributes of files, directories, and symlinks can be overridden by creating a corresponding entry in the `files`, `directories`, or `links` section; such `files` entries must omit `contents` and such `links` entries must omit `target`.
<     * **local** (string): the base of the local directory tree, relative to the directory specified by the `--files-dir` command-line argument.
<     * **_path_** (string): the path of the tree within the target system. Defaults to `/`.
< * **_systemd_** (object): describes the desired state of the systemd units.
<   * **_units_** (list of objects): the list of systemd units.
<     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service"). Every unit must have a unique `name`.
<     * **_enabled_** (boolean): whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section.
<     * **_mask_** (boolean): whether or not the service shall be masked. When true, the service is masked by symlinking it to `/dev/null`.
<     * **_contents_** (string): the contents of the unit.
<     * **_dropins_** (list of objects): the list of drop-ins for the unit. Every drop-in must have a unique `name`.
<       * **name** (string): the name of the drop-in. This must be suffixed with ".conf".
<       * **_contents_** (string): the contents of the drop-in.
< * **_passwd_** (object): describes the desired additions to the passwd database.
<   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
<     * **name** (string): the username for the account.
<     * **_password_hash_** (string): the hashed password for the account.
<     * **_ssh_authorized_keys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
<     * **_uid_** (integer): the user ID of the account.
<     * **_gecos_** (string): the GECOS field of the account.
<     * **_home_dir_** (string): the home directory of the account.
<     * **_no_create_home_** (boolean): whether or not to create the user's home directory. This only has an effect if the account doesn't exist yet.
<     * **_primary_group_** (string): the name of the primary group of the account.
<     * **_groups_** (list of strings): the list of supplementary groups of the account.
<     * **_no_user_group_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
<     * **_no_log_init_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
<     * **_shell_** (string): the login shell of the new account.
<     * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
<   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
<     * **name** (string): the name of the group.
<     * **_gid_** (integer): the group ID of the new group.
<     * **_password_hash_** (string): the hashed password of the new group.
<     * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
< * **_boot_device_** (object): describes the desired boot device configuration. At least one of `luks` or `mirror` must be specified.
<   * **_layout_** (string): the disk layout of the target OS image. Supported values are `aarch64`, `ppc64le`, and `x86_64`. Defaults to `x86_64`.
<   * **_luks_** (object): describes the clevis configuration for encrypting the root filesystem.
<     * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
<       * **url** (string): url of the tang server.
<       * **thumbprint** (string): thumbprint of a trusted signing key.
<     * **_tpm2_** (bool): whether or not to use a tpm2 device.
<     * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device.
<   * **_mirror_** (object): describes mirroring of the boot disk for fault tolerance.
<     * **_devices_** (list of strings): the list of whole-disk devices (not partitions) to include in the disk array, referenced by their absolute path. At least two devices must be specified.
< 
< [part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
< [rfc2397]: https://tools.ietf.org/html/rfc2397
< [systemd-escape]: https://www.freedesktop.org/software/systemd/man/systemd-escape.html
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/config-fcos-v1_4-exp.md updated/vendor/github.com/coreos/fcct/docs/config-fcos-v1_4-exp.md
1,206d0
< ---
< layout: default
< title: Fedora CoreOS v1.4.0-experimental
< parent: Configuration specifications
< nav_order: 50
< ---
< 
< # Fedora CoreOS Specification v1.4.0-experimental
< 
< **Note: This configuration is experimental and has not been stabilized. It is subject to change without warning or announcement.**
< 
< The Fedora CoreOS configuration is a YAML document conforming to the following specification, with **_italicized_** entries being optional:
< 
< * **variant** (string): used to differentiate configs for different operating systems. Must be `fcos` for this specification.
< * **version** (string): the semantic version of the spec for this document. This document is for version `1.4.0-experimental` and generates Ignition configs with version `3.3.0-experimental`.
< * **ignition** (object): metadata about the configuration itself.
<   * **_config_** (objects): options related to the configuration.
<     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_replace_** (object): the config that will replace the current.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
<     * **_http_response_headers_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
<     * **_http_total_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
<   * **_security_** (object): options relating to network security.
<     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
<       * **_certificate_authorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`, `inline`, or `local`.
<         * **_source_** (string): the URL of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<         * **_inline_** (string): the contents of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `local`.
<         * **_local_** (string): a local path to the contents of the certificate bundle (in PEM format), relative to the directory specified by the `--files-dir` command-line argument. With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `inline`.
<         * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<           * **name** (string): the header name.
<           * **_value_** (string): the header contents.
<         * **_verification_** (object): options related to the verification of the certificate.
<           * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
<     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
<     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
<     * **_noProxy_** (list of strings): specifies a list of strings to hosts that should be excluded from proxying. Each value is represented by an `IP address prefix (1.2.3.4)`, `an IP address prefix in CIDR notation (1.2.3.4/8)`, `a domain name`, or `a special DNS label (*)`. An IP address prefix and domain name can also include a literal port number `(1.2.3.4:80)`. A domain name matches that name and all subdomains. A domain name with a leading `.` matches subdomains only. For example `foo.com` matches `foo.com` and `bar.foo.com`; `.y.com` matches `x.y.com` but not `y.com`. A single asterisk `(*)` indicates that no proxying should be done.
< * **_storage_** (object): describes the desired state of the system's storage devices.
<   * **_disks_** (list of objects): the list of disks to be configured and their options. Every entry must have a unique `device`.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_wipe_table_** (boolean): whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact.
<     * **_partitions_** (list of objects): the list of partitions and their configuration for this particular disk. Every partition must have a unique `number`, or if 0 is specified, a unique `label`.
<       * **_label_** (string): the PARTLABEL for the partition.
<       * **_number_** (integer): the partition number, which dictates it's position in the partition table (one-indexed). If zero, use the next available partition slot.
<       * **_size_mib_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
<       * **_start_mib_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
<       * **_type_guid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
<       * **_guid_** (string): the GPT unique partition GUID.
<       * **_wipe_partition_entry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
<       * **_should_exist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
<   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
<     * **name** (string): the name to use for the resulting md device.
<     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
<     * **devices** (list of strings): the list of devices (referenced by their absolute path) in the array.
<     * **_spares_** (integer): the number of spares (if applicable) in the array.
<     * **_options_** (list of strings): any additional options to be passed to mdadm.
<   * **_filesystems_** (list of objects): the list of filesystems to be configured. `path`, `device`, and `format` all need to be specified. Every filesystem must have a unique `device`.
<     * **path** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
<     * **_wipe_filesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_label_** (string): the label of the filesystem.
<     * **_uuid_** (string): the uuid of the filesystem.
<     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
<     * **_mount_options_** (list of strings): any special options to be passed to the mount command.
<     * **_with_mount_unit_** (bool): Whether to generate a generic mount unit for this filesystem as well. If a more specific unit is needed, a custom one can be specified in the `systemd.units` section. The unit will be named with the [escaped][systemd-escape] version of the `path`. If your filesystem is located on a Tang-backed LUKS device, the unit will automatically require network access if you specify the device as `/dev/mapper/<device-name>` or `/dev/disk/by-id/dm-name-<device-name>`.
<   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
<     * **path** (string): the absolute path to the file.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
<     * **_contents_** (object): options related to the contents of the file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents to append. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents to append, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the appended contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_mode_** (integer): the file's permission mode. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
<     * **_user_** (object): specifies the file's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the directory.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
<     * **_mode_** (integer): the directory's permission mode. If not specified, the permission mode for directories defaults to 0755 or the mode of an existing directory if `overwrite` is false and a directory already exists at the path.
<     * **_user_** (object): specifies the directory's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the link
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
<     * **_user_** (object): specifies the symbolic link's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<     * **target** (string): the target path of the link
<     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
<  * **_luks_** (list of objects): the list of luks devices to be created. Every device must have a unique `name`.
<     * **name** (string): the name of the luks device.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_key_file_** (string): options related to the contents of the key file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the key file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the key file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the key file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_label_** (string): the label of the luks device.
<     * **_uuid_** (string): the uuid of the luks device.
<     * **_options_** (list of strings): any additional options to be passed to the cryptsetup utility.
<     * **_wipe_volume_** (boolean): whether or not to wipe the device before volume creation, see [the Ignition documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_clevis_** (object): describes the clevis configuration for the luks device.
<       * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
<         * **url** (string): url of the tang server.
<         * **thumbprint** (string): thumbprint of a trusted signing key.
<       * **_tpm2_** (bool): whether or not to use a tpm2 device.
<       * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device.
<       * **_custom_** (object): overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
<         * **pin** (string): the clevis pin.
<         * **config** (string): the clevis configuration JSON.
<         * **_needs_network_** (bool): whether or not the device requires networking.
<   * **_trees_** (list of objects): a list of local directory trees to be embedded in the config. Ownership is not preserved. File modes are set to 0755 if the local file is executable or 0644 otherwise. Attributes of files, directories, and symlinks can be overridden by creating a corresponding entry in the `files`, `directories`, or `links` section; such `files` entries must omit `contents` and such `links` entries must omit `target`.
<     * **local** (string): the base of the local directory tree, relative to the directory specified by the `--files-dir` command-line argument.
<     * **_path_** (string): the path of the tree within the target system. Defaults to `/`.
< * **_systemd_** (object): describes the desired state of the systemd units.
<   * **_units_** (list of objects): the list of systemd units.
<     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service"). Every unit must have a unique `name`.
<     * **_enabled_** (boolean): whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section.
<     * **_mask_** (boolean): whether or not the service shall be masked. When true, the service is masked by symlinking it to `/dev/null`.
<     * **_contents_** (string): the contents of the unit.
<     * **_dropins_** (list of objects): the list of drop-ins for the unit. Every drop-in must have a unique `name`.
<       * **name** (string): the name of the drop-in. This must be suffixed with ".conf".
<       * **_contents_** (string): the contents of the drop-in.
< * **_passwd_** (object): describes the desired additions to the passwd database.
<   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
<     * **name** (string): the username for the account.
<     * **_password_hash_** (string): the hashed password for the account.
<     * **_ssh_authorized_keys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
<     * **_uid_** (integer): the user ID of the account.
<     * **_gecos_** (string): the GECOS field of the account.
<     * **_home_dir_** (string): the home directory of the account.
<     * **_no_create_home_** (boolean): whether or not to create the user's home directory. This only has an effect if the account doesn't exist yet.
<     * **_primary_group_** (string): the name of the primary group of the account.
<     * **_groups_** (list of strings): the list of supplementary groups of the account.
<     * **_no_user_group_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
<     * **_no_log_init_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
<     * **_shell_** (string): the login shell of the new account.
<     * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
<   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
<     * **name** (string): the name of the group.
<     * **_gid_** (integer): the group ID of the new group.
<     * **_password_hash_** (string): the hashed password of the new group.
<     * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
< * **_boot_device_** (object): describes the desired boot device configuration. At least one of `luks` or `mirror` must be specified.
<   * **_layout_** (string): the disk layout of the target OS image. Supported values are `aarch64`, `ppc64le`, and `x86_64`. Defaults to `x86_64`.
<   * **_luks_** (object): describes the clevis configuration for encrypting the root filesystem.
<     * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
<       * **url** (string): url of the tang server.
<       * **thumbprint** (string): thumbprint of a trusted signing key.
<     * **_tpm2_** (bool): whether or not to use a tpm2 device.
<     * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device.
<   * **_mirror_** (object): describes mirroring of the boot disk for fault tolerance.
<     * **_devices_** (list of strings): the list of whole-disk devices (not partitions) to include in the disk array, referenced by their absolute path. At least two devices must be specified.
< 
< [part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
< [rfc2397]: https://tools.ietf.org/html/rfc2397
< [systemd-escape]: https://www.freedesktop.org/software/systemd/man/systemd-escape.html
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/config-rhcos-v0_1.md updated/vendor/github.com/coreos/fcct/docs/config-rhcos-v0_1.md
1,204d0
< ---
< layout: default
< title: RHEL CoreOS v0.1.0
< parent: Configuration specifications
< nav_order: 99
< ---
< 
< # RHEL CoreOS Specification v0.1.0
< 
< The RHEL CoreOS configuration is a YAML document conforming to the following specification, with **_italicized_** entries being optional:
< 
< * **variant** (string): used to differentiate configs for different operating systems. Must be `rhcos` for this specification.
< * **version** (string): the semantic version of the spec for this document. This document is for version `0.1.0` and generates Ignition configs with version `3.2.0`.
< * **ignition** (object): metadata about the configuration itself.
<   * **_config_** (objects): options related to the configuration.
<     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_replace_** (object): the config that will replace the current.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
<     * **_http_response_headers_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
<     * **_http_total_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
<   * **_security_** (object): options relating to network security.
<     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
<       * **_certificate_authorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`, `inline`, or `local`.
<         * **_source_** (string): the URL of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<         * **_inline_** (string): the contents of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `local`.
<         * **_local_** (string): a local path to the contents of the certificate bundle (in PEM format), relative to the directory specified by the `--files-dir` command-line argument. With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `inline`.
<         * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<           * **name** (string): the header name.
<           * **_value_** (string): the header contents.
<         * **_verification_** (object): options related to the verification of the certificate.
<           * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
<     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
<     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
<     * **_noProxy_** (list of strings): specifies a list of strings to hosts that should be excluded from proxying. Each value is represented by an `IP address prefix (1.2.3.4)`, `an IP address prefix in CIDR notation (1.2.3.4/8)`, `a domain name`, or `a special DNS label (*)`. An IP address prefix and domain name can also include a literal port number `(1.2.3.4:80)`. A domain name matches that name and all subdomains. A domain name with a leading `.` matches subdomains only. For example `foo.com` matches `foo.com` and `bar.foo.com`; `.y.com` matches `x.y.com` but not `y.com`. A single asterisk `(*)` indicates that no proxying should be done.
< * **_storage_** (object): describes the desired state of the system's storage devices.
<   * **_disks_** (list of objects): the list of disks to be configured and their options. Every entry must have a unique `device`.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_wipe_table_** (boolean): whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact.
<     * **_partitions_** (list of objects): the list of partitions and their configuration for this particular disk. Every partition must have a unique `number`, or if 0 is specified, a unique `label`.
<       * **_label_** (string): the PARTLABEL for the partition.
<       * **_number_** (integer): the partition number, which dictates it's position in the partition table (one-indexed). If zero, use the next available partition slot.
<       * **_size_mib_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
<       * **_start_mib_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
<       * **_type_guid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
<       * **_guid_** (string): the GPT unique partition GUID.
<       * **_wipe_partition_entry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
<       * **_should_exist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
<   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
<     * **name** (string): the name to use for the resulting md device.
<     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
<     * **devices** (list of strings): the list of devices (referenced by their absolute path) in the array.
<     * **_spares_** (integer): the number of spares (if applicable) in the array.
<     * **_options_** (list of strings): any additional options to be passed to mdadm.
<   * **_filesystems_** (list of objects): the list of filesystems to be configured. `path`, `device`, and `format` all need to be specified. Every filesystem must have a unique `device`.
<     * **path** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
<     * **_wipe_filesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_label_** (string): the label of the filesystem.
<     * **_uuid_** (string): the uuid of the filesystem.
<     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
<     * **_mount_options_** (list of strings): any special options to be passed to the mount command.
<     * **_with_mount_unit_** (bool): Whether to generate a generic mount unit for this filesystem as well. If a more specific unit is needed, a custom one can be specified in the `systemd.units` section. The unit will be named with the [escaped][systemd-escape] version of the `path`. If your filesystem is located on a Tang-backed LUKS device, the unit will automatically require network access if you specify the device as `/dev/mapper/<device-name>` or `/dev/disk/by-id/dm-name-<device-name>`.
<   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
<     * **path** (string): the absolute path to the file.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
<     * **_contents_** (object): options related to the contents of the file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents to append. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents to append, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the appended contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_mode_** (integer): the file's permission mode. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
<     * **_user_** (object): specifies the file's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the directory.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
<     * **_mode_** (integer): the directory's permission mode. If not specified, the permission mode for directories defaults to 0755 or the mode of an existing directory if `overwrite` is false and a directory already exists at the path.
<     * **_user_** (object): specifies the directory's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the link
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
<     * **_user_** (object): specifies the symbolic link's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<     * **target** (string): the target path of the link
<     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
<  * **_luks_** (list of objects): the list of luks devices to be created. Every device must have a unique `name`.
<     * **name** (string): the name of the luks device.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_key_file_** (string): options related to the contents of the key file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the key file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the key file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the key file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_label_** (string): the label of the luks device.
<     * **_uuid_** (string): the uuid of the luks device.
<     * **_options_** (list of strings): any additional options to be passed to the cryptsetup utility.
<     * **_wipe_volume_** (boolean): whether or not to wipe the device before volume creation, see [the Ignition documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_clevis_** (object): describes the clevis configuration for the luks device.
<       * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
<         * **url** (string): url of the tang server.
<         * **thumbprint** (string): thumbprint of a trusted signing key.
<       * **_tpm2_** (bool): whether or not to use a tpm2 device.
<       * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device.
<       * **_custom_** (object): overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
<         * **pin** (string): the clevis pin.
<         * **config** (string): the clevis configuration JSON.
<         * **_needs_network_** (bool): whether or not the device requires networking.
<   * **_trees_** (list of objects): a list of local directory trees to be embedded in the config. Ownership is not preserved. File modes are set to 0755 if the local file is executable or 0644 otherwise. Attributes of files, directories, and symlinks can be overridden by creating a corresponding entry in the `files`, `directories`, or `links` section; such `files` entries must omit `contents` and such `links` entries must omit `target`.
<     * **local** (string): the base of the local directory tree, relative to the directory specified by the `--files-dir` command-line argument.
<     * **_path_** (string): the path of the tree within the target system. Defaults to `/`.
< * **_systemd_** (object): describes the desired state of the systemd units.
<   * **_units_** (list of objects): the list of systemd units.
<     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service"). Every unit must have a unique `name`.
<     * **_enabled_** (boolean): whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section.
<     * **_mask_** (boolean): whether or not the service shall be masked. When true, the service is masked by symlinking it to `/dev/null`.
<     * **_contents_** (string): the contents of the unit.
<     * **_dropins_** (list of objects): the list of drop-ins for the unit. Every drop-in must have a unique `name`.
<       * **name** (string): the name of the drop-in. This must be suffixed with ".conf".
<       * **_contents_** (string): the contents of the drop-in.
< * **_passwd_** (object): describes the desired additions to the passwd database.
<   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
<     * **name** (string): the username for the account.
<     * **_password_hash_** (string): the hashed password for the account.
<     * **_ssh_authorized_keys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
<     * **_uid_** (integer): the user ID of the account.
<     * **_gecos_** (string): the GECOS field of the account.
<     * **_home_dir_** (string): the home directory of the account.
<     * **_no_create_home_** (boolean): whether or not to create the user's home directory. This only has an effect if the account doesn't exist yet.
<     * **_primary_group_** (string): the name of the primary group of the account.
<     * **_groups_** (list of strings): the list of supplementary groups of the account.
<     * **_no_user_group_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
<     * **_no_log_init_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
<     * **_shell_** (string): the login shell of the new account.
<     * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
<   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
<     * **name** (string): the name of the group.
<     * **_gid_** (integer): the group ID of the new group.
<     * **_password_hash_** (string): the hashed password of the new group.
<     * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
< * **_boot_device_** (object): describes the desired boot device configuration. At least one of `luks` or `mirror` must be specified.
<   * **_layout_** (string): the disk layout of the target OS image. Supported values are `aarch64`, `ppc64le`, and `x86_64`. Defaults to `x86_64`.
<   * **_luks_** (object): describes the clevis configuration for encrypting the root filesystem.
<     * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
<       * **url** (string): url of the tang server.
<       * **thumbprint** (string): thumbprint of a trusted signing key.
<     * **_tpm2_** (bool): whether or not to use a tpm2 device.
<     * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device.
<   * **_mirror_** (object): describes mirroring of the boot disk for fault tolerance.
<     * **_devices_** (list of strings): the list of whole-disk devices (not partitions) to include in the disk array, referenced by their absolute path. At least two devices must be specified.
< 
< [part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
< [rfc2397]: https://tools.ietf.org/html/rfc2397
< [systemd-escape]: https://www.freedesktop.org/software/systemd/man/systemd-escape.html
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/config-rhcos-v0_2-exp.md updated/vendor/github.com/coreos/fcct/docs/config-rhcos-v0_2-exp.md
1,206d0
< ---
< layout: default
< title: RHEL CoreOS v0.2.0-experimental
< parent: Configuration specifications
< nav_order: 100
< ---
< 
< # RHEL CoreOS Specification v0.2.0-experimental
< 
< **Note: This configuration is experimental and has not been stabilized. It is subject to change without warning or announcement.**
< 
< The RHEL CoreOS configuration is a YAML document conforming to the following specification, with **_italicized_** entries being optional:
< 
< * **variant** (string): used to differentiate configs for different operating systems. Must be `rhcos` for this specification.
< * **version** (string): the semantic version of the spec for this document. This document is for version `0.2.0-experimental` and generates Ignition configs with version `3.3.0-experimental`.
< * **ignition** (object): metadata about the configuration itself.
<   * **_config_** (objects): options related to the configuration.
<     * **_merge_** (list of objects): a list of the configs to be merged to the current config.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_replace_** (object): the config that will replace the current.
<       * **_source_** (string): the URL of the config. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the config. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the config, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the config.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_timeouts_** (object): options relating to `http` timeouts when fetching files over `http` or `https`.
<     * **_http_response_headers_** (integer) the time to wait (in seconds) for the server's response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds.
<     * **_http_total_** (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0.
<   * **_security_** (object): options relating to network security.
<     * **_tls_** (object): options relating to TLS when fetching resources over `https`.
<       * **_certificate_authorities_** (list of objects): the list of additional certificate authorities (in addition to the system authorities) to be used for TLS verification when fetching over `https`. All certificate authorities must have a unique `source`, `inline`, or `local`.
<         * **_source_** (string): the URL of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Supported schemes are `http`, `https`, `s3`, `tftp`, and [`data`][rfc2397]. Note: When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<         * **_inline_** (string): the contents of the certificate bundle (in PEM format). With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `local`.
<         * **_local_** (string): a local path to the contents of the certificate bundle (in PEM format), relative to the directory specified by the `--files-dir` command-line argument. With Ignition &ge; 2.4.0, the bundle can contain multiple concatenated certificates. Mutually exclusive with `source` and `inline`.
<         * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<           * **name** (string): the header name.
<           * **_value_** (string): the header contents.
<         * **_verification_** (object): options related to the verification of the certificate.
<           * **_hash_** (string): the hash of the certificate, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<   * **_proxy_** (object): options relating to setting an `HTTP(S)` proxy when fetching resources.
<     * **_httpProxy_** (string): will be used as the proxy URL for HTTP requests and HTTPS requests unless overridden by `httpsProxy` or `noProxy`.
<     * **_httpsProxy_** (string): will be used as the proxy URL for HTTPS requests unless overridden by `noProxy`.
<     * **_noProxy_** (list of strings): specifies a list of strings to hosts that should be excluded from proxying. Each value is represented by an `IP address prefix (1.2.3.4)`, `an IP address prefix in CIDR notation (1.2.3.4/8)`, `a domain name`, or `a special DNS label (*)`. An IP address prefix and domain name can also include a literal port number `(1.2.3.4:80)`. A domain name matches that name and all subdomains. A domain name with a leading `.` matches subdomains only. For example `foo.com` matches `foo.com` and `bar.foo.com`; `.y.com` matches `x.y.com` but not `y.com`. A single asterisk `(*)` indicates that no proxying should be done.
< * **_storage_** (object): describes the desired state of the system's storage devices.
<   * **_disks_** (list of objects): the list of disks to be configured and their options. Every entry must have a unique `device`.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_wipe_table_** (boolean): whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact.
<     * **_partitions_** (list of objects): the list of partitions and their configuration for this particular disk. Every partition must have a unique `number`, or if 0 is specified, a unique `label`.
<       * **_label_** (string): the PARTLABEL for the partition.
<       * **_number_** (integer): the partition number, which dictates it's position in the partition table (one-indexed). If zero, use the next available partition slot.
<       * **_size_mib_** (integer): the size of the partition (in mebibytes). If zero, the partition will be made as large as possible.
<       * **_start_mib_** (integer): the start of the partition (in mebibytes). If zero, the partition will be positioned at the start of the largest block available.
<       * **_type_guid_** (string): the GPT [partition type GUID][part-types]. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data).
<       * **_guid_** (string): the GPT unique partition GUID.
<       * **_wipe_partition_entry_** (boolean) if true, Ignition will clobber an existing partition if it does not match the config. If false (default), Ignition will fail instead.
<       * **_should_exist_** (boolean) whether or not the partition with the specified `number` should exist. If omitted, it defaults to true. If false Ignition will either delete the specified partition or fail, depending on `wipePartitionEntry`. If false `number` must be specified and non-zero and `label`, `start`, `size`, `guid`, and `typeGuid` must all be omitted.
<   * **_raid_** (list of objects): the list of RAID arrays to be configured. Every RAID array must have a unique `name`.
<     * **name** (string): the name to use for the resulting md device.
<     * **level** (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.).
<     * **devices** (list of strings): the list of devices (referenced by their absolute path) in the array.
<     * **_spares_** (integer): the number of spares (if applicable) in the array.
<     * **_options_** (list of strings): any additional options to be passed to mdadm.
<   * **_filesystems_** (list of objects): the list of filesystems to be configured. `path`, `device`, and `format` all need to be specified. Every filesystem must have a unique `device`.
<     * **path** (string): the mount-point of the filesystem while Ignition is running relative to where the root filesystem will be mounted. This is not necessarily the same as where it should be mounted in the real root, but it is encouraged to make it the same.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **format** (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap).
<     * **_wipe_filesystem_** (boolean): whether or not to wipe the device before filesystem creation, see [the documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_label_** (string): the label of the filesystem.
<     * **_uuid_** (string): the uuid of the filesystem.
<     * **_options_** (list of strings): any additional options to be passed to the format-specific mkfs utility.
<     * **_mount_options_** (list of strings): any special options to be passed to the mount command.
<     * **_with_mount_unit_** (bool): Whether to generate a generic mount unit for this filesystem as well. If a more specific unit is needed, a custom one can be specified in the `systemd.units` section. The unit will be named with the [escaped][systemd-escape] version of the `path`. If your filesystem is located on a Tang-backed LUKS device, the unit will automatically require network access if you specify the device as `/dev/mapper/<device-name>` or `/dev/disk/by-id/dm-name-<device-name>`.
<   * **_files_** (list of objects): the list of files to be written. Every file, directory and link must have a unique `path`.
<     * **path** (string): the absolute path to the file.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. `contents` must be specified if `overwrite` is true. Defaults to false.
<     * **_contents_** (object): options related to the contents of the file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. If source is omitted and a regular file already exists at the path, Ignition will do nothing. If source is omitted and no file exists, an empty file will be created. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_append_** (list of objects): list of contents to be appended to the file. Follows the same stucture as `contents`
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the contents to append. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents to append. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents to append, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the appended contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_mode_** (integer): the file's permission mode. If not specified, the permission mode for files defaults to 0644 or the existing file's permissions if `overwrite` is false, `contents` is unspecified, and a file already exists at the path.
<     * **_user_** (object): specifies the file's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_directories_** (list of objects): the list of directories to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the directory.
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If false and a directory already exists at the path, Ignition will only set its permissions. If false and a non-directory exists at that path, Ignition will fail. Defaults to false.
<     * **_mode_** (integer): the directory's permission mode. If not specified, the permission mode for directories defaults to 0755 or the mode of an existing directory if `overwrite` is false and a directory already exists at the path.
<     * **_user_** (object): specifies the directory's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<   * **_links_** (list of objects): the list of links to be created. Every file, directory, and link must have a unique `path`.
<     * **path** (string): the absolute path to the link
<     * **_overwrite_** (boolean): whether to delete preexisting nodes at the path. If overwrite is false and a matching link exists at the path, Ignition will only set the owner and group. Defaults to false.
<     * **_user_** (object): specifies the symbolic link's owner.
<       * **_id_** (integer): the user ID of the owner.
<       * **_name_** (string): the user name of the owner.
<     * **_group_** (object): specifies the group of the owner.
<       * **_id_** (integer): the group ID of the owner.
<       * **_name_** (string): the group name of the owner.
<     * **target** (string): the target path of the link
<     * **_hard_** (boolean): a symbolic link is created if this is false, a hard one if this is true.
<  * **_luks_** (list of objects): the list of luks devices to be created. Every device must have a unique `name`.
<     * **name** (string): the name of the luks device.
<     * **device** (string): the absolute path to the device. Devices are typically referenced by the `/dev/disk/by-*` symlinks.
<     * **_key_file_** (string): options related to the contents of the key file.
<       * **_compression_** (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3.
<       * **_source_** (string): the URL of the key file contents. Supported schemes are `http`, `https`, `tftp`, `s3`, and [`data`][rfc2397]. When using `http`, it is advisable to use the verification option to ensure the contents haven't been modified. Mutually exclusive with `inline` and `local`.
<       * **_inline_** (string): the contents of the key file. Mutually exclusive with `source` and `local`.
<       * **_local_** (string): a local path to the contents of the key file, relative to the directory specified by the `--files-dir` command-line argument. Mutually exclusive with `source` and `inline`.
<       * **_http_headers_** (list of objects): a list of HTTP headers to be added to the request. Available for `http` and `https` source schemes only.
<         * **name** (string): the header name.
<         * **_value_** (string): the header contents.
<       * **_verification_** (object): options related to the verification of the file contents.
<         * **_hash_** (string): the hash of the config, in the form `<type>-<value>` where type is either `sha512` or `sha256`.
<     * **_label_** (string): the label of the luks device.
<     * **_uuid_** (string): the uuid of the luks device.
<     * **_options_** (list of strings): any additional options to be passed to the cryptsetup utility.
<     * **_wipe_volume_** (boolean): whether or not to wipe the device before volume creation, see [the Ignition documentation on filesystems](https://coreos.github.io/ignition/operator-notes/#filesystem-reuse-semantics) for more information.
<     * **_clevis_** (object): describes the clevis configuration for the luks device.
<       * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
<         * **url** (string): url of the tang server.
<         * **thumbprint** (string): thumbprint of a trusted signing key.
<       * **_tpm2_** (bool): whether or not to use a tpm2 device.
<       * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device.
<       * **_custom_** (object): overrides the clevis configuration. The `pin` & `config` will be passed directly to `clevis luks bind`. If specified, all other clevis options must be omitted.
<         * **pin** (string): the clevis pin.
<         * **config** (string): the clevis configuration JSON.
<         * **_needs_network_** (bool): whether or not the device requires networking.
<   * **_trees_** (list of objects): a list of local directory trees to be embedded in the config. Ownership is not preserved. File modes are set to 0755 if the local file is executable or 0644 otherwise. Attributes of files, directories, and symlinks can be overridden by creating a corresponding entry in the `files`, `directories`, or `links` section; such `files` entries must omit `contents` and such `links` entries must omit `target`.
<     * **local** (string): the base of the local directory tree, relative to the directory specified by the `--files-dir` command-line argument.
<     * **_path_** (string): the path of the tree within the target system. Defaults to `/`.
< * **_systemd_** (object): describes the desired state of the systemd units.
<   * **_units_** (list of objects): the list of systemd units.
<     * **name** (string): the name of the unit. This must be suffixed with a valid unit type (e.g. "thing.service"). Every unit must have a unique `name`.
<     * **_enabled_** (boolean): whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section.
<     * **_mask_** (boolean): whether or not the service shall be masked. When true, the service is masked by symlinking it to `/dev/null`.
<     * **_contents_** (string): the contents of the unit.
<     * **_dropins_** (list of objects): the list of drop-ins for the unit. Every drop-in must have a unique `name`.
<       * **name** (string): the name of the drop-in. This must be suffixed with ".conf".
<       * **_contents_** (string): the contents of the drop-in.
< * **_passwd_** (object): describes the desired additions to the passwd database.
<   * **_users_** (list of objects): the list of accounts that shall exist. All users must have a unique `name`.
<     * **name** (string): the username for the account.
<     * **_password_hash_** (string): the hashed password for the account.
<     * **_ssh_authorized_keys_** (list of strings): a list of SSH keys to be added as an SSH key fragment at `.ssh/authorized_keys.d/ignition` in the user's home directory. All SSH keys must be unique.
<     * **_uid_** (integer): the user ID of the account.
<     * **_gecos_** (string): the GECOS field of the account.
<     * **_home_dir_** (string): the home directory of the account.
<     * **_no_create_home_** (boolean): whether or not to create the user's home directory. This only has an effect if the account doesn't exist yet.
<     * **_primary_group_** (string): the name of the primary group of the account.
<     * **_groups_** (list of strings): the list of supplementary groups of the account.
<     * **_no_user_group_** (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn't exist yet.
<     * **_no_log_init_** (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn't exist yet.
<     * **_shell_** (string): the login shell of the new account.
<     * **_system_** (bool): whether or not this account should be a system account. This only has an effect if the account doesn't exist yet.
<   * **_groups_** (list of objects): the list of groups to be added. All groups must have a unique `name`.
<     * **name** (string): the name of the group.
<     * **_gid_** (integer): the group ID of the new group.
<     * **_password_hash_** (string): the hashed password of the new group.
<     * **_system_** (bool): whether or not the group should be a system group. This only has an effect if the group doesn't exist yet.
< * **_boot_device_** (object): describes the desired boot device configuration. At least one of `luks` or `mirror` must be specified.
<   * **_layout_** (string): the disk layout of the target OS image. Supported values are `aarch64`, `ppc64le`, and `x86_64`. Defaults to `x86_64`.
<   * **_luks_** (object): describes the clevis configuration for encrypting the root filesystem.
<     * **_tang_** (list of objects): describes a tang server. Every server must have a unique `url`.
<       * **url** (string): url of the tang server.
<       * **thumbprint** (string): thumbprint of a trusted signing key.
<     * **_tpm2_** (bool): whether or not to use a tpm2 device.
<     * **_threshold_** (int): sets the minimum number of pieces required to decrypt the device.
<   * **_mirror_** (object): describes mirroring of the boot disk for fault tolerance.
<     * **_devices_** (list of strings): the list of whole-disk devices (not partitions) to include in the disk array, referenced by their absolute path. At least two devices must be specified.
< 
< [part-types]: http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_type_GUIDs
< [rfc2397]: https://tools.ietf.org/html/rfc2397
< [systemd-escape]: https://www.freedesktop.org/software/systemd/man/systemd-escape.html
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/development.md updated/vendor/github.com/coreos/fcct/docs/development.md
1,50d0
< ---
< layout: default
< nav_order: 9
< ---
< 
< # Developing FCCT
< {: .no_toc }
< 
< 1. TOC
< {:toc}
< 
< ## Creating a release
< 
< Create a [release checklist](https://github.com/coreos/fcct/issues/new?template=release-checklist.md) and follow those steps.
< 
< ## Bumping spec versions
< 
< This checklist describes bumping the Ignition spec version, `base` version, and `config` version. If your scenario is different, modify to taste.
< 
< ### Stabilize Ignition spec version
< 
< - Bump `go.mod` for new Ignition release and update vendor.
< - Update imports. Drop `-experimental` from Ignition spec versions in `base/vB_exp/translate_test.go`.
< 
< ### Bump base version
< 
< - Rename `base/vB_exp` to `base/vB` and update `package` statements. Update imports.
< - Copy `base/vB` to `base/vB+1_exp`.
< - Update `package` statements in `base/vB+1_exp`.
< 
< ### Bump config version
< 
< - Rename `config/fcos/vC_exp` to `config/fcos/vC` and update `package` statements. Update imports.
< - Drop `-experimental` from `init()` in `config/config.go`.
< - Drop `-experimental` from examples in `docs/`.
< - Copy `config/fcos/vC` to `config/fcos/vC+1_exp`.
< - Update `package` statements in `config/fcos/vC+1_exp`. Bump its base dependency to `base/vB+1_exp`.
< - Import `config/vC+1_exp` in `config/config.go` and add `fcos` `C+1-experimental` to `init()`.
< 
< ### Bump Ignition spec version
< 
< - Bump Ignition types imports and rename `ToIgnI` and `TestToIgnI` functions in `base/vB+1_exp`. Bump Ignition spec versions in `base/vB+1_exp/translate_test.go`.
< - Bump Ignition types imports in `config/fcos/vC+1_exp`. Update `ToIgnI` function names, `util` calls, and header comments to `ToIgnI+1`.
< 
< ### Update docs
< 
< - Copy the `C-exp` spec doc to `C+1-exp`. Update the header and the version numbers in the description of the `version` field.
< - Rename the `C-exp` spec doc to `C`. Update the header, delete the experimental config warning, and update the version numbers in the description of the `version` field. Update the `nav_order` to one less than the previous stable release.
< - Update `docs/specs.md`.
< - Update `docs/migrating-configs.md` for the new spec version. Copy the relevant section from Ignition's `doc/migrating-configs.md`, convert the configs to FCCs, convert field names to snake case, and update wording as needed. Add subsections for any new FCC-specific features.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/examples.md updated/vendor/github.com/coreos/fcct/docs/examples.md
1,357d0
< ---
< layout: default
< nav_order: 3
< ---
< 
< # Examples
< {: .no_toc }
< 
< 1. TOC
< {:toc}
< 
< Here you can find a bunch of simple examples for using `fcct`, with some explanations about what they do. The examples here are in no way comprehensive, for a full list of all the options present in `fcct` check out the [configuration specification][spec].
< 
< ## Users and groups
< 
< This example modifies the existing `core` user and sets its ssh key.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< passwd:
<   users:
<     - name: core
<       ssh_authorized_keys:
<         - key1
< ```
< 
< This example creates one user, `user1` and sets up one ssh public key for the user. The user is also given the home directory `/home/user1`, but it's not created, the user is added to the `wheel` and `plugdev` groups, and the user's shell is set to `/bin/bash`.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< passwd:
<   users:
<     - name: user1
<       ssh_authorized_keys:
<         - key1
<       home_dir: /home/user1
<       no_create_home: true
<       groups:
<         - wheel
<         - plugdev
<       shell: /bin/bash
< ```
< 
< ### Using password authentication
< 
< You can use a Fedora CoreOS Config to set a password for a local user. Building on the previous example, we can configure the `password_hash` for one or more users:
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< passwd:
<   users:
<     - name: user1
<       ssh_authorized_keys:
<         - key1
<       password_hash: $y$j9T$aUmgEDoFIDPhGxEe2FUjc/$C5A...
<       home_dir: /home/user1
<       no_create_home: true
<       groups:
<         - wheel
<         - plugdev
<       shell: /bin/bash
< ```
< 
< To generate a secure password hash, use the `mkpasswd` command:
< 
< ```
< $ mkpasswd --method=yescrypt
< Password:
< $y$j9T$A0Y3wwVOKP69S.1K/zYGN.$S596l11UGH3XjN...
< ```
< 
< The `yescrypt` hashing method is recommended for new passwords. For more details on hashing methods, see `man 5 crypt`.
< 
< For more information, see the Fedora CoreOS documentation on [Authentication][fcos-auth-docs].
< 
< ## Storage and files
< 
< ### Files
< 
< This example creates a file at `/opt/file` with the contents `Hello, world!`, permissions 0644 (so readable and writable by the owner, and only readable by everyone else), and the file is owned by user uid 500 and gid 501.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   files:
<     - path: /opt/file
<       contents:
<         inline: Hello, world!
<       mode: 0644
<       user:
<         id: 500
<       group:
<         id: 501
< ```
< 
< This example fetches a gzip-compressed file from `http://example.com/file2`, makes sure that the _uncompressed_ contents match the provided sha512 hash, and writes it to `/opt/file2`.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   files:
<     - path: /opt/file2
<       contents:
<         source: http://example.com/file2
<         compression: gzip
<         verification:
<           hash: sha512-4ee6a9d20cc0e6c7ee187daffa6822bdef7f4cebe109eff44b235f97e45dc3d7a5bb932efc841192e46618f48a6f4f5bc0d15fd74b1038abf46bf4b4fd409f2e
<       mode: 0644
< ```
< 
< This example creates a file at `/opt/file3` whose contents are read from a local file `local-file3` on the system running FCCT. The path of the local file is relative to a _files-dir_ which must be specified via the `-d`/`--files-dir` option to FCCT.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   files:
<     - path: /opt/file3
<       contents:
<         local: local-file3
<       mode: 0644
< ```
< 
< ### Directory trees
< 
< Consider a directory tree at `~/fcc/tree` on the system running FCCT:
< 
< ```
< file
< overridden-file
< directory/file
< directory/symlink -> ../file
< ```
< 
< This example copies that directory tree to `/etc/files` on the target system. The ownership and mode for `overridden-file` are explicitly set by the config. All other filesystem objects are owned by `root:root`, directory modes are set to 0755, and file modes are set to 0755 if the source file is executable or 0644 otherwise. The example must be transpiled with `--files-dir ~/fcc`.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   trees:
<     - local: tree
<       path: /etc/files
<   files:
<     - path: /etc/files/overridden-file
<       mode: 0600
<       user:
<         id: 500
<       group:
<         id: 501
< ```
< 
< ### Filesystems and partitions
< 
< This example creates a single partition spanning all of the sdb device then creates a btrfs filesystem on it to use as /var. Finally it creates the mount unit for systemd so it gets mounted on boot.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   disks:
<     - device: /dev/sdb
<       wipe_table: true
<       partitions:
<         - number: 1
<           label: var
<   filesystems:
<     - path: /var
<       device: /dev/disk/by-partlabel/var
<       format: btrfs
<       wipe_filesystem: true
<       label: var
<       with_mount_unit: true
< ```
< 
< ### LUKS encrypted storage
< 
< This example creates three LUKS2 encrypted storage volumes: one unlocked with a static key file, one with a TPM2 device via Clevis, and one with a network Tang server via Clevis. Volumes can be unlocked with any combination of these methods, or with a custom Clevis PIN and CFG. If a key file is not specified for a device, an ephemeral one will be created.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.2.0
< storage:
<   luks:
<     - name: static-key-example
<       device: /dev/sdb
<       key_file:
<         inline: REPLACE-THIS-WITH-YOUR-KEY-MATERIAL
<     - name: tpm-example
<       device: /dev/sdc
<       clevis:
<         tpm2: true
<     - name: tang-example
<       device: /dev/sdd
<       clevis:
<         tang:
<           - url: https://tang.example.com
<             thumbprint: REPLACE-THIS-WITH-YOUR-TANG-THUMBPRINT
<   filesystems:
<     - path: /var/lib/static_key_example
<       device: /dev/disk/by-id/dm-name-static-key-example
<       format: ext4
<       label: STATIC-EXAMPLE
<       with_mount_unit: true
<     - path: /var/lib/tpm_example
<       device: /dev/disk/by-id/dm-name-tpm-example
<       format: ext4
<       label: TPM-EXAMPLE
<       with_mount_unit: true
<     - path: /var/lib/tang_example
<       device: /dev/disk/by-id/dm-name-tang-example
<       format: ext4
<       label: TANG-EXAMPLE
<       with_mount_unit: true
< ```
< 
< This example uses the shortcut `boot_device` syntax to configure an encrypted root filesystem unlocked with a combination of a TPM2 device and a network Tang server.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.3.0
< boot_device:
<   luks:
<     tpm2: true
<     tang:
<       - url: https://tang.example.com
<         thumbprint: REPLACE-THIS-WITH-YOUR-TANG-THUMBPRINT
< ```
< 
< This example combines `boot_device` with a manually-specified filesystem `format` to create an encrypted root filesystem formatted with `ext4` instead of the default `xfs`.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.3.0
< boot_device:
<   luks:
<     tpm2: true
< storage:
<   filesystems:
<     - device: /dev/mapper/root
<       format: ext4
< ```
< 
< ### Mirrored boot disk
< 
< This example replicates all default partitions on the boot disk across multiple disks, allowing the system to survive disk failure.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.3.0
< boot_device:
<   mirror:
<     devices:
<       - /dev/sda
<       - /dev/sdb
< ```
< 
< This example configures a mirrored boot disk with a TPM2-encrypted root filesystem, overrides the size of the root partition replicas, and adds a mirrored `/var` partition which consumes the remainder of the disks.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.3.0
< boot_device:
<   luks:
<     tpm2: true
<   mirror:
<     devices:
<       - /dev/sda
<       - /dev/sdb
< storage:
<   disks:
<     - device: /dev/sda
<       partitions:
<         - label: root-1
<           size_mib: 8192
<         - label: var-1
<     - device: /dev/sdb
<       partitions:
<         - label: root-2
<           size_mib: 8192
<         - label: var-2
<   raid:
<     - name: md-var
<       level: raid1
<       devices:
<         - /dev/disk/by-partlabel/var-1
<         - /dev/disk/by-partlabel/var-2
<   filesystems:
<     - device: /dev/md/md-var
<       path: /var
<       format: xfs
<       wipe_filesystem: true
<       with_mount_unit: true
< ```
< 
< ## systemd units
< 
< This example adds a drop-in for the `serial-getty@ttyS0` unit, turning on autologin on `ttyS0` by overriding the `ExecStart=` defined in the default unit. More information on systemd dropins can be found in [the systemd docs][dropins].
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< systemd:
<   units:
<     - name: serial-getty@ttyS0.service
<       dropins:
<         - name: autologin.conf
<           contents: |
<             [Service]
<             TTYVTDisallocate=no
<             ExecStart=
<             ExecStart=-/usr/sbin/agetty --autologin core --noclear %I $TERM
< ```
< 
< This example creates a new systemd unit called hello.service, enables it so it will run on boot, and defines the contents to simply echo `"Hello, World!"`.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< systemd:
<   units:
<     - name: hello.service
<       enabled: true
<       contents: |
<         [Unit]
<         Description=A hello world unit!
<         [Service]
<         Type=oneshot
<         RemainAfterExit=yes
<         ExecStart=/usr/bin/echo "Hello, World!"
<         [Install]
<         WantedBy=multi-user.target
< ```
< 
< [spec]: specs.md
< [dropins]: https://www.freedesktop.org/software/systemd/man/systemd.unit.html#Description
< [fcos-auth-docs]: https://docs.fedoraproject.org/en-US/fedora-coreos/authentication
Binary files current/vendor/github.com/coreos/fcct/docs/favicon.ico and updated/vendor/github.com/coreos/fcct/docs/favicon.ico differ
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/getting-started.md updated/vendor/github.com/coreos/fcct/docs/getting-started.md
1,76d0
< ---
< layout: default
< nav_order: 2
< ---
< 
< # Getting started
< 
< `fcct`, the Fedora CoreOS Config Transpiler, is a tool that consumes a Fedora CoreOS Config and produces an Ignition config, which is a JSON document that can be given to a Fedora CoreOS machine when it first boots. Using this config, a machine can be told to create users, create filesystems, set up the network, install systemd units, and more.
< 
< Fedora CoreOS Configs are YAML files conforming to `fcct`'s schema. For more information on the schema, take a look at the [configuration specifications][spec].
< 
< ### Getting FCCT
< 
< `fcct` can be downloaded as a standalone binary or run as a container with docker or podman.
< 
< #### Standalone binary
< 
< Download the latest version of `fcct` and the detached signature from the [releases page](https://github.com/coreos/fcct/releases). Verify it with gpg:
< 
< ```
< gpg --verify <detached sig> <fcct binary>
< ```
< You may need to download the [Fedora signing keys](https://getfedora.org/static/fedora.gpg) and import them with `gpg --import <key>` if you have not already done so.
< 
< New releases of `fcct` are backwards compatible with old releases unless otherwise noted.
< 
< #### Container
< 
< This example uses podman, but docker can also be used.
< 
< ```bash
< # Pull the latest release
< podman pull quay.io/coreos/fcct:release
< 
< # Run fcct using standard in and standard out
< podman run -i --rm quay.io/coreos/fcct:release --pretty --strict < your_config.fcc > transpiled_config.ign
< 
< # Run fcct using files.
< podman run --rm -v /path/to/your_config.fcc:/config.fcc:z quay.io/coreos/fcct:release --pretty --strict /config.fcc > transpiled_config.ign
< ```
< 
< ### Writing and using Fedora CoreOS Configs
< 
< As a simple example, let's use `fcct` to set the authorized ssh key for the `core` user on a Fedora CoreOS machine.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< passwd:
<   users:
<     - name: core
<       ssh_authorized_keys:
<         - ssh-rsa AAAAB3NzaC1yc...
< ```
< 
< In this above file, you'll want to set the `ssh-rsa AAAAB3NzaC1yc...` line to be your ssh public key (which is probably the contents of `~/.ssh/id_rsa.pub`, if you're on Linux).
< 
< If we take this file and give it to `fcct`:
< 
< ```
< $ ./bin/amd64/fcct example.yaml
< 
< {"ignition":{"config":{"replace":{"source":null,"verification":{}}},"security":{"tls":{}},"timeouts":{},"version":"3.0.0"},"passwd":{"users":[{"name":"core","sshAuthorizedKeys":["ssh-rsa ssh-rsa AAAAB3NzaC1yc..."]}]},"storage":{},"systemd":{}}
< ```
< 
< We can see that it produces a JSON file. This file isn't intended to be human-friendly, and will definitely be a pain to read/edit (especially if you have multi-line things like systemd units). Luckily, you shouldn't have to care about this file! Just provide it to a booting Fedora CoreOS machine and [Ignition][ignition], the utility inside of Fedora CoreOS that receives this file, will know what to do with it.
< 
< The method by which this file is provided to a Fedora CoreOS machine depends on the environment in which the machine is running. For instructions on a given provider, head over to the [list of supported platforms for Ignition][supported-platforms].
< 
< To see some examples for what else `fcct` can do, head over to the [examples][examples].
< 
< [spec]: specs.md
< [ignition]: https://coreos.github.io/ignition/
< [supported-platforms]: https://coreos.github.io/ignition/supported-platforms/
< [examples]: examples.md
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/index.md updated/vendor/github.com/coreos/fcct/docs/index.md
1,11d0
< ---
< layout: default
< nav_order: 1
< ---
< 
< # Fedora CoreOS Config Transpiler
< 
< The Fedora CoreOS Config Transpiler (FCCT) translates human readable Fedora CoreOS Configs (FCCs)
< into machine readable [Ignition](https://coreos.github.io/ignition/) Configs. See the [getting
< started](getting-started) guide for how to use FCCT and the [configuration specifications](specs.md)
< for everything FCCs support.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/migrating-configs.md updated/vendor/github.com/coreos/fcct/docs/migrating-configs.md
1,359d0
< ---
< layout: default
< nav_order: 5
< ---
< 
< # Upgrading Configs
< 
< Occasionally, there are changes made to Fedora CoreOS configuration that break backward compatibility. While this is not a concern for running machines (since Ignition only runs one time during first boot), it is a concern for those who maintain configuration files. This document serves to detail each of the breaking changes and tries to provide some reasoning for the change. This does not cover all of the changes to the spec - just those that need to be considered when migrating from one version to the next.
< 
< {: .no_toc }
< 
< 1. TOC
< {:toc}
< 
< ## From Version 1.2.0 to 1.3.0
< 
< There are no breaking changes between versions 1.2.0 and 1.3.0 of the configuration specification. Any valid 1.2.0 configuration can be updated to a 1.3.0 configuration by changing the version string in the config.
< 
< The following is a list of notable new features, deprecations, and changes.
< 
< ### Boot disk mirroring and LUKS
< 
< The config gained a new top-level `boot_device` section with `luks` and `mirror` subsections, which provide a simple way to configure encryption and/or mirroring for the boot disk. When `luks` is specified, the root filesystem is encrypted and can be unlocked with any combination of a TPM2 device and network Tang servers. When `mirror` is specified, all default partitions are replicated across multiple disks, allowing the system to survive disk failure. On aarch64 or ppc64le systems, the `layout` field must be set to `aarch64` or `ppc64le` to select the correct partition layout.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.3.0
< boot_device:
<   layout: ppc64le
<   mirror:
<     devices:
<       - /dev/sda
<       - /dev/sdb
<   luks:
<     tang:
<       - url: https://tang.example.com
<         thumbprint: REPLACE-THIS-WITH-YOUR-TANG-THUMBPRINT
<     tpm2: true
<     threshold: 2
< ```
< 
< ## From Version 1.1.0 to 1.2.0
< 
< There are no breaking changes between versions 1.1.0 and 1.2.0 of the configuration specification. Any valid 1.1.0 configuration can be updated to a 1.2.0 configuration by changing the version string in the config.
< 
< The following is a list of notable new features, deprecations, and changes.
< 
< ### Partition resizing
< 
< The `partition` section gained a new `resize` field. When true, Ignition will resize an existing partition if it matches the config in all respects except the partition size.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.2.0
< storage:
<   disks:
<     - device: /dev/sda
<       partitions:
<         - label: root
<           size_mib: 16384
<           resize: true
< ```
< 
< ### LUKS encrypted storage
< 
< Ignition now supports creating LUKS2 encrypted storage volumes. Volumes can be configured to allow unlocking with any combination of a TPM2 device via Clevis, network Tang servers via Clevis, and static key files. Alternatively, the Clevis configuration can be manually specified with a custom PIN and CFG. If a key file is not specified for a device, an ephemeral one will be created.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.2.0
< storage:
<   luks:
<     - name: static-key-example
<       device: /dev/sdb
<       key_file:
<         inline: REPLACE-THIS-WITH-YOUR-KEY-MATERIAL
<     - name: tpm-example
<       device: /dev/sdc
<       clevis:
<         tpm2: true
<     - name: tang-example
<       device: /dev/sdd
<       clevis:
<         tang:
<           - url: https://tang.example.com
<             thumbprint: REPLACE-THIS-WITH-YOUR-TANG-THUMBPRINT
<   filesystems:
<     - path: /var/lib/static_key_example
<       device: /dev/disk/by-id/dm-name-static-key-example
<       format: ext4
<       label: STATIC-EXAMPLE
<       with_mount_unit: true
<     - path: /var/lib/tpm_example
<       device: /dev/disk/by-id/dm-name-tpm-example
<       format: ext4
<       label: TPM-EXAMPLE
<       with_mount_unit: true
<     - path: /var/lib/tang_example
<       device: /dev/disk/by-id/dm-name-tang-example
<       format: ext4
<       label: TANG-EXAMPLE
<       with_mount_unit: true
< ```
< 
< ### User/group deletion
< 
< The `passwd` `users` and `groups` sections have a new field `should_exist`. If specified and false, Ignition will delete the specified user or group if it exists.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.2.0
< passwd:
<   users:
<     - name: core
<       should_exist: false
<   groups:
<     - name: core
<       should_exist: false
< ```
< 
< ### Google Cloud Storage URL support
< 
< The sections which allow fetching a remote URL now accept Google Cloud Storage (`gs://`) URLs in the `source` field.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.2.0
< storage:
<   files:
<     - path: /etc/example
<       mode: 0644
<       contents:
<         source: gs://bucket/object
< ```
< 
< ## From Version 1.0.0 to 1.1.0
< 
< There are no breaking changes between versions 1.0.0 and 1.1.0 of the configuration specification. Any valid 1.0.0 configuration can be updated to a 1.1.0 configuration by changing the version string in the config.
< 
< The following is a list of notable new features, deprecations, and changes.
< 
< ### Embedding local files in configs
< 
< The config `merge` and `replace` sections, the `certificate_authorities` section, and the files `contents` and `append` sections gained a new field called `local`, which is mutually exclusive with the `source` and `inline` fields. It causes the contents of a file from the system running FCCT to be embedded in the config. The specified path is relative to a local _files-dir_, specified with the `-d`/`--files-dir` option to FCCT. If no _files-dir_ is specified, this functionality is unavailable.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< ignition:
<   config:
<     merge:
<       - local: config.ign
<   security:
<     tls:
<       certificate_authorities:
<         - local: ca.pem
< storage:
<   files:
<     - path: /opt/file
<       contents:
<         local: file
<       append:
<         - local: file-epilogue
<       mode: 0644
< ```
< 
< ### Embedding directory trees in configs
< 
< The `storage` section gained a new subsection called `trees`. It is a list of directory trees on the system running FCCT whose files, directories, and symlinks will be embedded in the config. By default, the resulting filesystem objects are owned by `root:root`, directory modes are set to 0755, and file modes are set to 0755 if the source file is executable or 0644 otherwise. Attributes of files, directories, and symlinks can be overridden by creating an entry in the `files`, `directories`, or `links` section; such `files` entries must omit `contents` and such `links` entries must omit `target`.
< 
< Tree paths are relative to a local _files-dir_, specified with the `-d`/`--files-dir` option to FCCT. If no _files-dir_ is specified, this functionality is unavailable.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   trees:
<     - local: tree
<       path: /etc/files
<   files:
<     - path: /etc/files/overridden-file
<       mode: 0600
<       user:
<         id: 500
<       group:
<         id: 501
< ```
< 
< ### Inline contents on certificate authorities and merged configs
< 
< The `certificate_authorities` section now supports inline contents via the `inline` field. The config `merge` and `replace` sections also now support `inline`, but using this functionality is not recommended.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< ignition:
<   config:
<     merge:
<       - inline: |
<           {"ignition": {"version": "3.1.0"}}
<   security:
<     tls:
<       certificate_authorities:
<         - inline: |
<             -----BEGIN CERTIFICATE-----
<             MIICzTCCAlKgAwIBAgIJALTP0pfNBMzGMAoGCCqGSM49BAMCMIGZMQswCQYDVQQG
<             EwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNU2FuIEZyYW5jaXNj
<             bzETMBEGA1UECgwKQ29yZU9TIEluYzEUMBIGA1UECwwLRW5naW5lZXJpbmcxEzAR
<             BgNVBAMMCmNvcmVvcy5jb20xHTAbBgkqhkiG9w0BCQEWDm9lbUBjb3Jlb3MuY29t
<             MB4XDTE4MDEyNTAwMDczOVoXDTI4MDEyMzAwMDczOVowgZkxCzAJBgNVBAYTAlVT
<             MRMwEQYDVQQIDApDYWxpZm9ybmlhMRYwFAYDVQQHDA1TYW4gRnJhbmNpc2NvMRMw
<             EQYDVQQKDApDb3JlT1MgSW5jMRQwEgYDVQQLDAtFbmdpbmVlcmluZzETMBEGA1UE
<             AwwKY29yZW9zLmNvbTEdMBsGCSqGSIb3DQEJARYOb2VtQGNvcmVvcy5jb20wdjAQ
<             BgcqhkjOPQIBBgUrgQQAIgNiAAQDEhfHEulYKlANw9eR5l455gwzAIQuraa049Rh
<             vM7PPywaiD8DobteQmE8wn7cJSzOYw6GLvrL4Q1BO5EFUXknkW50t8lfnUeHveCN
<             sqvm82F1NVevVoExAUhDYmMREa6jZDBiMA8GA1UdEQQIMAaHBH8AAAEwHQYDVR0O
<             BBYEFEbFy0SPiF1YXt+9T3Jig2rNmBtpMB8GA1UdIwQYMBaAFEbFy0SPiF1YXt+9
<             T3Jig2rNmBtpMA8GA1UdEwEB/wQFMAMBAf8wCgYIKoZIzj0EAwIDaQAwZgIxAOul
<             t3MhI02IONjTDusl2YuCxMgpy2uy0MPkEGUHnUOsxmPSG0gEBCNHyeKVeTaPUwIx
<             AKbyaAqbChEy9CvDgyv6qxTYU+eeBImLKS3PH2uW5etc/69V/sDojqpH3hEffsOt
<             9g==
<             -----END CERTIFICATE-----
< ```
< 
< ### Compression support for certificate authorities and merged configs
< 
< The config `merge` and `replace` sections and the `certificate_authorities` section now support gzip-compressed resources via the `compression` field. `gzip` compression is supported for all URL schemes except `s3`.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< ignition:
<   config:
<     merge:
<       - source: https://secure.example.com/example.ign.gz
<         compression: gzip
<   security:
<     tls:
<       certificate_authorities:
<         - source: https://example.com/ca.pem.gz
<           compression: gzip
< ```
< 
< ### SHA-256 resource verification
< 
< All `verification.hash` fields now support the `sha256` hash type.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   files:
<     - path: /etc/hosts
<       mode: 0644
<       contents:
<         source: https://example.com/etc/hosts
<         verification:
<           hash: sha256-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
< ```
< 
< ### Automatic generation of mount units
< 
< The `filesystems` section gained a new `with_mount_unit` field. If `true`, a generic mount unit will be automatically generated for the specified filesystem.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   filesystems:
<     - path: /var/data
<       device: /dev/vdb1
<       format: ext4
<       with_mount_unit: true
< ```
< 
< ### Filesystem mount options
< 
< The `filesystems` section gained a new `mount_options` field. It is a list of options Ignition should pass to `mount -o` when mounting the specified filesystem. This is useful for mounting btrfs subvolumes. If the `with_mount_unit` field is `true`, this field also affects mount options used by the provisioned system when mounting the filesystem.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   filesystems:
<     - path: /var/data
<       device: /dev/vdb1
<       wipe_filesystem: false
<       format: btrfs
<       mount_options:
<         - subvolid=5
<       with_mount_unit: true
< ```
< 
< ### Custom HTTP headers
< 
< The sections which allow fetching a remote URL &mdash; config `merge` and `replace`, `certificate_authorities`, and file `contents` and `append` &mdash; gained a new field called `http_headers`. This field can be set to an array of HTTP headers which will be added to an HTTP or HTTPS request. Custom headers can override Ignition's default headers, and will not be retained across HTTP redirects.
< 
< During config merging, if a child config specifies a header `name` but not a corresponding `value`, any header with that `name` in the parent config will be removed.
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< storage:
<   files:
<     - path: /etc/hosts
<       mode: 0644
<       contents:
<         source: https://example.com/etc/hosts
<         http_headers:
<           - name: Authorization
<             value: Basic YWxhZGRpbjpvcGVuc2VzYW1l
<           - name: User-Agent
<             value: Mozilla/5.0 (compatible; MSIE 6.0; Windows NT 5.1)
< ```
< 
< ### HTTP proxies
< 
< The `ignition` section gained a new field called `proxy`. It allows configuring proxies for HTTP and HTTPS requests, as well as exempting certain hosts from proxying.
< 
< The `https_proxy` field specifies the proxy URL for HTTPS requests. The `http_proxy` field specifies the proxy URL for HTTP requests, and also for HTTPS requests if `https_proxy` is not specified. The `no_proxy` field lists specifiers of hosts that should not be proxied, in any of several formats:
< 
< - An IP address prefix (`1.2.3.4`)
< - An IP address prefix in CIDR notation (`1.2.3.4/8`)
< - A domain name, matching the domain and its subdomains (`example.com`)
< - A domain name, matching subdomains only (`.example.com`)
< - A wildcard matching all hosts (`*`)
< 
< IP addresses and domain names can also include a port number (`1.2.3.4:80`).
< 
< <!-- fedora-coreos-config -->
< ```yaml
< variant: fcos
< version: 1.1.0
< ignition:
<   proxy:
<     http_proxy: https://proxy.example.net/
<     https_proxy: https://secure.proxy.example.net/
<     no_proxy:
<      - www.example.net
< storage:
<   files:
<     - path: /etc/hosts
<       mode: 0644
<       contents:
<         source: https://example.com/etc/hosts
< ```
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/docs/specs.md updated/vendor/github.com/coreos/fcct/docs/specs.md
1,47d0
< ---
< layout: default
< has_children: true
< nav_order: 4
< has_toc: false
< ---
< 
< # Configuration specifications
< 
< CoreOS Configs must conform to a specific variant and version of the `fcct` schema, specified with the `variant` and `version` fields in the configuration.
< 
< See the [Upgrading Configs](migrating-configs.md) page for instructions to update a configuration to the latest specification.
< 
< ## Stable specification versions
< 
< We recommend that you always use the latest **stable** specification for your operating system to benefit from new features and bug fixes. The following **stable** specification versions are currently supported in `fcct`:
< 
< - Fedora CoreOS (`fcos`)
<   - [v1.3.0](config-fcos-v1_3.md)
<   - [v1.2.0](config-fcos-v1_2.md)
<   - [v1.1.0](config-fcos-v1_1.md)
<   - [v1.0.0](config-fcos-v1_0.md)
< - RHEL CoreOS (`rhcos`)
<   - [v0.1.0](config-rhcos-v0_1.md)
< 
< ## Experimental specification versions
< 
< Do not use **experimental** specifications for anything beyond **development and testing** as they are subject to change **without warning or announcement**. The following **experimental** specification versions are currently available in `fcct`:
< 
< - Fedora CoreOS (`fcos`)
<   - [v1.4.0-experimental](config-fcos-v1_4-exp.md)
< - RHEL CoreOS (`rhcos`)
<   - [v0.2.0-experimental](config-rhcos-v0_2-exp.md)
< 
< ## FCC specifications and Ignition specifications
< 
< Each version of the FCC specification corresponds to a version of the Ignition specification:
< 
< | FCC variant | FCC version        | Ignition spec      |
< |-------------|--------------------|--------------------|
< | `fcos`      | 1.0.0              | 3.0.0              |
< | `fcos`      | 1.1.0              | 3.1.0              |
< | `fcos`      | 1.2.0              | 3.2.0              |
< | `fcos`      | 1.3.0              | 3.2.0              |
< | `fcos`      | 1.4.0-experimental | 3.3.0-experimental |
< | `rhcos`     | 0.1.0              | 3.2.0              |
< | `rhcos`     | 0.2.0-experimental | 3.3.0-experimental |
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/go.mod updated/vendor/github.com/coreos/fcct/go.mod
1,17d0
< module github.com/coreos/fcct
< 
< go 1.12
< 
< require (
< 	github.com/clarketm/json v1.14.1
< 	github.com/coreos/go-semver v0.3.0
< 	github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e
< 	github.com/coreos/ignition/v2 v2.8.1
< 	github.com/coreos/vcontext v0.0.0-20201120045928-b0e13dab675c
< 	github.com/davecgh/go-spew v1.1.1 // indirect
< 	github.com/spf13/pflag v1.0.5
< 	github.com/stretchr/testify v1.5.1
< 	github.com/vincent-petithory/dataurl v0.0.0-20160330182126-9a301d65acbb
< 	gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 // indirect
< 	gopkg.in/yaml.v3 v3.0.0-20191010095647-fc94e3f71652
< )
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/go.sum updated/vendor/github.com/coreos/fcct/go.sum
1,383d0
< cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
< cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
< cloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=
< cloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=
< cloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=
< cloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=
< cloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=
< cloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=
< cloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=
< cloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=
< cloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=
< cloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=
< cloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=
< cloud.google.com/go v0.58.0/go.mod h1:W+9FnSUw6nhVwXlFcp1eL+krq5+HQUJeUogSeJZZiWg=
< cloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=
< cloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=
< cloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=
< cloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=
< cloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=
< cloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=
< cloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=
< cloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=
< cloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=
< cloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=
< cloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=
< cloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=
< cloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=
< cloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=
< cloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=
< cloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=
< cloud.google.com/go/storage v1.9.0/go.mod h1:m+/etGaqZbylxaNT876QGXqEHp4PR2Rq5GMqICWb9bU=
< dmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=
< github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
< github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=
< github.com/aws/aws-sdk-go v1.30.28/go.mod h1:5zCpMtNQVjRREroY7sYe8lOMRSxkhG6MZveU8YkpAk0=
< github.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=
< github.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=
< github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=
< github.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=
< github.com/clarketm/json v1.14.1 h1:43bkbTTKKdDx7crs3WHzkrnH6S1EvAF1VZrdFGMmmz4=
< github.com/clarketm/json v1.14.1/go.mod h1:ynr2LRfb0fQU34l07csRNBTcivjySLLiY1YzQqKVfdo=
< github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
< github.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=
< github.com/coreos/go-json v0.0.0-20170920214419-6a2fe990e083 h1:iLYct0QOZLUuTbFBf+PDiKvpG1xPicwkcgnKaGCeTgc=
< github.com/coreos/go-json v0.0.0-20170920214419-6a2fe990e083/go.mod h1:FmxyHfvrCFfCsXRylD4QQRlQmvzl+DG6iTHyEEykPfU=
< github.com/coreos/go-semver v0.3.0 h1:wkHLiw0WNATZnSG7epLsujiMCgPAc9xhjJ4tgnAxmfM=
< github.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
< github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e h1:Wf6HqHfScWJN9/ZjdUKyjop4mf3Qdd+1TvvltAvM3m8=
< github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
< github.com/coreos/go-systemd/v22 v22.0.0 h1:XJIw/+VlJ+87J+doOxznsAWIdmWuViOVhkQamW5YV28=
< github.com/coreos/go-systemd/v22 v22.0.0/go.mod h1:xO0FLkIi5MaZafQlIrOotqXZ90ih+1atmu1JpKERPPk=
< github.com/coreos/ignition/v2 v2.8.1 h1:gKCX6NwGGFh866MvpJlq2ZCqppVbWK0DA/uflL34tDU=
< github.com/coreos/ignition/v2 v2.8.1/go.mod h1:A5lFFzA2/zvZQPVEvI1lR5WPLWRb7KZ7Q1QOeUMtcAc=
< github.com/coreos/vcontext v0.0.0-20201120045928-b0e13dab675c h1:jA28WeORitsxGFVWhyWB06sAG2HbLHPQuHwDydhU2CQ=
< github.com/coreos/vcontext v0.0.0-20201120045928-b0e13dab675c/go.mod h1:z4pMVvaUrxs98RROlIYdAQCKhEicjnTirOaVyDRH5h8=
< github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=
< github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
< github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
< github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
< github.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
< github.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=
< github.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=
< github.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=
< github.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=
< github.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
< github.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=
< github.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=
< github.com/godbus/dbus/v5 v5.0.3/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
< github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
< github.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
< github.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
< github.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
< github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
< github.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
< github.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=
< github.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
< github.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
< github.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=
< github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
< github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
< github.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
< github.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
< github.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=
< github.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=
< github.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=
< github.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=
< github.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=
< github.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=
< github.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=
< github.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=
< github.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=
< github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
< github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
< github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
< github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
< github.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
< github.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
< github.com/google/go-cmp v0.4.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
< github.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=
< github.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
< github.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
< github.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
< github.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
< github.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
< github.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
< github.com/google/pprof v0.0.0-20200507031123-427632fa3b1c/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=
< github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
< github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
< github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=
< github.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=
< github.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=
< github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
< github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
< github.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=
< github.com/jmespath/go-jmespath v0.3.0/go.mod h1:9QtRXoHjLGCJ5IBSaohpXITPlowMeeYCZ7fLUTSywik=
< github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=
< github.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=
< github.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=
< github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
< github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
< github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
< github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
< github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
< github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
< github.com/pin/tftp v2.1.0+incompatible/go.mod h1:xVpZOMCXTy+A5QMjEVN0Glwa1sUvaJhFXbr/aAxuxGY=
< github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
< github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
< github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
< github.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
< github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
< github.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=
< github.com/smartystreets/goconvey v0.0.0-20190222223459-a17d461953aa/go.mod h1:2RVY1rIf+2J2o/IM9+vPq9RzmHDSseB7FoXiSNIUsoU=
< github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
< github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
< github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
< github.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=
< github.com/stretchr/testify v1.5.1 h1:nOGnQDM7FYENwehXlg/kFVnos3rEvtKTjRvOWSzb6H4=
< github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
< github.com/vincent-petithory/dataurl v0.0.0-20160330182126-9a301d65acbb h1:lyL3z7vYwTWXf4/bI+A01+cCSnfhKIBhy+SQ46Z/ml8=
< github.com/vincent-petithory/dataurl v0.0.0-20160330182126-9a301d65acbb/go.mod h1:FHafX5vmDzyP+1CQATJn7WFKc9CvnvxyvZy6I1MrG/U=
< github.com/vmware/vmw-guestinfo v0.0.0-20170707015358-25eff159a728/go.mod h1:x9oS4Wk2s2u4tS29nEaDLdzvuHdB19CvSGJjPgkZJNk=
< github.com/vmware/vmw-ovflib v0.0.0-20170608004843-1f217b9dc714/go.mod h1:jiPk45kn7klhByRvUq5i2vo1RtHKBHj+iWGFpxbXuuI=
< github.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
< github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
< go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=
< go.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=
< go.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
< go.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=
< go.opencensus.io v0.22.5/go.mod h1:5pWMHQbX5EPX2/62yrJeAkowc+lfs/XD7Uxpq3pI6kk=
< golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
< golang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
< golang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
< golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
< golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
< golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
< golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
< golang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=
< golang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=
< golang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
< golang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
< golang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=
< golang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=
< golang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=
< golang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=
< golang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=
< golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
< golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
< golang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
< golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
< golang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
< golang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
< golang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
< golang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=
< golang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
< golang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=
< golang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=
< golang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=
< golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
< golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
< golang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
< golang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=
< golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
< golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
< golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
< golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
< golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
< golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
< golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
< golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
< golang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
< golang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
< golang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
< golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
< golang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
< golang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
< golang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
< golang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
< golang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
< golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
< golang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
< golang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
< golang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
< golang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
< golang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
< golang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
< golang.org/x/net v0.0.0-20200602114024-627f9648deb9/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=
< golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
< golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
< golang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
< golang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
< golang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
< golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
< golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
< golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
< golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
< golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
< golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
< golang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
< golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
< golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
< golang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/sys v0.0.0-20200610111108-226ff32320da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
< golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
< golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
< golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
< golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
< golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
< golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
< golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
< golang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
< golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
< golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
< golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
< golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
< golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
< golang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
< golang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
< golang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
< golang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
< golang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
< golang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
< golang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
< golang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
< golang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
< golang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
< golang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
< golang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
< golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
< golang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
< golang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
< golang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=
< golang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
< golang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=
< golang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=
< golang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
< golang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
< golang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
< golang.org/x/tools v0.0.0-20200601175630-2caf76543d99/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
< golang.org/x/tools v0.0.0-20200606014950-c42cb6316fb6/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
< golang.org/x/tools v0.0.0-20200610160956-3e83d1e96d0e/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
< golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
< golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
< golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
< google.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=
< google.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=
< google.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
< google.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=
< google.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
< google.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
< google.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=
< google.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
< google.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
< google.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
< google.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
< google.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=
< google.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
< google.golang.org/api v0.26.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=
< google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
< google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
< google.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
< google.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=
< google.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
< google.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=
< google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
< google.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
< google.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
< google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
< google.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
< google.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
< google.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=
< google.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=
< google.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
< google.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
< google.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
< google.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
< google.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
< google.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=
< google.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=
< google.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
< google.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
< google.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
< google.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
< google.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
< google.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
< google.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
< google.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=
< google.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=
< google.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=
< google.golang.org/genproto v0.0.0-20200603110839-e855014d5736/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
< google.golang.org/genproto v0.0.0-20200608115520-7c474a2e3482/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
< google.golang.org/genproto v0.0.0-20200610104632-a5b850bcf112/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=
< google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
< google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=
< google.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=
< google.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=
< google.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=
< google.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
< google.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
< google.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=
< google.golang.org/grpc v1.28.0/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=
< google.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=
< google.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=
< google.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=
< google.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=
< google.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=
< google.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=
< google.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
< google.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
< google.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=
< google.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=
< gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=
< gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
< gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=
< gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
< gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15 h1:YR8cESwS4TdDjEe65xsg0ogRM/Nc3DYOhEAlW+xobZo=
< gopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
< gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
< gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=
< gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
< gopkg.in/yaml.v3 v3.0.0-20190502103701-55513cacd4ae h1:ehhBuCxzgQEGk38YjhFv/97fMIc2JGHZAhAWMmEjmu0=
< gopkg.in/yaml.v3 v3.0.0-20190502103701-55513cacd4ae/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
< gopkg.in/yaml.v3 v3.0.0-20191010095647-fc94e3f71652 h1:VKvJ/mQ4BgCjZUDggYFxTe0qv9jPMHsZPD4Xt91Y5H4=
< gopkg.in/yaml.v3 v3.0.0-20191010095647-fc94e3f71652/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
< honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
< honnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
< honnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
< honnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
< honnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=
< honnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
< honnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=
< rsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=
< rsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=
< rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/internal/main.go updated/vendor/github.com/coreos/fcct/internal/main.go
1,111d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package main
< 
< import (
< 	"fmt"
< 	"io/ioutil"
< 	"os"
< 
< 	"github.com/spf13/pflag"
< 
< 	"github.com/coreos/fcct/config"
< 	"github.com/coreos/fcct/config/common"
< 	"github.com/coreos/fcct/internal/version"
< )
< 
< func fail(format string, args ...interface{}) {
< 	fmt.Fprintf(os.Stderr, format, args...)
< 	os.Exit(1)
< }
< 
< func main() {
< 	var (
< 		input       string
< 		output      string
< 		helpFlag    bool
< 		versionFlag bool
< 	)
< 	options := common.TranslateBytesOptions{}
< 	pflag.BoolVarP(&helpFlag, "help", "h", false, "show usage and exit")
< 	pflag.BoolVarP(&versionFlag, "version", "V", false, "print the version and exit")
< 	pflag.BoolVarP(&options.Strict, "strict", "s", false, "fail on any warning")
< 	pflag.BoolVarP(&options.Pretty, "pretty", "p", false, "output formatted json")
< 	pflag.StringVar(&input, "input", "", "read from input file instead of stdin")
< 	pflag.Lookup("input").Deprecated = "specify filename directly on command line"
< 	pflag.Lookup("input").Hidden = true
< 	pflag.StringVarP(&output, "output", "o", "", "write to output file instead of stdout")
< 	pflag.StringVarP(&options.FilesDir, "files-dir", "d", "", "allow embedding local files from this directory")
< 
< 	pflag.Usage = func() {
< 		fmt.Fprintf(os.Stderr, "Usage: %s [options] [input-file]\n", os.Args[0])
< 		fmt.Fprintf(os.Stderr, "Options:\n")
< 		pflag.PrintDefaults()
< 	}
< 	pflag.Parse()
< 
< 	args := pflag.Args()
< 	if len(args) == 1 && input == "" {
< 		input = args[0]
< 	} else if len(args) > 0 {
< 		pflag.Usage()
< 		os.Exit(2)
< 	}
< 
< 	if helpFlag {
< 		pflag.Usage()
< 		os.Exit(0)
< 	}
< 
< 	if versionFlag {
< 		fmt.Println(version.String)
< 		os.Exit(0)
< 	}
< 
< 	var infile *os.File = os.Stdin
< 	var outfile *os.File = os.Stdout
< 	if input != "" {
< 		var err error
< 		infile, err = os.Open(input)
< 		if err != nil {
< 			fail("failed to open %s: %v\n", input, err)
< 		}
< 		defer infile.Close()
< 	}
< 
< 	dataIn, err := ioutil.ReadAll(infile)
< 	if err != nil {
< 		fail("failed to read %s: %v\n", infile.Name(), err)
< 	}
< 
< 	dataOut, r, err := config.TranslateBytes(dataIn, options)
< 	fmt.Fprintf(os.Stderr, "%s", r.String())
< 	if err != nil {
< 		fail("Error translating config: %v\n", err)
< 	}
< 
< 	if output != "" {
< 		var err error
< 		outfile, err = os.OpenFile(output, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
< 		if err != nil {
< 			fail("failed to open %s: %v\n", output, err)
< 		}
< 		defer outfile.Close()
< 	}
< 
< 	if _, err := outfile.Write(append(dataOut, '\n')); err != nil {
< 		fail("Failed to write config to %s: %v\n", outfile.Name(), err)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/internal/version/version.go updated/vendor/github.com/coreos/fcct/internal/version/version.go
1,24d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package version
< 
< import (
< 	"fmt"
< )
< 
< var (
< 	Raw    = "was not built properly"
< 	String = fmt.Sprintf("Fedora CoreOS Config Transpiler %s", Raw)
< )
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/tag_release.sh updated/vendor/github.com/coreos/fcct/tag_release.sh
1,23d0
< #!/usr/bin/env bash
< 
< set -e
< 
< [ $# == 2 ] || { echo "usage: $0 <version> <commit>" && exit 1; }
< 
< VER=$1
< COMMIT=$2
< 
< [[ "${VER}" =~ ^v[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+(-.+)?$ ]] || {
< 	echo "malformed version: \"${VER}\""
< 	exit 2
< }
< 
< [[ "${COMMIT}" =~ ^[[:xdigit:]]+$ ]] || {
< 	echo "malformed commit id: \"${COMMIT}\""
< 	exit 3
< }
< 
< source ./build
< 
< git tag --sign --message "Fedora CoreOS Config Transpiler ${VER}" "${VER}" "${COMMIT}"
< git verify-tag --verbose "${VER}"
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/test updated/vendor/github.com/coreos/fcct/test
1,42d0
< #!/bin/bash
< set -euo pipefail
< 
< export GO111MODULE=on
< export GOFLAGS=-mod=vendor
< 
< SRC=$(find . -name '*.go' -not -path "./vendor/*")
< 
< echo "checking gofmt"
< res=$(gofmt -d $SRC)
< echo "$res"
< test -z "$res"
< 
< echo "Running tests"
< go test ./... -cover
< 
< echo "Checking docs"
< shopt -s nullglob
< mkdir tmpdocs
< trap 'rm -r tmpdocs' EXIT
< # Create files-dir contents expected by configs
< mkdir -p tmpdocs/files-dir/tree
< touch tmpdocs/files-dir/{config.ign,ca.pem,file,file-epilogue,local-file3}
< 
< for doc in docs/*md
< do
< 	echo "Checking $doc"
< 	# split each doc into a bunch of tmpfiles then run fcct on them
< 	sed -n '/^<!-- fedora-coreos-config -->/,/^```$/ p' < ${doc} \
< 		| csplit - '/<!-- fedora-coreos-config -->/' '{*}' -z --prefix "tmpdocs/fcc_$(basename ${doc%.*})_" -q
< 
< 	for i in tmpdocs/fcc_*
< 	do
< 		echo "Checking $i"
< 		cat "$i" | tail -n +3 | head -n -1 \
< 			| go run internal/main.go --strict --files-dir tmpdocs/files-dir > /dev/null \
< 			|| (cat -n "$i" && false)
< 	done
< 	rm -f tmpdocs/fcc_*
< done
< 
< echo ok
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/translate/set.go updated/vendor/github.com/coreos/fcct/translate/set.go
1,117d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package translate
< 
< import (
< 	"fmt"
< 	"reflect"
< 
< 	"github.com/coreos/vcontext/path"
< )
< 
< // Translation represents how a path changes when translating. If something at $yaml.storage.filesystems.4
< // generates content at $json.systemd.units.3 a translation can represent that. This allows validation errors
< // in Ignition structs to be tracked back to their source in the yaml.
< type Translation struct {
< 	From path.ContextPath
< 	To   path.ContextPath
< }
< 
< // TranslationSet represents all of the translations that occurred. They're stored in a map from a string representation
< // of the destination path to the translation struct. The map is purely an optimization to allow fast lookups. Ideally the
< // map would just be from the destination path.ContextPath to the source path.ContextPath, but ContextPath contains a slice
< // which are not comparable and thus cannot be used as keys in maps.
< type TranslationSet struct {
< 	FromTag string
< 	ToTag   string
< 	Set     map[string]Translation
< }
< 
< func NewTranslationSet(fromTag, toTag string) TranslationSet {
< 	return TranslationSet{
< 		FromTag: fromTag,
< 		ToTag:   toTag,
< 		Set:     map[string]Translation{},
< 	}
< }
< 
< func (ts TranslationSet) String() string {
< 	str := fmt.Sprintf("from: %v\nto: %v\n", ts.FromTag, ts.ToTag)
< 	for k, v := range ts.Set {
< 		str += fmt.Sprintf("%s: %v -> %v\n", k, v.From.String(), v.To.String())
< 	}
< 	return str
< }
< 
< // AddTranslation adds a translation to the set
< func (ts TranslationSet) AddTranslation(from, to path.ContextPath) {
< 	// create copies of the paths so if someone else changes from.Path the added translation does not change.
< 	from = from.Copy()
< 	to = to.Copy()
< 	translation := Translation{
< 		From: from,
< 		To:   to,
< 	}
< 	toString := translation.To.String()
< 	ts.Set[toString] = translation
< }
< 
< // Shortcut for AddTranslation for identity translations
< func (ts TranslationSet) AddIdentity(paths ...string) {
< 	for _, p := range paths {
< 		from := path.New(ts.FromTag, p)
< 		to := path.New(ts.ToTag, p)
< 		ts.AddTranslation(from, to)
< 	}
< }
< 
< // AddFromCommonSource adds translations for all of the paths in to from a single common path. This is useful
< // if one part of a config generates a large struct and all of the large struct should map to one path in the
< // config being translated.
< func (ts TranslationSet) AddFromCommonSource(common path.ContextPath, toPrefix path.ContextPath, to interface{}) {
< 	v := reflect.ValueOf(to)
< 	vPaths := prefixPaths(getAllPaths(v, ts.ToTag), toPrefix.Path...)
< 	for _, path := range vPaths {
< 		ts.AddTranslation(common, path)
< 	}
< }
< 
< // Merge adds all the entries to the set. It mutates the Set in place.
< func (ts TranslationSet) Merge(from TranslationSet) {
< 	for _, t := range from.Set {
< 		ts.AddTranslation(t.From, t.To)
< 	}
< }
< 
< // MergeP is like Merge, but first it calls Prefix on the set being merged in.
< func (ts TranslationSet) MergeP(prefix interface{}, from TranslationSet) {
< 	from = from.Prefix(prefix)
< 	ts.Merge(from)
< }
< 
< // Prefix returns a TranslationSet with all translation paths prefixed by prefix.
< func (ts TranslationSet) Prefix(prefix interface{}) TranslationSet {
< 	return ts.PrefixPaths(path.New(ts.FromTag, prefix), path.New(ts.ToTag, prefix))
< }
< 
< // PrefixPaths returns a TranslationSet with from translation paths prefixed by
< // fromPrefix and to translation paths prefixed by toPrefix.
< func (ts TranslationSet) PrefixPaths(fromPrefix, toPrefix path.ContextPath) TranslationSet {
< 	ret := NewTranslationSet(ts.FromTag, ts.ToTag)
< 	for _, tr := range ts.Set {
< 		ret.AddTranslation(fromPrefix.Append(tr.From.Path...), toPrefix.Append(tr.To.Path...))
< 	}
< 	return ret
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/translate/tests/pkga/types.go updated/vendor/github.com/coreos/fcct/translate/tests/pkga/types.go
1,42d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package pkga
< 
< type Trivial struct {
< 	A string
< 	B int
< 	C bool
< }
< 
< type Nested struct {
< 	D string
< 	Trivial
< }
< 
< type TrivialReordered struct {
< 	B int
< 	A string
< 	C bool
< }
< 
< type HasList struct {
< 	L []Trivial
< }
< 
< type TrivialSkip struct {
< 	A string `fcct:"auto_skip"`
< 	B int
< 	C bool
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/translate/tests/pkgb/types.go updated/vendor/github.com/coreos/fcct/translate/tests/pkgb/types.go
1,42d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package pkgb
< 
< type Trivial struct {
< 	A string
< 	B int
< 	C bool
< }
< 
< type Nested struct {
< 	D string
< 	Trivial
< }
< 
< // note: struct ordering is different from pkga
< type TrivialReordered struct {
< 	A string
< 	B int
< 	C bool
< }
< 
< type HasList struct {
< 	L []Nested
< }
< 
< type TrivialSkip struct {
< 	B int
< 	C bool
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/translate/tests/readme.txt updated/vendor/github.com/coreos/fcct/translate/tests/readme.txt
1,3d0
< Tests for this translator are in their own package since it needs to test
< translating from one package to another. This pattern should not be replicated
< in other places in the codebase
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/translate/translate.go updated/vendor/github.com/coreos/fcct/translate/translate.go
1,273d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package translate
< 
< import (
< 	"fmt"
< 	"reflect"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< /*
<  * This is an automatic translator that replace boilerplate code to copy one
<  * struct into a nearly identical struct in another package. To use it first
<  * call NewTranslator() to get a translator instance. This can then have
<  * additional translation rules (in the form of functions) to translate from
<  * types in one struct to the other. Those functions are in the form:
<  *     func(fromType, optionsType) -> (toType, TranslationSet, report.Report)
<  * These can be closures that reference the translator as well. This allows for
<  * manually translating some fields but resuming automatic translation on the
<  * other fields through the Translator.Translate() function.
<  */
< 
< const (
< 	TAG_KEY       = "fcct"
< 	TAG_AUTO_SKIP = "auto_skip"
< )
< 
< var (
< 	translationsType = reflect.TypeOf(TranslationSet{})
< 	reportType       = reflect.TypeOf(report.Report{})
< )
< 
< // Returns if this type can be translated without a custom translator. Children or other
< // ancestors might require custom translators however
< func (t translator) translatable(t1, t2 reflect.Type) bool {
< 	k1 := t1.Kind()
< 	k2 := t2.Kind()
< 	if k1 != k2 {
< 		return false
< 	}
< 	switch {
< 	case util.IsPrimitive(k1):
< 		return true
< 	case util.IsInvalidInConfig(k1):
< 		panic(fmt.Sprintf("Encountered invalid kind %s in config. This is a bug, please file a report", k1))
< 	case k1 == reflect.Ptr || k1 == reflect.Slice:
< 		return t.translatable(t1.Elem(), t2.Elem()) || t.hasTranslator(t1.Elem(), t2.Elem())
< 	case k1 == reflect.Struct:
< 		return t.translatableStruct(t1, t2)
< 	default:
< 		panic(fmt.Sprintf("Encountered unknown kind %s in config. This is a bug, please file a report", k1))
< 	}
< }
< 
< // precondition: t1, t2 are both of Kind 'struct'
< func (t translator) translatableStruct(t1, t2 reflect.Type) bool {
< 	if t1.Name() != t2.Name() {
< 		return false
< 	}
< 	t1Fields := 0
< 	for i := 0; i < t1.NumField(); i++ {
< 		t1f := t1.Field(i)
< 		if t1f.Tag.Get(TAG_KEY) == TAG_AUTO_SKIP {
< 			// ignore this input field
< 			continue
< 		}
< 		t1Fields++
< 
< 		t2f, ok := t2.FieldByName(t1f.Name)
< 		if !ok {
< 			return false
< 		}
< 		if !t.translatable(t1f.Type, t2f.Type) && !t.hasTranslator(t1f.Type, t2f.Type) {
< 			return false
< 		}
< 	}
< 	return t2.NumField() == t1Fields
< }
< 
< // checks that t could reasonably be the type of a translator function
< func (t translator) couldBeValidTranslator(tr reflect.Type) bool {
< 	if tr.Kind() != reflect.Func {
< 		return false
< 	}
< 	if tr.NumIn() != 2 || tr.NumOut() != 3 {
< 		return false
< 	}
< 	if util.IsInvalidInConfig(tr.In(0).Kind()) ||
< 		util.IsInvalidInConfig(tr.Out(0).Kind()) ||
< 		tr.In(1) != reflect.TypeOf(t.options) ||
< 		tr.Out(1) != translationsType ||
< 		tr.Out(2) != reportType {
< 		return false
< 	}
< 	return true
< }
< 
< // translate from one type to another, but deep copy all data
< // precondition: vFrom and vTo are the same type as defined by translatable()
< // precondition: vTo is addressable and settable
< func (t translator) translateSameType(vFrom, vTo reflect.Value, fromPath, toPath path.ContextPath) {
< 	k := vFrom.Kind()
< 	switch {
< 	case util.IsPrimitive(k):
< 		// Use convert, even if not needed; type alias to primitives are not
< 		// directly assignable and calling Convert on primitives does no harm
< 		vTo.Set(vFrom.Convert(vTo.Type()))
< 		t.translations.AddTranslation(fromPath, toPath)
< 	case k == reflect.Ptr:
< 		if vFrom.IsNil() {
< 			return
< 		}
< 		vTo.Set(reflect.New(vTo.Type().Elem()))
< 		t.translate(vFrom.Elem(), vTo.Elem(), fromPath, toPath)
< 	case k == reflect.Slice:
< 		if vFrom.IsNil() {
< 			return
< 		}
< 		vTo.Set(reflect.MakeSlice(vTo.Type(), vFrom.Len(), vFrom.Len()))
< 		for i := 0; i < vFrom.Len(); i++ {
< 			t.translate(vFrom.Index(i), vTo.Index(i), fromPath.Append(i), toPath.Append(i))
< 		}
< 	case k == reflect.Struct:
< 		for i := 0; i < vFrom.NumField(); i++ {
< 			if vFrom.Type().Field(i).Tag.Get(TAG_KEY) == TAG_AUTO_SKIP {
< 				// ignore this input field
< 				continue
< 			}
< 			fieldGoName := vFrom.Type().Field(i).Name
< 			toStructField, ok := vTo.Type().FieldByName(fieldGoName)
< 			if !ok {
< 				panic("vTo did not have a matching type. This is a bug; please file a report")
< 			}
< 			toFieldIndex := toStructField.Index[0]
< 			vToField := vTo.FieldByName(fieldGoName)
< 
< 			from := fromPath.Append(fieldName(vFrom, i, fromPath.Tag))
< 			to := toPath.Append(fieldName(vTo, toFieldIndex, toPath.Tag))
< 			if vFrom.Type().Field(i).Anonymous {
< 				from = fromPath
< 				to = toPath
< 			}
< 			t.translate(vFrom.Field(i), vToField, from, to)
< 		}
< 	default:
< 		panic("Encountered types that are not the same when they should be. This is a bug, please file a report")
< 	}
< }
< 
< // helper to return if a custom translator was defined
< func (t translator) hasTranslator(tFrom, tTo reflect.Type) bool {
< 	return t.getTranslator(tFrom, tTo).IsValid()
< }
< 
< // vTo must be addressable, should be acquired by calling reflect.ValueOf() on a variable of the correct type
< func (t translator) translate(vFrom, vTo reflect.Value, fromPath, toPath path.ContextPath) {
< 	tFrom := vFrom.Type()
< 	tTo := vTo.Type()
< 	if fnv := t.getTranslator(tFrom, tTo); fnv.IsValid() {
< 		returns := fnv.Call([]reflect.Value{vFrom, reflect.ValueOf(t.options)})
< 		vTo.Set(returns[0])
< 
< 		// handle all the translations and "rebase" them to our current place
< 		retSet := returns[1].Interface().(TranslationSet)
< 		for _, trans := range retSet.Set {
< 			from := fromPath.Append(trans.From.Path...)
< 			to := toPath.Append(trans.To.Path...)
< 			t.translations.AddTranslation(from, to)
< 		}
< 
< 		// likewise for the report entries
< 		retReport := returns[2].Interface().(report.Report)
< 		for i := range retReport.Entries {
< 			entry := &retReport.Entries[i]
< 			entry.Context = fromPath.Append(entry.Context.Path...)
< 		}
< 		t.report.Merge(retReport)
< 		return
< 	}
< 	if t.translatable(tFrom, tTo) {
< 		t.translateSameType(vFrom, vTo, fromPath, toPath)
< 		return
< 	}
< 
< 	panic(fmt.Sprintf("Translator not defined for %v to %v", tFrom, tTo))
< }
< 
< type Translator interface {
< 	// Adds a custom translator for cases where the structs are not identical. Must be of type
< 	// func(fromType, optionsType) -> (toType, TranslationSet, report.Report).
< 	// The translator should return the set of all translations it did.
< 	AddCustomTranslator(t interface{})
< 	// Also returns a list of source and dest paths, autocompleted by fromTag and toTag
< 	Translate(from, to interface{}) (TranslationSet, report.Report)
< }
< 
< // NewTranslator creates a new Translator for translating from types with fromTag struct tags (e.g. "yaml")
< // to types with toTag struct tages (e.g. "json"). These tags are used when determining paths when generating
< // the TranslationSet returned by Translator.Translate()
< func NewTranslator(fromTag, toTag string, options interface{}) Translator {
< 	return &translator{
< 		options: options,
< 		translations: TranslationSet{
< 			FromTag: fromTag,
< 			ToTag:   toTag,
< 			Set:     map[string]Translation{},
< 		},
< 	}
< }
< 
< type translator struct {
< 	options interface{}
< 	// List of custom translation funcs, must pass couldBeValidTranslator
< 	// This is only for fields that cannot or should not be trivially translated,
< 	// All trivially translated fields use the default behavior.
< 	translators  []reflect.Value
< 	translations TranslationSet
< 	report       *report.Report
< }
< 
< // fn should be of the form
< // func(fromType, optionsType) -> (toType, TranslationSet, report.Report)
< func (t *translator) AddCustomTranslator(fn interface{}) {
< 	fnv := reflect.ValueOf(fn)
< 	if !t.couldBeValidTranslator(fnv.Type()) {
< 		panic("Tried to register invalid translator function")
< 	}
< 	t.translators = append(t.translators, fnv)
< }
< 
< func (t translator) getTranslator(from, to reflect.Type) reflect.Value {
< 	for _, fn := range t.translators {
< 		if fn.Type().In(0) == from && fn.Type().Out(0) == to {
< 			return fn
< 		}
< 	}
< 	return reflect.Value{}
< }
< 
< // Translate translates from into to and returns a set of all the path changes it performed.
< func (t translator) Translate(from, to interface{}) (TranslationSet, report.Report) {
< 	fv := reflect.ValueOf(from)
< 	tv := reflect.ValueOf(to)
< 	if fv.Kind() != reflect.Ptr || tv.Kind() != reflect.Ptr {
< 		panic("Translate needs to be called on pointers")
< 	}
< 	fv = fv.Elem()
< 	tv = tv.Elem()
< 	// Make sure to clear these every time
< 	t.translations = TranslationSet{
< 		FromTag: t.translations.FromTag,
< 		ToTag:   t.translations.ToTag,
< 		Set:     map[string]Translation{},
< 	}
< 	t.report = &report.Report{}
< 	t.translate(fv, tv, path.New(t.translations.FromTag), path.New(t.translations.ToTag))
< 	return t.translations, *t.report
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/translate/translate_test.go updated/vendor/github.com/coreos/fcct/translate/translate_test.go
1,346d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package translate
< 
< import (
< 	"errors"
< 	"testing"
< 
< 	"github.com/coreos/fcct/translate/tests/pkga"
< 	"github.com/coreos/fcct/translate/tests/pkgb"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/stretchr/testify/assert"
< )
< 
< type testOptions struct{}
< 
< // Note: we need different input and output types which unfortunately means a lot of tests
< 
< // mkTrans makes a TranslationSet with no tag in the paths consuming pairs of args. i.e:
< // mkTrans(from1, to1, from2, to2) -> a set wiht from1->to1, from2->to2
< // This is just a shorthand for making writing tests easier
< func mkTrans(paths ...path.ContextPath) TranslationSet {
< 	ret := TranslationSet{Set: map[string]Translation{}}
< 	if len(paths)%2 == 1 {
< 		panic("Odd number of args to mkTrans")
< 	}
< 	for i := 0; i < len(paths); i += 2 {
< 		ret.AddTranslation(paths[i], paths[i+1])
< 	}
< 	return ret
< }
< 
< // fp means "fastpath"; super shorthand, we'll use it a lot
< func fp(parts ...interface{}) path.ContextPath {
< 	return path.New("", parts...)
< }
< 
< func TestTranslateTrivial(t *testing.T) {
< 	in := pkga.Trivial{
< 		A: "asdf",
< 		B: 5,
< 		C: true,
< 	}
< 
< 	expected := pkgb.Trivial{
< 		A: "asdf",
< 		B: 5,
< 		C: true,
< 	}
< 	exTrans := mkTrans(
< 		fp("A"), fp("A"),
< 		fp("B"), fp("B"),
< 		fp("C"), fp("C"),
< 	)
< 
< 	got := pkgb.Trivial{}
< 
< 	trans := NewTranslator("", "", testOptions{})
< 
< 	ts, r := trans.Translate(&in, &got)
< 	assert.Equal(t, got, expected, "bad translation")
< 	assert.Equal(t, ts, exTrans, "bad translation")
< 	assert.Equal(t, r.String(), "", "non-empty report")
< }
< 
< func TestTranslateNested(t *testing.T) {
< 	in := pkga.Nested{
< 		D: "foobar",
< 		Trivial: pkga.Trivial{
< 			A: "asdf",
< 			B: 5,
< 			C: true,
< 		},
< 	}
< 
< 	expected := pkgb.Nested{
< 		D: "foobar",
< 		Trivial: pkgb.Trivial{
< 			A: "asdf",
< 			B: 5,
< 			C: true,
< 		},
< 	}
< 	exTrans := mkTrans(
< 		fp("A"), fp("A"),
< 		fp("B"), fp("B"),
< 		fp("C"), fp("C"),
< 		fp("D"), fp("D"),
< 	)
< 
< 	got := pkgb.Nested{}
< 
< 	trans := NewTranslator("", "", testOptions{})
< 
< 	ts, r := trans.Translate(&in, &got)
< 	assert.Equal(t, got, expected, "bad translation")
< 	assert.Equal(t, ts, exTrans, "bad translation")
< 	assert.Equal(t, r.String(), "", "non-empty report")
< }
< 
< func TestTranslateTrivialReordered(t *testing.T) {
< 	in := pkga.TrivialReordered{
< 		A: "asdf",
< 		B: 5,
< 		C: true,
< 	}
< 
< 	expected := pkgb.TrivialReordered{
< 		A: "asdf",
< 		B: 5,
< 		C: true,
< 	}
< 	exTrans := mkTrans(
< 		fp("A"), fp("A"),
< 		fp("B"), fp("B"),
< 		fp("C"), fp("C"),
< 	)
< 
< 	got := pkgb.TrivialReordered{}
< 
< 	trans := NewTranslator("", "", testOptions{})
< 
< 	ts, r := trans.Translate(&in, &got)
< 	assert.Equal(t, got, expected, "bad translation")
< 	assert.Equal(t, ts, exTrans, "bad translation")
< 	assert.Equal(t, r.String(), "", "non-empty report")
< }
< 
< func TestTranslateTrivialSkip(t *testing.T) {
< 	in := pkga.TrivialSkip{
< 		A: "asdf",
< 		B: 5,
< 		C: true,
< 	}
< 
< 	expected := pkgb.TrivialSkip{
< 		B: 5,
< 		C: true,
< 	}
< 	exTrans := mkTrans(
< 		fp("B"), fp("B"),
< 		fp("C"), fp("C"),
< 	)
< 
< 	got := pkgb.TrivialSkip{}
< 
< 	trans := NewTranslator("", "", testOptions{})
< 
< 	ts, r := trans.Translate(&in, &got)
< 	assert.Equal(t, got, expected, "bad translation")
< 	assert.Equal(t, ts, exTrans, "bad translation")
< 	assert.Equal(t, r.String(), "", "non-empty report")
< }
< 
< func TestCustomTranslatorTrivial(t *testing.T) {
< 	tr := func(a pkga.Trivial, options testOptions) (pkgb.Nested, TranslationSet, report.Report) {
< 		ts := mkTrans(fp("A"), fp("A"),
< 			fp("B"), fp("B"),
< 			fp("C"), fp("C"),
< 			fp("C"), fp("D"),
< 		)
< 		var r report.Report
< 		r.AddOnInfo(fp("A"), errors.New("info"))
< 		return pkgb.Nested{
< 			Trivial: pkgb.Trivial{
< 				A: a.A,
< 				B: a.B,
< 				C: a.C,
< 			},
< 			D: "abc",
< 		}, ts, r
< 	}
< 	in := pkga.Trivial{
< 		A: "asdf",
< 		B: 5,
< 		C: true,
< 	}
< 
< 	expected := pkgb.Nested{
< 		D: "abc",
< 		Trivial: pkgb.Trivial{
< 			A: "asdf",
< 			B: 5,
< 			C: true,
< 		},
< 	}
< 	exTrans := mkTrans(
< 		fp("A"), fp("A"),
< 		fp("B"), fp("B"),
< 		fp("C"), fp("C"),
< 		fp("C"), fp("D"),
< 	)
< 
< 	got := pkgb.Nested{}
< 
< 	trans := NewTranslator("", "", testOptions{})
< 	trans.AddCustomTranslator(tr)
< 
< 	ts, r := trans.Translate(&in, &got)
< 	assert.Equal(t, got, expected, "bad translation")
< 	assert.Equal(t, ts, exTrans, "bad translation")
< 	assert.Equal(t, r.String(), "info at $.A: info\n", "bad report")
< }
< 
< func TestCustomTranslatorTrivialWithAutomaticResume(t *testing.T) {
< 	trans := NewTranslator("", "", testOptions{})
< 	tr := func(a pkga.Trivial, options testOptions) (pkgb.Nested, TranslationSet, report.Report) {
< 		ret := pkgb.Nested{
< 			D: "abc",
< 		}
< 		ts, r := trans.Translate(&a, &ret.Trivial)
< 		ts.AddTranslation(fp("C"), fp("D"))
< 		return ret, ts, r
< 	}
< 	in := pkga.Trivial{
< 		A: "asdf",
< 		B: 5,
< 		C: true,
< 	}
< 	exTrans := mkTrans(
< 		fp("A"), fp("A"),
< 		fp("B"), fp("B"),
< 		fp("C"), fp("C"),
< 		fp("C"), fp("D"),
< 	)
< 
< 	expected := pkgb.Nested{
< 		D: "abc",
< 		Trivial: pkgb.Trivial{
< 			A: "asdf",
< 			B: 5,
< 			C: true,
< 		},
< 	}
< 
< 	got := pkgb.Nested{}
< 
< 	trans.AddCustomTranslator(tr)
< 
< 	ts, r := trans.Translate(&in, &got)
< 	assert.Equal(t, got, expected, "bad translation")
< 	assert.Equal(t, ts, exTrans, "bad translation")
< 	assert.Equal(t, r.String(), "", "non-empty report")
< }
< 
< func TestCustomTranslatorList(t *testing.T) {
< 	tr := func(a pkga.Trivial, options testOptions) (pkgb.Nested, TranslationSet, report.Report) {
< 		ts := mkTrans(fp("A"), fp("A"),
< 			fp("B"), fp("B"),
< 			fp("C"), fp("C"),
< 			fp("C"), fp("D"),
< 		)
< 		return pkgb.Nested{
< 			Trivial: pkgb.Trivial{
< 				A: a.A,
< 				B: a.B,
< 				C: a.C,
< 			},
< 			D: "abc",
< 		}, ts, report.Report{}
< 	}
< 	in := pkga.HasList{
< 		L: []pkga.Trivial{
< 			{
< 				A: "asdf",
< 				B: 5,
< 				C: true,
< 			},
< 		},
< 	}
< 
< 	expected := pkgb.HasList{
< 		L: []pkgb.Nested{
< 			{
< 				D: "abc",
< 				Trivial: pkgb.Trivial{
< 					A: "asdf",
< 					B: 5,
< 					C: true,
< 				},
< 			},
< 		},
< 	}
< 	exTrans := mkTrans(
< 		fp("L", 0, "A"), fp("L", 0, "A"),
< 		fp("L", 0, "B"), fp("L", 0, "B"),
< 		fp("L", 0, "C"), fp("L", 0, "C"),
< 		fp("L", 0, "C"), fp("L", 0, "D"),
< 	)
< 
< 	got := pkgb.HasList{}
< 
< 	trans := NewTranslator("", "", testOptions{})
< 	trans.AddCustomTranslator(tr)
< 
< 	ts, r := trans.Translate(&in, &got)
< 	assert.Equal(t, got, expected, "bad translation")
< 	assert.Equal(t, ts, exTrans, "bad translation")
< 	assert.Equal(t, r.String(), "", "non-empty report")
< }
< 
< func TestAddIdentity(t *testing.T) {
< 	ts := NewTranslationSet("1", "2")
< 	ts.AddIdentity("foo", "bar")
< 	expectedFoo := Translation{
< 		From: path.New("1", "foo"),
< 		To:   path.New("2", "foo"),
< 	}
< 	expectedBar := Translation{
< 		From: path.New("1", "bar"),
< 		To:   path.New("2", "bar"),
< 	}
< 	expectedFoo2 := Translation{
< 		From: path.New("1", "pre", "foo"),
< 		To:   path.New("2", "pre", "foo"),
< 	}
< 	expectedBar2 := Translation{
< 		From: path.New("1", "pre", "bar"),
< 		To:   path.New("2", "pre", "bar"),
< 	}
< 	ts2 := NewTranslationSet("1", "2")
< 	ts2.MergeP("pre", ts)
< 	ts3 := NewTranslationSet("1", "2")
< 	ts3.Merge(ts.Prefix("pre"))
< 
< 	assert.Equal(t, ts.Set["$.foo"], expectedFoo, "foo not added correctly")
< 	assert.Equal(t, ts.Set["$.bar"], expectedBar, "bar not added correctly")
< 	assert.Equal(t, ts2.Set["$.pre.foo"], expectedFoo2, "foo not added correctly")
< 	assert.Equal(t, ts3.Set["$.pre.bar"], expectedBar2, "bar not added correctly")
< 	assert.Equal(t, ts3.Set["$.pre.foo"], expectedFoo2, "foo not added correctly")
< 	assert.Equal(t, ts2.Set["$.pre.bar"], expectedBar2, "bar not added correctly")
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/translate/util.go updated/vendor/github.com/coreos/fcct/translate/util.go
1,114d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package translate
< 
< import (
< 	"reflect"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // fieldName returns the name uses when (un)marshalling a field. t should be a reflect.Value of a struct,
< // index is the field index, and tag is the struct tag used when (un)marshalling (e.g. "json" or "yaml")
< func fieldName(t reflect.Value, index int, tag string) string {
< 	f := t.Type().Field(index)
< 	if tag == "" {
< 		return f.Name
< 	}
< 	return strings.Split(f.Tag.Get(tag), ",")[0]
< }
< 
< func prefixPath(p path.ContextPath, prefix ...interface{}) path.ContextPath {
< 	return path.New(p.Tag, prefix...).Append(p.Path...)
< }
< 
< func prefixPaths(ps []path.ContextPath, prefix ...interface{}) []path.ContextPath {
< 	ret := []path.ContextPath{}
< 	for _, p := range ps {
< 		ret = append(ret, prefixPath(p, prefix...))
< 	}
< 	return ret
< }
< 
< func getAllPaths(v reflect.Value, tag string) []path.ContextPath {
< 	k := v.Kind()
< 	t := v.Type()
< 	switch {
< 	case util.IsPrimitive(k):
< 		return nil
< 	case k == reflect.Ptr:
< 		if v.IsNil() {
< 			return nil
< 		}
< 		return getAllPaths(v.Elem(), tag)
< 	case k == reflect.Slice:
< 		ret := []path.ContextPath{}
< 		for i := 0; i < v.Len(); i++ {
< 			paths := getAllPaths(v.Index(i), tag)
< 			if len(paths) > 0 {
< 				// struct, pointer to struct, etc.; add children
< 				ret = append(ret, prefixPaths(paths, i)...)
< 			} else {
< 				// primitive type; add slice entry
< 				ret = append(ret, path.New(tag, i))
< 			}
< 		}
< 		return ret
< 	case k == reflect.Struct:
< 		ret := []path.ContextPath{}
< 		for i := 0; i < t.NumField(); i++ {
< 			name := fieldName(v, i, tag)
< 			field := v.Field(i)
< 			if t.Field(i).Anonymous {
< 				ret = append(ret, getAllPaths(field, tag)...)
< 			} else {
< 				ret = append(ret, prefixPaths(getAllPaths(field, tag), name)...)
< 				ret = append(ret, path.New(tag, name))
< 			}
< 		}
< 		return ret
< 	default:
< 		panic("Encountered types that are not the same when they should be. This is a bug, please file a report")
< 	}
< }
< 
< // Return a copy of the report, with the context paths prefixed by prefix.
< func prefixReport(r report.Report, prefix interface{}) report.Report {
< 	var ret report.Report
< 	ret.Merge(r)
< 	for i := range ret.Entries {
< 		entry := &ret.Entries[i]
< 		entry.Context = path.New(entry.Context.Tag, prefix).Append(entry.Context.Path...)
< 	}
< 	return ret
< }
< 
< // Utility function to run a translation and prefix the resulting
< // TranslationSet and Report.
< func Prefixed(tr Translator, prefix interface{}, from interface{}, to interface{}) (TranslationSet, report.Report) {
< 	tm, r := tr.Translate(from, to)
< 	return tm.Prefix(prefix), prefixReport(r, prefix)
< }
< 
< // Utility function to run a translation and merge the result, with the
< // specified prefix, into the specified TranslationSet and Report.
< func MergeP(tr Translator, tm TranslationSet, r *report.Report, prefix interface{}, from interface{}, to interface{}) {
< 	translations, report := tr.Translate(from, to)
< 	tm.MergeP(prefix, translations)
< 	r.Merge(prefixReport(report, prefix))
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/LICENSE
1,27d0
< Copyright (c) 2009 The Go Authors. All rights reserved.
< 
< Redistribution and use in source and binary forms, with or without
< modification, are permitted provided that the following conditions are
< met:
< 
<    * Redistributions of source code must retain the above copyright
< notice, this list of conditions and the following disclaimer.
<    * Redistributions in binary form must reproduce the above
< copyright notice, this list of conditions and the following disclaimer
< in the documentation and/or other materials provided with the
< distribution.
<    * Neither the name of Google Inc. nor the names of its
< contributors may be used to endorse or promote products derived from
< this software without specific prior written permission.
< 
< THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
< "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
< LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
< A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
< OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
< SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
< LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
< DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
< THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
< (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
< OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/README.md updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/README.md
1,19d0
< # [json](https://godoc.org/github.com/clarketm/json)
< > Mirrors [golang/go](https://github.com/golang/go) [![Golang version](https://img.shields.io/badge/go-1.12.7-green)](https://github.com/golang/go/releases/tag/go1.12.7)
< 
< Drop-in replacement for Golang [`encoding/json`](https://golang.org/pkg/encoding/json/) with additional features.
< 
< ## Installation
< ```shell
< $ go get -u github.com/clarketm/json
< ```
< 
< ## Usage
< Same usage as Golang [`encoding/json`](https://golang.org/pkg/encoding/json/).
< 
< ## Features
< - Support zero values of structs with `omitempty`: [golang/go#11939](https://github.com/golang/go/issues/11939).
< > If `omitempty` is applied to a struct and all the children of the struct are *empty*, then on marshalling it will be **omitted** from the encoded json.
< 
< ## License
< Refer to the [Golang](https://github.com/golang/go/blob/master/LICENSE) license. See [LICENSE](LICENSE) for more information.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/decode.go updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/decode.go
1,1304d0
< // Copyright 2010 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< // Represents JSON data structure using native Go types: booleans, floats,
< // strings, arrays, and maps.
< 
< package json
< 
< import (
< 	"encoding"
< 	"encoding/base64"
< 	"fmt"
< 	"reflect"
< 	"strconv"
< 	"strings"
< 	"unicode"
< 	"unicode/utf16"
< 	"unicode/utf8"
< )
< 
< // Unmarshal parses the JSON-encoded data and stores the result
< // in the value pointed to by v. If v is nil or not a pointer,
< // Unmarshal returns an InvalidUnmarshalError.
< //
< // Unmarshal uses the inverse of the encodings that
< // Marshal uses, allocating maps, slices, and pointers as necessary,
< // with the following additional rules:
< //
< // To unmarshal JSON into a pointer, Unmarshal first handles the case of
< // the JSON being the JSON literal null. In that case, Unmarshal sets
< // the pointer to nil. Otherwise, Unmarshal unmarshals the JSON into
< // the value pointed at by the pointer. If the pointer is nil, Unmarshal
< // allocates a new value for it to point to.
< //
< // To unmarshal JSON into a value implementing the Unmarshaler interface,
< // Unmarshal calls that value's UnmarshalJSON method, including
< // when the input is a JSON null.
< // Otherwise, if the value implements encoding.TextUnmarshaler
< // and the input is a JSON quoted string, Unmarshal calls that value's
< // UnmarshalText method with the unquoted form of the string.
< //
< // To unmarshal JSON into a struct, Unmarshal matches incoming object
< // keys to the keys used by Marshal (either the struct field name or its tag),
< // preferring an exact match but also accepting a case-insensitive match. By
< // default, object keys which don't have a corresponding struct field are
< // ignored (see Decoder.DisallowUnknownFields for an alternative).
< //
< // To unmarshal JSON into an interface value,
< // Unmarshal stores one of these in the interface value:
< //
< //	bool, for JSON booleans
< //	float64, for JSON numbers
< //	string, for JSON strings
< //	[]interface{}, for JSON arrays
< //	map[string]interface{}, for JSON objects
< //	nil for JSON null
< //
< // To unmarshal a JSON array into a slice, Unmarshal resets the slice length
< // to zero and then appends each element to the slice.
< // As a special case, to unmarshal an empty JSON array into a slice,
< // Unmarshal replaces the slice with a new empty slice.
< //
< // To unmarshal a JSON array into a Go array, Unmarshal decodes
< // JSON array elements into corresponding Go array elements.
< // If the Go array is smaller than the JSON array,
< // the additional JSON array elements are discarded.
< // If the JSON array is smaller than the Go array,
< // the additional Go array elements are set to zero values.
< //
< // To unmarshal a JSON object into a map, Unmarshal first establishes a map to
< // use. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal
< // reuses the existing map, keeping existing entries. Unmarshal then stores
< // key-value pairs from the JSON object into the map. The map's key type must
< // either be any string type, an integer, implement json.Unmarshaler, or
< // implement encoding.TextUnmarshaler.
< //
< // If a JSON value is not appropriate for a given target type,
< // or if a JSON number overflows the target type, Unmarshal
< // skips that field and completes the unmarshaling as best it can.
< // If no more serious errors are encountered, Unmarshal returns
< // an UnmarshalTypeError describing the earliest such error. In any
< // case, it's not guaranteed that all the remaining fields following
< // the problematic one will be unmarshaled into the target object.
< //
< // The JSON null value unmarshals into an interface, map, pointer, or slice
< // by setting that Go value to nil. Because null is often used in JSON to mean
< // ``not present,'' unmarshaling a JSON null into any other Go type has no effect
< // on the value and produces no error.
< //
< // When unmarshaling quoted strings, invalid UTF-8 or
< // invalid UTF-16 surrogate pairs are not treated as an error.
< // Instead, they are replaced by the Unicode replacement
< // character U+FFFD.
< //
< func Unmarshal(data []byte, v interface{}) error {
< 	// Check for well-formedness.
< 	// Avoids filling out half a data structure
< 	// before discovering a JSON syntax error.
< 	var d decodeState
< 	err := checkValid(data, &d.scan)
< 	if err != nil {
< 		return err
< 	}
< 
< 	d.init(data)
< 	return d.unmarshal(v)
< }
< 
< // Unmarshaler is the interface implemented by types
< // that can unmarshal a JSON description of themselves.
< // The input can be assumed to be a valid encoding of
< // a JSON value. UnmarshalJSON must copy the JSON data
< // if it wishes to retain the data after returning.
< //
< // By convention, to approximate the behavior of Unmarshal itself,
< // Unmarshalers implement UnmarshalJSON([]byte("null")) as a no-op.
< type Unmarshaler interface {
< 	UnmarshalJSON([]byte) error
< }
< 
< // An UnmarshalTypeError describes a JSON value that was
< // not appropriate for a value of a specific Go type.
< type UnmarshalTypeError struct {
< 	Value  string       // description of JSON value - "bool", "array", "number -5"
< 	Type   reflect.Type // type of Go value it could not be assigned to
< 	Offset int64        // error occurred after reading Offset bytes
< 	Struct string       // name of the struct type containing the field
< 	Field  string       // the full path from root node to the field
< }
< 
< func (e *UnmarshalTypeError) Error() string {
< 	if e.Struct != "" || e.Field != "" {
< 		return "json: cannot unmarshal " + e.Value + " into Go struct field " + e.Struct + "." + e.Field + " of type " + e.Type.String()
< 	}
< 	return "json: cannot unmarshal " + e.Value + " into Go value of type " + e.Type.String()
< }
< 
< // An UnmarshalFieldError describes a JSON object key that
< // led to an unexported (and therefore unwritable) struct field.
< //
< // Deprecated: No longer used; kept for compatibility.
< type UnmarshalFieldError struct {
< 	Key   string
< 	Type  reflect.Type
< 	Field reflect.StructField
< }
< 
< func (e *UnmarshalFieldError) Error() string {
< 	return "json: cannot unmarshal object key " + strconv.Quote(e.Key) + " into unexported field " + e.Field.Name + " of type " + e.Type.String()
< }
< 
< // An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.
< // (The argument to Unmarshal must be a non-nil pointer.)
< type InvalidUnmarshalError struct {
< 	Type reflect.Type
< }
< 
< func (e *InvalidUnmarshalError) Error() string {
< 	if e.Type == nil {
< 		return "json: Unmarshal(nil)"
< 	}
< 
< 	if e.Type.Kind() != reflect.Ptr {
< 		return "json: Unmarshal(non-pointer " + e.Type.String() + ")"
< 	}
< 	return "json: Unmarshal(nil " + e.Type.String() + ")"
< }
< 
< func (d *decodeState) unmarshal(v interface{}) error {
< 	rv := reflect.ValueOf(v)
< 	if rv.Kind() != reflect.Ptr || rv.IsNil() {
< 		return &InvalidUnmarshalError{reflect.TypeOf(v)}
< 	}
< 
< 	d.scan.reset()
< 	d.scanWhile(scanSkipSpace)
< 	// We decode rv not rv.Elem because the Unmarshaler interface
< 	// test must be applied at the top level of the value.
< 	err := d.value(rv)
< 	if err != nil {
< 		return d.addErrorContext(err)
< 	}
< 	return d.savedError
< }
< 
< // A Number represents a JSON number literal.
< type Number string
< 
< // String returns the literal text of the number.
< func (n Number) String() string { return string(n) }
< 
< // Float64 returns the number as a float64.
< func (n Number) Float64() (float64, error) {
< 	return strconv.ParseFloat(string(n), 64)
< }
< 
< // Int64 returns the number as an int64.
< func (n Number) Int64() (int64, error) {
< 	return strconv.ParseInt(string(n), 10, 64)
< }
< 
< // decodeState represents the state while decoding a JSON value.
< type decodeState struct {
< 	data         []byte
< 	off          int // next read offset in data
< 	opcode       int // last read result
< 	scan         scanner
< 	errorContext struct { // provides context for type errors
< 		Struct     reflect.Type
< 		FieldStack []string
< 	}
< 	savedError            error
< 	useNumber             bool
< 	disallowUnknownFields bool
< 	// safeUnquote is the number of current string literal bytes that don't
< 	// need to be unquoted. When negative, no bytes need unquoting.
< 	safeUnquote int
< }
< 
< // readIndex returns the position of the last byte read.
< func (d *decodeState) readIndex() int {
< 	return d.off - 1
< }
< 
< // phasePanicMsg is used as a panic message when we end up with something that
< // shouldn't happen. It can indicate a bug in the JSON decoder, or that
< // something is editing the data slice while the decoder executes.
< const phasePanicMsg = "JSON decoder out of sync - data changing underfoot?"
< 
< func (d *decodeState) init(data []byte) *decodeState {
< 	d.data = data
< 	d.off = 0
< 	d.savedError = nil
< 	d.errorContext.Struct = nil
< 
< 	// Reuse the allocated space for the FieldStack slice.
< 	d.errorContext.FieldStack = d.errorContext.FieldStack[:0]
< 	return d
< }
< 
< // saveError saves the first err it is called with,
< // for reporting at the end of the unmarshal.
< func (d *decodeState) saveError(err error) {
< 	if d.savedError == nil {
< 		d.savedError = d.addErrorContext(err)
< 	}
< }
< 
< // addErrorContext returns a new error enhanced with information from d.errorContext
< func (d *decodeState) addErrorContext(err error) error {
< 	if d.errorContext.Struct != nil || len(d.errorContext.FieldStack) > 0 {
< 		switch err := err.(type) {
< 		case *UnmarshalTypeError:
< 			err.Struct = d.errorContext.Struct.Name()
< 			err.Field = strings.Join(d.errorContext.FieldStack, ".")
< 			return err
< 		}
< 	}
< 	return err
< }
< 
< // skip scans to the end of what was started.
< func (d *decodeState) skip() {
< 	s, data, i := &d.scan, d.data, d.off
< 	depth := len(s.parseState)
< 	for {
< 		op := s.step(s, data[i])
< 		i++
< 		if len(s.parseState) < depth {
< 			d.off = i
< 			d.opcode = op
< 			return
< 		}
< 	}
< }
< 
< // scanNext processes the byte at d.data[d.off].
< func (d *decodeState) scanNext() {
< 	if d.off < len(d.data) {
< 		d.opcode = d.scan.step(&d.scan, d.data[d.off])
< 		d.off++
< 	} else {
< 		d.opcode = d.scan.eof()
< 		d.off = len(d.data) + 1 // mark processed EOF with len+1
< 	}
< }
< 
< // scanWhile processes bytes in d.data[d.off:] until it
< // receives a scan code not equal to op.
< func (d *decodeState) scanWhile(op int) {
< 	s, data, i := &d.scan, d.data, d.off
< 	for i < len(data) {
< 		newOp := s.step(s, data[i])
< 		i++
< 		if newOp != op {
< 			d.opcode = newOp
< 			d.off = i
< 			return
< 		}
< 	}
< 
< 	d.off = len(data) + 1 // mark processed EOF with len+1
< 	d.opcode = d.scan.eof()
< }
< 
< // rescanLiteral is similar to scanWhile(scanContinue), but it specialises the
< // common case where we're decoding a literal. The decoder scans the input
< // twice, once for syntax errors and to check the length of the value, and the
< // second to perform the decoding.
< //
< // Only in the second step do we use decodeState to tokenize literals, so we
< // know there aren't any syntax errors. We can take advantage of that knowledge,
< // and scan a literal's bytes much more quickly.
< func (d *decodeState) rescanLiteral() {
< 	data, i := d.data, d.off
< Switch:
< 	switch data[i-1] {
< 	case '"': // string
< 		// safeUnquote is initialized at -1, which means that all bytes
< 		// checked so far can be unquoted at a later time with no work
< 		// at all. When reaching the closing '"', if safeUnquote is
< 		// still -1, all bytes can be unquoted with no work. Otherwise,
< 		// only those bytes up until the first '\\' or non-ascii rune
< 		// can be safely unquoted.
< 		safeUnquote := -1
< 		for ; i < len(data); i++ {
< 			if c := data[i]; c == '\\' {
< 				if safeUnquote < 0 { // first unsafe byte
< 					safeUnquote = int(i - d.off)
< 				}
< 				i++ // escaped char
< 			} else if c == '"' {
< 				d.safeUnquote = safeUnquote
< 				i++ // tokenize the closing quote too
< 				break Switch
< 			} else if c >= utf8.RuneSelf {
< 				if safeUnquote < 0 { // first unsafe byte
< 					safeUnquote = int(i - d.off)
< 				}
< 			}
< 		}
< 	case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-': // number
< 		for ; i < len(data); i++ {
< 			switch data[i] {
< 			case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
< 				'.', 'e', 'E', '+', '-':
< 			default:
< 				break Switch
< 			}
< 		}
< 	case 't': // true
< 		i += len("rue")
< 	case 'f': // false
< 		i += len("alse")
< 	case 'n': // null
< 		i += len("ull")
< 	}
< 	if i < len(data) {
< 		d.opcode = stateEndValue(&d.scan, data[i])
< 	} else {
< 		d.opcode = scanEnd
< 	}
< 	d.off = i + 1
< }
< 
< // value consumes a JSON value from d.data[d.off-1:], decoding into v, and
< // reads the following byte ahead. If v is invalid, the value is discarded.
< // The first byte of the value has been read already.
< func (d *decodeState) value(v reflect.Value) error {
< 	switch d.opcode {
< 	default:
< 		panic(phasePanicMsg)
< 
< 	case scanBeginArray:
< 		if v.IsValid() {
< 			if err := d.array(v); err != nil {
< 				return err
< 			}
< 		} else {
< 			d.skip()
< 		}
< 		d.scanNext()
< 
< 	case scanBeginObject:
< 		if v.IsValid() {
< 			if err := d.object(v); err != nil {
< 				return err
< 			}
< 		} else {
< 			d.skip()
< 		}
< 		d.scanNext()
< 
< 	case scanBeginLiteral:
< 		// All bytes inside literal return scanContinue op code.
< 		start := d.readIndex()
< 		d.rescanLiteral()
< 
< 		if v.IsValid() {
< 			if err := d.literalStore(d.data[start:d.readIndex()], v, false); err != nil {
< 				return err
< 			}
< 		}
< 	}
< 	return nil
< }
< 
< type unquotedValue struct{}
< 
< // valueQuoted is like value but decodes a
< // quoted string literal or literal null into an interface value.
< // If it finds anything other than a quoted string literal or null,
< // valueQuoted returns unquotedValue{}.
< func (d *decodeState) valueQuoted() interface{} {
< 	switch d.opcode {
< 	default:
< 		panic(phasePanicMsg)
< 
< 	case scanBeginArray, scanBeginObject:
< 		d.skip()
< 		d.scanNext()
< 
< 	case scanBeginLiteral:
< 		v := d.literalInterface()
< 		switch v.(type) {
< 		case nil, string:
< 			return v
< 		}
< 	}
< 	return unquotedValue{}
< }
< 
< // indirect walks down v allocating pointers as needed,
< // until it gets to a non-pointer.
< // If it encounters an Unmarshaler, indirect stops and returns that.
< // If decodingNull is true, indirect stops at the first settable pointer so it
< // can be set to nil.
< func indirect(v reflect.Value, decodingNull bool) (Unmarshaler, encoding.TextUnmarshaler, reflect.Value) {
< 	// Issue #24153 indicates that it is generally not a guaranteed property
< 	// that you may round-trip a reflect.Value by calling Value.Addr().Elem()
< 	// and expect the value to still be settable for values derived from
< 	// unexported embedded struct fields.
< 	//
< 	// The logic below effectively does this when it first addresses the value
< 	// (to satisfy possible pointer methods) and continues to dereference
< 	// subsequent pointers as necessary.
< 	//
< 	// After the first round-trip, we set v back to the original value to
< 	// preserve the original RW flags contained in reflect.Value.
< 	v0 := v
< 	haveAddr := false
< 
< 	// If v is a named type and is addressable,
< 	// start with its address, so that if the type has pointer methods,
< 	// we find them.
< 	if v.Kind() != reflect.Ptr && v.Type().Name() != "" && v.CanAddr() {
< 		haveAddr = true
< 		v = v.Addr()
< 	}
< 	for {
< 		// Load value from interface, but only if the result will be
< 		// usefully addressable.
< 		if v.Kind() == reflect.Interface && !v.IsNil() {
< 			e := v.Elem()
< 			if e.Kind() == reflect.Ptr && !e.IsNil() && (!decodingNull || e.Elem().Kind() == reflect.Ptr) {
< 				haveAddr = false
< 				v = e
< 				continue
< 			}
< 		}
< 
< 		if v.Kind() != reflect.Ptr {
< 			break
< 		}
< 
< 		if decodingNull && v.CanSet() {
< 			break
< 		}
< 
< 		// Prevent infinite loop if v is an interface pointing to its own address:
< 		//     var v interface{}
< 		//     v = &v
< 		if v.Elem().Kind() == reflect.Interface && v.Elem().Elem() == v {
< 			v = v.Elem()
< 			break
< 		}
< 		if v.IsNil() {
< 			v.Set(reflect.New(v.Type().Elem()))
< 		}
< 		if v.Type().NumMethod() > 0 && v.CanInterface() {
< 			if u, ok := v.Interface().(Unmarshaler); ok {
< 				return u, nil, reflect.Value{}
< 			}
< 			if !decodingNull {
< 				if u, ok := v.Interface().(encoding.TextUnmarshaler); ok {
< 					return nil, u, reflect.Value{}
< 				}
< 			}
< 		}
< 
< 		if haveAddr {
< 			v = v0 // restore original value after round-trip Value.Addr().Elem()
< 			haveAddr = false
< 		} else {
< 			v = v.Elem()
< 		}
< 	}
< 	return nil, nil, v
< }
< 
< // array consumes an array from d.data[d.off-1:], decoding into v.
< // The first byte of the array ('[') has been read already.
< func (d *decodeState) array(v reflect.Value) error {
< 	// Check for unmarshaler.
< 	u, ut, pv := indirect(v, false)
< 	if u != nil {
< 		start := d.readIndex()
< 		d.skip()
< 		return u.UnmarshalJSON(d.data[start:d.off])
< 	}
< 	if ut != nil {
< 		d.saveError(&UnmarshalTypeError{Value: "array", Type: v.Type(), Offset: int64(d.off)})
< 		d.skip()
< 		return nil
< 	}
< 	v = pv
< 
< 	// Check type of target.
< 	switch v.Kind() {
< 	case reflect.Interface:
< 		if v.NumMethod() == 0 {
< 			// Decoding into nil interface? Switch to non-reflect code.
< 			ai := d.arrayInterface()
< 			v.Set(reflect.ValueOf(ai))
< 			return nil
< 		}
< 		// Otherwise it's invalid.
< 		fallthrough
< 	default:
< 		d.saveError(&UnmarshalTypeError{Value: "array", Type: v.Type(), Offset: int64(d.off)})
< 		d.skip()
< 		return nil
< 	case reflect.Array, reflect.Slice:
< 		break
< 	}
< 
< 	i := 0
< 	for {
< 		// Look ahead for ] - can only happen on first iteration.
< 		d.scanWhile(scanSkipSpace)
< 		if d.opcode == scanEndArray {
< 			break
< 		}
< 
< 		// Get element of array, growing if necessary.
< 		if v.Kind() == reflect.Slice {
< 			// Grow slice if necessary
< 			if i >= v.Cap() {
< 				newcap := v.Cap() + v.Cap()/2
< 				if newcap < 4 {
< 					newcap = 4
< 				}
< 				newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)
< 				reflect.Copy(newv, v)
< 				v.Set(newv)
< 			}
< 			if i >= v.Len() {
< 				v.SetLen(i + 1)
< 			}
< 		}
< 
< 		if i < v.Len() {
< 			// Decode into element.
< 			if err := d.value(v.Index(i)); err != nil {
< 				return err
< 			}
< 		} else {
< 			// Ran out of fixed array: skip.
< 			if err := d.value(reflect.Value{}); err != nil {
< 				return err
< 			}
< 		}
< 		i++
< 
< 		// Next token must be , or ].
< 		if d.opcode == scanSkipSpace {
< 			d.scanWhile(scanSkipSpace)
< 		}
< 		if d.opcode == scanEndArray {
< 			break
< 		}
< 		if d.opcode != scanArrayValue {
< 			panic(phasePanicMsg)
< 		}
< 	}
< 
< 	if i < v.Len() {
< 		if v.Kind() == reflect.Array {
< 			// Array. Zero the rest.
< 			z := reflect.Zero(v.Type().Elem())
< 			for ; i < v.Len(); i++ {
< 				v.Index(i).Set(z)
< 			}
< 		} else {
< 			v.SetLen(i)
< 		}
< 	}
< 	if i == 0 && v.Kind() == reflect.Slice {
< 		v.Set(reflect.MakeSlice(v.Type(), 0, 0))
< 	}
< 	return nil
< }
< 
< var nullLiteral = []byte("null")
< var textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
< 
< // object consumes an object from d.data[d.off-1:], decoding into v.
< // The first byte ('{') of the object has been read already.
< func (d *decodeState) object(v reflect.Value) error {
< 	// Check for unmarshaler.
< 	u, ut, pv := indirect(v, false)
< 	if u != nil {
< 		start := d.readIndex()
< 		d.skip()
< 		return u.UnmarshalJSON(d.data[start:d.off])
< 	}
< 	if ut != nil {
< 		d.saveError(&UnmarshalTypeError{Value: "object", Type: v.Type(), Offset: int64(d.off)})
< 		d.skip()
< 		return nil
< 	}
< 	v = pv
< 	t := v.Type()
< 
< 	// Decoding into nil interface? Switch to non-reflect code.
< 	if v.Kind() == reflect.Interface && v.NumMethod() == 0 {
< 		oi := d.objectInterface()
< 		v.Set(reflect.ValueOf(oi))
< 		return nil
< 	}
< 
< 	var fields structFields
< 
< 	// Check type of target:
< 	//   struct or
< 	//   map[T1]T2 where T1 is string, an integer type,
< 	//             or an encoding.TextUnmarshaler
< 	switch v.Kind() {
< 	case reflect.Map:
< 		// Map key must either have string kind, have an integer kind,
< 		// or be an encoding.TextUnmarshaler.
< 		switch t.Key().Kind() {
< 		case reflect.String,
< 			reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
< 			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		default:
< 			if !reflect.PtrTo(t.Key()).Implements(textUnmarshalerType) {
< 				d.saveError(&UnmarshalTypeError{Value: "object", Type: t, Offset: int64(d.off)})
< 				d.skip()
< 				return nil
< 			}
< 		}
< 		if v.IsNil() {
< 			v.Set(reflect.MakeMap(t))
< 		}
< 	case reflect.Struct:
< 		fields = cachedTypeFields(t)
< 		// ok
< 	default:
< 		d.saveError(&UnmarshalTypeError{Value: "object", Type: t, Offset: int64(d.off)})
< 		d.skip()
< 		return nil
< 	}
< 
< 	var mapElem reflect.Value
< 	origErrorContext := d.errorContext
< 
< 	for {
< 		// Read opening " of string key or closing }.
< 		d.scanWhile(scanSkipSpace)
< 		if d.opcode == scanEndObject {
< 			// closing } - can only happen on first iteration.
< 			break
< 		}
< 		if d.opcode != scanBeginLiteral {
< 			panic(phasePanicMsg)
< 		}
< 
< 		// Read key.
< 		start := d.readIndex()
< 		d.rescanLiteral()
< 		item := d.data[start:d.readIndex()]
< 		key, ok := d.unquoteBytes(item)
< 		if !ok {
< 			panic(phasePanicMsg)
< 		}
< 
< 		// Figure out field corresponding to key.
< 		var subv reflect.Value
< 		destring := false // whether the value is wrapped in a string to be decoded first
< 
< 		if v.Kind() == reflect.Map {
< 			elemType := t.Elem()
< 			if !mapElem.IsValid() {
< 				mapElem = reflect.New(elemType).Elem()
< 			} else {
< 				mapElem.Set(reflect.Zero(elemType))
< 			}
< 			subv = mapElem
< 		} else {
< 			var f *field
< 			if i, ok := fields.nameIndex[string(key)]; ok {
< 				// Found an exact name match.
< 				f = &fields.list[i]
< 			} else {
< 				// Fall back to the expensive case-insensitive
< 				// linear search.
< 				for i := range fields.list {
< 					ff := &fields.list[i]
< 					if ff.equalFold(ff.nameBytes, key) {
< 						f = ff
< 						break
< 					}
< 				}
< 			}
< 			if f != nil {
< 				subv = v
< 				destring = f.quoted
< 				for _, i := range f.index {
< 					if subv.Kind() == reflect.Ptr {
< 						if subv.IsNil() {
< 							// If a struct embeds a pointer to an unexported type,
< 							// it is not possible to set a newly allocated value
< 							// since the field is unexported.
< 							//
< 							// See https://golang.org/issue/21357
< 							if !subv.CanSet() {
< 								d.saveError(fmt.Errorf("json: cannot set embedded pointer to unexported struct: %v", subv.Type().Elem()))
< 								// Invalidate subv to ensure d.value(subv) skips over
< 								// the JSON value without assigning it to subv.
< 								subv = reflect.Value{}
< 								destring = false
< 								break
< 							}
< 							subv.Set(reflect.New(subv.Type().Elem()))
< 						}
< 						subv = subv.Elem()
< 					}
< 					subv = subv.Field(i)
< 				}
< 				d.errorContext.FieldStack = append(d.errorContext.FieldStack, f.name)
< 				d.errorContext.Struct = t
< 			} else if d.disallowUnknownFields {
< 				d.saveError(fmt.Errorf("json: unknown field %q", key))
< 			}
< 		}
< 
< 		// Read : before value.
< 		if d.opcode == scanSkipSpace {
< 			d.scanWhile(scanSkipSpace)
< 		}
< 		if d.opcode != scanObjectKey {
< 			panic(phasePanicMsg)
< 		}
< 		d.scanWhile(scanSkipSpace)
< 
< 		if destring {
< 			switch qv := d.valueQuoted().(type) {
< 			case nil:
< 				if err := d.literalStore(nullLiteral, subv, false); err != nil {
< 					return err
< 				}
< 			case string:
< 				if err := d.literalStore([]byte(qv), subv, true); err != nil {
< 					return err
< 				}
< 			default:
< 				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal unquoted value into %v", subv.Type()))
< 			}
< 		} else {
< 			if err := d.value(subv); err != nil {
< 				return err
< 			}
< 		}
< 
< 		// Write value back to map;
< 		// if using struct, subv points into struct already.
< 		if v.Kind() == reflect.Map {
< 			kt := t.Key()
< 			var kv reflect.Value
< 			switch {
< 			case reflect.PtrTo(kt).Implements(textUnmarshalerType):
< 				kv = reflect.New(kt)
< 				if err := d.literalStore(item, kv, true); err != nil {
< 					return err
< 				}
< 				kv = kv.Elem()
< 			case kt.Kind() == reflect.String:
< 				kv = reflect.ValueOf(key).Convert(kt)
< 			default:
< 				switch kt.Kind() {
< 				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 					s := string(key)
< 					n, err := strconv.ParseInt(s, 10, 64)
< 					if err != nil || reflect.Zero(kt).OverflowInt(n) {
< 						d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: kt, Offset: int64(start + 1)})
< 						break
< 					}
< 					kv = reflect.ValueOf(n).Convert(kt)
< 				case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 					s := string(key)
< 					n, err := strconv.ParseUint(s, 10, 64)
< 					if err != nil || reflect.Zero(kt).OverflowUint(n) {
< 						d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: kt, Offset: int64(start + 1)})
< 						break
< 					}
< 					kv = reflect.ValueOf(n).Convert(kt)
< 				default:
< 					panic("json: Unexpected key type") // should never occur
< 				}
< 			}
< 			if kv.IsValid() {
< 				v.SetMapIndex(kv, subv)
< 			}
< 		}
< 
< 		// Next token must be , or }.
< 		if d.opcode == scanSkipSpace {
< 			d.scanWhile(scanSkipSpace)
< 		}
< 		// Reset errorContext to its original state.
< 		// Keep the same underlying array for FieldStack, to reuse the
< 		// space and avoid unnecessary allocs.
< 		d.errorContext.FieldStack = d.errorContext.FieldStack[:len(origErrorContext.FieldStack)]
< 		d.errorContext.Struct = origErrorContext.Struct
< 		if d.opcode == scanEndObject {
< 			break
< 		}
< 		if d.opcode != scanObjectValue {
< 			panic(phasePanicMsg)
< 		}
< 	}
< 	return nil
< }
< 
< // convertNumber converts the number literal s to a float64 or a Number
< // depending on the setting of d.useNumber.
< func (d *decodeState) convertNumber(s string) (interface{}, error) {
< 	if d.useNumber {
< 		return Number(s), nil
< 	}
< 	f, err := strconv.ParseFloat(s, 64)
< 	if err != nil {
< 		return nil, &UnmarshalTypeError{Value: "number " + s, Type: reflect.TypeOf(0.0), Offset: int64(d.off)}
< 	}
< 	return f, nil
< }
< 
< var numberType = reflect.TypeOf(Number(""))
< 
< // literalStore decodes a literal stored in item into v.
< //
< // fromQuoted indicates whether this literal came from unwrapping a
< // string from the ",string" struct tag option. this is used only to
< // produce more helpful error messages.
< func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) error {
< 	// Check for unmarshaler.
< 	if len(item) == 0 {
< 		//Empty string given
< 		d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 		return nil
< 	}
< 	isNull := item[0] == 'n' // null
< 	u, ut, pv := indirect(v, isNull)
< 	if u != nil {
< 		return u.UnmarshalJSON(item)
< 	}
< 	if ut != nil {
< 		if item[0] != '"' {
< 			if fromQuoted {
< 				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 				return nil
< 			}
< 			val := "number"
< 			switch item[0] {
< 			case 'n':
< 				val = "null"
< 			case 't', 'f':
< 				val = "bool"
< 			}
< 			d.saveError(&UnmarshalTypeError{Value: val, Type: v.Type(), Offset: int64(d.readIndex())})
< 			return nil
< 		}
< 		s, ok := d.unquoteBytes(item)
< 		if !ok {
< 			if fromQuoted {
< 				return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
< 			}
< 			panic(phasePanicMsg)
< 		}
< 		return ut.UnmarshalText(s)
< 	}
< 
< 	v = pv
< 
< 	switch c := item[0]; c {
< 	case 'n': // null
< 		// The main parser checks that only true and false can reach here,
< 		// but if this was a quoted string input, it could be anything.
< 		if fromQuoted && string(item) != "null" {
< 			d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 			break
< 		}
< 		switch v.Kind() {
< 		case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:
< 			v.Set(reflect.Zero(v.Type()))
< 			// otherwise, ignore null for primitives/string
< 		}
< 	case 't', 'f': // true, false
< 		value := item[0] == 't'
< 		// The main parser checks that only true and false can reach here,
< 		// but if this was a quoted string input, it could be anything.
< 		if fromQuoted && string(item) != "true" && string(item) != "false" {
< 			d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 			break
< 		}
< 		switch v.Kind() {
< 		default:
< 			if fromQuoted {
< 				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 			} else {
< 				d.saveError(&UnmarshalTypeError{Value: "bool", Type: v.Type(), Offset: int64(d.readIndex())})
< 			}
< 		case reflect.Bool:
< 			v.SetBool(value)
< 		case reflect.Interface:
< 			if v.NumMethod() == 0 {
< 				v.Set(reflect.ValueOf(value))
< 			} else {
< 				d.saveError(&UnmarshalTypeError{Value: "bool", Type: v.Type(), Offset: int64(d.readIndex())})
< 			}
< 		}
< 
< 	case '"': // string
< 		s, ok := d.unquoteBytes(item)
< 		if !ok {
< 			if fromQuoted {
< 				return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
< 			}
< 			panic(phasePanicMsg)
< 		}
< 		switch v.Kind() {
< 		default:
< 			d.saveError(&UnmarshalTypeError{Value: "string", Type: v.Type(), Offset: int64(d.readIndex())})
< 		case reflect.Slice:
< 			if v.Type().Elem().Kind() != reflect.Uint8 {
< 				d.saveError(&UnmarshalTypeError{Value: "string", Type: v.Type(), Offset: int64(d.readIndex())})
< 				break
< 			}
< 			b := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
< 			n, err := base64.StdEncoding.Decode(b, s)
< 			if err != nil {
< 				d.saveError(err)
< 				break
< 			}
< 			v.SetBytes(b[:n])
< 		case reflect.String:
< 			if v.Type() == numberType && !isValidNumber(string(s)) {
< 				return fmt.Errorf("json: invalid number literal, trying to unmarshal %q into Number", item)
< 			}
< 			v.SetString(string(s))
< 		case reflect.Interface:
< 			if v.NumMethod() == 0 {
< 				v.Set(reflect.ValueOf(string(s)))
< 			} else {
< 				d.saveError(&UnmarshalTypeError{Value: "string", Type: v.Type(), Offset: int64(d.readIndex())})
< 			}
< 		}
< 
< 	default: // number
< 		if c != '-' && (c < '0' || c > '9') {
< 			if fromQuoted {
< 				return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
< 			}
< 			panic(phasePanicMsg)
< 		}
< 		s := string(item)
< 		switch v.Kind() {
< 		default:
< 			if v.Kind() == reflect.String && v.Type() == numberType {
< 				// s must be a valid number, because it's
< 				// already been tokenized.
< 				v.SetString(s)
< 				break
< 			}
< 			if fromQuoted {
< 				return fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type())
< 			}
< 			d.saveError(&UnmarshalTypeError{Value: "number", Type: v.Type(), Offset: int64(d.readIndex())})
< 		case reflect.Interface:
< 			n, err := d.convertNumber(s)
< 			if err != nil {
< 				d.saveError(err)
< 				break
< 			}
< 			if v.NumMethod() != 0 {
< 				d.saveError(&UnmarshalTypeError{Value: "number", Type: v.Type(), Offset: int64(d.readIndex())})
< 				break
< 			}
< 			v.Set(reflect.ValueOf(n))
< 
< 		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 			n, err := strconv.ParseInt(s, 10, 64)
< 			if err != nil || v.OverflowInt(n) {
< 				d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: v.Type(), Offset: int64(d.readIndex())})
< 				break
< 			}
< 			v.SetInt(n)
< 
< 		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 			n, err := strconv.ParseUint(s, 10, 64)
< 			if err != nil || v.OverflowUint(n) {
< 				d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: v.Type(), Offset: int64(d.readIndex())})
< 				break
< 			}
< 			v.SetUint(n)
< 
< 		case reflect.Float32, reflect.Float64:
< 			n, err := strconv.ParseFloat(s, v.Type().Bits())
< 			if err != nil || v.OverflowFloat(n) {
< 				d.saveError(&UnmarshalTypeError{Value: "number " + s, Type: v.Type(), Offset: int64(d.readIndex())})
< 				break
< 			}
< 			v.SetFloat(n)
< 		}
< 	}
< 	return nil
< }
< 
< // The xxxInterface routines build up a value to be stored
< // in an empty interface. They are not strictly necessary,
< // but they avoid the weight of reflection in this common case.
< 
< // valueInterface is like value but returns interface{}
< func (d *decodeState) valueInterface() (val interface{}) {
< 	switch d.opcode {
< 	default:
< 		panic(phasePanicMsg)
< 	case scanBeginArray:
< 		val = d.arrayInterface()
< 		d.scanNext()
< 	case scanBeginObject:
< 		val = d.objectInterface()
< 		d.scanNext()
< 	case scanBeginLiteral:
< 		val = d.literalInterface()
< 	}
< 	return
< }
< 
< // arrayInterface is like array but returns []interface{}.
< func (d *decodeState) arrayInterface() []interface{} {
< 	var v = make([]interface{}, 0)
< 	for {
< 		// Look ahead for ] - can only happen on first iteration.
< 		d.scanWhile(scanSkipSpace)
< 		if d.opcode == scanEndArray {
< 			break
< 		}
< 
< 		v = append(v, d.valueInterface())
< 
< 		// Next token must be , or ].
< 		if d.opcode == scanSkipSpace {
< 			d.scanWhile(scanSkipSpace)
< 		}
< 		if d.opcode == scanEndArray {
< 			break
< 		}
< 		if d.opcode != scanArrayValue {
< 			panic(phasePanicMsg)
< 		}
< 	}
< 	return v
< }
< 
< // objectInterface is like object but returns map[string]interface{}.
< func (d *decodeState) objectInterface() map[string]interface{} {
< 	m := make(map[string]interface{})
< 	for {
< 		// Read opening " of string key or closing }.
< 		d.scanWhile(scanSkipSpace)
< 		if d.opcode == scanEndObject {
< 			// closing } - can only happen on first iteration.
< 			break
< 		}
< 		if d.opcode != scanBeginLiteral {
< 			panic(phasePanicMsg)
< 		}
< 
< 		// Read string key.
< 		start := d.readIndex()
< 		d.rescanLiteral()
< 		item := d.data[start:d.readIndex()]
< 		key, ok := d.unquote(item)
< 		if !ok {
< 			panic(phasePanicMsg)
< 		}
< 
< 		// Read : before value.
< 		if d.opcode == scanSkipSpace {
< 			d.scanWhile(scanSkipSpace)
< 		}
< 		if d.opcode != scanObjectKey {
< 			panic(phasePanicMsg)
< 		}
< 		d.scanWhile(scanSkipSpace)
< 
< 		// Read value.
< 		m[key] = d.valueInterface()
< 
< 		// Next token must be , or }.
< 		if d.opcode == scanSkipSpace {
< 			d.scanWhile(scanSkipSpace)
< 		}
< 		if d.opcode == scanEndObject {
< 			break
< 		}
< 		if d.opcode != scanObjectValue {
< 			panic(phasePanicMsg)
< 		}
< 	}
< 	return m
< }
< 
< // literalInterface consumes and returns a literal from d.data[d.off-1:] and
< // it reads the following byte ahead. The first byte of the literal has been
< // read already (that's how the caller knows it's a literal).
< func (d *decodeState) literalInterface() interface{} {
< 	// All bytes inside literal return scanContinue op code.
< 	start := d.readIndex()
< 	d.rescanLiteral()
< 
< 	item := d.data[start:d.readIndex()]
< 
< 	switch c := item[0]; c {
< 	case 'n': // null
< 		return nil
< 
< 	case 't', 'f': // true, false
< 		return c == 't'
< 
< 	case '"': // string
< 		s, ok := d.unquote(item)
< 		if !ok {
< 			panic(phasePanicMsg)
< 		}
< 		return s
< 
< 	default: // number
< 		if c != '-' && (c < '0' || c > '9') {
< 			panic(phasePanicMsg)
< 		}
< 		n, err := d.convertNumber(string(item))
< 		if err != nil {
< 			d.saveError(err)
< 		}
< 		return n
< 	}
< }
< 
< // getu4 decodes \uXXXX from the beginning of s, returning the hex value,
< // or it returns -1.
< func getu4(s []byte) rune {
< 	if len(s) < 6 || s[0] != '\\' || s[1] != 'u' {
< 		return -1
< 	}
< 	var r rune
< 	for _, c := range s[2:6] {
< 		switch {
< 		case '0' <= c && c <= '9':
< 			c = c - '0'
< 		case 'a' <= c && c <= 'f':
< 			c = c - 'a' + 10
< 		case 'A' <= c && c <= 'F':
< 			c = c - 'A' + 10
< 		default:
< 			return -1
< 		}
< 		r = r*16 + rune(c)
< 	}
< 	return r
< }
< 
< // unquote converts a quoted JSON string literal s into an actual string t.
< // The rules are different than for Go, so cannot use strconv.Unquote.
< // The first byte in s must be '"'.
< func (d *decodeState) unquote(s []byte) (t string, ok bool) {
< 	s, ok = d.unquoteBytes(s)
< 	t = string(s)
< 	return
< }
< 
< func (d *decodeState) unquoteBytes(s []byte) (t []byte, ok bool) {
< 	// We already know that s[0] == '"'. However, we don't know that the
< 	// closing quote exists in all cases, such as when the string is nested
< 	// via the ",string" option.
< 	if len(s) < 2 || s[len(s)-1] != '"' {
< 		return
< 	}
< 	s = s[1 : len(s)-1]
< 
< 	// If there are no unusual characters, no unquoting is needed, so return
< 	// a slice of the original bytes.
< 	r := d.safeUnquote
< 	if r == -1 {
< 		return s, true
< 	}
< 
< 	b := make([]byte, len(s)+2*utf8.UTFMax)
< 	w := copy(b, s[0:r])
< 	for r < len(s) {
< 		// Out of room? Can only happen if s is full of
< 		// malformed UTF-8 and we're replacing each
< 		// byte with RuneError.
< 		if w >= len(b)-2*utf8.UTFMax {
< 			nb := make([]byte, (len(b)+utf8.UTFMax)*2)
< 			copy(nb, b[0:w])
< 			b = nb
< 		}
< 		switch c := s[r]; {
< 		case c == '\\':
< 			r++
< 			if r >= len(s) {
< 				return
< 			}
< 			switch s[r] {
< 			default:
< 				return
< 			case '"', '\\', '/', '\'':
< 				b[w] = s[r]
< 				r++
< 				w++
< 			case 'b':
< 				b[w] = '\b'
< 				r++
< 				w++
< 			case 'f':
< 				b[w] = '\f'
< 				r++
< 				w++
< 			case 'n':
< 				b[w] = '\n'
< 				r++
< 				w++
< 			case 'r':
< 				b[w] = '\r'
< 				r++
< 				w++
< 			case 't':
< 				b[w] = '\t'
< 				r++
< 				w++
< 			case 'u':
< 				r--
< 				rr := getu4(s[r:])
< 				if rr < 0 {
< 					return
< 				}
< 				r += 6
< 				if utf16.IsSurrogate(rr) {
< 					rr1 := getu4(s[r:])
< 					if dec := utf16.DecodeRune(rr, rr1); dec != unicode.ReplacementChar {
< 						// A valid pair; consume.
< 						r += 6
< 						w += utf8.EncodeRune(b[w:], dec)
< 						break
< 					}
< 					// Invalid surrogate; fall back to replacement rune.
< 					rr = unicode.ReplacementChar
< 				}
< 				w += utf8.EncodeRune(b[w:], rr)
< 			}
< 
< 		// Quote, control characters are invalid.
< 		case c == '"', c < ' ':
< 			return
< 
< 		// ASCII
< 		case c < utf8.RuneSelf:
< 			b[w] = c
< 			r++
< 			w++
< 
< 		// Coerce to well-formed UTF-8.
< 		default:
< 			rr, size := utf8.DecodeRune(s[r:])
< 			r += size
< 			w += utf8.EncodeRune(b[w:], rr)
< 		}
< 	}
< 	return b[0:w], true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/encode.go updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/encode.go
1,1374d0
< // Copyright 2010 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< // Package json implements encoding and decoding of JSON as defined in
< // RFC 7159. The mapping between JSON and Go values is described
< // in the documentation for the Marshal and Unmarshal functions.
< //
< // See "JSON and Go" for an introduction to this package:
< // https://golang.org/doc/articles/json_and_go.html
< package json
< 
< import (
< 	"bytes"
< 	"encoding"
< 	"encoding/base64"
< 	"fmt"
< 	"math"
< 	"reflect"
< 	"sort"
< 	"strconv"
< 	"strings"
< 	"sync"
< 	"unicode"
< 	"unicode/utf8"
< )
< 
< // Marshal returns the JSON encoding of v.
< //
< // Marshal traverses the value v recursively.
< // If an encountered value implements the Marshaler interface
< // and is not a nil pointer, Marshal calls its MarshalJSON method
< // to produce JSON. If no MarshalJSON method is present but the
< // value implements encoding.TextMarshaler instead, Marshal calls
< // its MarshalText method and encodes the result as a JSON string.
< // The nil pointer exception is not strictly necessary
< // but mimics a similar, necessary exception in the behavior of
< // UnmarshalJSON.
< //
< // Otherwise, Marshal uses the following type-dependent default encodings:
< //
< // Boolean values encode as JSON booleans.
< //
< // Floating point, integer, and Number values encode as JSON numbers.
< //
< // String values encode as JSON strings coerced to valid UTF-8,
< // replacing invalid bytes with the Unicode replacement rune.
< // So that the JSON will be safe to embed inside HTML <script> tags,
< // the string is encoded using HTMLEscape,
< // which replaces "<", ">", "&", U+2028, and U+2029 are escaped
< // to "\u003c","\u003e", "\u0026", "\u2028", and "\u2029".
< // This replacement can be disabled when using an Encoder,
< // by calling SetEscapeHTML(false).
< //
< // Array and slice values encode as JSON arrays, except that
< // []byte encodes as a base64-encoded string, and a nil slice
< // encodes as the null JSON value.
< //
< // Struct values encode as JSON objects.
< // Each exported struct field becomes a member of the object, using the
< // field name as the object key, unless the field is omitted for one of the
< // reasons given below.
< //
< // The encoding of each struct field can be customized by the format string
< // stored under the "json" key in the struct field's tag.
< // The format string gives the name of the field, possibly followed by a
< // comma-separated list of options. The name may be empty in order to
< // specify options without overriding the default field name.
< //
< // The "omitempty" option specifies that the field should be omitted
< // from the encoding if the field has an empty value, defined as
< // false, 0, a nil pointer, a nil interface value, and any empty array,
< // slice, map, or string.
< //
< // As a special case, if the field tag is "-", the field is always omitted.
< // Note that a field with name "-" can still be generated using the tag "-,".
< //
< // Examples of struct field tags and their meanings:
< //
< //   // Field appears in JSON as key "myName".
< //   Field int `json:"myName"`
< //
< //   // Field appears in JSON as key "myName" and
< //   // the field is omitted from the object if its value is empty,
< //   // as defined above.
< //   Field int `json:"myName,omitempty"`
< //
< //   // Field appears in JSON as key "Field" (the default), but
< //   // the field is skipped if empty.
< //   // Note the leading comma.
< //   Field int `json:",omitempty"`
< //
< //   // Field is ignored by this package.
< //   Field int `json:"-"`
< //
< //   // Field appears in JSON as key "-".
< //   Field int `json:"-,"`
< //
< // The "string" option signals that a field is stored as JSON inside a
< // JSON-encoded string. It applies only to fields of string, floating point,
< // integer, or boolean types. This extra level of encoding is sometimes used
< // when communicating with JavaScript programs:
< //
< //    Int64String int64 `json:",string"`
< //
< // The key name will be used if it's a non-empty string consisting of
< // only Unicode letters, digits, and ASCII punctuation except quotation
< // marks, backslash, and comma.
< //
< // Anonymous struct fields are usually marshaled as if their inner exported fields
< // were fields in the outer struct, subject to the usual Go visibility rules amended
< // as described in the next paragraph.
< // An anonymous struct field with a name given in its JSON tag is treated as
< // having that name, rather than being anonymous.
< // An anonymous struct field of interface type is treated the same as having
< // that type as its name, rather than being anonymous.
< //
< // The Go visibility rules for struct fields are amended for JSON when
< // deciding which field to marshal or unmarshal. If there are
< // multiple fields at the same level, and that level is the least
< // nested (and would therefore be the nesting level selected by the
< // usual Go rules), the following extra rules apply:
< //
< // 1) Of those fields, if any are JSON-tagged, only tagged fields are considered,
< // even if there are multiple untagged fields that would otherwise conflict.
< //
< // 2) If there is exactly one field (tagged or not according to the first rule), that is selected.
< //
< // 3) Otherwise there are multiple fields, and all are ignored; no error occurs.
< //
< // Handling of anonymous struct fields is new in Go 1.1.
< // Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of
< // an anonymous struct field in both current and earlier versions, give the field
< // a JSON tag of "-".
< //
< // Map values encode as JSON objects. The map's key type must either be a
< // string, an integer type, or implement encoding.TextMarshaler. The map keys
< // are sorted and used as JSON object keys by applying the following rules,
< // subject to the UTF-8 coercion described for string values above:
< //   - keys of any string type are used directly
< //   - encoding.TextMarshalers are marshaled
< //   - integer keys are converted to strings
< //
< // Pointer values encode as the value pointed to.
< // A nil pointer encodes as the null JSON value.
< //
< // Interface values encode as the value contained in the interface.
< // A nil interface value encodes as the null JSON value.
< //
< // Channel, complex, and function values cannot be encoded in JSON.
< // Attempting to encode such a value causes Marshal to return
< // an UnsupportedTypeError.
< //
< // JSON cannot represent cyclic data structures and Marshal does not
< // handle them. Passing cyclic structures to Marshal will result in
< // an infinite recursion.
< //
< func Marshal(v interface{}) ([]byte, error) {
< 	e := newEncodeState()
< 
< 	err := e.marshal(v, encOpts{escapeHTML: true})
< 	if err != nil {
< 		return nil, err
< 	}
< 	buf := append([]byte(nil), e.Bytes()...)
< 
< 	encodeStatePool.Put(e)
< 
< 	return buf, nil
< }
< 
< // MarshalIndent is like Marshal but applies Indent to format the output.
< // Each JSON element in the output will begin on a new line beginning with prefix
< // followed by one or more copies of indent according to the indentation nesting.
< func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {
< 	b, err := Marshal(v)
< 	if err != nil {
< 		return nil, err
< 	}
< 	var buf bytes.Buffer
< 	err = Indent(&buf, b, prefix, indent)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return buf.Bytes(), nil
< }
< 
< // HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029
< // characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029
< // so that the JSON will be safe to embed inside HTML <script> tags.
< // For historical reasons, web browsers don't honor standard HTML
< // escaping within <script> tags, so an alternative JSON encoding must
< // be used.
< func HTMLEscape(dst *bytes.Buffer, src []byte) {
< 	// The characters can only appear in string literals,
< 	// so just scan the string one byte at a time.
< 	start := 0
< 	for i, c := range src {
< 		if c == '<' || c == '>' || c == '&' {
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			dst.WriteString(`\u00`)
< 			dst.WriteByte(hex[c>>4])
< 			dst.WriteByte(hex[c&0xF])
< 			start = i + 1
< 		}
< 		// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
< 		if c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			dst.WriteString(`\u202`)
< 			dst.WriteByte(hex[src[i+2]&0xF])
< 			start = i + 3
< 		}
< 	}
< 	if start < len(src) {
< 		dst.Write(src[start:])
< 	}
< }
< 
< // Marshaler is the interface implemented by types that
< // can marshal themselves into valid JSON.
< type Marshaler interface {
< 	MarshalJSON() ([]byte, error)
< }
< 
< // An UnsupportedTypeError is returned by Marshal when attempting
< // to encode an unsupported value type.
< type UnsupportedTypeError struct {
< 	Type reflect.Type
< }
< 
< func (e *UnsupportedTypeError) Error() string {
< 	return "json: unsupported type: " + e.Type.String()
< }
< 
< type UnsupportedValueError struct {
< 	Value reflect.Value
< 	Str   string
< }
< 
< func (e *UnsupportedValueError) Error() string {
< 	return "json: unsupported value: " + e.Str
< }
< 
< // Before Go 1.2, an InvalidUTF8Error was returned by Marshal when
< // attempting to encode a string value with invalid UTF-8 sequences.
< // As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by
< // replacing invalid bytes with the Unicode replacement rune U+FFFD.
< //
< // Deprecated: No longer used; kept for compatibility.
< type InvalidUTF8Error struct {
< 	S string // the whole string value that caused the error
< }
< 
< func (e *InvalidUTF8Error) Error() string {
< 	return "json: invalid UTF-8 in string: " + strconv.Quote(e.S)
< }
< 
< // A MarshalerError represents an error from calling a MarshalJSON or MarshalText method.
< type MarshalerError struct {
< 	Type       reflect.Type
< 	Err        error
< 	sourceFunc string
< }
< 
< func (e *MarshalerError) Error() string {
< 	srcFunc := e.sourceFunc
< 	if srcFunc == "" {
< 		srcFunc = "MarshalJSON"
< 	}
< 	return "json: error calling " + srcFunc +
< 		" for type " + e.Type.String() +
< 		": " + e.Err.Error()
< }
< 
< // Unwrap returns the underlying error.
< func (e *MarshalerError) Unwrap() error { return e.Err }
< 
< var hex = "0123456789abcdef"
< 
< // An encodeState encodes JSON into a bytes.Buffer.
< type encodeState struct {
< 	bytes.Buffer // accumulated output
< 	scratch      [64]byte
< }
< 
< var encodeStatePool sync.Pool
< 
< func newEncodeState() *encodeState {
< 	if v := encodeStatePool.Get(); v != nil {
< 		e := v.(*encodeState)
< 		e.Reset()
< 		return e
< 	}
< 	return new(encodeState)
< }
< 
< // jsonError is an error wrapper type for internal use only.
< // Panics with errors are wrapped in jsonError so that the top-level recover
< // can distinguish intentional panics from this package.
< type jsonError struct{ error }
< 
< func (e *encodeState) marshal(v interface{}, opts encOpts) (err error) {
< 	defer func() {
< 		if r := recover(); r != nil {
< 			if je, ok := r.(jsonError); ok {
< 				err = je.error
< 			} else {
< 				panic(r)
< 			}
< 		}
< 	}()
< 	e.reflectValue(reflect.ValueOf(v), opts)
< 	return nil
< }
< 
< // error aborts the encoding by panicking with err wrapped in jsonError.
< func (e *encodeState) error(err error) {
< 	panic(jsonError{err})
< }
< 
< func isEmptyValue(v reflect.Value) bool {
< 	switch v.Kind() {
< 	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
< 		return v.Len() == 0
< 	case reflect.Bool:
< 		return !v.Bool()
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return v.Int() == 0
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return v.Uint() == 0
< 	case reflect.Float32, reflect.Float64:
< 		return v.Float() == 0
< 	case reflect.Interface, reflect.Ptr:
< 		return v.IsNil()
< 	case reflect.Struct:
< 		vt := v.Type()
< 		for i := v.NumField() - 1; i >= 0; i-- {
< 			if vt.Field(i).PkgPath != "" {
< 				continue // Private field
< 			}
< 			if !isEmptyValue(v.Field(i)) {
< 				return false
< 			}
< 		}
< 		return true
< 	}
< 	return false
< }
< 
< func (e *encodeState) reflectValue(v reflect.Value, opts encOpts) {
< 	valueEncoder(v)(e, v, opts)
< }
< 
< type encOpts struct {
< 	// quoted causes primitive fields to be encoded inside JSON strings.
< 	quoted bool
< 	// escapeHTML causes '<', '>', and '&' to be escaped in JSON strings.
< 	escapeHTML bool
< }
< 
< type encoderFunc func(e *encodeState, v reflect.Value, opts encOpts)
< 
< var encoderCache sync.Map // map[reflect.Type]encoderFunc
< 
< func valueEncoder(v reflect.Value) encoderFunc {
< 	if !v.IsValid() {
< 		return invalidValueEncoder
< 	}
< 	return typeEncoder(v.Type())
< }
< 
< func typeEncoder(t reflect.Type) encoderFunc {
< 	if fi, ok := encoderCache.Load(t); ok {
< 		return fi.(encoderFunc)
< 	}
< 
< 	// To deal with recursive types, populate the map with an
< 	// indirect func before we build it. This type waits on the
< 	// real func (f) to be ready and then calls it. This indirect
< 	// func is only used for recursive types.
< 	var (
< 		wg sync.WaitGroup
< 		f  encoderFunc
< 	)
< 	wg.Add(1)
< 	fi, loaded := encoderCache.LoadOrStore(t, encoderFunc(func(e *encodeState, v reflect.Value, opts encOpts) {
< 		wg.Wait()
< 		f(e, v, opts)
< 	}))
< 	if loaded {
< 		return fi.(encoderFunc)
< 	}
< 
< 	// Compute the real encoder and replace the indirect func with it.
< 	f = newTypeEncoder(t, true)
< 	wg.Done()
< 	encoderCache.Store(t, f)
< 	return f
< }
< 
< var (
< 	marshalerType     = reflect.TypeOf((*Marshaler)(nil)).Elem()
< 	textMarshalerType = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
< )
< 
< // newTypeEncoder constructs an encoderFunc for a type.
< // The returned encoder only checks CanAddr when allowAddr is true.
< func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {
< 	// If we have a non-pointer value whose type implements
< 	// Marshaler with a value receiver, then we're better off taking
< 	// the address of the value - otherwise we end up with an
< 	// allocation as we cast the value to an interface.
< 	if t.Kind() != reflect.Ptr && allowAddr && reflect.PtrTo(t).Implements(marshalerType) {
< 		return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))
< 	}
< 	if t.Implements(marshalerType) {
< 		return marshalerEncoder
< 	}
< 	if t.Kind() != reflect.Ptr && allowAddr && reflect.PtrTo(t).Implements(textMarshalerType) {
< 		return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false))
< 	}
< 	if t.Implements(textMarshalerType) {
< 		return textMarshalerEncoder
< 	}
< 
< 	switch t.Kind() {
< 	case reflect.Bool:
< 		return boolEncoder
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return intEncoder
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return uintEncoder
< 	case reflect.Float32:
< 		return float32Encoder
< 	case reflect.Float64:
< 		return float64Encoder
< 	case reflect.String:
< 		return stringEncoder
< 	case reflect.Interface:
< 		return interfaceEncoder
< 	case reflect.Struct:
< 		return newStructEncoder(t)
< 	case reflect.Map:
< 		return newMapEncoder(t)
< 	case reflect.Slice:
< 		return newSliceEncoder(t)
< 	case reflect.Array:
< 		return newArrayEncoder(t)
< 	case reflect.Ptr:
< 		return newPtrEncoder(t)
< 	default:
< 		return unsupportedTypeEncoder
< 	}
< }
< 
< func invalidValueEncoder(e *encodeState, v reflect.Value, _ encOpts) {
< 	e.WriteString("null")
< }
< 
< func marshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
< 	if v.Kind() == reflect.Ptr && v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	m, ok := v.Interface().(Marshaler)
< 	if !ok {
< 		e.WriteString("null")
< 		return
< 	}
< 	b, err := m.MarshalJSON()
< 	if err == nil {
< 		// copy JSON into buffer, checking validity.
< 		err = compact(&e.Buffer, b, opts.escapeHTML)
< 	}
< 	if err != nil {
< 		e.error(&MarshalerError{v.Type(), err, "MarshalJSON"})
< 	}
< }
< 
< func addrMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
< 	va := v.Addr()
< 	if va.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	m := va.Interface().(Marshaler)
< 	b, err := m.MarshalJSON()
< 	if err == nil {
< 		// copy JSON into buffer, checking validity.
< 		err = compact(&e.Buffer, b, opts.escapeHTML)
< 	}
< 	if err != nil {
< 		e.error(&MarshalerError{v.Type(), err, "MarshalJSON"})
< 	}
< }
< 
< func textMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
< 	if v.Kind() == reflect.Ptr && v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	m, ok := v.Interface().(encoding.TextMarshaler)
< 	if !ok {
< 		e.WriteString("null")
< 		return
< 	}
< 	b, err := m.MarshalText()
< 	if err != nil {
< 		e.error(&MarshalerError{v.Type(), err, "MarshalText"})
< 	}
< 	e.stringBytes(b, opts.escapeHTML)
< }
< 
< func addrTextMarshalerEncoder(e *encodeState, v reflect.Value, opts encOpts) {
< 	va := v.Addr()
< 	if va.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	m := va.Interface().(encoding.TextMarshaler)
< 	b, err := m.MarshalText()
< 	if err != nil {
< 		e.error(&MarshalerError{v.Type(), err, "MarshalText"})
< 	}
< 	e.stringBytes(b, opts.escapeHTML)
< }
< 
< func boolEncoder(e *encodeState, v reflect.Value, opts encOpts) {
< 	if opts.quoted {
< 		e.WriteByte('"')
< 	}
< 	if v.Bool() {
< 		e.WriteString("true")
< 	} else {
< 		e.WriteString("false")
< 	}
< 	if opts.quoted {
< 		e.WriteByte('"')
< 	}
< }
< 
< func intEncoder(e *encodeState, v reflect.Value, opts encOpts) {
< 	b := strconv.AppendInt(e.scratch[:0], v.Int(), 10)
< 	if opts.quoted {
< 		e.WriteByte('"')
< 	}
< 	e.Write(b)
< 	if opts.quoted {
< 		e.WriteByte('"')
< 	}
< }
< 
< func uintEncoder(e *encodeState, v reflect.Value, opts encOpts) {
< 	b := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)
< 	if opts.quoted {
< 		e.WriteByte('"')
< 	}
< 	e.Write(b)
< 	if opts.quoted {
< 		e.WriteByte('"')
< 	}
< }
< 
< type floatEncoder int // number of bits
< 
< func (bits floatEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
< 	f := v.Float()
< 	if math.IsInf(f, 0) || math.IsNaN(f) {
< 		e.error(&UnsupportedValueError{v, strconv.FormatFloat(f, 'g', -1, int(bits))})
< 	}
< 
< 	// Convert as if by ES6 number to string conversion.
< 	// This matches most other JSON generators.
< 	// See golang.org/issue/6384 and golang.org/issue/14135.
< 	// Like fmt %g, but the exponent cutoffs are different
< 	// and exponents themselves are not padded to two digits.
< 	b := e.scratch[:0]
< 	abs := math.Abs(f)
< 	fmt := byte('f')
< 	// Note: Must use float32 comparisons for underlying float32 value to get precise cutoffs right.
< 	if abs != 0 {
< 		if bits == 64 && (abs < 1e-6 || abs >= 1e21) || bits == 32 && (float32(abs) < 1e-6 || float32(abs) >= 1e21) {
< 			fmt = 'e'
< 		}
< 	}
< 	b = strconv.AppendFloat(b, f, fmt, -1, int(bits))
< 	if fmt == 'e' {
< 		// clean up e-09 to e-9
< 		n := len(b)
< 		if n >= 4 && b[n-4] == 'e' && b[n-3] == '-' && b[n-2] == '0' {
< 			b[n-2] = b[n-1]
< 			b = b[:n-1]
< 		}
< 	}
< 
< 	if opts.quoted {
< 		e.WriteByte('"')
< 	}
< 	e.Write(b)
< 	if opts.quoted {
< 		e.WriteByte('"')
< 	}
< }
< 
< var (
< 	float32Encoder = (floatEncoder(32)).encode
< 	float64Encoder = (floatEncoder(64)).encode
< )
< 
< func stringEncoder(e *encodeState, v reflect.Value, opts encOpts) {
< 	if v.Type() == numberType {
< 		numStr := v.String()
< 		// In Go1.5 the empty string encodes to "0", while this is not a valid number literal
< 		// we keep compatibility so check validity after this.
< 		if numStr == "" {
< 			numStr = "0" // Number's zero-val
< 		}
< 		if !isValidNumber(numStr) {
< 			e.error(fmt.Errorf("json: invalid number literal %q", numStr))
< 		}
< 		if opts.quoted {
< 			e.WriteByte('"')
< 		}
< 		e.WriteString(numStr)
< 		if opts.quoted {
< 			e.WriteByte('"')
< 		}
< 		return
< 	}
< 	if opts.quoted {
< 		b := make([]byte, 0, v.Len()+2)
< 		b = append(b, '"')
< 		b = append(b, []byte(v.String())...)
< 		b = append(b, '"')
< 		e.stringBytes(b, opts.escapeHTML)
< 	} else {
< 		e.string(v.String(), opts.escapeHTML)
< 	}
< }
< 
< // isValidNumber reports whether s is a valid JSON number literal.
< func isValidNumber(s string) bool {
< 	// This function implements the JSON numbers grammar.
< 	// See https://tools.ietf.org/html/rfc7159#section-6
< 	// and https://json.org/number.gif
< 
< 	if s == "" {
< 		return false
< 	}
< 
< 	// Optional -
< 	if s[0] == '-' {
< 		s = s[1:]
< 		if s == "" {
< 			return false
< 		}
< 	}
< 
< 	// Digits
< 	switch {
< 	default:
< 		return false
< 
< 	case s[0] == '0':
< 		s = s[1:]
< 
< 	case '1' <= s[0] && s[0] <= '9':
< 		s = s[1:]
< 		for len(s) > 0 && '0' <= s[0] && s[0] <= '9' {
< 			s = s[1:]
< 		}
< 	}
< 
< 	// . followed by 1 or more digits.
< 	if len(s) >= 2 && s[0] == '.' && '0' <= s[1] && s[1] <= '9' {
< 		s = s[2:]
< 		for len(s) > 0 && '0' <= s[0] && s[0] <= '9' {
< 			s = s[1:]
< 		}
< 	}
< 
< 	// e or E followed by an optional - or + and
< 	// 1 or more digits.
< 	if len(s) >= 2 && (s[0] == 'e' || s[0] == 'E') {
< 		s = s[1:]
< 		if s[0] == '+' || s[0] == '-' {
< 			s = s[1:]
< 			if s == "" {
< 				return false
< 			}
< 		}
< 		for len(s) > 0 && '0' <= s[0] && s[0] <= '9' {
< 			s = s[1:]
< 		}
< 	}
< 
< 	// Make sure we are at the end.
< 	return s == ""
< }
< 
< func interfaceEncoder(e *encodeState, v reflect.Value, opts encOpts) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	e.reflectValue(v.Elem(), opts)
< }
< 
< func unsupportedTypeEncoder(e *encodeState, v reflect.Value, _ encOpts) {
< 	e.error(&UnsupportedTypeError{v.Type()})
< }
< 
< type structEncoder struct {
< 	fields structFields
< }
< 
< type structFields struct {
< 	list      []field
< 	nameIndex map[string]int
< }
< 
< func (se structEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
< 	next := byte('{')
< FieldLoop:
< 	for i := range se.fields.list {
< 		f := &se.fields.list[i]
< 
< 		// Find the nested struct field by following f.index.
< 		fv := v
< 		for _, i := range f.index {
< 			if fv.Kind() == reflect.Ptr {
< 				if fv.IsNil() {
< 					continue FieldLoop
< 				}
< 				fv = fv.Elem()
< 			}
< 			fv = fv.Field(i)
< 		}
< 
< 		if f.omitEmpty && isEmptyValue(fv) {
< 			continue
< 		}
< 		e.WriteByte(next)
< 		next = ','
< 		if opts.escapeHTML {
< 			e.WriteString(f.nameEscHTML)
< 		} else {
< 			e.WriteString(f.nameNonEsc)
< 		}
< 		opts.quoted = f.quoted
< 		f.encoder(e, fv, opts)
< 	}
< 	if next == '{' {
< 		e.WriteString("{}")
< 	} else {
< 		e.WriteByte('}')
< 	}
< }
< 
< func newStructEncoder(t reflect.Type) encoderFunc {
< 	se := structEncoder{fields: cachedTypeFields(t)}
< 	return se.encode
< }
< 
< type mapEncoder struct {
< 	elemEnc encoderFunc
< }
< 
< func (me mapEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	e.WriteByte('{')
< 
< 	// Extract and sort the keys.
< 	keys := v.MapKeys()
< 	sv := make([]reflectWithString, len(keys))
< 	for i, v := range keys {
< 		sv[i].v = v
< 		if err := sv[i].resolve(); err != nil {
< 			e.error(fmt.Errorf("json: encoding error for type %q: %q", v.Type().String(), err.Error()))
< 		}
< 	}
< 	sort.Slice(sv, func(i, j int) bool { return sv[i].s < sv[j].s })
< 
< 	for i, kv := range sv {
< 		if i > 0 {
< 			e.WriteByte(',')
< 		}
< 		e.string(kv.s, opts.escapeHTML)
< 		e.WriteByte(':')
< 		me.elemEnc(e, v.MapIndex(kv.v), opts)
< 	}
< 	e.WriteByte('}')
< }
< 
< func newMapEncoder(t reflect.Type) encoderFunc {
< 	switch t.Key().Kind() {
< 	case reflect.String,
< 		reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
< 		reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 	default:
< 		if !t.Key().Implements(textMarshalerType) {
< 			return unsupportedTypeEncoder
< 		}
< 	}
< 	me := mapEncoder{typeEncoder(t.Elem())}
< 	return me.encode
< }
< 
< func encodeByteSlice(e *encodeState, v reflect.Value, _ encOpts) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	s := v.Bytes()
< 	e.WriteByte('"')
< 	encodedLen := base64.StdEncoding.EncodedLen(len(s))
< 	if encodedLen <= len(e.scratch) {
< 		// If the encoded bytes fit in e.scratch, avoid an extra
< 		// allocation and use the cheaper Encoding.Encode.
< 		dst := e.scratch[:encodedLen]
< 		base64.StdEncoding.Encode(dst, s)
< 		e.Write(dst)
< 	} else if encodedLen <= 1024 {
< 		// The encoded bytes are short enough to allocate for, and
< 		// Encoding.Encode is still cheaper.
< 		dst := make([]byte, encodedLen)
< 		base64.StdEncoding.Encode(dst, s)
< 		e.Write(dst)
< 	} else {
< 		// The encoded bytes are too long to cheaply allocate, and
< 		// Encoding.Encode is no longer noticeably cheaper.
< 		enc := base64.NewEncoder(base64.StdEncoding, e)
< 		enc.Write(s)
< 		enc.Close()
< 	}
< 	e.WriteByte('"')
< }
< 
< // sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn't nil.
< type sliceEncoder struct {
< 	arrayEnc encoderFunc
< }
< 
< func (se sliceEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	se.arrayEnc(e, v, opts)
< }
< 
< func newSliceEncoder(t reflect.Type) encoderFunc {
< 	// Byte slices get special treatment; arrays don't.
< 	if t.Elem().Kind() == reflect.Uint8 {
< 		p := reflect.PtrTo(t.Elem())
< 		if !p.Implements(marshalerType) && !p.Implements(textMarshalerType) {
< 			return encodeByteSlice
< 		}
< 	}
< 	enc := sliceEncoder{newArrayEncoder(t)}
< 	return enc.encode
< }
< 
< type arrayEncoder struct {
< 	elemEnc encoderFunc
< }
< 
< func (ae arrayEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
< 	e.WriteByte('[')
< 	n := v.Len()
< 	for i := 0; i < n; i++ {
< 		if i > 0 {
< 			e.WriteByte(',')
< 		}
< 		ae.elemEnc(e, v.Index(i), opts)
< 	}
< 	e.WriteByte(']')
< }
< 
< func newArrayEncoder(t reflect.Type) encoderFunc {
< 	enc := arrayEncoder{typeEncoder(t.Elem())}
< 	return enc.encode
< }
< 
< type ptrEncoder struct {
< 	elemEnc encoderFunc
< }
< 
< func (pe ptrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	pe.elemEnc(e, v.Elem(), opts)
< }
< 
< func newPtrEncoder(t reflect.Type) encoderFunc {
< 	enc := ptrEncoder{typeEncoder(t.Elem())}
< 	return enc.encode
< }
< 
< type condAddrEncoder struct {
< 	canAddrEnc, elseEnc encoderFunc
< }
< 
< func (ce condAddrEncoder) encode(e *encodeState, v reflect.Value, opts encOpts) {
< 	if v.CanAddr() {
< 		ce.canAddrEnc(e, v, opts)
< 	} else {
< 		ce.elseEnc(e, v, opts)
< 	}
< }
< 
< // newCondAddrEncoder returns an encoder that checks whether its value
< // CanAddr and delegates to canAddrEnc if so, else to elseEnc.
< func newCondAddrEncoder(canAddrEnc, elseEnc encoderFunc) encoderFunc {
< 	enc := condAddrEncoder{canAddrEnc: canAddrEnc, elseEnc: elseEnc}
< 	return enc.encode
< }
< 
< func isValidTag(s string) bool {
< 	if s == "" {
< 		return false
< 	}
< 	for _, c := range s {
< 		switch {
< 		case strings.ContainsRune("!#$%&()*+-./:<=>?@[]^_{|}~ ", c):
< 			// Backslash and quote chars are reserved, but
< 			// otherwise any punctuation chars are allowed
< 			// in a tag name.
< 		case !unicode.IsLetter(c) && !unicode.IsDigit(c):
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< func typeByIndex(t reflect.Type, index []int) reflect.Type {
< 	for _, i := range index {
< 		if t.Kind() == reflect.Ptr {
< 			t = t.Elem()
< 		}
< 		t = t.Field(i).Type
< 	}
< 	return t
< }
< 
< type reflectWithString struct {
< 	v reflect.Value
< 	s string
< }
< 
< func (w *reflectWithString) resolve() error {
< 	if w.v.Kind() == reflect.String {
< 		w.s = w.v.String()
< 		return nil
< 	}
< 	if tm, ok := w.v.Interface().(encoding.TextMarshaler); ok {
< 		if w.v.Kind() == reflect.Ptr && w.v.IsNil() {
< 			return nil
< 		}
< 		buf, err := tm.MarshalText()
< 		w.s = string(buf)
< 		return err
< 	}
< 	switch w.v.Kind() {
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		w.s = strconv.FormatInt(w.v.Int(), 10)
< 		return nil
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		w.s = strconv.FormatUint(w.v.Uint(), 10)
< 		return nil
< 	}
< 	panic("unexpected map key type")
< }
< 
< // NOTE: keep in sync with stringBytes below.
< func (e *encodeState) string(s string, escapeHTML bool) {
< 	e.WriteByte('"')
< 	start := 0
< 	for i := 0; i < len(s); {
< 		if b := s[i]; b < utf8.RuneSelf {
< 			if htmlSafeSet[b] || (!escapeHTML && safeSet[b]) {
< 				i++
< 				continue
< 			}
< 			if start < i {
< 				e.WriteString(s[start:i])
< 			}
< 			e.WriteByte('\\')
< 			switch b {
< 			case '\\', '"':
< 				e.WriteByte(b)
< 			case '\n':
< 				e.WriteByte('n')
< 			case '\r':
< 				e.WriteByte('r')
< 			case '\t':
< 				e.WriteByte('t')
< 			default:
< 				// This encodes bytes < 0x20 except for \t, \n and \r.
< 				// If escapeHTML is set, it also escapes <, >, and &
< 				// because they can lead to security holes when
< 				// user-controlled strings are rendered into JSON
< 				// and served to some browsers.
< 				e.WriteString(`u00`)
< 				e.WriteByte(hex[b>>4])
< 				e.WriteByte(hex[b&0xF])
< 			}
< 			i++
< 			start = i
< 			continue
< 		}
< 		c, size := utf8.DecodeRuneInString(s[i:])
< 		if c == utf8.RuneError && size == 1 {
< 			if start < i {
< 				e.WriteString(s[start:i])
< 			}
< 			e.WriteString(`\ufffd`)
< 			i += size
< 			start = i
< 			continue
< 		}
< 		// U+2028 is LINE SEPARATOR.
< 		// U+2029 is PARAGRAPH SEPARATOR.
< 		// They are both technically valid characters in JSON strings,
< 		// but don't work in JSONP, which has to be evaluated as JavaScript,
< 		// and can lead to security holes there. It is valid JSON to
< 		// escape them, so we do so unconditionally.
< 		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
< 		if c == '\u2028' || c == '\u2029' {
< 			if start < i {
< 				e.WriteString(s[start:i])
< 			}
< 			e.WriteString(`\u202`)
< 			e.WriteByte(hex[c&0xF])
< 			i += size
< 			start = i
< 			continue
< 		}
< 		i += size
< 	}
< 	if start < len(s) {
< 		e.WriteString(s[start:])
< 	}
< 	e.WriteByte('"')
< }
< 
< // NOTE: keep in sync with string above.
< func (e *encodeState) stringBytes(s []byte, escapeHTML bool) {
< 	e.WriteByte('"')
< 	start := 0
< 	for i := 0; i < len(s); {
< 		if b := s[i]; b < utf8.RuneSelf {
< 			if htmlSafeSet[b] || (!escapeHTML && safeSet[b]) {
< 				i++
< 				continue
< 			}
< 			if start < i {
< 				e.Write(s[start:i])
< 			}
< 			e.WriteByte('\\')
< 			switch b {
< 			case '\\', '"':
< 				e.WriteByte(b)
< 			case '\n':
< 				e.WriteByte('n')
< 			case '\r':
< 				e.WriteByte('r')
< 			case '\t':
< 				e.WriteByte('t')
< 			default:
< 				// This encodes bytes < 0x20 except for \t, \n and \r.
< 				// If escapeHTML is set, it also escapes <, >, and &
< 				// because they can lead to security holes when
< 				// user-controlled strings are rendered into JSON
< 				// and served to some browsers.
< 				e.WriteString(`u00`)
< 				e.WriteByte(hex[b>>4])
< 				e.WriteByte(hex[b&0xF])
< 			}
< 			i++
< 			start = i
< 			continue
< 		}
< 		c, size := utf8.DecodeRune(s[i:])
< 		if c == utf8.RuneError && size == 1 {
< 			if start < i {
< 				e.Write(s[start:i])
< 			}
< 			e.WriteString(`\ufffd`)
< 			i += size
< 			start = i
< 			continue
< 		}
< 		// U+2028 is LINE SEPARATOR.
< 		// U+2029 is PARAGRAPH SEPARATOR.
< 		// They are both technically valid characters in JSON strings,
< 		// but don't work in JSONP, which has to be evaluated as JavaScript,
< 		// and can lead to security holes there. It is valid JSON to
< 		// escape them, so we do so unconditionally.
< 		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
< 		if c == '\u2028' || c == '\u2029' {
< 			if start < i {
< 				e.Write(s[start:i])
< 			}
< 			e.WriteString(`\u202`)
< 			e.WriteByte(hex[c&0xF])
< 			i += size
< 			start = i
< 			continue
< 		}
< 		i += size
< 	}
< 	if start < len(s) {
< 		e.Write(s[start:])
< 	}
< 	e.WriteByte('"')
< }
< 
< // A field represents a single field found in a struct.
< type field struct {
< 	name      string
< 	nameBytes []byte                 // []byte(name)
< 	equalFold func(s, t []byte) bool // bytes.EqualFold or equivalent
< 
< 	nameNonEsc  string // `"` + name + `":`
< 	nameEscHTML string // `"` + HTMLEscape(name) + `":`
< 
< 	tag       bool
< 	index     []int
< 	typ       reflect.Type
< 	omitEmpty bool
< 	quoted    bool
< 
< 	encoder encoderFunc
< }
< 
< // byIndex sorts field by index sequence.
< type byIndex []field
< 
< func (x byIndex) Len() int { return len(x) }
< 
< func (x byIndex) Swap(i, j int) { x[i], x[j] = x[j], x[i] }
< 
< func (x byIndex) Less(i, j int) bool {
< 	for k, xik := range x[i].index {
< 		if k >= len(x[j].index) {
< 			return false
< 		}
< 		if xik != x[j].index[k] {
< 			return xik < x[j].index[k]
< 		}
< 	}
< 	return len(x[i].index) < len(x[j].index)
< }
< 
< // typeFields returns a list of fields that JSON should recognize for the given type.
< // The algorithm is breadth-first search over the set of structs to include - the top struct
< // and then any reachable anonymous structs.
< func typeFields(t reflect.Type) structFields {
< 	// Anonymous fields to explore at the current level and the next.
< 	current := []field{}
< 	next := []field{{typ: t}}
< 
< 	// Count of queued names for current level and the next.
< 	var count, nextCount map[reflect.Type]int
< 
< 	// Types already visited at an earlier level.
< 	visited := map[reflect.Type]bool{}
< 
< 	// Fields found.
< 	var fields []field
< 
< 	// Buffer to run HTMLEscape on field names.
< 	var nameEscBuf bytes.Buffer
< 
< 	for len(next) > 0 {
< 		current, next = next, current[:0]
< 		count, nextCount = nextCount, map[reflect.Type]int{}
< 
< 		for _, f := range current {
< 			if visited[f.typ] {
< 				continue
< 			}
< 			visited[f.typ] = true
< 
< 			// Scan f.typ for fields to include.
< 			for i := 0; i < f.typ.NumField(); i++ {
< 				sf := f.typ.Field(i)
< 				isUnexported := sf.PkgPath != ""
< 				if sf.Anonymous {
< 					t := sf.Type
< 					if t.Kind() == reflect.Ptr {
< 						t = t.Elem()
< 					}
< 					if isUnexported && t.Kind() != reflect.Struct {
< 						// Ignore embedded fields of unexported non-struct types.
< 						continue
< 					}
< 					// Do not ignore embedded fields of unexported struct types
< 					// since they may have exported fields.
< 				} else if isUnexported {
< 					// Ignore unexported non-embedded fields.
< 					continue
< 				}
< 				tag := sf.Tag.Get("json")
< 				if tag == "-" {
< 					continue
< 				}
< 				name, opts := parseTag(tag)
< 				if !isValidTag(name) {
< 					name = ""
< 				}
< 				index := make([]int, len(f.index)+1)
< 				copy(index, f.index)
< 				index[len(f.index)] = i
< 
< 				ft := sf.Type
< 				if ft.Name() == "" && ft.Kind() == reflect.Ptr {
< 					// Follow pointer.
< 					ft = ft.Elem()
< 				}
< 
< 				// Only strings, floats, integers, and booleans can be quoted.
< 				quoted := false
< 				if opts.Contains("string") {
< 					switch ft.Kind() {
< 					case reflect.Bool,
< 						reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
< 						reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
< 						reflect.Float32, reflect.Float64,
< 						reflect.String:
< 						quoted = true
< 					}
< 				}
< 
< 				// Record found field and index sequence.
< 				if name != "" || !sf.Anonymous || ft.Kind() != reflect.Struct {
< 					tagged := name != ""
< 					if name == "" {
< 						name = sf.Name
< 					}
< 					field := field{
< 						name:      name,
< 						tag:       tagged,
< 						index:     index,
< 						typ:       ft,
< 						omitEmpty: opts.Contains("omitempty"),
< 						quoted:    quoted,
< 					}
< 					field.nameBytes = []byte(field.name)
< 					field.equalFold = foldFunc(field.nameBytes)
< 
< 					// Build nameEscHTML and nameNonEsc ahead of time.
< 					nameEscBuf.Reset()
< 					nameEscBuf.WriteString(`"`)
< 					HTMLEscape(&nameEscBuf, field.nameBytes)
< 					nameEscBuf.WriteString(`":`)
< 					field.nameEscHTML = nameEscBuf.String()
< 					field.nameNonEsc = `"` + field.name + `":`
< 
< 					fields = append(fields, field)
< 					if count[f.typ] > 1 {
< 						// If there were multiple instances, add a second,
< 						// so that the annihilation code will see a duplicate.
< 						// It only cares about the distinction between 1 or 2,
< 						// so don't bother generating any more copies.
< 						fields = append(fields, fields[len(fields)-1])
< 					}
< 					continue
< 				}
< 
< 				// Record new anonymous struct to explore in next round.
< 				nextCount[ft]++
< 				if nextCount[ft] == 1 {
< 					next = append(next, field{name: ft.Name(), index: index, typ: ft})
< 				}
< 			}
< 		}
< 	}
< 
< 	sort.Slice(fields, func(i, j int) bool {
< 		x := fields
< 		// sort field by name, breaking ties with depth, then
< 		// breaking ties with "name came from json tag", then
< 		// breaking ties with index sequence.
< 		if x[i].name != x[j].name {
< 			return x[i].name < x[j].name
< 		}
< 		if len(x[i].index) != len(x[j].index) {
< 			return len(x[i].index) < len(x[j].index)
< 		}
< 		if x[i].tag != x[j].tag {
< 			return x[i].tag
< 		}
< 		return byIndex(x).Less(i, j)
< 	})
< 
< 	// Delete all fields that are hidden by the Go rules for embedded fields,
< 	// except that fields with JSON tags are promoted.
< 
< 	// The fields are sorted in primary order of name, secondary order
< 	// of field index length. Loop over names; for each name, delete
< 	// hidden fields by choosing the one dominant field that survives.
< 	out := fields[:0]
< 	for advance, i := 0, 0; i < len(fields); i += advance {
< 		// One iteration per name.
< 		// Find the sequence of fields with the name of this first field.
< 		fi := fields[i]
< 		name := fi.name
< 		for advance = 1; i+advance < len(fields); advance++ {
< 			fj := fields[i+advance]
< 			if fj.name != name {
< 				break
< 			}
< 		}
< 		if advance == 1 { // Only one field with this name
< 			out = append(out, fi)
< 			continue
< 		}
< 		dominant, ok := dominantField(fields[i : i+advance])
< 		if ok {
< 			out = append(out, dominant)
< 		}
< 	}
< 
< 	fields = out
< 	sort.Sort(byIndex(fields))
< 
< 	for i := range fields {
< 		f := &fields[i]
< 		f.encoder = typeEncoder(typeByIndex(t, f.index))
< 	}
< 	nameIndex := make(map[string]int, len(fields))
< 	for i, field := range fields {
< 		nameIndex[field.name] = i
< 	}
< 	return structFields{fields, nameIndex}
< }
< 
< // dominantField looks through the fields, all of which are known to
< // have the same name, to find the single field that dominates the
< // others using Go's embedding rules, modified by the presence of
< // JSON tags. If there are multiple top-level fields, the boolean
< // will be false: This condition is an error in Go and we skip all
< // the fields.
< func dominantField(fields []field) (field, bool) {
< 	// The fields are sorted in increasing index-length order, then by presence of tag.
< 	// That means that the first field is the dominant one. We need only check
< 	// for error cases: two fields at top level, either both tagged or neither tagged.
< 	if len(fields) > 1 && len(fields[0].index) == len(fields[1].index) && fields[0].tag == fields[1].tag {
< 		return field{}, false
< 	}
< 	return fields[0], true
< }
< 
< var fieldCache sync.Map // map[reflect.Type]structFields
< 
< // cachedTypeFields is like typeFields but uses a cache to avoid repeated work.
< func cachedTypeFields(t reflect.Type) structFields {
< 	if f, ok := fieldCache.Load(t); ok {
< 		return f.(structFields)
< 	}
< 	f, _ := fieldCache.LoadOrStore(t, typeFields(t))
< 	return f.(structFields)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/fold.go updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/fold.go
1,143d0
< // Copyright 2013 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< import (
< 	"bytes"
< 	"unicode/utf8"
< )
< 
< const (
< 	caseMask     = ^byte(0x20) // Mask to ignore case in ASCII.
< 	kelvin       = '\u212a'
< 	smallLongEss = '\u017f'
< )
< 
< // foldFunc returns one of four different case folding equivalence
< // functions, from most general (and slow) to fastest:
< //
< // 1) bytes.EqualFold, if the key s contains any non-ASCII UTF-8
< // 2) equalFoldRight, if s contains special folding ASCII ('k', 'K', 's', 'S')
< // 3) asciiEqualFold, no special, but includes non-letters (including _)
< // 4) simpleLetterEqualFold, no specials, no non-letters.
< //
< // The letters S and K are special because they map to 3 runes, not just 2:
< //  * S maps to s and to U+017F 'ſ' Latin small letter long s
< //  * k maps to K and to U+212A 'K' Kelvin sign
< // See https://play.golang.org/p/tTxjOc0OGo
< //
< // The returned function is specialized for matching against s and
< // should only be given s. It's not curried for performance reasons.
< func foldFunc(s []byte) func(s, t []byte) bool {
< 	nonLetter := false
< 	special := false // special letter
< 	for _, b := range s {
< 		if b >= utf8.RuneSelf {
< 			return bytes.EqualFold
< 		}
< 		upper := b & caseMask
< 		if upper < 'A' || upper > 'Z' {
< 			nonLetter = true
< 		} else if upper == 'K' || upper == 'S' {
< 			// See above for why these letters are special.
< 			special = true
< 		}
< 	}
< 	if special {
< 		return equalFoldRight
< 	}
< 	if nonLetter {
< 		return asciiEqualFold
< 	}
< 	return simpleLetterEqualFold
< }
< 
< // equalFoldRight is a specialization of bytes.EqualFold when s is
< // known to be all ASCII (including punctuation), but contains an 's',
< // 'S', 'k', or 'K', requiring a Unicode fold on the bytes in t.
< // See comments on foldFunc.
< func equalFoldRight(s, t []byte) bool {
< 	for _, sb := range s {
< 		if len(t) == 0 {
< 			return false
< 		}
< 		tb := t[0]
< 		if tb < utf8.RuneSelf {
< 			if sb != tb {
< 				sbUpper := sb & caseMask
< 				if 'A' <= sbUpper && sbUpper <= 'Z' {
< 					if sbUpper != tb&caseMask {
< 						return false
< 					}
< 				} else {
< 					return false
< 				}
< 			}
< 			t = t[1:]
< 			continue
< 		}
< 		// sb is ASCII and t is not. t must be either kelvin
< 		// sign or long s; sb must be s, S, k, or K.
< 		tr, size := utf8.DecodeRune(t)
< 		switch sb {
< 		case 's', 'S':
< 			if tr != smallLongEss {
< 				return false
< 			}
< 		case 'k', 'K':
< 			if tr != kelvin {
< 				return false
< 			}
< 		default:
< 			return false
< 		}
< 		t = t[size:]
< 
< 	}
< 	if len(t) > 0 {
< 		return false
< 	}
< 	return true
< }
< 
< // asciiEqualFold is a specialization of bytes.EqualFold for use when
< // s is all ASCII (but may contain non-letters) and contains no
< // special-folding letters.
< // See comments on foldFunc.
< func asciiEqualFold(s, t []byte) bool {
< 	if len(s) != len(t) {
< 		return false
< 	}
< 	for i, sb := range s {
< 		tb := t[i]
< 		if sb == tb {
< 			continue
< 		}
< 		if ('a' <= sb && sb <= 'z') || ('A' <= sb && sb <= 'Z') {
< 			if sb&caseMask != tb&caseMask {
< 				return false
< 			}
< 		} else {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< // simpleLetterEqualFold is a specialization of bytes.EqualFold for
< // use when s is all ASCII letters (no underscores, etc) and also
< // doesn't contain 'k', 'K', 's', or 'S'.
< // See comments on foldFunc.
< func simpleLetterEqualFold(s, t []byte) bool {
< 	if len(s) != len(t) {
< 		return false
< 	}
< 	for i, b := range s {
< 		if b&caseMask != t[i]&caseMask {
< 			return false
< 		}
< 	}
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/fuzz.go updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/fuzz.go
1,42d0
< // Copyright 2019 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< // +build gofuzz
< 
< package json
< 
< import (
< 	"fmt"
< )
< 
< func Fuzz(data []byte) (score int) {
< 	for _, ctor := range []func() interface{}{
< 		func() interface{} { return new(interface{}) },
< 		func() interface{} { return new(map[string]interface{}) },
< 		func() interface{} { return new([]interface{}) },
< 	} {
< 		v := ctor()
< 		err := Unmarshal(data, v)
< 		if err != nil {
< 			continue
< 		}
< 		score = 1
< 
< 		m, err := Marshal(v)
< 		if err != nil {
< 			fmt.Printf("v=%#v\n", v)
< 			panic(err)
< 		}
< 
< 		u := ctor()
< 		err = Unmarshal(m, u)
< 		if err != nil {
< 			fmt.Printf("v=%#v\n", v)
< 			fmt.Printf("m=%s\n", m)
< 			panic(err)
< 		}
< 	}
< 
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/indent.go updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/indent.go
1,143d0
< // Copyright 2010 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< import (
< 	"bytes"
< )
< 
< // Compact appends to dst the JSON-encoded src with
< // insignificant space characters elided.
< func Compact(dst *bytes.Buffer, src []byte) error {
< 	return compact(dst, src, false)
< }
< 
< func compact(dst *bytes.Buffer, src []byte, escape bool) error {
< 	origLen := dst.Len()
< 	scan := newScanner()
< 	defer freeScanner(scan)
< 	start := 0
< 	for i, c := range src {
< 		if escape && (c == '<' || c == '>' || c == '&') {
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			dst.WriteString(`\u00`)
< 			dst.WriteByte(hex[c>>4])
< 			dst.WriteByte(hex[c&0xF])
< 			start = i + 1
< 		}
< 		// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
< 		if escape && c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			dst.WriteString(`\u202`)
< 			dst.WriteByte(hex[src[i+2]&0xF])
< 			start = i + 3
< 		}
< 		v := scan.step(scan, c)
< 		if v >= scanSkipSpace {
< 			if v == scanError {
< 				break
< 			}
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			start = i + 1
< 		}
< 	}
< 	if scan.eof() == scanError {
< 		dst.Truncate(origLen)
< 		return scan.err
< 	}
< 	if start < len(src) {
< 		dst.Write(src[start:])
< 	}
< 	return nil
< }
< 
< func newline(dst *bytes.Buffer, prefix, indent string, depth int) {
< 	dst.WriteByte('\n')
< 	dst.WriteString(prefix)
< 	for i := 0; i < depth; i++ {
< 		dst.WriteString(indent)
< 	}
< }
< 
< // Indent appends to dst an indented form of the JSON-encoded src.
< // Each element in a JSON object or array begins on a new,
< // indented line beginning with prefix followed by one or more
< // copies of indent according to the indentation nesting.
< // The data appended to dst does not begin with the prefix nor
< // any indentation, to make it easier to embed inside other formatted JSON data.
< // Although leading space characters (space, tab, carriage return, newline)
< // at the beginning of src are dropped, trailing space characters
< // at the end of src are preserved and copied to dst.
< // For example, if src has no trailing spaces, neither will dst;
< // if src ends in a trailing newline, so will dst.
< func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error {
< 	origLen := dst.Len()
< 	scan := newScanner()
< 	defer freeScanner(scan)
< 	needIndent := false
< 	depth := 0
< 	for _, c := range src {
< 		scan.bytes++
< 		v := scan.step(scan, c)
< 		if v == scanSkipSpace {
< 			continue
< 		}
< 		if v == scanError {
< 			break
< 		}
< 		if needIndent && v != scanEndObject && v != scanEndArray {
< 			needIndent = false
< 			depth++
< 			newline(dst, prefix, indent, depth)
< 		}
< 
< 		// Emit semantically uninteresting bytes
< 		// (in particular, punctuation in strings) unmodified.
< 		if v == scanContinue {
< 			dst.WriteByte(c)
< 			continue
< 		}
< 
< 		// Add spacing around real punctuation.
< 		switch c {
< 		case '{', '[':
< 			// delay indent so that empty object and array are formatted as {} and [].
< 			needIndent = true
< 			dst.WriteByte(c)
< 
< 		case ',':
< 			dst.WriteByte(c)
< 			newline(dst, prefix, indent, depth)
< 
< 		case ':':
< 			dst.WriteByte(c)
< 			dst.WriteByte(' ')
< 
< 		case '}', ']':
< 			if needIndent {
< 				// suppress indent in empty object/array
< 				needIndent = false
< 			} else {
< 				depth--
< 				newline(dst, prefix, indent, depth)
< 			}
< 			dst.WriteByte(c)
< 
< 		default:
< 			dst.WriteByte(c)
< 		}
< 	}
< 	if scan.eof() == scanError {
< 		dst.Truncate(origLen)
< 		return scan.err
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/scanner.go updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/scanner.go
1,601d0
< // Copyright 2010 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< // JSON value parser state machine.
< // Just about at the limit of what is reasonable to write by hand.
< // Some parts are a bit tedious, but overall it nicely factors out the
< // otherwise common code from the multiple scanning functions
< // in this package (Compact, Indent, checkValid, etc).
< //
< // This file starts with two simple examples using the scanner
< // before diving into the scanner itself.
< 
< import (
< 	"strconv"
< 	"sync"
< )
< 
< // Valid reports whether data is a valid JSON encoding.
< func Valid(data []byte) bool {
< 	scan := newScanner()
< 	defer freeScanner(scan)
< 	return checkValid(data, scan) == nil
< }
< 
< // checkValid verifies that data is valid JSON-encoded data.
< // scan is passed in for use by checkValid to avoid an allocation.
< func checkValid(data []byte, scan *scanner) error {
< 	scan.reset()
< 	for _, c := range data {
< 		scan.bytes++
< 		if scan.step(scan, c) == scanError {
< 			return scan.err
< 		}
< 	}
< 	if scan.eof() == scanError {
< 		return scan.err
< 	}
< 	return nil
< }
< 
< // A SyntaxError is a description of a JSON syntax error.
< type SyntaxError struct {
< 	msg    string // description of error
< 	Offset int64  // error occurred after reading Offset bytes
< }
< 
< func (e *SyntaxError) Error() string { return e.msg }
< 
< // A scanner is a JSON scanning state machine.
< // Callers call scan.reset and then pass bytes in one at a time
< // by calling scan.step(&scan, c) for each byte.
< // The return value, referred to as an opcode, tells the
< // caller about significant parsing events like beginning
< // and ending literals, objects, and arrays, so that the
< // caller can follow along if it wishes.
< // The return value scanEnd indicates that a single top-level
< // JSON value has been completed, *before* the byte that
< // just got passed in.  (The indication must be delayed in order
< // to recognize the end of numbers: is 123 a whole value or
< // the beginning of 12345e+6?).
< type scanner struct {
< 	// The step is a func to be called to execute the next transition.
< 	// Also tried using an integer constant and a single func
< 	// with a switch, but using the func directly was 10% faster
< 	// on a 64-bit Mac Mini, and it's nicer to read.
< 	step func(*scanner, byte) int
< 
< 	// Reached end of top-level value.
< 	endTop bool
< 
< 	// Stack of what we're in the middle of - array values, object keys, object values.
< 	parseState []int
< 
< 	// Error that happened, if any.
< 	err error
< 
< 	// total bytes consumed, updated by decoder.Decode (and deliberately
< 	// not set to zero by scan.reset)
< 	bytes int64
< }
< 
< var scannerPool = sync.Pool{
< 	New: func() interface{} {
< 		return &scanner{}
< 	},
< }
< 
< func newScanner() *scanner {
< 	scan := scannerPool.Get().(*scanner)
< 	// scan.reset by design doesn't set bytes to zero
< 	scan.bytes = 0
< 	scan.reset()
< 	return scan
< }
< 
< func freeScanner(scan *scanner) {
< 	// Avoid hanging on to too much memory in extreme cases.
< 	if len(scan.parseState) > 1024 {
< 		scan.parseState = nil
< 	}
< 	scannerPool.Put(scan)
< }
< 
< // These values are returned by the state transition functions
< // assigned to scanner.state and the method scanner.eof.
< // They give details about the current state of the scan that
< // callers might be interested to know about.
< // It is okay to ignore the return value of any particular
< // call to scanner.state: if one call returns scanError,
< // every subsequent call will return scanError too.
< const (
< 	// Continue.
< 	scanContinue     = iota // uninteresting byte
< 	scanBeginLiteral        // end implied by next result != scanContinue
< 	scanBeginObject         // begin object
< 	scanObjectKey           // just finished object key (string)
< 	scanObjectValue         // just finished non-last object value
< 	scanEndObject           // end object (implies scanObjectValue if possible)
< 	scanBeginArray          // begin array
< 	scanArrayValue          // just finished array value
< 	scanEndArray            // end array (implies scanArrayValue if possible)
< 	scanSkipSpace           // space byte; can skip; known to be last "continue" result
< 
< 	// Stop.
< 	scanEnd   // top-level value ended *before* this byte; known to be first "stop" result
< 	scanError // hit an error, scanner.err.
< )
< 
< // These values are stored in the parseState stack.
< // They give the current state of a composite value
< // being scanned. If the parser is inside a nested value
< // the parseState describes the nested state, outermost at entry 0.
< const (
< 	parseObjectKey   = iota // parsing object key (before colon)
< 	parseObjectValue        // parsing object value (after colon)
< 	parseArrayValue         // parsing array value
< )
< 
< // reset prepares the scanner for use.
< // It must be called before calling s.step.
< func (s *scanner) reset() {
< 	s.step = stateBeginValue
< 	s.parseState = s.parseState[0:0]
< 	s.err = nil
< 	s.endTop = false
< }
< 
< // eof tells the scanner that the end of input has been reached.
< // It returns a scan status just as s.step does.
< func (s *scanner) eof() int {
< 	if s.err != nil {
< 		return scanError
< 	}
< 	if s.endTop {
< 		return scanEnd
< 	}
< 	s.step(s, ' ')
< 	if s.endTop {
< 		return scanEnd
< 	}
< 	if s.err == nil {
< 		s.err = &SyntaxError{"unexpected end of JSON input", s.bytes}
< 	}
< 	return scanError
< }
< 
< // pushParseState pushes a new parse state p onto the parse stack.
< func (s *scanner) pushParseState(p int) {
< 	s.parseState = append(s.parseState, p)
< }
< 
< // popParseState pops a parse state (already obtained) off the stack
< // and updates s.step accordingly.
< func (s *scanner) popParseState() {
< 	n := len(s.parseState) - 1
< 	s.parseState = s.parseState[0:n]
< 	if n == 0 {
< 		s.step = stateEndTop
< 		s.endTop = true
< 	} else {
< 		s.step = stateEndValue
< 	}
< }
< 
< func isSpace(c byte) bool {
< 	return c == ' ' || c == '\t' || c == '\r' || c == '\n'
< }
< 
< // stateBeginValueOrEmpty is the state after reading `[`.
< func stateBeginValueOrEmpty(s *scanner, c byte) int {
< 	if c <= ' ' && isSpace(c) {
< 		return scanSkipSpace
< 	}
< 	if c == ']' {
< 		return stateEndValue(s, c)
< 	}
< 	return stateBeginValue(s, c)
< }
< 
< // stateBeginValue is the state at the beginning of the input.
< func stateBeginValue(s *scanner, c byte) int {
< 	if c <= ' ' && isSpace(c) {
< 		return scanSkipSpace
< 	}
< 	switch c {
< 	case '{':
< 		s.step = stateBeginStringOrEmpty
< 		s.pushParseState(parseObjectKey)
< 		return scanBeginObject
< 	case '[':
< 		s.step = stateBeginValueOrEmpty
< 		s.pushParseState(parseArrayValue)
< 		return scanBeginArray
< 	case '"':
< 		s.step = stateInString
< 		return scanBeginLiteral
< 	case '-':
< 		s.step = stateNeg
< 		return scanBeginLiteral
< 	case '0': // beginning of 0.123
< 		s.step = state0
< 		return scanBeginLiteral
< 	case 't': // beginning of true
< 		s.step = stateT
< 		return scanBeginLiteral
< 	case 'f': // beginning of false
< 		s.step = stateF
< 		return scanBeginLiteral
< 	case 'n': // beginning of null
< 		s.step = stateN
< 		return scanBeginLiteral
< 	}
< 	if '1' <= c && c <= '9' { // beginning of 1234.5
< 		s.step = state1
< 		return scanBeginLiteral
< 	}
< 	return s.error(c, "looking for beginning of value")
< }
< 
< // stateBeginStringOrEmpty is the state after reading `{`.
< func stateBeginStringOrEmpty(s *scanner, c byte) int {
< 	if c <= ' ' && isSpace(c) {
< 		return scanSkipSpace
< 	}
< 	if c == '}' {
< 		n := len(s.parseState)
< 		s.parseState[n-1] = parseObjectValue
< 		return stateEndValue(s, c)
< 	}
< 	return stateBeginString(s, c)
< }
< 
< // stateBeginString is the state after reading `{"key": value,`.
< func stateBeginString(s *scanner, c byte) int {
< 	if c <= ' ' && isSpace(c) {
< 		return scanSkipSpace
< 	}
< 	if c == '"' {
< 		s.step = stateInString
< 		return scanBeginLiteral
< 	}
< 	return s.error(c, "looking for beginning of object key string")
< }
< 
< // stateEndValue is the state after completing a value,
< // such as after reading `{}` or `true` or `["x"`.
< func stateEndValue(s *scanner, c byte) int {
< 	n := len(s.parseState)
< 	if n == 0 {
< 		// Completed top-level before the current byte.
< 		s.step = stateEndTop
< 		s.endTop = true
< 		return stateEndTop(s, c)
< 	}
< 	if c <= ' ' && isSpace(c) {
< 		s.step = stateEndValue
< 		return scanSkipSpace
< 	}
< 	ps := s.parseState[n-1]
< 	switch ps {
< 	case parseObjectKey:
< 		if c == ':' {
< 			s.parseState[n-1] = parseObjectValue
< 			s.step = stateBeginValue
< 			return scanObjectKey
< 		}
< 		return s.error(c, "after object key")
< 	case parseObjectValue:
< 		if c == ',' {
< 			s.parseState[n-1] = parseObjectKey
< 			s.step = stateBeginString
< 			return scanObjectValue
< 		}
< 		if c == '}' {
< 			s.popParseState()
< 			return scanEndObject
< 		}
< 		return s.error(c, "after object key:value pair")
< 	case parseArrayValue:
< 		if c == ',' {
< 			s.step = stateBeginValue
< 			return scanArrayValue
< 		}
< 		if c == ']' {
< 			s.popParseState()
< 			return scanEndArray
< 		}
< 		return s.error(c, "after array element")
< 	}
< 	return s.error(c, "")
< }
< 
< // stateEndTop is the state after finishing the top-level value,
< // such as after reading `{}` or `[1,2,3]`.
< // Only space characters should be seen now.
< func stateEndTop(s *scanner, c byte) int {
< 	if !isSpace(c) {
< 		// Complain about non-space byte on next call.
< 		s.error(c, "after top-level value")
< 	}
< 	return scanEnd
< }
< 
< // stateInString is the state after reading `"`.
< func stateInString(s *scanner, c byte) int {
< 	if c == '"' {
< 		s.step = stateEndValue
< 		return scanContinue
< 	}
< 	if c == '\\' {
< 		s.step = stateInStringEsc
< 		return scanContinue
< 	}
< 	if c < 0x20 {
< 		return s.error(c, "in string literal")
< 	}
< 	return scanContinue
< }
< 
< // stateInStringEsc is the state after reading `"\` during a quoted string.
< func stateInStringEsc(s *scanner, c byte) int {
< 	switch c {
< 	case 'b', 'f', 'n', 'r', 't', '\\', '/', '"':
< 		s.step = stateInString
< 		return scanContinue
< 	case 'u':
< 		s.step = stateInStringEscU
< 		return scanContinue
< 	}
< 	return s.error(c, "in string escape code")
< }
< 
< // stateInStringEscU is the state after reading `"\u` during a quoted string.
< func stateInStringEscU(s *scanner, c byte) int {
< 	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
< 		s.step = stateInStringEscU1
< 		return scanContinue
< 	}
< 	// numbers
< 	return s.error(c, "in \\u hexadecimal character escape")
< }
< 
< // stateInStringEscU1 is the state after reading `"\u1` during a quoted string.
< func stateInStringEscU1(s *scanner, c byte) int {
< 	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
< 		s.step = stateInStringEscU12
< 		return scanContinue
< 	}
< 	// numbers
< 	return s.error(c, "in \\u hexadecimal character escape")
< }
< 
< // stateInStringEscU12 is the state after reading `"\u12` during a quoted string.
< func stateInStringEscU12(s *scanner, c byte) int {
< 	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
< 		s.step = stateInStringEscU123
< 		return scanContinue
< 	}
< 	// numbers
< 	return s.error(c, "in \\u hexadecimal character escape")
< }
< 
< // stateInStringEscU123 is the state after reading `"\u123` during a quoted string.
< func stateInStringEscU123(s *scanner, c byte) int {
< 	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
< 		s.step = stateInString
< 		return scanContinue
< 	}
< 	// numbers
< 	return s.error(c, "in \\u hexadecimal character escape")
< }
< 
< // stateNeg is the state after reading `-` during a number.
< func stateNeg(s *scanner, c byte) int {
< 	if c == '0' {
< 		s.step = state0
< 		return scanContinue
< 	}
< 	if '1' <= c && c <= '9' {
< 		s.step = state1
< 		return scanContinue
< 	}
< 	return s.error(c, "in numeric literal")
< }
< 
< // state1 is the state after reading a non-zero integer during a number,
< // such as after reading `1` or `100` but not `0`.
< func state1(s *scanner, c byte) int {
< 	if '0' <= c && c <= '9' {
< 		s.step = state1
< 		return scanContinue
< 	}
< 	return state0(s, c)
< }
< 
< // state0 is the state after reading `0` during a number.
< func state0(s *scanner, c byte) int {
< 	if c == '.' {
< 		s.step = stateDot
< 		return scanContinue
< 	}
< 	if c == 'e' || c == 'E' {
< 		s.step = stateE
< 		return scanContinue
< 	}
< 	return stateEndValue(s, c)
< }
< 
< // stateDot is the state after reading the integer and decimal point in a number,
< // such as after reading `1.`.
< func stateDot(s *scanner, c byte) int {
< 	if '0' <= c && c <= '9' {
< 		s.step = stateDot0
< 		return scanContinue
< 	}
< 	return s.error(c, "after decimal point in numeric literal")
< }
< 
< // stateDot0 is the state after reading the integer, decimal point, and subsequent
< // digits of a number, such as after reading `3.14`.
< func stateDot0(s *scanner, c byte) int {
< 	if '0' <= c && c <= '9' {
< 		return scanContinue
< 	}
< 	if c == 'e' || c == 'E' {
< 		s.step = stateE
< 		return scanContinue
< 	}
< 	return stateEndValue(s, c)
< }
< 
< // stateE is the state after reading the mantissa and e in a number,
< // such as after reading `314e` or `0.314e`.
< func stateE(s *scanner, c byte) int {
< 	if c == '+' || c == '-' {
< 		s.step = stateESign
< 		return scanContinue
< 	}
< 	return stateESign(s, c)
< }
< 
< // stateESign is the state after reading the mantissa, e, and sign in a number,
< // such as after reading `314e-` or `0.314e+`.
< func stateESign(s *scanner, c byte) int {
< 	if '0' <= c && c <= '9' {
< 		s.step = stateE0
< 		return scanContinue
< 	}
< 	return s.error(c, "in exponent of numeric literal")
< }
< 
< // stateE0 is the state after reading the mantissa, e, optional sign,
< // and at least one digit of the exponent in a number,
< // such as after reading `314e-2` or `0.314e+1` or `3.14e0`.
< func stateE0(s *scanner, c byte) int {
< 	if '0' <= c && c <= '9' {
< 		return scanContinue
< 	}
< 	return stateEndValue(s, c)
< }
< 
< // stateT is the state after reading `t`.
< func stateT(s *scanner, c byte) int {
< 	if c == 'r' {
< 		s.step = stateTr
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal true (expecting 'r')")
< }
< 
< // stateTr is the state after reading `tr`.
< func stateTr(s *scanner, c byte) int {
< 	if c == 'u' {
< 		s.step = stateTru
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal true (expecting 'u')")
< }
< 
< // stateTru is the state after reading `tru`.
< func stateTru(s *scanner, c byte) int {
< 	if c == 'e' {
< 		s.step = stateEndValue
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal true (expecting 'e')")
< }
< 
< // stateF is the state after reading `f`.
< func stateF(s *scanner, c byte) int {
< 	if c == 'a' {
< 		s.step = stateFa
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal false (expecting 'a')")
< }
< 
< // stateFa is the state after reading `fa`.
< func stateFa(s *scanner, c byte) int {
< 	if c == 'l' {
< 		s.step = stateFal
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal false (expecting 'l')")
< }
< 
< // stateFal is the state after reading `fal`.
< func stateFal(s *scanner, c byte) int {
< 	if c == 's' {
< 		s.step = stateFals
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal false (expecting 's')")
< }
< 
< // stateFals is the state after reading `fals`.
< func stateFals(s *scanner, c byte) int {
< 	if c == 'e' {
< 		s.step = stateEndValue
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal false (expecting 'e')")
< }
< 
< // stateN is the state after reading `n`.
< func stateN(s *scanner, c byte) int {
< 	if c == 'u' {
< 		s.step = stateNu
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal null (expecting 'u')")
< }
< 
< // stateNu is the state after reading `nu`.
< func stateNu(s *scanner, c byte) int {
< 	if c == 'l' {
< 		s.step = stateNul
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal null (expecting 'l')")
< }
< 
< // stateNul is the state after reading `nul`.
< func stateNul(s *scanner, c byte) int {
< 	if c == 'l' {
< 		s.step = stateEndValue
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal null (expecting 'l')")
< }
< 
< // stateError is the state after reaching a syntax error,
< // such as after reading `[1}` or `5.1.2`.
< func stateError(s *scanner, c byte) int {
< 	return scanError
< }
< 
< // error records an error and switches to the error state.
< func (s *scanner) error(c byte, context string) int {
< 	s.step = stateError
< 	s.err = &SyntaxError{"invalid character " + quoteChar(c) + " " + context, s.bytes}
< 	return scanError
< }
< 
< // quoteChar formats c as a quoted character literal
< func quoteChar(c byte) string {
< 	// special cases - different from quoted strings
< 	if c == '\'' {
< 		return `'\''`
< 	}
< 	if c == '"' {
< 		return `'"'`
< 	}
< 
< 	// use quoted string with different quotation marks
< 	s := strconv.Quote(string(c))
< 	return "'" + s[1:len(s)-1] + "'"
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/stream.go updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/stream.go
1,514d0
< // Copyright 2010 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< import (
< 	"bytes"
< 	"errors"
< 	"io"
< )
< 
< // A Decoder reads and decodes JSON values from an input stream.
< type Decoder struct {
< 	r       io.Reader
< 	buf     []byte
< 	d       decodeState
< 	scanp   int   // start of unread data in buf
< 	scanned int64 // amount of data already scanned
< 	scan    scanner
< 	err     error
< 
< 	tokenState int
< 	tokenStack []int
< }
< 
< // NewDecoder returns a new decoder that reads from r.
< //
< // The decoder introduces its own buffering and may
< // read data from r beyond the JSON values requested.
< func NewDecoder(r io.Reader) *Decoder {
< 	return &Decoder{r: r}
< }
< 
< // UseNumber causes the Decoder to unmarshal a number into an interface{} as a
< // Number instead of as a float64.
< func (dec *Decoder) UseNumber() { dec.d.useNumber = true }
< 
< // DisallowUnknownFields causes the Decoder to return an error when the destination
< // is a struct and the input contains object keys which do not match any
< // non-ignored, exported fields in the destination.
< func (dec *Decoder) DisallowUnknownFields() { dec.d.disallowUnknownFields = true }
< 
< // Decode reads the next JSON-encoded value from its
< // input and stores it in the value pointed to by v.
< //
< // See the documentation for Unmarshal for details about
< // the conversion of JSON into a Go value.
< func (dec *Decoder) Decode(v interface{}) error {
< 	if dec.err != nil {
< 		return dec.err
< 	}
< 
< 	if err := dec.tokenPrepareForDecode(); err != nil {
< 		return err
< 	}
< 
< 	if !dec.tokenValueAllowed() {
< 		return &SyntaxError{msg: "not at beginning of value", Offset: dec.InputOffset()}
< 	}
< 
< 	// Read whole value into buffer.
< 	n, err := dec.readValue()
< 	if err != nil {
< 		return err
< 	}
< 	dec.d.init(dec.buf[dec.scanp : dec.scanp+n])
< 	dec.scanp += n
< 
< 	// Don't save err from unmarshal into dec.err:
< 	// the connection is still usable since we read a complete JSON
< 	// object from it before the error happened.
< 	err = dec.d.unmarshal(v)
< 
< 	// fixup token streaming state
< 	dec.tokenValueEnd()
< 
< 	return err
< }
< 
< // Buffered returns a reader of the data remaining in the Decoder's
< // buffer. The reader is valid until the next call to Decode.
< func (dec *Decoder) Buffered() io.Reader {
< 	return bytes.NewReader(dec.buf[dec.scanp:])
< }
< 
< // readValue reads a JSON value into dec.buf.
< // It returns the length of the encoding.
< func (dec *Decoder) readValue() (int, error) {
< 	dec.scan.reset()
< 
< 	scanp := dec.scanp
< 	var err error
< Input:
< 	// help the compiler see that scanp is never negative, so it can remove
< 	// some bounds checks below.
< 	for scanp >= 0 {
< 
< 		// Look in the buffer for a new value.
< 		for ; scanp < len(dec.buf); scanp++ {
< 			c := dec.buf[scanp]
< 			dec.scan.bytes++
< 			switch dec.scan.step(&dec.scan, c) {
< 			case scanEnd:
< 				// scanEnd is delayed one byte so we decrement
< 				// the scanner bytes count by 1 to ensure that
< 				// this value is correct in the next call of Decode.
< 				dec.scan.bytes--
< 				break Input
< 			case scanEndObject, scanEndArray:
< 				// scanEnd is delayed one byte.
< 				// We might block trying to get that byte from src,
< 				// so instead invent a space byte.
< 				if stateEndValue(&dec.scan, ' ') == scanEnd {
< 					scanp++
< 					break Input
< 				}
< 			case scanError:
< 				dec.err = dec.scan.err
< 				return 0, dec.scan.err
< 			}
< 		}
< 
< 		// Did the last read have an error?
< 		// Delayed until now to allow buffer scan.
< 		if err != nil {
< 			if err == io.EOF {
< 				if dec.scan.step(&dec.scan, ' ') == scanEnd {
< 					break Input
< 				}
< 				if nonSpace(dec.buf) {
< 					err = io.ErrUnexpectedEOF
< 				}
< 			}
< 			dec.err = err
< 			return 0, err
< 		}
< 
< 		n := scanp - dec.scanp
< 		err = dec.refill()
< 		scanp = dec.scanp + n
< 	}
< 	return scanp - dec.scanp, nil
< }
< 
< func (dec *Decoder) refill() error {
< 	// Make room to read more into the buffer.
< 	// First slide down data already consumed.
< 	if dec.scanp > 0 {
< 		dec.scanned += int64(dec.scanp)
< 		n := copy(dec.buf, dec.buf[dec.scanp:])
< 		dec.buf = dec.buf[:n]
< 		dec.scanp = 0
< 	}
< 
< 	// Grow buffer if not large enough.
< 	const minRead = 512
< 	if cap(dec.buf)-len(dec.buf) < minRead {
< 		newBuf := make([]byte, len(dec.buf), 2*cap(dec.buf)+minRead)
< 		copy(newBuf, dec.buf)
< 		dec.buf = newBuf
< 	}
< 
< 	// Read. Delay error for next iteration (after scan).
< 	n, err := dec.r.Read(dec.buf[len(dec.buf):cap(dec.buf)])
< 	dec.buf = dec.buf[0 : len(dec.buf)+n]
< 
< 	return err
< }
< 
< func nonSpace(b []byte) bool {
< 	for _, c := range b {
< 		if !isSpace(c) {
< 			return true
< 		}
< 	}
< 	return false
< }
< 
< // An Encoder writes JSON values to an output stream.
< type Encoder struct {
< 	w          io.Writer
< 	err        error
< 	escapeHTML bool
< 
< 	indentBuf    *bytes.Buffer
< 	indentPrefix string
< 	indentValue  string
< }
< 
< // NewEncoder returns a new encoder that writes to w.
< func NewEncoder(w io.Writer) *Encoder {
< 	return &Encoder{w: w, escapeHTML: true}
< }
< 
< // Encode writes the JSON encoding of v to the stream,
< // followed by a newline character.
< //
< // See the documentation for Marshal for details about the
< // conversion of Go values to JSON.
< func (enc *Encoder) Encode(v interface{}) error {
< 	if enc.err != nil {
< 		return enc.err
< 	}
< 	e := newEncodeState()
< 	err := e.marshal(v, encOpts{escapeHTML: enc.escapeHTML})
< 	if err != nil {
< 		return err
< 	}
< 
< 	// Terminate each value with a newline.
< 	// This makes the output look a little nicer
< 	// when debugging, and some kind of space
< 	// is required if the encoded value was a number,
< 	// so that the reader knows there aren't more
< 	// digits coming.
< 	e.WriteByte('\n')
< 
< 	b := e.Bytes()
< 	if enc.indentPrefix != "" || enc.indentValue != "" {
< 		if enc.indentBuf == nil {
< 			enc.indentBuf = new(bytes.Buffer)
< 		}
< 		enc.indentBuf.Reset()
< 		err = Indent(enc.indentBuf, b, enc.indentPrefix, enc.indentValue)
< 		if err != nil {
< 			return err
< 		}
< 		b = enc.indentBuf.Bytes()
< 	}
< 	if _, err = enc.w.Write(b); err != nil {
< 		enc.err = err
< 	}
< 	encodeStatePool.Put(e)
< 	return err
< }
< 
< // SetIndent instructs the encoder to format each subsequent encoded
< // value as if indented by the package-level function Indent(dst, src, prefix, indent).
< // Calling SetIndent("", "") disables indentation.
< func (enc *Encoder) SetIndent(prefix, indent string) {
< 	enc.indentPrefix = prefix
< 	enc.indentValue = indent
< }
< 
< // SetEscapeHTML specifies whether problematic HTML characters
< // should be escaped inside JSON quoted strings.
< // The default behavior is to escape &, <, and > to \u0026, \u003c, and \u003e
< // to avoid certain safety problems that can arise when embedding JSON in HTML.
< //
< // In non-HTML settings where the escaping interferes with the readability
< // of the output, SetEscapeHTML(false) disables this behavior.
< func (enc *Encoder) SetEscapeHTML(on bool) {
< 	enc.escapeHTML = on
< }
< 
< // RawMessage is a raw encoded JSON value.
< // It implements Marshaler and Unmarshaler and can
< // be used to delay JSON decoding or precompute a JSON encoding.
< type RawMessage []byte
< 
< // MarshalJSON returns m as the JSON encoding of m.
< func (m RawMessage) MarshalJSON() ([]byte, error) {
< 	if m == nil {
< 		return []byte("null"), nil
< 	}
< 	return m, nil
< }
< 
< // UnmarshalJSON sets *m to a copy of data.
< func (m *RawMessage) UnmarshalJSON(data []byte) error {
< 	if m == nil {
< 		return errors.New("json.RawMessage: UnmarshalJSON on nil pointer")
< 	}
< 	*m = append((*m)[0:0], data...)
< 	return nil
< }
< 
< var _ Marshaler = (*RawMessage)(nil)
< var _ Unmarshaler = (*RawMessage)(nil)
< 
< // A Token holds a value of one of these types:
< //
< //	Delim, for the four JSON delimiters [ ] { }
< //	bool, for JSON booleans
< //	float64, for JSON numbers
< //	Number, for JSON numbers
< //	string, for JSON string literals
< //	nil, for JSON null
< //
< type Token interface{}
< 
< const (
< 	tokenTopValue = iota
< 	tokenArrayStart
< 	tokenArrayValue
< 	tokenArrayComma
< 	tokenObjectStart
< 	tokenObjectKey
< 	tokenObjectColon
< 	tokenObjectValue
< 	tokenObjectComma
< )
< 
< // advance tokenstate from a separator state to a value state
< func (dec *Decoder) tokenPrepareForDecode() error {
< 	// Note: Not calling peek before switch, to avoid
< 	// putting peek into the standard Decode path.
< 	// peek is only called when using the Token API.
< 	switch dec.tokenState {
< 	case tokenArrayComma:
< 		c, err := dec.peek()
< 		if err != nil {
< 			return err
< 		}
< 		if c != ',' {
< 			return &SyntaxError{"expected comma after array element", dec.InputOffset()}
< 		}
< 		dec.scanp++
< 		dec.tokenState = tokenArrayValue
< 	case tokenObjectColon:
< 		c, err := dec.peek()
< 		if err != nil {
< 			return err
< 		}
< 		if c != ':' {
< 			return &SyntaxError{"expected colon after object key", dec.InputOffset()}
< 		}
< 		dec.scanp++
< 		dec.tokenState = tokenObjectValue
< 	}
< 	return nil
< }
< 
< func (dec *Decoder) tokenValueAllowed() bool {
< 	switch dec.tokenState {
< 	case tokenTopValue, tokenArrayStart, tokenArrayValue, tokenObjectValue:
< 		return true
< 	}
< 	return false
< }
< 
< func (dec *Decoder) tokenValueEnd() {
< 	switch dec.tokenState {
< 	case tokenArrayStart, tokenArrayValue:
< 		dec.tokenState = tokenArrayComma
< 	case tokenObjectValue:
< 		dec.tokenState = tokenObjectComma
< 	}
< }
< 
< // A Delim is a JSON array or object delimiter, one of [ ] { or }.
< type Delim rune
< 
< func (d Delim) String() string {
< 	return string(d)
< }
< 
< // Token returns the next JSON token in the input stream.
< // At the end of the input stream, Token returns nil, io.EOF.
< //
< // Token guarantees that the delimiters [ ] { } it returns are
< // properly nested and matched: if Token encounters an unexpected
< // delimiter in the input, it will return an error.
< //
< // The input stream consists of basic JSON values—bool, string,
< // number, and null—along with delimiters [ ] { } of type Delim
< // to mark the start and end of arrays and objects.
< // Commas and colons are elided.
< func (dec *Decoder) Token() (Token, error) {
< 	for {
< 		c, err := dec.peek()
< 		if err != nil {
< 			return nil, err
< 		}
< 		switch c {
< 		case '[':
< 			if !dec.tokenValueAllowed() {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenStack = append(dec.tokenStack, dec.tokenState)
< 			dec.tokenState = tokenArrayStart
< 			return Delim('['), nil
< 
< 		case ']':
< 			if dec.tokenState != tokenArrayStart && dec.tokenState != tokenArrayComma {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
< 			dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
< 			dec.tokenValueEnd()
< 			return Delim(']'), nil
< 
< 		case '{':
< 			if !dec.tokenValueAllowed() {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenStack = append(dec.tokenStack, dec.tokenState)
< 			dec.tokenState = tokenObjectStart
< 			return Delim('{'), nil
< 
< 		case '}':
< 			if dec.tokenState != tokenObjectStart && dec.tokenState != tokenObjectComma {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
< 			dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
< 			dec.tokenValueEnd()
< 			return Delim('}'), nil
< 
< 		case ':':
< 			if dec.tokenState != tokenObjectColon {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenState = tokenObjectValue
< 			continue
< 
< 		case ',':
< 			if dec.tokenState == tokenArrayComma {
< 				dec.scanp++
< 				dec.tokenState = tokenArrayValue
< 				continue
< 			}
< 			if dec.tokenState == tokenObjectComma {
< 				dec.scanp++
< 				dec.tokenState = tokenObjectKey
< 				continue
< 			}
< 			return dec.tokenError(c)
< 
< 		case '"':
< 			if dec.tokenState == tokenObjectStart || dec.tokenState == tokenObjectKey {
< 				var x string
< 				old := dec.tokenState
< 				dec.tokenState = tokenTopValue
< 				err := dec.Decode(&x)
< 				dec.tokenState = old
< 				if err != nil {
< 					return nil, err
< 				}
< 				dec.tokenState = tokenObjectColon
< 				return x, nil
< 			}
< 			fallthrough
< 
< 		default:
< 			if !dec.tokenValueAllowed() {
< 				return dec.tokenError(c)
< 			}
< 			var x interface{}
< 			if err := dec.Decode(&x); err != nil {
< 				return nil, err
< 			}
< 			return x, nil
< 		}
< 	}
< }
< 
< func (dec *Decoder) tokenError(c byte) (Token, error) {
< 	var context string
< 	switch dec.tokenState {
< 	case tokenTopValue:
< 		context = " looking for beginning of value"
< 	case tokenArrayStart, tokenArrayValue, tokenObjectValue:
< 		context = " looking for beginning of value"
< 	case tokenArrayComma:
< 		context = " after array element"
< 	case tokenObjectKey:
< 		context = " looking for beginning of object key string"
< 	case tokenObjectColon:
< 		context = " after object key"
< 	case tokenObjectComma:
< 		context = " after object key:value pair"
< 	}
< 	return nil, &SyntaxError{"invalid character " + quoteChar(c) + context, dec.InputOffset()}
< }
< 
< // More reports whether there is another element in the
< // current array or object being parsed.
< func (dec *Decoder) More() bool {
< 	c, err := dec.peek()
< 	return err == nil && c != ']' && c != '}'
< }
< 
< func (dec *Decoder) peek() (byte, error) {
< 	var err error
< 	for {
< 		for i := dec.scanp; i < len(dec.buf); i++ {
< 			c := dec.buf[i]
< 			if isSpace(c) {
< 				continue
< 			}
< 			dec.scanp = i
< 			return c, nil
< 		}
< 		// buffer has been scanned, now report any error
< 		if err != nil {
< 			return 0, err
< 		}
< 		err = dec.refill()
< 	}
< }
< 
< // InputOffset returns the input stream byte offset of the current decoder position.
< // The offset gives the location of the end of the most recently returned token
< // and the beginning of the next token.
< func (dec *Decoder) InputOffset() int64 {
< 	return dec.scanned + int64(dec.scanp)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/tables.go updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/tables.go
1,218d0
< // Copyright 2016 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< import "unicode/utf8"
< 
< // safeSet holds the value true if the ASCII character with the given array
< // position can be represented inside a JSON string without any further
< // escaping.
< //
< // All values are true except for the ASCII control characters (0-31), the
< // double quote ("), and the backslash character ("\").
< var safeSet = [utf8.RuneSelf]bool{
< 	' ':      true,
< 	'!':      true,
< 	'"':      false,
< 	'#':      true,
< 	'$':      true,
< 	'%':      true,
< 	'&':      true,
< 	'\'':     true,
< 	'(':      true,
< 	')':      true,
< 	'*':      true,
< 	'+':      true,
< 	',':      true,
< 	'-':      true,
< 	'.':      true,
< 	'/':      true,
< 	'0':      true,
< 	'1':      true,
< 	'2':      true,
< 	'3':      true,
< 	'4':      true,
< 	'5':      true,
< 	'6':      true,
< 	'7':      true,
< 	'8':      true,
< 	'9':      true,
< 	':':      true,
< 	';':      true,
< 	'<':      true,
< 	'=':      true,
< 	'>':      true,
< 	'?':      true,
< 	'@':      true,
< 	'A':      true,
< 	'B':      true,
< 	'C':      true,
< 	'D':      true,
< 	'E':      true,
< 	'F':      true,
< 	'G':      true,
< 	'H':      true,
< 	'I':      true,
< 	'J':      true,
< 	'K':      true,
< 	'L':      true,
< 	'M':      true,
< 	'N':      true,
< 	'O':      true,
< 	'P':      true,
< 	'Q':      true,
< 	'R':      true,
< 	'S':      true,
< 	'T':      true,
< 	'U':      true,
< 	'V':      true,
< 	'W':      true,
< 	'X':      true,
< 	'Y':      true,
< 	'Z':      true,
< 	'[':      true,
< 	'\\':     false,
< 	']':      true,
< 	'^':      true,
< 	'_':      true,
< 	'`':      true,
< 	'a':      true,
< 	'b':      true,
< 	'c':      true,
< 	'd':      true,
< 	'e':      true,
< 	'f':      true,
< 	'g':      true,
< 	'h':      true,
< 	'i':      true,
< 	'j':      true,
< 	'k':      true,
< 	'l':      true,
< 	'm':      true,
< 	'n':      true,
< 	'o':      true,
< 	'p':      true,
< 	'q':      true,
< 	'r':      true,
< 	's':      true,
< 	't':      true,
< 	'u':      true,
< 	'v':      true,
< 	'w':      true,
< 	'x':      true,
< 	'y':      true,
< 	'z':      true,
< 	'{':      true,
< 	'|':      true,
< 	'}':      true,
< 	'~':      true,
< 	'\u007f': true,
< }
< 
< // htmlSafeSet holds the value true if the ASCII character with the given
< // array position can be safely represented inside a JSON string, embedded
< // inside of HTML <script> tags, without any additional escaping.
< //
< // All values are true except for the ASCII control characters (0-31), the
< // double quote ("), the backslash character ("\"), HTML opening and closing
< // tags ("<" and ">"), and the ampersand ("&").
< var htmlSafeSet = [utf8.RuneSelf]bool{
< 	' ':      true,
< 	'!':      true,
< 	'"':      false,
< 	'#':      true,
< 	'$':      true,
< 	'%':      true,
< 	'&':      false,
< 	'\'':     true,
< 	'(':      true,
< 	')':      true,
< 	'*':      true,
< 	'+':      true,
< 	',':      true,
< 	'-':      true,
< 	'.':      true,
< 	'/':      true,
< 	'0':      true,
< 	'1':      true,
< 	'2':      true,
< 	'3':      true,
< 	'4':      true,
< 	'5':      true,
< 	'6':      true,
< 	'7':      true,
< 	'8':      true,
< 	'9':      true,
< 	':':      true,
< 	';':      true,
< 	'<':      false,
< 	'=':      true,
< 	'>':      false,
< 	'?':      true,
< 	'@':      true,
< 	'A':      true,
< 	'B':      true,
< 	'C':      true,
< 	'D':      true,
< 	'E':      true,
< 	'F':      true,
< 	'G':      true,
< 	'H':      true,
< 	'I':      true,
< 	'J':      true,
< 	'K':      true,
< 	'L':      true,
< 	'M':      true,
< 	'N':      true,
< 	'O':      true,
< 	'P':      true,
< 	'Q':      true,
< 	'R':      true,
< 	'S':      true,
< 	'T':      true,
< 	'U':      true,
< 	'V':      true,
< 	'W':      true,
< 	'X':      true,
< 	'Y':      true,
< 	'Z':      true,
< 	'[':      true,
< 	'\\':     false,
< 	']':      true,
< 	'^':      true,
< 	'_':      true,
< 	'`':      true,
< 	'a':      true,
< 	'b':      true,
< 	'c':      true,
< 	'd':      true,
< 	'e':      true,
< 	'f':      true,
< 	'g':      true,
< 	'h':      true,
< 	'i':      true,
< 	'j':      true,
< 	'k':      true,
< 	'l':      true,
< 	'm':      true,
< 	'n':      true,
< 	'o':      true,
< 	'p':      true,
< 	'q':      true,
< 	'r':      true,
< 	's':      true,
< 	't':      true,
< 	'u':      true,
< 	'v':      true,
< 	'w':      true,
< 	'x':      true,
< 	'y':      true,
< 	'z':      true,
< 	'{':      true,
< 	'|':      true,
< 	'}':      true,
< 	'~':      true,
< 	'\u007f': true,
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/tags.go updated/vendor/github.com/coreos/fcct/vendor/github.com/clarketm/json/tags.go
1,44d0
< // Copyright 2011 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< import (
< 	"strings"
< )
< 
< // tagOptions is the string following a comma in a struct field's "json"
< // tag, or the empty string. It does not include the leading comma.
< type tagOptions string
< 
< // parseTag splits a struct field's json tag into its name and
< // comma-separated options.
< func parseTag(tag string) (string, tagOptions) {
< 	if idx := strings.Index(tag, ","); idx != -1 {
< 		return tag[:idx], tagOptions(tag[idx+1:])
< 	}
< 	return tag, tagOptions("")
< }
< 
< // Contains reports whether a comma-separated list of options
< // contains a particular substr flag. substr must be surrounded by a
< // string boundary or commas.
< func (o tagOptions) Contains(optionName string) bool {
< 	if len(o) == 0 {
< 		return false
< 	}
< 	s := string(o)
< 	for s != "" {
< 		var next string
< 		i := strings.Index(s, ",")
< 		if i >= 0 {
< 			s, next = s[:i], s[i+1:]
< 		}
< 		if s == optionName {
< 			return true
< 		}
< 		s = next
< 	}
< 	return false
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/README updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/README
1,10d0
< This is a fork of go's encoding/json library. It adds the a third target for unmarshalling, json.Node.
< Unmarshalling to a Node behaves similarilarly to unmarshalling to an interface{}, except it also records
< the offsets for the start and end of the value that was unmarshalled and, if the value was part of a json
< object, it also records the offsets of the start and end of the object's key. The Value field of the Node
< will be unmarshalled to the same types as if it were an interface{}, except in the case of arrays and
< objects. In those case it will be unmarshalled to a []Node or map[string]Node instead []interface{} or
< map[string]interface{} for arrays and objects, respectively.
< 
< There are two branchs, go15 and go16. go15 contains the modified go1.5 library and go16 contains the
< modified go1.6 library.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/decode.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/decode.go
1,1226d0
< // Copyright 2010 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< // Represents JSON data structure using native Go types: booleans, floats,
< // strings, arrays, and maps.
< 
< package json
< 
< import (
< 	"bytes"
< 	"encoding"
< 	"encoding/base64"
< 	"errors"
< 	"fmt"
< 	"reflect"
< 	"runtime"
< 	"strconv"
< 	"unicode"
< 	"unicode/utf16"
< 	"unicode/utf8"
< )
< 
< // Unmarshal parses the JSON-encoded data and stores the result
< // in the value pointed to by v.
< //
< // Unmarshal uses the inverse of the encodings that
< // Marshal uses, allocating maps, slices, and pointers as necessary,
< // with the following additional rules:
< //
< // To unmarshal JSON into a pointer, Unmarshal first handles the case of
< // the JSON being the JSON literal null.  In that case, Unmarshal sets
< // the pointer to nil.  Otherwise, Unmarshal unmarshals the JSON into
< // the value pointed at by the pointer.  If the pointer is nil, Unmarshal
< // allocates a new value for it to point to.
< //
< // To unmarshal JSON into a struct, Unmarshal matches incoming object
< // keys to the keys used by Marshal (either the struct field name or its tag),
< // preferring an exact match but also accepting a case-insensitive match.
< //
< // To unmarshal JSON into an interface value,
< // Unmarshal stores one of these in the interface value:
< //
< //	bool, for JSON booleans
< //	float64, for JSON numbers
< //	string, for JSON strings
< //	[]interface{}, for JSON arrays
< //	map[string]interface{}, for JSON objects
< //	nil for JSON null
< //
< // To unmarshal a JSON array into a slice, Unmarshal resets the slice to nil
< // and then appends each element to the slice.
< //
< // To unmarshal a JSON object into a map, Unmarshal replaces the map
< // with an empty map and then adds key-value pairs from the object to
< // the map.
< //
< // If a JSON value is not appropriate for a given target type,
< // or if a JSON number overflows the target type, Unmarshal
< // skips that field and completes the unmarshalling as best it can.
< // If no more serious errors are encountered, Unmarshal returns
< // an UnmarshalTypeError describing the earliest such error.
< //
< // The JSON null value unmarshals into an interface, map, pointer, or slice
< // by setting that Go value to nil. Because null is often used in JSON to mean
< // ``not present,'' unmarshaling a JSON null into any other Go type has no effect
< // on the value and produces no error.
< //
< // When unmarshaling quoted strings, invalid UTF-8 or
< // invalid UTF-16 surrogate pairs are not treated as an error.
< // Instead, they are replaced by the Unicode replacement
< // character U+FFFD.
< //
< func Unmarshal(data []byte, v interface{}) error {
< 	// Check for well-formedness.
< 	// Avoids filling out half a data structure
< 	// before discovering a JSON syntax error.
< 	var d decodeState
< 	err := checkValid(data, &d.scan)
< 	if err != nil {
< 		return err
< 	}
< 
< 	d.init(data)
< 	return d.unmarshal(v)
< }
< 
< // Unmarshaler is the interface implemented by objects
< // that can unmarshal a JSON description of themselves.
< // The input can be assumed to be a valid encoding of
< // a JSON value. UnmarshalJSON must copy the JSON data
< // if it wishes to retain the data after returning.
< type Unmarshaler interface {
< 	UnmarshalJSON([]byte) error
< }
< 
< // An UnmarshalTypeError describes a JSON value that was
< // not appropriate for a value of a specific Go type.
< type UnmarshalTypeError struct {
< 	Value  string       // description of JSON value - "bool", "array", "number -5"
< 	Type   reflect.Type // type of Go value it could not be assigned to
< 	Offset int64        // error occurred after reading Offset bytes
< }
< 
< func (e *UnmarshalTypeError) Error() string {
< 	return "json: cannot unmarshal " + e.Value + " into Go value of type " + e.Type.String()
< }
< 
< // An UnmarshalFieldError describes a JSON object key that
< // led to an unexported (and therefore unwritable) struct field.
< // (No longer used; kept for compatibility.)
< type UnmarshalFieldError struct {
< 	Key   string
< 	Type  reflect.Type
< 	Field reflect.StructField
< }
< 
< func (e *UnmarshalFieldError) Error() string {
< 	return "json: cannot unmarshal object key " + strconv.Quote(e.Key) + " into unexported field " + e.Field.Name + " of type " + e.Type.String()
< }
< 
< // An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.
< // (The argument to Unmarshal must be a non-nil pointer.)
< type InvalidUnmarshalError struct {
< 	Type reflect.Type
< }
< 
< type Node struct {
< 	Start    int
< 	End      int
< 	KeyStart int // Only value if a member of a struct
< 	KeyEnd   int
< 	Value    interface{}
< }
< 
< func (e *InvalidUnmarshalError) Error() string {
< 	if e.Type == nil {
< 		return "json: Unmarshal(nil)"
< 	}
< 
< 	if e.Type.Kind() != reflect.Ptr {
< 		return "json: Unmarshal(non-pointer " + e.Type.String() + ")"
< 	}
< 	return "json: Unmarshal(nil " + e.Type.String() + ")"
< }
< 
< func (d *decodeState) unmarshal(v interface{}) (err error) {
< 	defer func() {
< 		if r := recover(); r != nil {
< 			if _, ok := r.(runtime.Error); ok {
< 				panic(r)
< 			}
< 			err = r.(error)
< 		}
< 	}()
< 
< 	rv := reflect.ValueOf(v)
< 	if rv.Kind() != reflect.Ptr || rv.IsNil() {
< 		return &InvalidUnmarshalError{reflect.TypeOf(v)}
< 	}
< 
< 	d.scan.reset()
< 	// We decode rv not rv.Elem because the Unmarshaler interface
< 	// test must be applied at the top level of the value.
< 	d.value(rv)
< 	return d.savedError
< }
< 
< // A Number represents a JSON number literal.
< type Number string
< 
< // String returns the literal text of the number.
< func (n Number) String() string { return string(n) }
< 
< // Float64 returns the number as a float64.
< func (n Number) Float64() (float64, error) {
< 	return strconv.ParseFloat(string(n), 64)
< }
< 
< // Int64 returns the number as an int64.
< func (n Number) Int64() (int64, error) {
< 	return strconv.ParseInt(string(n), 10, 64)
< }
< 
< // decodeState represents the state while decoding a JSON value.
< type decodeState struct {
< 	data       []byte
< 	off        int // read offset in data
< 	scan       scanner
< 	nextscan   scanner // for calls to nextValue
< 	savedError error
< 	useNumber  bool
< }
< 
< // errPhase is used for errors that should not happen unless
< // there is a bug in the JSON decoder or something is editing
< // the data slice while the decoder executes.
< var errPhase = errors.New("JSON decoder out of sync - data changing underfoot?")
< 
< func (d *decodeState) init(data []byte) *decodeState {
< 	d.data = data
< 	d.off = 0
< 	d.savedError = nil
< 	return d
< }
< 
< // error aborts the decoding by panicking with err.
< func (d *decodeState) error(err error) {
< 	panic(err)
< }
< 
< // saveError saves the first err it is called with,
< // for reporting at the end of the unmarshal.
< func (d *decodeState) saveError(err error) {
< 	if d.savedError == nil {
< 		d.savedError = err
< 	}
< }
< 
< // next cuts off and returns the next full JSON value in d.data[d.off:].
< // The next value is known to be an object or array, not a literal.
< func (d *decodeState) next() []byte {
< 	c := d.data[d.off]
< 	item, rest, err := nextValue(d.data[d.off:], &d.nextscan)
< 	if err != nil {
< 		d.error(err)
< 	}
< 	d.off = len(d.data) - len(rest)
< 
< 	// Our scanner has seen the opening brace/bracket
< 	// and thinks we're still in the middle of the object.
< 	// invent a closing brace/bracket to get it out.
< 	if c == '{' {
< 		d.scan.step(&d.scan, '}')
< 	} else {
< 		d.scan.step(&d.scan, ']')
< 	}
< 
< 	return item
< }
< 
< // scanWhile processes bytes in d.data[d.off:] until it
< // receives a scan code not equal to op.
< // It updates d.off and returns the new scan code.
< func (d *decodeState) scanWhile(op int) int {
< 	var newOp int
< 	for {
< 		if d.off >= len(d.data) {
< 			newOp = d.scan.eof()
< 			d.off = len(d.data) + 1 // mark processed EOF with len+1
< 		} else {
< 			c := int(d.data[d.off])
< 			d.off++
< 			newOp = d.scan.step(&d.scan, c)
< 		}
< 		if newOp != op {
< 			break
< 		}
< 	}
< 	return newOp
< }
< 
< // value decodes a JSON value from d.data[d.off:] into the value.
< // it updates d.off to point past the decoded value.
< func (d *decodeState) value(v reflect.Value) {
< 	if !v.IsValid() {
< 		_, rest, err := nextValue(d.data[d.off:], &d.nextscan)
< 		if err != nil {
< 			d.error(err)
< 		}
< 		d.off = len(d.data) - len(rest)
< 
< 		// d.scan thinks we're still at the beginning of the item.
< 		// Feed in an empty string - the shortest, simplest value -
< 		// so that it knows we got to the end of the value.
< 		if d.scan.redo {
< 			// rewind.
< 			d.scan.redo = false
< 			d.scan.step = stateBeginValue
< 		}
< 		d.scan.step(&d.scan, '"')
< 		d.scan.step(&d.scan, '"')
< 
< 		n := len(d.scan.parseState)
< 		if n > 0 && d.scan.parseState[n-1] == parseObjectKey {
< 			// d.scan thinks we just read an object key; finish the object
< 			d.scan.step(&d.scan, ':')
< 			d.scan.step(&d.scan, '"')
< 			d.scan.step(&d.scan, '"')
< 			d.scan.step(&d.scan, '}')
< 		}
< 
< 		return
< 	}
< 
< 	switch op := d.scanWhile(scanSkipSpace); op {
< 	default:
< 		d.error(errPhase)
< 
< 	case scanBeginArray:
< 		d.array(v)
< 
< 	case scanBeginObject:
< 		d.object(v)
< 
< 	case scanBeginLiteral:
< 		d.literal(v)
< 	}
< }
< 
< type unquotedValue struct{}
< 
< // valueQuoted is like value but decodes a
< // quoted string literal or literal null into an interface value.
< // If it finds anything other than a quoted string literal or null,
< // valueQuoted returns unquotedValue{}.
< func (d *decodeState) valueQuoted() interface{} {
< 	switch op := d.scanWhile(scanSkipSpace); op {
< 	default:
< 		d.error(errPhase)
< 
< 	case scanBeginArray:
< 		d.array(reflect.Value{})
< 
< 	case scanBeginObject:
< 		d.object(reflect.Value{})
< 
< 	case scanBeginLiteral:
< 		switch v := d.literalInterface().(type) {
< 		case nil, string:
< 			return v
< 		}
< 	}
< 	return unquotedValue{}
< }
< 
< // indirect walks down v allocating pointers as needed,
< // until it gets to a non-pointer.
< // if it encounters an Unmarshaler, indirect stops and returns that.
< // if decodingNull is true, indirect stops at the last pointer so it can be set to nil.
< func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler, encoding.TextUnmarshaler, reflect.Value) {
< 	// If v is a named type and is addressable,
< 	// start with its address, so that if the type has pointer methods,
< 	// we find them.
< 	if v.Kind() != reflect.Ptr && v.Type().Name() != "" && v.CanAddr() {
< 		v = v.Addr()
< 	}
< 	for {
< 		// Load value from interface, but only if the result will be
< 		// usefully addressable.
< 		if v.Kind() == reflect.Interface && !v.IsNil() {
< 			e := v.Elem()
< 			if e.Kind() == reflect.Ptr && !e.IsNil() && (!decodingNull || e.Elem().Kind() == reflect.Ptr) {
< 				v = e
< 				continue
< 			}
< 		}
< 
< 		if v.Kind() != reflect.Ptr {
< 			break
< 		}
< 
< 		if v.Elem().Kind() != reflect.Ptr && decodingNull && v.CanSet() {
< 			break
< 		}
< 		if v.IsNil() {
< 			v.Set(reflect.New(v.Type().Elem()))
< 		}
< 		if v.Type().NumMethod() > 0 {
< 			if u, ok := v.Interface().(Unmarshaler); ok {
< 				return u, nil, reflect.Value{}
< 			}
< 			if u, ok := v.Interface().(encoding.TextUnmarshaler); ok {
< 				return nil, u, reflect.Value{}
< 			}
< 		}
< 		v = v.Elem()
< 	}
< 	return nil, nil, v
< }
< 
< // array consumes an array from d.data[d.off-1:], decoding into the value v.
< // the first byte of the array ('[') has been read already.
< func (d *decodeState) array(v reflect.Value) {
< 	// Check for unmarshaler.
< 	u, ut, pv := d.indirect(v, false)
< 	if u != nil {
< 		d.off--
< 		err := u.UnmarshalJSON(d.next())
< 		if err != nil {
< 			d.error(err)
< 		}
< 		return
< 	}
< 	if ut != nil {
< 		d.saveError(&UnmarshalTypeError{"array", v.Type(), int64(d.off)})
< 		d.off--
< 		d.next()
< 		return
< 	}
< 
< 	v = pv
< 
< 	// Check type of target.
< 	switch v.Kind() {
< 	case reflect.Interface:
< 		if v.NumMethod() == 0 {
< 			// Decoding into nil interface?  Switch to non-reflect code.
< 			v.Set(reflect.ValueOf(d.arrayInterface()))
< 			return
< 		}
< 		// Otherwise it's invalid.
< 		fallthrough
< 	default:
< 		if v.Type() == reflect.TypeOf(Node{}) {
< 			// Decoding to Node? Switch to that code
< 			v.Set(reflect.ValueOf(d.arrayNode()))
< 			return
< 		}
< 		d.saveError(&UnmarshalTypeError{"array", v.Type(), int64(d.off)})
< 		d.off--
< 		d.next()
< 		return
< 	case reflect.Array:
< 	case reflect.Slice:
< 		break
< 	}
< 
< 	i := 0
< 	for {
< 		// Look ahead for ] - can only happen on first iteration.
< 		op := d.scanWhile(scanSkipSpace)
< 		if op == scanEndArray {
< 			break
< 		}
< 
< 		// Back up so d.value can have the byte we just read.
< 		d.off--
< 		d.scan.undo(op)
< 
< 		// Get element of array, growing if necessary.
< 		if v.Kind() == reflect.Slice {
< 			// Grow slice if necessary
< 			if i >= v.Cap() {
< 				newcap := v.Cap() + v.Cap()/2
< 				if newcap < 4 {
< 					newcap = 4
< 				}
< 				newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)
< 				reflect.Copy(newv, v)
< 				v.Set(newv)
< 			}
< 			if i >= v.Len() {
< 				v.SetLen(i + 1)
< 			}
< 		}
< 
< 		if i < v.Len() {
< 			// Decode into element.
< 			d.value(v.Index(i))
< 		} else {
< 			// Ran out of fixed array: skip.
< 			d.value(reflect.Value{})
< 		}
< 		i++
< 
< 		// Next token must be , or ].
< 		op = d.scanWhile(scanSkipSpace)
< 		if op == scanEndArray {
< 			break
< 		}
< 		if op != scanArrayValue {
< 			d.error(errPhase)
< 		}
< 	}
< 
< 	if i < v.Len() {
< 		if v.Kind() == reflect.Array {
< 			// Array.  Zero the rest.
< 			z := reflect.Zero(v.Type().Elem())
< 			for ; i < v.Len(); i++ {
< 				v.Index(i).Set(z)
< 			}
< 		} else {
< 			v.SetLen(i)
< 		}
< 	}
< 	if i == 0 && v.Kind() == reflect.Slice {
< 		v.Set(reflect.MakeSlice(v.Type(), 0, 0))
< 	}
< }
< 
< var nullLiteral = []byte("null")
< 
< // object consumes an object from d.data[d.off-1:], decoding into the value v.
< // the first byte ('{') of the object has been read already.
< func (d *decodeState) object(v reflect.Value) {
< 	// Check for unmarshaler.
< 	u, ut, pv := d.indirect(v, false)
< 	if u != nil {
< 		d.off--
< 		err := u.UnmarshalJSON(d.next())
< 		if err != nil {
< 			d.error(err)
< 		}
< 		return
< 	}
< 	if ut != nil {
< 		d.saveError(&UnmarshalTypeError{"object", v.Type(), int64(d.off)})
< 		d.off--
< 		d.next() // skip over { } in input
< 		return
< 	}
< 	v = pv
< 
< 	// Decoding into nil interface?  Switch to non-reflect code.
< 	if v.Kind() == reflect.Interface && v.NumMethod() == 0 {
< 		v.Set(reflect.ValueOf(d.objectInterface()))
< 		return
< 	} else if v.Type() == reflect.TypeOf(Node{}) {
< 		// Decoding to Node? Switch to that code
< 		v.Set(reflect.ValueOf(d.objectNode()))
< 		return
< 	}
< 
< 	// Check type of target: struct or map[string]T
< 	switch v.Kind() {
< 	case reflect.Map:
< 		// map must have string kind
< 		t := v.Type()
< 		if t.Key().Kind() != reflect.String {
< 			d.saveError(&UnmarshalTypeError{"object", v.Type(), int64(d.off)})
< 			d.off--
< 			d.next() // skip over { } in input
< 			return
< 		}
< 		if v.IsNil() {
< 			v.Set(reflect.MakeMap(t))
< 		}
< 	case reflect.Struct:
< 
< 	default:
< 		d.saveError(&UnmarshalTypeError{"object", v.Type(), int64(d.off)})
< 		d.off--
< 		d.next() // skip over { } in input
< 		return
< 	}
< 
< 	var mapElem reflect.Value
< 
< 	for {
< 		// Read opening " of string key or closing }.
< 		op := d.scanWhile(scanSkipSpace)
< 		if op == scanEndObject {
< 			// closing } - can only happen on first iteration.
< 			break
< 		}
< 		if op != scanBeginLiteral {
< 			d.error(errPhase)
< 		}
< 
< 		// Read key.
< 		start := d.off - 1
< 		op = d.scanWhile(scanContinue)
< 		item := d.data[start : d.off-1]
< 		key, ok := unquoteBytes(item)
< 		if !ok {
< 			d.error(errPhase)
< 		}
< 
< 		// Figure out field corresponding to key.
< 		var subv reflect.Value
< 		destring := false // whether the value is wrapped in a string to be decoded first
< 
< 		if v.Kind() == reflect.Map {
< 			elemType := v.Type().Elem()
< 			if !mapElem.IsValid() {
< 				mapElem = reflect.New(elemType).Elem()
< 			} else {
< 				mapElem.Set(reflect.Zero(elemType))
< 			}
< 			subv = mapElem
< 		} else {
< 			var f *field
< 			fields := cachedTypeFields(v.Type())
< 			for i := range fields {
< 				ff := &fields[i]
< 				if bytes.Equal(ff.nameBytes, key) {
< 					f = ff
< 					break
< 				}
< 				if f == nil && ff.equalFold(ff.nameBytes, key) {
< 					f = ff
< 				}
< 			}
< 			if f != nil {
< 				subv = v
< 				destring = f.quoted
< 				for _, i := range f.index {
< 					if subv.Kind() == reflect.Ptr {
< 						if subv.IsNil() {
< 							subv.Set(reflect.New(subv.Type().Elem()))
< 						}
< 						subv = subv.Elem()
< 					}
< 					subv = subv.Field(i)
< 				}
< 			}
< 		}
< 
< 		// Read : before value.
< 		if op == scanSkipSpace {
< 			op = d.scanWhile(scanSkipSpace)
< 		}
< 		if op != scanObjectKey {
< 			d.error(errPhase)
< 		}
< 
< 		// Read value.
< 		if destring {
< 			switch qv := d.valueQuoted().(type) {
< 			case nil:
< 				d.literalStore(nullLiteral, subv, false)
< 			case string:
< 				d.literalStore([]byte(qv), subv, true)
< 			default:
< 				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal unquoted value into %v", subv.Type()))
< 			}
< 		} else {
< 			d.value(subv)
< 		}
< 
< 		// Write value back to map;
< 		// if using struct, subv points into struct already.
< 		if v.Kind() == reflect.Map {
< 			kv := reflect.ValueOf(key).Convert(v.Type().Key())
< 			v.SetMapIndex(kv, subv)
< 		}
< 
< 		// Next token must be , or }.
< 		op = d.scanWhile(scanSkipSpace)
< 		if op == scanEndObject {
< 			break
< 		}
< 		if op != scanObjectValue {
< 			d.error(errPhase)
< 		}
< 	}
< }
< 
< // literal consumes a literal from d.data[d.off-1:], decoding into the value v.
< // The first byte of the literal has been read already
< // (that's how the caller knows it's a literal).
< func (d *decodeState) literal(v reflect.Value) {
< 	// All bytes inside literal return scanContinue op code.
< 	start := d.off - 1
< 	op := d.scanWhile(scanContinue)
< 
< 	// Scan read one byte too far; back up.
< 	d.off--
< 	d.scan.undo(op)
< 
< 	d.literalStore(d.data[start:d.off], v, false)
< }
< 
< // convertNumber converts the number literal s to a float64 or a Number
< // depending on the setting of d.useNumber.
< func (d *decodeState) convertNumber(s string) (interface{}, error) {
< 	if d.useNumber {
< 		return Number(s), nil
< 	}
< 	f, err := strconv.ParseFloat(s, 64)
< 	if err != nil {
< 		return nil, &UnmarshalTypeError{"number " + s, reflect.TypeOf(0.0), int64(d.off)}
< 	}
< 	return f, nil
< }
< 
< var numberType = reflect.TypeOf(Number(""))
< 
< // literalStore decodes a literal stored in item into v.
< //
< // fromQuoted indicates whether this literal came from unwrapping a
< // string from the ",string" struct tag option. this is used only to
< // produce more helpful error messages.
< func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) {
< 	// Check for unmarshaler.
< 	if len(item) == 0 {
< 		//Empty string given
< 		d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 		return
< 	}
< 	wantptr := item[0] == 'n' // null
< 	u, ut, pv := d.indirect(v, wantptr)
< 	if u != nil {
< 		err := u.UnmarshalJSON(item)
< 		if err != nil {
< 			d.error(err)
< 		}
< 		return
< 	}
< 	if ut != nil {
< 		if item[0] != '"' {
< 			if fromQuoted {
< 				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 			} else {
< 				d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
< 			}
< 			return
< 		}
< 		s, ok := unquoteBytes(item)
< 		if !ok {
< 			if fromQuoted {
< 				d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 			} else {
< 				d.error(errPhase)
< 			}
< 		}
< 		err := ut.UnmarshalText(s)
< 		if err != nil {
< 			d.error(err)
< 		}
< 		return
< 	}
< 
< 	v = pv
< 
< 	switch c := item[0]; c {
< 	case 'n': // null
< 		switch v.Kind() {
< 		case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:
< 			v.Set(reflect.Zero(v.Type()))
< 			// otherwise, ignore null for primitives/string
< 		}
< 	case 't', 'f': // true, false
< 		value := c == 't'
< 		switch v.Kind() {
< 		default:
< 			if fromQuoted {
< 				d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 			} else {
< 				d.saveError(&UnmarshalTypeError{"bool", v.Type(), int64(d.off)})
< 			}
< 		case reflect.Bool:
< 			v.SetBool(value)
< 		case reflect.Interface:
< 			if v.NumMethod() == 0 {
< 				v.Set(reflect.ValueOf(value))
< 			} else {
< 				d.saveError(&UnmarshalTypeError{"bool", v.Type(), int64(d.off)})
< 			}
< 		}
< 
< 	case '"': // string
< 		s, ok := unquoteBytes(item)
< 		if !ok {
< 			if fromQuoted {
< 				d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 			} else {
< 				d.error(errPhase)
< 			}
< 		}
< 		switch v.Kind() {
< 		default:
< 			d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
< 		case reflect.Slice:
< 			if v.Type().Elem().Kind() != reflect.Uint8 {
< 				d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
< 				break
< 			}
< 			b := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
< 			n, err := base64.StdEncoding.Decode(b, s)
< 			if err != nil {
< 				d.saveError(err)
< 				break
< 			}
< 			v.Set(reflect.ValueOf(b[0:n]))
< 		case reflect.String:
< 			v.SetString(string(s))
< 		case reflect.Interface:
< 			if v.NumMethod() == 0 {
< 				v.Set(reflect.ValueOf(string(s)))
< 			} else {
< 				d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
< 			}
< 		}
< 
< 	default: // number
< 		if c != '-' && (c < '0' || c > '9') {
< 			if fromQuoted {
< 				d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 			} else {
< 				d.error(errPhase)
< 			}
< 		}
< 		s := string(item)
< 		switch v.Kind() {
< 		default:
< 			if v.Kind() == reflect.String && v.Type() == numberType {
< 				v.SetString(s)
< 				break
< 			}
< 			if fromQuoted {
< 				d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
< 			} else {
< 				d.error(&UnmarshalTypeError{"number", v.Type(), int64(d.off)})
< 			}
< 		case reflect.Interface:
< 			n, err := d.convertNumber(s)
< 			if err != nil {
< 				d.saveError(err)
< 				break
< 			}
< 			if v.NumMethod() != 0 {
< 				d.saveError(&UnmarshalTypeError{"number", v.Type(), int64(d.off)})
< 				break
< 			}
< 			v.Set(reflect.ValueOf(n))
< 
< 		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 			n, err := strconv.ParseInt(s, 10, 64)
< 			if err != nil || v.OverflowInt(n) {
< 				d.saveError(&UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
< 				break
< 			}
< 			v.SetInt(n)
< 
< 		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 			n, err := strconv.ParseUint(s, 10, 64)
< 			if err != nil || v.OverflowUint(n) {
< 				d.saveError(&UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
< 				break
< 			}
< 			v.SetUint(n)
< 
< 		case reflect.Float32, reflect.Float64:
< 			n, err := strconv.ParseFloat(s, v.Type().Bits())
< 			if err != nil || v.OverflowFloat(n) {
< 				d.saveError(&UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
< 				break
< 			}
< 			v.SetFloat(n)
< 		}
< 	}
< }
< 
< // The xxxInterface routines build up a value to be stored
< // in an empty interface.  They are not strictly necessary,
< // but they avoid the weight of reflection in this common case.
< 
< // valueInterface is like value but returns interface{}
< func (d *decodeState) valueInterface() interface{} {
< 	switch d.scanWhile(scanSkipSpace) {
< 	default:
< 		d.error(errPhase)
< 		panic("unreachable")
< 	case scanBeginArray:
< 		return d.arrayInterface()
< 	case scanBeginObject:
< 		return d.objectInterface()
< 	case scanBeginLiteral:
< 		return d.literalInterface()
< 	}
< }
< 
< // valueNode is like valueInterface but returns a wrapped version that
< // contains metadata about where it decoded from
< func (d *decodeState) valueNode() Node {
< 	switch d.scanWhile(scanSkipSpace) {
< 	default:
< 		d.error(errPhase)
< 		panic("unreachable")
< 	case scanBeginArray:
< 		return d.arrayNode()
< 	case scanBeginObject:
< 		return d.objectNode()
< 	case scanBeginLiteral:
< 		return d.literalNode()
< 	}
< }
< 
< // arrayInterface is like array but returns []interface{}.
< func (d *decodeState) arrayInterface() []interface{} {
< 	var v = make([]interface{}, 0)
< 	for {
< 		// Look ahead for ] - can only happen on first iteration.
< 		op := d.scanWhile(scanSkipSpace)
< 		if op == scanEndArray {
< 			break
< 		}
< 
< 		// Back up so d.value can have the byte we just read.
< 		d.off--
< 		d.scan.undo(op)
< 
< 		v = append(v, d.valueInterface())
< 
< 		// Next token must be , or ].
< 		op = d.scanWhile(scanSkipSpace)
< 		if op == scanEndArray {
< 			break
< 		}
< 		if op != scanArrayValue {
< 			d.error(errPhase)
< 		}
< 	}
< 	return v
< }
< 
< // arrayNode is like arrayInterface but returns Node.
< func (d *decodeState) arrayNode() Node {
< 	var v = make([]Node, 0)
< 	node := Node{
< 		Start: d.off,
< 		Value: v,
< 	}
< 	for {
< 		// Look ahead for ] - can only happen on first iteration.
< 		op := d.scanWhile(scanSkipSpace)
< 		if op == scanEndArray {
< 			break
< 		}
< 
< 		// Back up so d.value can have the byte we just read.
< 		d.off--
< 		d.scan.undo(op)
< 
< 		v = append(v, d.valueNode())
< 
< 		// Next token must be , or ].
< 		op = d.scanWhile(scanSkipSpace)
< 		if op == scanEndArray {
< 			break
< 		}
< 		if op != scanArrayValue {
< 			d.error(errPhase)
< 		}
< 	}
< 	node.Value = v
< 	node.End = d.off - 1
< 	return node
< }
< 
< // objectInterface is like object but returns map[string]interface{}.
< func (d *decodeState) objectInterface() map[string]interface{} {
< 	m := make(map[string]interface{})
< 	for {
< 		// Read opening " of string key or closing }.
< 		op := d.scanWhile(scanSkipSpace)
< 		if op == scanEndObject {
< 			// closing } - can only happen on first iteration.
< 			break
< 		}
< 		if op != scanBeginLiteral {
< 			d.error(errPhase)
< 		}
< 
< 		// Read string key.
< 		start := d.off - 1
< 		op = d.scanWhile(scanContinue)
< 		item := d.data[start : d.off-1]
< 		key, ok := unquote(item)
< 		if !ok {
< 			d.error(errPhase)
< 		}
< 
< 		// Read : before value.
< 		if op == scanSkipSpace {
< 			op = d.scanWhile(scanSkipSpace)
< 		}
< 		if op != scanObjectKey {
< 			d.error(errPhase)
< 		}
< 
< 		// Read value.
< 		m[key] = d.valueInterface()
< 
< 		// Next token must be , or }.
< 		op = d.scanWhile(scanSkipSpace)
< 		if op == scanEndObject {
< 			break
< 		}
< 		if op != scanObjectValue {
< 			d.error(errPhase)
< 		}
< 	}
< 	return m
< }
< 
< // objectNode is like object but returns Node.
< func (d *decodeState) objectNode() Node {
< 	m := make(map[string]Node)
< 	node := Node{
< 		Start: d.off,
< 	}
< 	for {
< 		// Read opening " of string key or closing }.
< 		op := d.scanWhile(scanSkipSpace)
< 		if op == scanEndObject {
< 			// closing } - can only happen on first iteration.
< 			break
< 		}
< 		if op != scanBeginLiteral {
< 			d.error(errPhase)
< 		}
< 
< 		// Read string key.
< 		start := d.off - 1
< 		op = d.scanWhile(scanContinue)
< 		item := d.data[start : d.off-1]
< 		keyEnd := d.off - 1
< 		key, ok := unquote(item)
< 		if !ok {
< 			d.error(errPhase)
< 		}
< 
< 		// Read : before value.
< 		if op == scanSkipSpace {
< 			op = d.scanWhile(scanSkipSpace)
< 		}
< 		if op != scanObjectKey {
< 			d.error(errPhase)
< 		}
< 
< 		// Read value.
< 		val := d.valueNode()
< 		val.KeyStart = start
< 		val.KeyEnd = keyEnd
< 		m[key] = val
< 
< 		// Next token must be , or }.
< 		op = d.scanWhile(scanSkipSpace)
< 		if op == scanEndObject {
< 			break
< 		}
< 		if op != scanObjectValue {
< 			d.error(errPhase)
< 		}
< 	}
< 	node.Value = m
< 	node.End = d.off - 1
< 	return node
< }
< 
< // literalInterface is like literal but returns an interface value.
< func (d *decodeState) literalInterface() interface{} {
< 	// All bytes inside literal return scanContinue op code.
< 	start := d.off - 1
< 	op := d.scanWhile(scanContinue)
< 
< 	// Scan read one byte too far; back up.
< 	d.off--
< 	d.scan.undo(op)
< 	item := d.data[start:d.off]
< 
< 	switch c := item[0]; c {
< 	case 'n': // null
< 		return nil
< 
< 	case 't', 'f': // true, false
< 		return c == 't'
< 
< 	case '"': // string
< 		s, ok := unquote(item)
< 		if !ok {
< 			d.error(errPhase)
< 		}
< 		return s
< 
< 	default: // number
< 		if c != '-' && (c < '0' || c > '9') {
< 			d.error(errPhase)
< 		}
< 		n, err := d.convertNumber(string(item))
< 		if err != nil {
< 			d.saveError(err)
< 		}
< 		return n
< 	}
< }
< 
< func (d *decodeState) literalNode() Node {
< 	start := d.off - 1
< 	// Can just use the interface version since this has no children
< 	node := Node{
< 		Start: start,
< 		Value: d.literalInterface(),
< 	}
< 	node.End = d.off - 1
< 	return node
< }
< 
< // getu4 decodes \uXXXX from the beginning of s, returning the hex value,
< // or it returns -1.
< func getu4(s []byte) rune {
< 	if len(s) < 6 || s[0] != '\\' || s[1] != 'u' {
< 		return -1
< 	}
< 	r, err := strconv.ParseUint(string(s[2:6]), 16, 64)
< 	if err != nil {
< 		return -1
< 	}
< 	return rune(r)
< }
< 
< // unquote converts a quoted JSON string literal s into an actual string t.
< // The rules are different than for Go, so cannot use strconv.Unquote.
< func unquote(s []byte) (t string, ok bool) {
< 	s, ok = unquoteBytes(s)
< 	t = string(s)
< 	return
< }
< 
< func unquoteBytes(s []byte) (t []byte, ok bool) {
< 	if len(s) < 2 || s[0] != '"' || s[len(s)-1] != '"' {
< 		return
< 	}
< 	s = s[1 : len(s)-1]
< 
< 	// Check for unusual characters. If there are none,
< 	// then no unquoting is needed, so return a slice of the
< 	// original bytes.
< 	r := 0
< 	for r < len(s) {
< 		c := s[r]
< 		if c == '\\' || c == '"' || c < ' ' {
< 			break
< 		}
< 		if c < utf8.RuneSelf {
< 			r++
< 			continue
< 		}
< 		rr, size := utf8.DecodeRune(s[r:])
< 		if rr == utf8.RuneError && size == 1 {
< 			break
< 		}
< 		r += size
< 	}
< 	if r == len(s) {
< 		return s, true
< 	}
< 
< 	b := make([]byte, len(s)+2*utf8.UTFMax)
< 	w := copy(b, s[0:r])
< 	for r < len(s) {
< 		// Out of room?  Can only happen if s is full of
< 		// malformed UTF-8 and we're replacing each
< 		// byte with RuneError.
< 		if w >= len(b)-2*utf8.UTFMax {
< 			nb := make([]byte, (len(b)+utf8.UTFMax)*2)
< 			copy(nb, b[0:w])
< 			b = nb
< 		}
< 		switch c := s[r]; {
< 		case c == '\\':
< 			r++
< 			if r >= len(s) {
< 				return
< 			}
< 			switch s[r] {
< 			default:
< 				return
< 			case '"', '\\', '/', '\'':
< 				b[w] = s[r]
< 				r++
< 				w++
< 			case 'b':
< 				b[w] = '\b'
< 				r++
< 				w++
< 			case 'f':
< 				b[w] = '\f'
< 				r++
< 				w++
< 			case 'n':
< 				b[w] = '\n'
< 				r++
< 				w++
< 			case 'r':
< 				b[w] = '\r'
< 				r++
< 				w++
< 			case 't':
< 				b[w] = '\t'
< 				r++
< 				w++
< 			case 'u':
< 				r--
< 				rr := getu4(s[r:])
< 				if rr < 0 {
< 					return
< 				}
< 				r += 6
< 				if utf16.IsSurrogate(rr) {
< 					rr1 := getu4(s[r:])
< 					if dec := utf16.DecodeRune(rr, rr1); dec != unicode.ReplacementChar {
< 						// A valid pair; consume.
< 						r += 6
< 						w += utf8.EncodeRune(b[w:], dec)
< 						break
< 					}
< 					// Invalid surrogate; fall back to replacement rune.
< 					rr = unicode.ReplacementChar
< 				}
< 				w += utf8.EncodeRune(b[w:], rr)
< 			}
< 
< 		// Quote, control characters are invalid.
< 		case c == '"', c < ' ':
< 			return
< 
< 		// ASCII
< 		case c < utf8.RuneSelf:
< 			b[w] = c
< 			r++
< 			w++
< 
< 		// Coerce to well-formed UTF-8.
< 		default:
< 			rr, size := utf8.DecodeRune(s[r:])
< 			r += size
< 			w += utf8.EncodeRune(b[w:], rr)
< 		}
< 	}
< 	return b[0:w], true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/encode.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/encode.go
1,1194d0
< // Copyright 2010 The Go Authors.  All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< // Package json implements encoding and decoding of JSON objects as defined in
< // RFC 4627. The mapping between JSON objects and Go values is described
< // in the documentation for the Marshal and Unmarshal functions.
< //
< // See "JSON and Go" for an introduction to this package:
< // https://golang.org/doc/articles/json_and_go.html
< package json
< 
< import (
< 	"bytes"
< 	"encoding"
< 	"encoding/base64"
< 	"math"
< 	"reflect"
< 	"runtime"
< 	"sort"
< 	"strconv"
< 	"strings"
< 	"sync"
< 	"unicode"
< 	"unicode/utf8"
< )
< 
< // Marshal returns the JSON encoding of v.
< //
< // Marshal traverses the value v recursively.
< // If an encountered value implements the Marshaler interface
< // and is not a nil pointer, Marshal calls its MarshalJSON method
< // to produce JSON.  The nil pointer exception is not strictly necessary
< // but mimics a similar, necessary exception in the behavior of
< // UnmarshalJSON.
< //
< // Otherwise, Marshal uses the following type-dependent default encodings:
< //
< // Boolean values encode as JSON booleans.
< //
< // Floating point, integer, and Number values encode as JSON numbers.
< //
< // String values encode as JSON strings coerced to valid UTF-8,
< // replacing invalid bytes with the Unicode replacement rune.
< // The angle brackets "<" and ">" are escaped to "\u003c" and "\u003e"
< // to keep some browsers from misinterpreting JSON output as HTML.
< // Ampersand "&" is also escaped to "\u0026" for the same reason.
< //
< // Array and slice values encode as JSON arrays, except that
< // []byte encodes as a base64-encoded string, and a nil slice
< // encodes as the null JSON object.
< //
< // Struct values encode as JSON objects. Each exported struct field
< // becomes a member of the object unless
< //   - the field's tag is "-", or
< //   - the field is empty and its tag specifies the "omitempty" option.
< // The empty values are false, 0, any
< // nil pointer or interface value, and any array, slice, map, or string of
< // length zero. The object's default key string is the struct field name
< // but can be specified in the struct field's tag value. The "json" key in
< // the struct field's tag value is the key name, followed by an optional comma
< // and options. Examples:
< //
< //   // Field is ignored by this package.
< //   Field int `json:"-"`
< //
< //   // Field appears in JSON as key "myName".
< //   Field int `json:"myName"`
< //
< //   // Field appears in JSON as key "myName" and
< //   // the field is omitted from the object if its value is empty,
< //   // as defined above.
< //   Field int `json:"myName,omitempty"`
< //
< //   // Field appears in JSON as key "Field" (the default), but
< //   // the field is skipped if empty.
< //   // Note the leading comma.
< //   Field int `json:",omitempty"`
< //
< // The "string" option signals that a field is stored as JSON inside a
< // JSON-encoded string. It applies only to fields of string, floating point,
< // integer, or boolean types. This extra level of encoding is sometimes used
< // when communicating with JavaScript programs:
< //
< //    Int64String int64 `json:",string"`
< //
< // The key name will be used if it's a non-empty string consisting of
< // only Unicode letters, digits, dollar signs, percent signs, hyphens,
< // underscores and slashes.
< //
< // Anonymous struct fields are usually marshaled as if their inner exported fields
< // were fields in the outer struct, subject to the usual Go visibility rules amended
< // as described in the next paragraph.
< // An anonymous struct field with a name given in its JSON tag is treated as
< // having that name, rather than being anonymous.
< // An anonymous struct field of interface type is treated the same as having
< // that type as its name, rather than being anonymous.
< //
< // The Go visibility rules for struct fields are amended for JSON when
< // deciding which field to marshal or unmarshal. If there are
< // multiple fields at the same level, and that level is the least
< // nested (and would therefore be the nesting level selected by the
< // usual Go rules), the following extra rules apply:
< //
< // 1) Of those fields, if any are JSON-tagged, only tagged fields are considered,
< // even if there are multiple untagged fields that would otherwise conflict.
< // 2) If there is exactly one field (tagged or not according to the first rule), that is selected.
< // 3) Otherwise there are multiple fields, and all are ignored; no error occurs.
< //
< // Handling of anonymous struct fields is new in Go 1.1.
< // Prior to Go 1.1, anonymous struct fields were ignored. To force ignoring of
< // an anonymous struct field in both current and earlier versions, give the field
< // a JSON tag of "-".
< //
< // Map values encode as JSON objects.
< // The map's key type must be string; the map keys are used as JSON object
< // keys, subject to the UTF-8 coercion described for string values above.
< //
< // Pointer values encode as the value pointed to.
< // A nil pointer encodes as the null JSON object.
< //
< // Interface values encode as the value contained in the interface.
< // A nil interface value encodes as the null JSON object.
< //
< // Channel, complex, and function values cannot be encoded in JSON.
< // Attempting to encode such a value causes Marshal to return
< // an UnsupportedTypeError.
< //
< // JSON cannot represent cyclic data structures and Marshal does not
< // handle them.  Passing cyclic structures to Marshal will result in
< // an infinite recursion.
< //
< func Marshal(v interface{}) ([]byte, error) {
< 	e := &encodeState{}
< 	err := e.marshal(v)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return e.Bytes(), nil
< }
< 
< // MarshalIndent is like Marshal but applies Indent to format the output.
< func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {
< 	b, err := Marshal(v)
< 	if err != nil {
< 		return nil, err
< 	}
< 	var buf bytes.Buffer
< 	err = Indent(&buf, b, prefix, indent)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return buf.Bytes(), nil
< }
< 
< // HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029
< // characters inside string literals changed to \u003c, \u003e, \u0026, \u2028, \u2029
< // so that the JSON will be safe to embed inside HTML <script> tags.
< // For historical reasons, web browsers don't honor standard HTML
< // escaping within <script> tags, so an alternative JSON encoding must
< // be used.
< func HTMLEscape(dst *bytes.Buffer, src []byte) {
< 	// The characters can only appear in string literals,
< 	// so just scan the string one byte at a time.
< 	start := 0
< 	for i, c := range src {
< 		if c == '<' || c == '>' || c == '&' {
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			dst.WriteString(`\u00`)
< 			dst.WriteByte(hex[c>>4])
< 			dst.WriteByte(hex[c&0xF])
< 			start = i + 1
< 		}
< 		// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
< 		if c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			dst.WriteString(`\u202`)
< 			dst.WriteByte(hex[src[i+2]&0xF])
< 			start = i + 3
< 		}
< 	}
< 	if start < len(src) {
< 		dst.Write(src[start:])
< 	}
< }
< 
< // Marshaler is the interface implemented by objects that
< // can marshal themselves into valid JSON.
< type Marshaler interface {
< 	MarshalJSON() ([]byte, error)
< }
< 
< // An UnsupportedTypeError is returned by Marshal when attempting
< // to encode an unsupported value type.
< type UnsupportedTypeError struct {
< 	Type reflect.Type
< }
< 
< func (e *UnsupportedTypeError) Error() string {
< 	return "json: unsupported type: " + e.Type.String()
< }
< 
< type UnsupportedValueError struct {
< 	Value reflect.Value
< 	Str   string
< }
< 
< func (e *UnsupportedValueError) Error() string {
< 	return "json: unsupported value: " + e.Str
< }
< 
< // Before Go 1.2, an InvalidUTF8Error was returned by Marshal when
< // attempting to encode a string value with invalid UTF-8 sequences.
< // As of Go 1.2, Marshal instead coerces the string to valid UTF-8 by
< // replacing invalid bytes with the Unicode replacement rune U+FFFD.
< // This error is no longer generated but is kept for backwards compatibility
< // with programs that might mention it.
< type InvalidUTF8Error struct {
< 	S string // the whole string value that caused the error
< }
< 
< func (e *InvalidUTF8Error) Error() string {
< 	return "json: invalid UTF-8 in string: " + strconv.Quote(e.S)
< }
< 
< type MarshalerError struct {
< 	Type reflect.Type
< 	Err  error
< }
< 
< func (e *MarshalerError) Error() string {
< 	return "json: error calling MarshalJSON for type " + e.Type.String() + ": " + e.Err.Error()
< }
< 
< var hex = "0123456789abcdef"
< 
< // An encodeState encodes JSON into a bytes.Buffer.
< type encodeState struct {
< 	bytes.Buffer // accumulated output
< 	scratch      [64]byte
< }
< 
< var encodeStatePool sync.Pool
< 
< func newEncodeState() *encodeState {
< 	if v := encodeStatePool.Get(); v != nil {
< 		e := v.(*encodeState)
< 		e.Reset()
< 		return e
< 	}
< 	return new(encodeState)
< }
< 
< func (e *encodeState) marshal(v interface{}) (err error) {
< 	defer func() {
< 		if r := recover(); r != nil {
< 			if _, ok := r.(runtime.Error); ok {
< 				panic(r)
< 			}
< 			if s, ok := r.(string); ok {
< 				panic(s)
< 			}
< 			err = r.(error)
< 		}
< 	}()
< 	e.reflectValue(reflect.ValueOf(v))
< 	return nil
< }
< 
< func (e *encodeState) error(err error) {
< 	panic(err)
< }
< 
< func isEmptyValue(v reflect.Value) bool {
< 	switch v.Kind() {
< 	case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
< 		return v.Len() == 0
< 	case reflect.Bool:
< 		return !v.Bool()
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return v.Int() == 0
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return v.Uint() == 0
< 	case reflect.Float32, reflect.Float64:
< 		return v.Float() == 0
< 	case reflect.Interface, reflect.Ptr:
< 		return v.IsNil()
< 	}
< 	return false
< }
< 
< func (e *encodeState) reflectValue(v reflect.Value) {
< 	valueEncoder(v)(e, v, false)
< }
< 
< type encoderFunc func(e *encodeState, v reflect.Value, quoted bool)
< 
< var encoderCache struct {
< 	sync.RWMutex
< 	m map[reflect.Type]encoderFunc
< }
< 
< func valueEncoder(v reflect.Value) encoderFunc {
< 	if !v.IsValid() {
< 		return invalidValueEncoder
< 	}
< 	return typeEncoder(v.Type())
< }
< 
< func typeEncoder(t reflect.Type) encoderFunc {
< 	encoderCache.RLock()
< 	f := encoderCache.m[t]
< 	encoderCache.RUnlock()
< 	if f != nil {
< 		return f
< 	}
< 
< 	// To deal with recursive types, populate the map with an
< 	// indirect func before we build it. This type waits on the
< 	// real func (f) to be ready and then calls it.  This indirect
< 	// func is only used for recursive types.
< 	encoderCache.Lock()
< 	if encoderCache.m == nil {
< 		encoderCache.m = make(map[reflect.Type]encoderFunc)
< 	}
< 	var wg sync.WaitGroup
< 	wg.Add(1)
< 	encoderCache.m[t] = func(e *encodeState, v reflect.Value, quoted bool) {
< 		wg.Wait()
< 		f(e, v, quoted)
< 	}
< 	encoderCache.Unlock()
< 
< 	// Compute fields without lock.
< 	// Might duplicate effort but won't hold other computations back.
< 	f = newTypeEncoder(t, true)
< 	wg.Done()
< 	encoderCache.Lock()
< 	encoderCache.m[t] = f
< 	encoderCache.Unlock()
< 	return f
< }
< 
< var (
< 	marshalerType     = reflect.TypeOf(new(Marshaler)).Elem()
< 	textMarshalerType = reflect.TypeOf(new(encoding.TextMarshaler)).Elem()
< )
< 
< // newTypeEncoder constructs an encoderFunc for a type.
< // The returned encoder only checks CanAddr when allowAddr is true.
< func newTypeEncoder(t reflect.Type, allowAddr bool) encoderFunc {
< 	if t.Implements(marshalerType) {
< 		return marshalerEncoder
< 	}
< 	if t.Kind() != reflect.Ptr && allowAddr {
< 		if reflect.PtrTo(t).Implements(marshalerType) {
< 			return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false))
< 		}
< 	}
< 
< 	if t.Implements(textMarshalerType) {
< 		return textMarshalerEncoder
< 	}
< 	if t.Kind() != reflect.Ptr && allowAddr {
< 		if reflect.PtrTo(t).Implements(textMarshalerType) {
< 			return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false))
< 		}
< 	}
< 
< 	switch t.Kind() {
< 	case reflect.Bool:
< 		return boolEncoder
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return intEncoder
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return uintEncoder
< 	case reflect.Float32:
< 		return float32Encoder
< 	case reflect.Float64:
< 		return float64Encoder
< 	case reflect.String:
< 		return stringEncoder
< 	case reflect.Interface:
< 		return interfaceEncoder
< 	case reflect.Struct:
< 		return newStructEncoder(t)
< 	case reflect.Map:
< 		return newMapEncoder(t)
< 	case reflect.Slice:
< 		return newSliceEncoder(t)
< 	case reflect.Array:
< 		return newArrayEncoder(t)
< 	case reflect.Ptr:
< 		return newPtrEncoder(t)
< 	default:
< 		return unsupportedTypeEncoder
< 	}
< }
< 
< func invalidValueEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	e.WriteString("null")
< }
< 
< func marshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	if v.Kind() == reflect.Ptr && v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	m := v.Interface().(Marshaler)
< 	b, err := m.MarshalJSON()
< 	if err == nil {
< 		// copy JSON into buffer, checking validity.
< 		err = compact(&e.Buffer, b, true)
< 	}
< 	if err != nil {
< 		e.error(&MarshalerError{v.Type(), err})
< 	}
< }
< 
< func addrMarshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	va := v.Addr()
< 	if va.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	m := va.Interface().(Marshaler)
< 	b, err := m.MarshalJSON()
< 	if err == nil {
< 		// copy JSON into buffer, checking validity.
< 		err = compact(&e.Buffer, b, true)
< 	}
< 	if err != nil {
< 		e.error(&MarshalerError{v.Type(), err})
< 	}
< }
< 
< func textMarshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	if v.Kind() == reflect.Ptr && v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	m := v.Interface().(encoding.TextMarshaler)
< 	b, err := m.MarshalText()
< 	if err == nil {
< 		_, err = e.stringBytes(b)
< 	}
< 	if err != nil {
< 		e.error(&MarshalerError{v.Type(), err})
< 	}
< }
< 
< func addrTextMarshalerEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	va := v.Addr()
< 	if va.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	m := va.Interface().(encoding.TextMarshaler)
< 	b, err := m.MarshalText()
< 	if err == nil {
< 		_, err = e.stringBytes(b)
< 	}
< 	if err != nil {
< 		e.error(&MarshalerError{v.Type(), err})
< 	}
< }
< 
< func boolEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	if quoted {
< 		e.WriteByte('"')
< 	}
< 	if v.Bool() {
< 		e.WriteString("true")
< 	} else {
< 		e.WriteString("false")
< 	}
< 	if quoted {
< 		e.WriteByte('"')
< 	}
< }
< 
< func intEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	b := strconv.AppendInt(e.scratch[:0], v.Int(), 10)
< 	if quoted {
< 		e.WriteByte('"')
< 	}
< 	e.Write(b)
< 	if quoted {
< 		e.WriteByte('"')
< 	}
< }
< 
< func uintEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	b := strconv.AppendUint(e.scratch[:0], v.Uint(), 10)
< 	if quoted {
< 		e.WriteByte('"')
< 	}
< 	e.Write(b)
< 	if quoted {
< 		e.WriteByte('"')
< 	}
< }
< 
< type floatEncoder int // number of bits
< 
< func (bits floatEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {
< 	f := v.Float()
< 	if math.IsInf(f, 0) || math.IsNaN(f) {
< 		e.error(&UnsupportedValueError{v, strconv.FormatFloat(f, 'g', -1, int(bits))})
< 	}
< 	b := strconv.AppendFloat(e.scratch[:0], f, 'g', -1, int(bits))
< 	if quoted {
< 		e.WriteByte('"')
< 	}
< 	e.Write(b)
< 	if quoted {
< 		e.WriteByte('"')
< 	}
< }
< 
< var (
< 	float32Encoder = (floatEncoder(32)).encode
< 	float64Encoder = (floatEncoder(64)).encode
< )
< 
< func stringEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	if v.Type() == numberType {
< 		numStr := v.String()
< 		if numStr == "" {
< 			numStr = "0" // Number's zero-val
< 		}
< 		e.WriteString(numStr)
< 		return
< 	}
< 	if quoted {
< 		sb, err := Marshal(v.String())
< 		if err != nil {
< 			e.error(err)
< 		}
< 		e.string(string(sb))
< 	} else {
< 		e.string(v.String())
< 	}
< }
< 
< func interfaceEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	e.reflectValue(v.Elem())
< }
< 
< func unsupportedTypeEncoder(e *encodeState, v reflect.Value, quoted bool) {
< 	e.error(&UnsupportedTypeError{v.Type()})
< }
< 
< type structEncoder struct {
< 	fields    []field
< 	fieldEncs []encoderFunc
< }
< 
< func (se *structEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {
< 	e.WriteByte('{')
< 	first := true
< 	for i, f := range se.fields {
< 		fv := fieldByIndex(v, f.index)
< 		if !fv.IsValid() || f.omitEmpty && isEmptyValue(fv) {
< 			continue
< 		}
< 		if first {
< 			first = false
< 		} else {
< 			e.WriteByte(',')
< 		}
< 		e.string(f.name)
< 		e.WriteByte(':')
< 		se.fieldEncs[i](e, fv, f.quoted)
< 	}
< 	e.WriteByte('}')
< }
< 
< func newStructEncoder(t reflect.Type) encoderFunc {
< 	fields := cachedTypeFields(t)
< 	se := &structEncoder{
< 		fields:    fields,
< 		fieldEncs: make([]encoderFunc, len(fields)),
< 	}
< 	for i, f := range fields {
< 		se.fieldEncs[i] = typeEncoder(typeByIndex(t, f.index))
< 	}
< 	return se.encode
< }
< 
< type mapEncoder struct {
< 	elemEnc encoderFunc
< }
< 
< func (me *mapEncoder) encode(e *encodeState, v reflect.Value, _ bool) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	e.WriteByte('{')
< 	var sv stringValues = v.MapKeys()
< 	sort.Sort(sv)
< 	for i, k := range sv {
< 		if i > 0 {
< 			e.WriteByte(',')
< 		}
< 		e.string(k.String())
< 		e.WriteByte(':')
< 		me.elemEnc(e, v.MapIndex(k), false)
< 	}
< 	e.WriteByte('}')
< }
< 
< func newMapEncoder(t reflect.Type) encoderFunc {
< 	if t.Key().Kind() != reflect.String {
< 		return unsupportedTypeEncoder
< 	}
< 	me := &mapEncoder{typeEncoder(t.Elem())}
< 	return me.encode
< }
< 
< func encodeByteSlice(e *encodeState, v reflect.Value, _ bool) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	s := v.Bytes()
< 	e.WriteByte('"')
< 	if len(s) < 1024 {
< 		// for small buffers, using Encode directly is much faster.
< 		dst := make([]byte, base64.StdEncoding.EncodedLen(len(s)))
< 		base64.StdEncoding.Encode(dst, s)
< 		e.Write(dst)
< 	} else {
< 		// for large buffers, avoid unnecessary extra temporary
< 		// buffer space.
< 		enc := base64.NewEncoder(base64.StdEncoding, e)
< 		enc.Write(s)
< 		enc.Close()
< 	}
< 	e.WriteByte('"')
< }
< 
< // sliceEncoder just wraps an arrayEncoder, checking to make sure the value isn't nil.
< type sliceEncoder struct {
< 	arrayEnc encoderFunc
< }
< 
< func (se *sliceEncoder) encode(e *encodeState, v reflect.Value, _ bool) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	se.arrayEnc(e, v, false)
< }
< 
< func newSliceEncoder(t reflect.Type) encoderFunc {
< 	// Byte slices get special treatment; arrays don't.
< 	if t.Elem().Kind() == reflect.Uint8 {
< 		return encodeByteSlice
< 	}
< 	enc := &sliceEncoder{newArrayEncoder(t)}
< 	return enc.encode
< }
< 
< type arrayEncoder struct {
< 	elemEnc encoderFunc
< }
< 
< func (ae *arrayEncoder) encode(e *encodeState, v reflect.Value, _ bool) {
< 	e.WriteByte('[')
< 	n := v.Len()
< 	for i := 0; i < n; i++ {
< 		if i > 0 {
< 			e.WriteByte(',')
< 		}
< 		ae.elemEnc(e, v.Index(i), false)
< 	}
< 	e.WriteByte(']')
< }
< 
< func newArrayEncoder(t reflect.Type) encoderFunc {
< 	enc := &arrayEncoder{typeEncoder(t.Elem())}
< 	return enc.encode
< }
< 
< type ptrEncoder struct {
< 	elemEnc encoderFunc
< }
< 
< func (pe *ptrEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {
< 	if v.IsNil() {
< 		e.WriteString("null")
< 		return
< 	}
< 	pe.elemEnc(e, v.Elem(), quoted)
< }
< 
< func newPtrEncoder(t reflect.Type) encoderFunc {
< 	enc := &ptrEncoder{typeEncoder(t.Elem())}
< 	return enc.encode
< }
< 
< type condAddrEncoder struct {
< 	canAddrEnc, elseEnc encoderFunc
< }
< 
< func (ce *condAddrEncoder) encode(e *encodeState, v reflect.Value, quoted bool) {
< 	if v.CanAddr() {
< 		ce.canAddrEnc(e, v, quoted)
< 	} else {
< 		ce.elseEnc(e, v, quoted)
< 	}
< }
< 
< // newCondAddrEncoder returns an encoder that checks whether its value
< // CanAddr and delegates to canAddrEnc if so, else to elseEnc.
< func newCondAddrEncoder(canAddrEnc, elseEnc encoderFunc) encoderFunc {
< 	enc := &condAddrEncoder{canAddrEnc: canAddrEnc, elseEnc: elseEnc}
< 	return enc.encode
< }
< 
< func isValidTag(s string) bool {
< 	if s == "" {
< 		return false
< 	}
< 	for _, c := range s {
< 		switch {
< 		case strings.ContainsRune("!#$%&()*+-./:<=>?@[]^_{|}~ ", c):
< 			// Backslash and quote chars are reserved, but
< 			// otherwise any punctuation chars are allowed
< 			// in a tag name.
< 		default:
< 			if !unicode.IsLetter(c) && !unicode.IsDigit(c) {
< 				return false
< 			}
< 		}
< 	}
< 	return true
< }
< 
< func fieldByIndex(v reflect.Value, index []int) reflect.Value {
< 	for _, i := range index {
< 		if v.Kind() == reflect.Ptr {
< 			if v.IsNil() {
< 				return reflect.Value{}
< 			}
< 			v = v.Elem()
< 		}
< 		v = v.Field(i)
< 	}
< 	return v
< }
< 
< func typeByIndex(t reflect.Type, index []int) reflect.Type {
< 	for _, i := range index {
< 		if t.Kind() == reflect.Ptr {
< 			t = t.Elem()
< 		}
< 		t = t.Field(i).Type
< 	}
< 	return t
< }
< 
< // stringValues is a slice of reflect.Value holding *reflect.StringValue.
< // It implements the methods to sort by string.
< type stringValues []reflect.Value
< 
< func (sv stringValues) Len() int           { return len(sv) }
< func (sv stringValues) Swap(i, j int)      { sv[i], sv[j] = sv[j], sv[i] }
< func (sv stringValues) Less(i, j int) bool { return sv.get(i) < sv.get(j) }
< func (sv stringValues) get(i int) string   { return sv[i].String() }
< 
< // NOTE: keep in sync with stringBytes below.
< func (e *encodeState) string(s string) (int, error) {
< 	len0 := e.Len()
< 	e.WriteByte('"')
< 	start := 0
< 	for i := 0; i < len(s); {
< 		if b := s[i]; b < utf8.RuneSelf {
< 			if 0x20 <= b && b != '\\' && b != '"' && b != '<' && b != '>' && b != '&' {
< 				i++
< 				continue
< 			}
< 			if start < i {
< 				e.WriteString(s[start:i])
< 			}
< 			switch b {
< 			case '\\', '"':
< 				e.WriteByte('\\')
< 				e.WriteByte(b)
< 			case '\n':
< 				e.WriteByte('\\')
< 				e.WriteByte('n')
< 			case '\r':
< 				e.WriteByte('\\')
< 				e.WriteByte('r')
< 			case '\t':
< 				e.WriteByte('\\')
< 				e.WriteByte('t')
< 			default:
< 				// This encodes bytes < 0x20 except for \n and \r,
< 				// as well as <, > and &. The latter are escaped because they
< 				// can lead to security holes when user-controlled strings
< 				// are rendered into JSON and served to some browsers.
< 				e.WriteString(`\u00`)
< 				e.WriteByte(hex[b>>4])
< 				e.WriteByte(hex[b&0xF])
< 			}
< 			i++
< 			start = i
< 			continue
< 		}
< 		c, size := utf8.DecodeRuneInString(s[i:])
< 		if c == utf8.RuneError && size == 1 {
< 			if start < i {
< 				e.WriteString(s[start:i])
< 			}
< 			e.WriteString(`\ufffd`)
< 			i += size
< 			start = i
< 			continue
< 		}
< 		// U+2028 is LINE SEPARATOR.
< 		// U+2029 is PARAGRAPH SEPARATOR.
< 		// They are both technically valid characters in JSON strings,
< 		// but don't work in JSONP, which has to be evaluated as JavaScript,
< 		// and can lead to security holes there. It is valid JSON to
< 		// escape them, so we do so unconditionally.
< 		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
< 		if c == '\u2028' || c == '\u2029' {
< 			if start < i {
< 				e.WriteString(s[start:i])
< 			}
< 			e.WriteString(`\u202`)
< 			e.WriteByte(hex[c&0xF])
< 			i += size
< 			start = i
< 			continue
< 		}
< 		i += size
< 	}
< 	if start < len(s) {
< 		e.WriteString(s[start:])
< 	}
< 	e.WriteByte('"')
< 	return e.Len() - len0, nil
< }
< 
< // NOTE: keep in sync with string above.
< func (e *encodeState) stringBytes(s []byte) (int, error) {
< 	len0 := e.Len()
< 	e.WriteByte('"')
< 	start := 0
< 	for i := 0; i < len(s); {
< 		if b := s[i]; b < utf8.RuneSelf {
< 			if 0x20 <= b && b != '\\' && b != '"' && b != '<' && b != '>' && b != '&' {
< 				i++
< 				continue
< 			}
< 			if start < i {
< 				e.Write(s[start:i])
< 			}
< 			switch b {
< 			case '\\', '"':
< 				e.WriteByte('\\')
< 				e.WriteByte(b)
< 			case '\n':
< 				e.WriteByte('\\')
< 				e.WriteByte('n')
< 			case '\r':
< 				e.WriteByte('\\')
< 				e.WriteByte('r')
< 			case '\t':
< 				e.WriteByte('\\')
< 				e.WriteByte('t')
< 			default:
< 				// This encodes bytes < 0x20 except for \n and \r,
< 				// as well as <, >, and &. The latter are escaped because they
< 				// can lead to security holes when user-controlled strings
< 				// are rendered into JSON and served to some browsers.
< 				e.WriteString(`\u00`)
< 				e.WriteByte(hex[b>>4])
< 				e.WriteByte(hex[b&0xF])
< 			}
< 			i++
< 			start = i
< 			continue
< 		}
< 		c, size := utf8.DecodeRune(s[i:])
< 		if c == utf8.RuneError && size == 1 {
< 			if start < i {
< 				e.Write(s[start:i])
< 			}
< 			e.WriteString(`\ufffd`)
< 			i += size
< 			start = i
< 			continue
< 		}
< 		// U+2028 is LINE SEPARATOR.
< 		// U+2029 is PARAGRAPH SEPARATOR.
< 		// They are both technically valid characters in JSON strings,
< 		// but don't work in JSONP, which has to be evaluated as JavaScript,
< 		// and can lead to security holes there. It is valid JSON to
< 		// escape them, so we do so unconditionally.
< 		// See http://timelessrepo.com/json-isnt-a-javascript-subset for discussion.
< 		if c == '\u2028' || c == '\u2029' {
< 			if start < i {
< 				e.Write(s[start:i])
< 			}
< 			e.WriteString(`\u202`)
< 			e.WriteByte(hex[c&0xF])
< 			i += size
< 			start = i
< 			continue
< 		}
< 		i += size
< 	}
< 	if start < len(s) {
< 		e.Write(s[start:])
< 	}
< 	e.WriteByte('"')
< 	return e.Len() - len0, nil
< }
< 
< // A field represents a single field found in a struct.
< type field struct {
< 	name      string
< 	nameBytes []byte                 // []byte(name)
< 	equalFold func(s, t []byte) bool // bytes.EqualFold or equivalent
< 
< 	tag       bool
< 	index     []int
< 	typ       reflect.Type
< 	omitEmpty bool
< 	quoted    bool
< }
< 
< func fillField(f field) field {
< 	f.nameBytes = []byte(f.name)
< 	f.equalFold = foldFunc(f.nameBytes)
< 	return f
< }
< 
< // byName sorts field by name, breaking ties with depth,
< // then breaking ties with "name came from json tag", then
< // breaking ties with index sequence.
< type byName []field
< 
< func (x byName) Len() int { return len(x) }
< 
< func (x byName) Swap(i, j int) { x[i], x[j] = x[j], x[i] }
< 
< func (x byName) Less(i, j int) bool {
< 	if x[i].name != x[j].name {
< 		return x[i].name < x[j].name
< 	}
< 	if len(x[i].index) != len(x[j].index) {
< 		return len(x[i].index) < len(x[j].index)
< 	}
< 	if x[i].tag != x[j].tag {
< 		return x[i].tag
< 	}
< 	return byIndex(x).Less(i, j)
< }
< 
< // byIndex sorts field by index sequence.
< type byIndex []field
< 
< func (x byIndex) Len() int { return len(x) }
< 
< func (x byIndex) Swap(i, j int) { x[i], x[j] = x[j], x[i] }
< 
< func (x byIndex) Less(i, j int) bool {
< 	for k, xik := range x[i].index {
< 		if k >= len(x[j].index) {
< 			return false
< 		}
< 		if xik != x[j].index[k] {
< 			return xik < x[j].index[k]
< 		}
< 	}
< 	return len(x[i].index) < len(x[j].index)
< }
< 
< // typeFields returns a list of fields that JSON should recognize for the given type.
< // The algorithm is breadth-first search over the set of structs to include - the top struct
< // and then any reachable anonymous structs.
< func typeFields(t reflect.Type) []field {
< 	// Anonymous fields to explore at the current level and the next.
< 	current := []field{}
< 	next := []field{{typ: t}}
< 
< 	// Count of queued names for current level and the next.
< 	count := map[reflect.Type]int{}
< 	nextCount := map[reflect.Type]int{}
< 
< 	// Types already visited at an earlier level.
< 	visited := map[reflect.Type]bool{}
< 
< 	// Fields found.
< 	var fields []field
< 
< 	for len(next) > 0 {
< 		current, next = next, current[:0]
< 		count, nextCount = nextCount, map[reflect.Type]int{}
< 
< 		for _, f := range current {
< 			if visited[f.typ] {
< 				continue
< 			}
< 			visited[f.typ] = true
< 
< 			// Scan f.typ for fields to include.
< 			for i := 0; i < f.typ.NumField(); i++ {
< 				sf := f.typ.Field(i)
< 				if sf.PkgPath != "" { // unexported
< 					continue
< 				}
< 				tag := sf.Tag.Get("json")
< 				if tag == "-" {
< 					continue
< 				}
< 				name, opts := parseTag(tag)
< 				if !isValidTag(name) {
< 					name = ""
< 				}
< 				index := make([]int, len(f.index)+1)
< 				copy(index, f.index)
< 				index[len(f.index)] = i
< 
< 				ft := sf.Type
< 				if ft.Name() == "" && ft.Kind() == reflect.Ptr {
< 					// Follow pointer.
< 					ft = ft.Elem()
< 				}
< 
< 				// Only strings, floats, integers, and booleans can be quoted.
< 				quoted := false
< 				if opts.Contains("string") {
< 					switch ft.Kind() {
< 					case reflect.Bool,
< 						reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
< 						reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64,
< 						reflect.Float32, reflect.Float64,
< 						reflect.String:
< 						quoted = true
< 					}
< 				}
< 
< 				// Record found field and index sequence.
< 				if name != "" || !sf.Anonymous || ft.Kind() != reflect.Struct {
< 					tagged := name != ""
< 					if name == "" {
< 						name = sf.Name
< 					}
< 					fields = append(fields, fillField(field{
< 						name:      name,
< 						tag:       tagged,
< 						index:     index,
< 						typ:       ft,
< 						omitEmpty: opts.Contains("omitempty"),
< 						quoted:    quoted,
< 					}))
< 					if count[f.typ] > 1 {
< 						// If there were multiple instances, add a second,
< 						// so that the annihilation code will see a duplicate.
< 						// It only cares about the distinction between 1 or 2,
< 						// so don't bother generating any more copies.
< 						fields = append(fields, fields[len(fields)-1])
< 					}
< 					continue
< 				}
< 
< 				// Record new anonymous struct to explore in next round.
< 				nextCount[ft]++
< 				if nextCount[ft] == 1 {
< 					next = append(next, fillField(field{name: ft.Name(), index: index, typ: ft}))
< 				}
< 			}
< 		}
< 	}
< 
< 	sort.Sort(byName(fields))
< 
< 	// Delete all fields that are hidden by the Go rules for embedded fields,
< 	// except that fields with JSON tags are promoted.
< 
< 	// The fields are sorted in primary order of name, secondary order
< 	// of field index length. Loop over names; for each name, delete
< 	// hidden fields by choosing the one dominant field that survives.
< 	out := fields[:0]
< 	for advance, i := 0, 0; i < len(fields); i += advance {
< 		// One iteration per name.
< 		// Find the sequence of fields with the name of this first field.
< 		fi := fields[i]
< 		name := fi.name
< 		for advance = 1; i+advance < len(fields); advance++ {
< 			fj := fields[i+advance]
< 			if fj.name != name {
< 				break
< 			}
< 		}
< 		if advance == 1 { // Only one field with this name
< 			out = append(out, fi)
< 			continue
< 		}
< 		dominant, ok := dominantField(fields[i : i+advance])
< 		if ok {
< 			out = append(out, dominant)
< 		}
< 	}
< 
< 	fields = out
< 	sort.Sort(byIndex(fields))
< 
< 	return fields
< }
< 
< // dominantField looks through the fields, all of which are known to
< // have the same name, to find the single field that dominates the
< // others using Go's embedding rules, modified by the presence of
< // JSON tags. If there are multiple top-level fields, the boolean
< // will be false: This condition is an error in Go and we skip all
< // the fields.
< func dominantField(fields []field) (field, bool) {
< 	// The fields are sorted in increasing index-length order. The winner
< 	// must therefore be one with the shortest index length. Drop all
< 	// longer entries, which is easy: just truncate the slice.
< 	length := len(fields[0].index)
< 	tagged := -1 // Index of first tagged field.
< 	for i, f := range fields {
< 		if len(f.index) > length {
< 			fields = fields[:i]
< 			break
< 		}
< 		if f.tag {
< 			if tagged >= 0 {
< 				// Multiple tagged fields at the same level: conflict.
< 				// Return no field.
< 				return field{}, false
< 			}
< 			tagged = i
< 		}
< 	}
< 	if tagged >= 0 {
< 		return fields[tagged], true
< 	}
< 	// All remaining fields have the same length. If there's more than one,
< 	// we have a conflict (two fields named "X" at the same level) and we
< 	// return no field.
< 	if len(fields) > 1 {
< 		return field{}, false
< 	}
< 	return fields[0], true
< }
< 
< var fieldCache struct {
< 	sync.RWMutex
< 	m map[reflect.Type][]field
< }
< 
< // cachedTypeFields is like typeFields but uses a cache to avoid repeated work.
< func cachedTypeFields(t reflect.Type) []field {
< 	fieldCache.RLock()
< 	f := fieldCache.m[t]
< 	fieldCache.RUnlock()
< 	if f != nil {
< 		return f
< 	}
< 
< 	// Compute fields without lock.
< 	// Might duplicate effort but won't hold other computations back.
< 	f = typeFields(t)
< 	if f == nil {
< 		f = []field{}
< 	}
< 
< 	fieldCache.Lock()
< 	if fieldCache.m == nil {
< 		fieldCache.m = map[reflect.Type][]field{}
< 	}
< 	fieldCache.m[t] = f
< 	fieldCache.Unlock()
< 	return f
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/fold.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/fold.go
1,143d0
< // Copyright 2013 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< import (
< 	"bytes"
< 	"unicode/utf8"
< )
< 
< const (
< 	caseMask     = ^byte(0x20) // Mask to ignore case in ASCII.
< 	kelvin       = '\u212a'
< 	smallLongEss = '\u017f'
< )
< 
< // foldFunc returns one of four different case folding equivalence
< // functions, from most general (and slow) to fastest:
< //
< // 1) bytes.EqualFold, if the key s contains any non-ASCII UTF-8
< // 2) equalFoldRight, if s contains special folding ASCII ('k', 'K', 's', 'S')
< // 3) asciiEqualFold, no special, but includes non-letters (including _)
< // 4) simpleLetterEqualFold, no specials, no non-letters.
< //
< // The letters S and K are special because they map to 3 runes, not just 2:
< //  * S maps to s and to U+017F 'ſ' Latin small letter long s
< //  * k maps to K and to U+212A 'K' Kelvin sign
< // See https://play.golang.org/p/tTxjOc0OGo
< //
< // The returned function is specialized for matching against s and
< // should only be given s. It's not curried for performance reasons.
< func foldFunc(s []byte) func(s, t []byte) bool {
< 	nonLetter := false
< 	special := false // special letter
< 	for _, b := range s {
< 		if b >= utf8.RuneSelf {
< 			return bytes.EqualFold
< 		}
< 		upper := b & caseMask
< 		if upper < 'A' || upper > 'Z' {
< 			nonLetter = true
< 		} else if upper == 'K' || upper == 'S' {
< 			// See above for why these letters are special.
< 			special = true
< 		}
< 	}
< 	if special {
< 		return equalFoldRight
< 	}
< 	if nonLetter {
< 		return asciiEqualFold
< 	}
< 	return simpleLetterEqualFold
< }
< 
< // equalFoldRight is a specialization of bytes.EqualFold when s is
< // known to be all ASCII (including punctuation), but contains an 's',
< // 'S', 'k', or 'K', requiring a Unicode fold on the bytes in t.
< // See comments on foldFunc.
< func equalFoldRight(s, t []byte) bool {
< 	for _, sb := range s {
< 		if len(t) == 0 {
< 			return false
< 		}
< 		tb := t[0]
< 		if tb < utf8.RuneSelf {
< 			if sb != tb {
< 				sbUpper := sb & caseMask
< 				if 'A' <= sbUpper && sbUpper <= 'Z' {
< 					if sbUpper != tb&caseMask {
< 						return false
< 					}
< 				} else {
< 					return false
< 				}
< 			}
< 			t = t[1:]
< 			continue
< 		}
< 		// sb is ASCII and t is not. t must be either kelvin
< 		// sign or long s; sb must be s, S, k, or K.
< 		tr, size := utf8.DecodeRune(t)
< 		switch sb {
< 		case 's', 'S':
< 			if tr != smallLongEss {
< 				return false
< 			}
< 		case 'k', 'K':
< 			if tr != kelvin {
< 				return false
< 			}
< 		default:
< 			return false
< 		}
< 		t = t[size:]
< 
< 	}
< 	if len(t) > 0 {
< 		return false
< 	}
< 	return true
< }
< 
< // asciiEqualFold is a specialization of bytes.EqualFold for use when
< // s is all ASCII (but may contain non-letters) and contains no
< // special-folding letters.
< // See comments on foldFunc.
< func asciiEqualFold(s, t []byte) bool {
< 	if len(s) != len(t) {
< 		return false
< 	}
< 	for i, sb := range s {
< 		tb := t[i]
< 		if sb == tb {
< 			continue
< 		}
< 		if ('a' <= sb && sb <= 'z') || ('A' <= sb && sb <= 'Z') {
< 			if sb&caseMask != tb&caseMask {
< 				return false
< 			}
< 		} else {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< // simpleLetterEqualFold is a specialization of bytes.EqualFold for
< // use when s is all ASCII letters (no underscores, etc) and also
< // doesn't contain 'k', 'K', 's', or 'S'.
< // See comments on foldFunc.
< func simpleLetterEqualFold(s, t []byte) bool {
< 	if len(s) != len(t) {
< 		return false
< 	}
< 	for i, b := range s {
< 		if b&caseMask != t[i]&caseMask {
< 			return false
< 		}
< 	}
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/indent.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/indent.go
1,137d0
< // Copyright 2010 The Go Authors.  All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< import "bytes"
< 
< // Compact appends to dst the JSON-encoded src with
< // insignificant space characters elided.
< func Compact(dst *bytes.Buffer, src []byte) error {
< 	return compact(dst, src, false)
< }
< 
< func compact(dst *bytes.Buffer, src []byte, escape bool) error {
< 	origLen := dst.Len()
< 	var scan scanner
< 	scan.reset()
< 	start := 0
< 	for i, c := range src {
< 		if escape && (c == '<' || c == '>' || c == '&') {
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			dst.WriteString(`\u00`)
< 			dst.WriteByte(hex[c>>4])
< 			dst.WriteByte(hex[c&0xF])
< 			start = i + 1
< 		}
< 		// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
< 		if c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			dst.WriteString(`\u202`)
< 			dst.WriteByte(hex[src[i+2]&0xF])
< 			start = i + 3
< 		}
< 		v := scan.step(&scan, int(c))
< 		if v >= scanSkipSpace {
< 			if v == scanError {
< 				break
< 			}
< 			if start < i {
< 				dst.Write(src[start:i])
< 			}
< 			start = i + 1
< 		}
< 	}
< 	if scan.eof() == scanError {
< 		dst.Truncate(origLen)
< 		return scan.err
< 	}
< 	if start < len(src) {
< 		dst.Write(src[start:])
< 	}
< 	return nil
< }
< 
< func newline(dst *bytes.Buffer, prefix, indent string, depth int) {
< 	dst.WriteByte('\n')
< 	dst.WriteString(prefix)
< 	for i := 0; i < depth; i++ {
< 		dst.WriteString(indent)
< 	}
< }
< 
< // Indent appends to dst an indented form of the JSON-encoded src.
< // Each element in a JSON object or array begins on a new,
< // indented line beginning with prefix followed by one or more
< // copies of indent according to the indentation nesting.
< // The data appended to dst does not begin with the prefix nor
< // any indentation, and has no trailing newline, to make it
< // easier to embed inside other formatted JSON data.
< func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error {
< 	origLen := dst.Len()
< 	var scan scanner
< 	scan.reset()
< 	needIndent := false
< 	depth := 0
< 	for _, c := range src {
< 		scan.bytes++
< 		v := scan.step(&scan, int(c))
< 		if v == scanSkipSpace {
< 			continue
< 		}
< 		if v == scanError {
< 			break
< 		}
< 		if needIndent && v != scanEndObject && v != scanEndArray {
< 			needIndent = false
< 			depth++
< 			newline(dst, prefix, indent, depth)
< 		}
< 
< 		// Emit semantically uninteresting bytes
< 		// (in particular, punctuation in strings) unmodified.
< 		if v == scanContinue {
< 			dst.WriteByte(c)
< 			continue
< 		}
< 
< 		// Add spacing around real punctuation.
< 		switch c {
< 		case '{', '[':
< 			// delay indent so that empty object and array are formatted as {} and [].
< 			needIndent = true
< 			dst.WriteByte(c)
< 
< 		case ',':
< 			dst.WriteByte(c)
< 			newline(dst, prefix, indent, depth)
< 
< 		case ':':
< 			dst.WriteByte(c)
< 			dst.WriteByte(' ')
< 
< 		case '}', ']':
< 			if needIndent {
< 				// suppress indent in empty object/array
< 				needIndent = false
< 			} else {
< 				depth--
< 				newline(dst, prefix, indent, depth)
< 			}
< 			dst.WriteByte(c)
< 
< 		default:
< 			dst.WriteByte(c)
< 		}
< 	}
< 	if scan.eof() == scanError {
< 		dst.Truncate(origLen)
< 		return scan.err
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/scanner.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/scanner.go
1,630d0
< // Copyright 2010 The Go Authors.  All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< // JSON value parser state machine.
< // Just about at the limit of what is reasonable to write by hand.
< // Some parts are a bit tedious, but overall it nicely factors out the
< // otherwise common code from the multiple scanning functions
< // in this package (Compact, Indent, checkValid, nextValue, etc).
< //
< // This file starts with two simple examples using the scanner
< // before diving into the scanner itself.
< 
< import "strconv"
< 
< // checkValid verifies that data is valid JSON-encoded data.
< // scan is passed in for use by checkValid to avoid an allocation.
< func checkValid(data []byte, scan *scanner) error {
< 	scan.reset()
< 	for _, c := range data {
< 		scan.bytes++
< 		if scan.step(scan, int(c)) == scanError {
< 			return scan.err
< 		}
< 	}
< 	if scan.eof() == scanError {
< 		return scan.err
< 	}
< 	return nil
< }
< 
< // nextValue splits data after the next whole JSON value,
< // returning that value and the bytes that follow it as separate slices.
< // scan is passed in for use by nextValue to avoid an allocation.
< func nextValue(data []byte, scan *scanner) (value, rest []byte, err error) {
< 	scan.reset()
< 	for i, c := range data {
< 		v := scan.step(scan, int(c))
< 		if v >= scanEndObject {
< 			switch v {
< 			// probe the scanner with a space to determine whether we will
< 			// get scanEnd on the next character. Otherwise, if the next character
< 			// is not a space, scanEndTop allocates a needless error.
< 			case scanEndObject, scanEndArray:
< 				if scan.step(scan, ' ') == scanEnd {
< 					return data[:i+1], data[i+1:], nil
< 				}
< 			case scanError:
< 				return nil, nil, scan.err
< 			case scanEnd:
< 				return data[0:i], data[i:], nil
< 			}
< 		}
< 	}
< 	if scan.eof() == scanError {
< 		return nil, nil, scan.err
< 	}
< 	return data, nil, nil
< }
< 
< // A SyntaxError is a description of a JSON syntax error.
< type SyntaxError struct {
< 	msg    string // description of error
< 	Offset int64  // error occurred after reading Offset bytes
< }
< 
< func (e *SyntaxError) Error() string { return e.msg }
< 
< // A scanner is a JSON scanning state machine.
< // Callers call scan.reset() and then pass bytes in one at a time
< // by calling scan.step(&scan, c) for each byte.
< // The return value, referred to as an opcode, tells the
< // caller about significant parsing events like beginning
< // and ending literals, objects, and arrays, so that the
< // caller can follow along if it wishes.
< // The return value scanEnd indicates that a single top-level
< // JSON value has been completed, *before* the byte that
< // just got passed in.  (The indication must be delayed in order
< // to recognize the end of numbers: is 123 a whole value or
< // the beginning of 12345e+6?).
< type scanner struct {
< 	// The step is a func to be called to execute the next transition.
< 	// Also tried using an integer constant and a single func
< 	// with a switch, but using the func directly was 10% faster
< 	// on a 64-bit Mac Mini, and it's nicer to read.
< 	step func(*scanner, int) int
< 
< 	// Reached end of top-level value.
< 	endTop bool
< 
< 	// Stack of what we're in the middle of - array values, object keys, object values.
< 	parseState []int
< 
< 	// Error that happened, if any.
< 	err error
< 
< 	// 1-byte redo (see undo method)
< 	redo      bool
< 	redoCode  int
< 	redoState func(*scanner, int) int
< 
< 	// total bytes consumed, updated by decoder.Decode
< 	bytes int64
< }
< 
< // These values are returned by the state transition functions
< // assigned to scanner.state and the method scanner.eof.
< // They give details about the current state of the scan that
< // callers might be interested to know about.
< // It is okay to ignore the return value of any particular
< // call to scanner.state: if one call returns scanError,
< // every subsequent call will return scanError too.
< const (
< 	// Continue.
< 	scanContinue     = iota // uninteresting byte
< 	scanBeginLiteral        // end implied by next result != scanContinue
< 	scanBeginObject         // begin object
< 	scanObjectKey           // just finished object key (string)
< 	scanObjectValue         // just finished non-last object value
< 	scanEndObject           // end object (implies scanObjectValue if possible)
< 	scanBeginArray          // begin array
< 	scanArrayValue          // just finished array value
< 	scanEndArray            // end array (implies scanArrayValue if possible)
< 	scanSkipSpace           // space byte; can skip; known to be last "continue" result
< 
< 	// Stop.
< 	scanEnd   // top-level value ended *before* this byte; known to be first "stop" result
< 	scanError // hit an error, scanner.err.
< )
< 
< // These values are stored in the parseState stack.
< // They give the current state of a composite value
< // being scanned.  If the parser is inside a nested value
< // the parseState describes the nested state, outermost at entry 0.
< const (
< 	parseObjectKey   = iota // parsing object key (before colon)
< 	parseObjectValue        // parsing object value (after colon)
< 	parseArrayValue         // parsing array value
< )
< 
< // reset prepares the scanner for use.
< // It must be called before calling s.step.
< func (s *scanner) reset() {
< 	s.step = stateBeginValue
< 	s.parseState = s.parseState[0:0]
< 	s.err = nil
< 	s.redo = false
< 	s.endTop = false
< }
< 
< // eof tells the scanner that the end of input has been reached.
< // It returns a scan status just as s.step does.
< func (s *scanner) eof() int {
< 	if s.err != nil {
< 		return scanError
< 	}
< 	if s.endTop {
< 		return scanEnd
< 	}
< 	s.step(s, ' ')
< 	if s.endTop {
< 		return scanEnd
< 	}
< 	if s.err == nil {
< 		s.err = &SyntaxError{"unexpected end of JSON input", s.bytes}
< 	}
< 	return scanError
< }
< 
< // pushParseState pushes a new parse state p onto the parse stack.
< func (s *scanner) pushParseState(p int) {
< 	s.parseState = append(s.parseState, p)
< }
< 
< // popParseState pops a parse state (already obtained) off the stack
< // and updates s.step accordingly.
< func (s *scanner) popParseState() {
< 	n := len(s.parseState) - 1
< 	s.parseState = s.parseState[0:n]
< 	s.redo = false
< 	if n == 0 {
< 		s.step = stateEndTop
< 		s.endTop = true
< 	} else {
< 		s.step = stateEndValue
< 	}
< }
< 
< func isSpace(c rune) bool {
< 	return c == ' ' || c == '\t' || c == '\r' || c == '\n'
< }
< 
< // stateBeginValueOrEmpty is the state after reading `[`.
< func stateBeginValueOrEmpty(s *scanner, c int) int {
< 	if c <= ' ' && isSpace(rune(c)) {
< 		return scanSkipSpace
< 	}
< 	if c == ']' {
< 		return stateEndValue(s, c)
< 	}
< 	return stateBeginValue(s, c)
< }
< 
< // stateBeginValue is the state at the beginning of the input.
< func stateBeginValue(s *scanner, c int) int {
< 	if c <= ' ' && isSpace(rune(c)) {
< 		return scanSkipSpace
< 	}
< 	switch c {
< 	case '{':
< 		s.step = stateBeginStringOrEmpty
< 		s.pushParseState(parseObjectKey)
< 		return scanBeginObject
< 	case '[':
< 		s.step = stateBeginValueOrEmpty
< 		s.pushParseState(parseArrayValue)
< 		return scanBeginArray
< 	case '"':
< 		s.step = stateInString
< 		return scanBeginLiteral
< 	case '-':
< 		s.step = stateNeg
< 		return scanBeginLiteral
< 	case '0': // beginning of 0.123
< 		s.step = state0
< 		return scanBeginLiteral
< 	case 't': // beginning of true
< 		s.step = stateT
< 		return scanBeginLiteral
< 	case 'f': // beginning of false
< 		s.step = stateF
< 		return scanBeginLiteral
< 	case 'n': // beginning of null
< 		s.step = stateN
< 		return scanBeginLiteral
< 	}
< 	if '1' <= c && c <= '9' { // beginning of 1234.5
< 		s.step = state1
< 		return scanBeginLiteral
< 	}
< 	return s.error(c, "looking for beginning of value")
< }
< 
< // stateBeginStringOrEmpty is the state after reading `{`.
< func stateBeginStringOrEmpty(s *scanner, c int) int {
< 	if c <= ' ' && isSpace(rune(c)) {
< 		return scanSkipSpace
< 	}
< 	if c == '}' {
< 		n := len(s.parseState)
< 		s.parseState[n-1] = parseObjectValue
< 		return stateEndValue(s, c)
< 	}
< 	return stateBeginString(s, c)
< }
< 
< // stateBeginString is the state after reading `{"key": value,`.
< func stateBeginString(s *scanner, c int) int {
< 	if c <= ' ' && isSpace(rune(c)) {
< 		return scanSkipSpace
< 	}
< 	if c == '"' {
< 		s.step = stateInString
< 		return scanBeginLiteral
< 	}
< 	return s.error(c, "looking for beginning of object key string")
< }
< 
< // stateEndValue is the state after completing a value,
< // such as after reading `{}` or `true` or `["x"`.
< func stateEndValue(s *scanner, c int) int {
< 	n := len(s.parseState)
< 	if n == 0 {
< 		// Completed top-level before the current byte.
< 		s.step = stateEndTop
< 		s.endTop = true
< 		return stateEndTop(s, c)
< 	}
< 	if c <= ' ' && isSpace(rune(c)) {
< 		s.step = stateEndValue
< 		return scanSkipSpace
< 	}
< 	ps := s.parseState[n-1]
< 	switch ps {
< 	case parseObjectKey:
< 		if c == ':' {
< 			s.parseState[n-1] = parseObjectValue
< 			s.step = stateBeginValue
< 			return scanObjectKey
< 		}
< 		return s.error(c, "after object key")
< 	case parseObjectValue:
< 		if c == ',' {
< 			s.parseState[n-1] = parseObjectKey
< 			s.step = stateBeginString
< 			return scanObjectValue
< 		}
< 		if c == '}' {
< 			s.popParseState()
< 			return scanEndObject
< 		}
< 		return s.error(c, "after object key:value pair")
< 	case parseArrayValue:
< 		if c == ',' {
< 			s.step = stateBeginValue
< 			return scanArrayValue
< 		}
< 		if c == ']' {
< 			s.popParseState()
< 			return scanEndArray
< 		}
< 		return s.error(c, "after array element")
< 	}
< 	return s.error(c, "")
< }
< 
< // stateEndTop is the state after finishing the top-level value,
< // such as after reading `{}` or `[1,2,3]`.
< // Only space characters should be seen now.
< func stateEndTop(s *scanner, c int) int {
< 	if c != ' ' && c != '\t' && c != '\r' && c != '\n' {
< 		// Complain about non-space byte on next call.
< 		s.error(c, "after top-level value")
< 	}
< 	return scanEnd
< }
< 
< // stateInString is the state after reading `"`.
< func stateInString(s *scanner, c int) int {
< 	if c == '"' {
< 		s.step = stateEndValue
< 		return scanContinue
< 	}
< 	if c == '\\' {
< 		s.step = stateInStringEsc
< 		return scanContinue
< 	}
< 	if c < 0x20 {
< 		return s.error(c, "in string literal")
< 	}
< 	return scanContinue
< }
< 
< // stateInStringEsc is the state after reading `"\` during a quoted string.
< func stateInStringEsc(s *scanner, c int) int {
< 	switch c {
< 	case 'b', 'f', 'n', 'r', 't', '\\', '/', '"':
< 		s.step = stateInString
< 		return scanContinue
< 	}
< 	if c == 'u' {
< 		s.step = stateInStringEscU
< 		return scanContinue
< 	}
< 	return s.error(c, "in string escape code")
< }
< 
< // stateInStringEscU is the state after reading `"\u` during a quoted string.
< func stateInStringEscU(s *scanner, c int) int {
< 	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
< 		s.step = stateInStringEscU1
< 		return scanContinue
< 	}
< 	// numbers
< 	return s.error(c, "in \\u hexadecimal character escape")
< }
< 
< // stateInStringEscU1 is the state after reading `"\u1` during a quoted string.
< func stateInStringEscU1(s *scanner, c int) int {
< 	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
< 		s.step = stateInStringEscU12
< 		return scanContinue
< 	}
< 	// numbers
< 	return s.error(c, "in \\u hexadecimal character escape")
< }
< 
< // stateInStringEscU12 is the state after reading `"\u12` during a quoted string.
< func stateInStringEscU12(s *scanner, c int) int {
< 	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
< 		s.step = stateInStringEscU123
< 		return scanContinue
< 	}
< 	// numbers
< 	return s.error(c, "in \\u hexadecimal character escape")
< }
< 
< // stateInStringEscU123 is the state after reading `"\u123` during a quoted string.
< func stateInStringEscU123(s *scanner, c int) int {
< 	if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
< 		s.step = stateInString
< 		return scanContinue
< 	}
< 	// numbers
< 	return s.error(c, "in \\u hexadecimal character escape")
< }
< 
< // stateNeg is the state after reading `-` during a number.
< func stateNeg(s *scanner, c int) int {
< 	if c == '0' {
< 		s.step = state0
< 		return scanContinue
< 	}
< 	if '1' <= c && c <= '9' {
< 		s.step = state1
< 		return scanContinue
< 	}
< 	return s.error(c, "in numeric literal")
< }
< 
< // state1 is the state after reading a non-zero integer during a number,
< // such as after reading `1` or `100` but not `0`.
< func state1(s *scanner, c int) int {
< 	if '0' <= c && c <= '9' {
< 		s.step = state1
< 		return scanContinue
< 	}
< 	return state0(s, c)
< }
< 
< // state0 is the state after reading `0` during a number.
< func state0(s *scanner, c int) int {
< 	if c == '.' {
< 		s.step = stateDot
< 		return scanContinue
< 	}
< 	if c == 'e' || c == 'E' {
< 		s.step = stateE
< 		return scanContinue
< 	}
< 	return stateEndValue(s, c)
< }
< 
< // stateDot is the state after reading the integer and decimal point in a number,
< // such as after reading `1.`.
< func stateDot(s *scanner, c int) int {
< 	if '0' <= c && c <= '9' {
< 		s.step = stateDot0
< 		return scanContinue
< 	}
< 	return s.error(c, "after decimal point in numeric literal")
< }
< 
< // stateDot0 is the state after reading the integer, decimal point, and subsequent
< // digits of a number, such as after reading `3.14`.
< func stateDot0(s *scanner, c int) int {
< 	if '0' <= c && c <= '9' {
< 		s.step = stateDot0
< 		return scanContinue
< 	}
< 	if c == 'e' || c == 'E' {
< 		s.step = stateE
< 		return scanContinue
< 	}
< 	return stateEndValue(s, c)
< }
< 
< // stateE is the state after reading the mantissa and e in a number,
< // such as after reading `314e` or `0.314e`.
< func stateE(s *scanner, c int) int {
< 	if c == '+' {
< 		s.step = stateESign
< 		return scanContinue
< 	}
< 	if c == '-' {
< 		s.step = stateESign
< 		return scanContinue
< 	}
< 	return stateESign(s, c)
< }
< 
< // stateESign is the state after reading the mantissa, e, and sign in a number,
< // such as after reading `314e-` or `0.314e+`.
< func stateESign(s *scanner, c int) int {
< 	if '0' <= c && c <= '9' {
< 		s.step = stateE0
< 		return scanContinue
< 	}
< 	return s.error(c, "in exponent of numeric literal")
< }
< 
< // stateE0 is the state after reading the mantissa, e, optional sign,
< // and at least one digit of the exponent in a number,
< // such as after reading `314e-2` or `0.314e+1` or `3.14e0`.
< func stateE0(s *scanner, c int) int {
< 	if '0' <= c && c <= '9' {
< 		s.step = stateE0
< 		return scanContinue
< 	}
< 	return stateEndValue(s, c)
< }
< 
< // stateT is the state after reading `t`.
< func stateT(s *scanner, c int) int {
< 	if c == 'r' {
< 		s.step = stateTr
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal true (expecting 'r')")
< }
< 
< // stateTr is the state after reading `tr`.
< func stateTr(s *scanner, c int) int {
< 	if c == 'u' {
< 		s.step = stateTru
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal true (expecting 'u')")
< }
< 
< // stateTru is the state after reading `tru`.
< func stateTru(s *scanner, c int) int {
< 	if c == 'e' {
< 		s.step = stateEndValue
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal true (expecting 'e')")
< }
< 
< // stateF is the state after reading `f`.
< func stateF(s *scanner, c int) int {
< 	if c == 'a' {
< 		s.step = stateFa
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal false (expecting 'a')")
< }
< 
< // stateFa is the state after reading `fa`.
< func stateFa(s *scanner, c int) int {
< 	if c == 'l' {
< 		s.step = stateFal
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal false (expecting 'l')")
< }
< 
< // stateFal is the state after reading `fal`.
< func stateFal(s *scanner, c int) int {
< 	if c == 's' {
< 		s.step = stateFals
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal false (expecting 's')")
< }
< 
< // stateFals is the state after reading `fals`.
< func stateFals(s *scanner, c int) int {
< 	if c == 'e' {
< 		s.step = stateEndValue
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal false (expecting 'e')")
< }
< 
< // stateN is the state after reading `n`.
< func stateN(s *scanner, c int) int {
< 	if c == 'u' {
< 		s.step = stateNu
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal null (expecting 'u')")
< }
< 
< // stateNu is the state after reading `nu`.
< func stateNu(s *scanner, c int) int {
< 	if c == 'l' {
< 		s.step = stateNul
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal null (expecting 'l')")
< }
< 
< // stateNul is the state after reading `nul`.
< func stateNul(s *scanner, c int) int {
< 	if c == 'l' {
< 		s.step = stateEndValue
< 		return scanContinue
< 	}
< 	return s.error(c, "in literal null (expecting 'l')")
< }
< 
< // stateError is the state after reaching a syntax error,
< // such as after reading `[1}` or `5.1.2`.
< func stateError(s *scanner, c int) int {
< 	return scanError
< }
< 
< // error records an error and switches to the error state.
< func (s *scanner) error(c int, context string) int {
< 	s.step = stateError
< 	s.err = &SyntaxError{"invalid character " + quoteChar(c) + " " + context, s.bytes}
< 	return scanError
< }
< 
< // quoteChar formats c as a quoted character literal
< func quoteChar(c int) string {
< 	// special cases - different from quoted strings
< 	if c == '\'' {
< 		return `'\''`
< 	}
< 	if c == '"' {
< 		return `'"'`
< 	}
< 
< 	// use quoted string with different quotation marks
< 	s := strconv.Quote(string(c))
< 	return "'" + s[1:len(s)-1] + "'"
< }
< 
< // undo causes the scanner to return scanCode from the next state transition.
< // This gives callers a simple 1-byte undo mechanism.
< func (s *scanner) undo(scanCode int) {
< 	if s.redo {
< 		panic("json: invalid use of scanner")
< 	}
< 	s.redoCode = scanCode
< 	s.redoState = s.step
< 	s.step = stateRedo
< 	s.redo = true
< }
< 
< // stateRedo helps implement the scanner's 1-byte undo.
< func stateRedo(s *scanner, c int) int {
< 	s.redo = false
< 	s.step = s.redoState
< 	return s.redoCode
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/stream.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/stream.go
1,480d0
< // Copyright 2010 The Go Authors.  All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< import (
< 	"bytes"
< 	"errors"
< 	"io"
< )
< 
< // A Decoder reads and decodes JSON objects from an input stream.
< type Decoder struct {
< 	r     io.Reader
< 	buf   []byte
< 	d     decodeState
< 	scanp int // start of unread data in buf
< 	scan  scanner
< 	err   error
< 
< 	tokenState int
< 	tokenStack []int
< }
< 
< // NewDecoder returns a new decoder that reads from r.
< //
< // The decoder introduces its own buffering and may
< // read data from r beyond the JSON values requested.
< func NewDecoder(r io.Reader) *Decoder {
< 	return &Decoder{r: r}
< }
< 
< // UseNumber causes the Decoder to unmarshal a number into an interface{} as a
< // Number instead of as a float64.
< func (dec *Decoder) UseNumber() { dec.d.useNumber = true }
< 
< // Decode reads the next JSON-encoded value from its
< // input and stores it in the value pointed to by v.
< //
< // See the documentation for Unmarshal for details about
< // the conversion of JSON into a Go value.
< func (dec *Decoder) Decode(v interface{}) error {
< 	if dec.err != nil {
< 		return dec.err
< 	}
< 
< 	if err := dec.tokenPrepareForDecode(); err != nil {
< 		return err
< 	}
< 
< 	if !dec.tokenValueAllowed() {
< 		return &SyntaxError{msg: "not at beginning of value"}
< 	}
< 
< 	// Read whole value into buffer.
< 	n, err := dec.readValue()
< 	if err != nil {
< 		return err
< 	}
< 	dec.d.init(dec.buf[dec.scanp : dec.scanp+n])
< 	dec.scanp += n
< 
< 	// Don't save err from unmarshal into dec.err:
< 	// the connection is still usable since we read a complete JSON
< 	// object from it before the error happened.
< 	err = dec.d.unmarshal(v)
< 
< 	// fixup token streaming state
< 	dec.tokenValueEnd()
< 
< 	return err
< }
< 
< // Buffered returns a reader of the data remaining in the Decoder's
< // buffer. The reader is valid until the next call to Decode.
< func (dec *Decoder) Buffered() io.Reader {
< 	return bytes.NewReader(dec.buf[dec.scanp:])
< }
< 
< // readValue reads a JSON value into dec.buf.
< // It returns the length of the encoding.
< func (dec *Decoder) readValue() (int, error) {
< 	dec.scan.reset()
< 
< 	scanp := dec.scanp
< 	var err error
< Input:
< 	for {
< 		// Look in the buffer for a new value.
< 		for i, c := range dec.buf[scanp:] {
< 			dec.scan.bytes++
< 			v := dec.scan.step(&dec.scan, int(c))
< 			if v == scanEnd {
< 				scanp += i
< 				break Input
< 			}
< 			// scanEnd is delayed one byte.
< 			// We might block trying to get that byte from src,
< 			// so instead invent a space byte.
< 			if (v == scanEndObject || v == scanEndArray) && dec.scan.step(&dec.scan, ' ') == scanEnd {
< 				scanp += i + 1
< 				break Input
< 			}
< 			if v == scanError {
< 				dec.err = dec.scan.err
< 				return 0, dec.scan.err
< 			}
< 		}
< 		scanp = len(dec.buf)
< 
< 		// Did the last read have an error?
< 		// Delayed until now to allow buffer scan.
< 		if err != nil {
< 			if err == io.EOF {
< 				if dec.scan.step(&dec.scan, ' ') == scanEnd {
< 					break Input
< 				}
< 				if nonSpace(dec.buf) {
< 					err = io.ErrUnexpectedEOF
< 				}
< 			}
< 			dec.err = err
< 			return 0, err
< 		}
< 
< 		n := scanp - dec.scanp
< 		err = dec.refill()
< 		scanp = dec.scanp + n
< 	}
< 	return scanp - dec.scanp, nil
< }
< 
< func (dec *Decoder) refill() error {
< 	// Make room to read more into the buffer.
< 	// First slide down data already consumed.
< 	if dec.scanp > 0 {
< 		n := copy(dec.buf, dec.buf[dec.scanp:])
< 		dec.buf = dec.buf[:n]
< 		dec.scanp = 0
< 	}
< 
< 	// Grow buffer if not large enough.
< 	const minRead = 512
< 	if cap(dec.buf)-len(dec.buf) < minRead {
< 		newBuf := make([]byte, len(dec.buf), 2*cap(dec.buf)+minRead)
< 		copy(newBuf, dec.buf)
< 		dec.buf = newBuf
< 	}
< 
< 	// Read.  Delay error for next iteration (after scan).
< 	n, err := dec.r.Read(dec.buf[len(dec.buf):cap(dec.buf)])
< 	dec.buf = dec.buf[0 : len(dec.buf)+n]
< 
< 	return err
< }
< 
< func nonSpace(b []byte) bool {
< 	for _, c := range b {
< 		if !isSpace(rune(c)) {
< 			return true
< 		}
< 	}
< 	return false
< }
< 
< // An Encoder writes JSON objects to an output stream.
< type Encoder struct {
< 	w   io.Writer
< 	err error
< }
< 
< // NewEncoder returns a new encoder that writes to w.
< func NewEncoder(w io.Writer) *Encoder {
< 	return &Encoder{w: w}
< }
< 
< // Encode writes the JSON encoding of v to the stream,
< // followed by a newline character.
< //
< // See the documentation for Marshal for details about the
< // conversion of Go values to JSON.
< func (enc *Encoder) Encode(v interface{}) error {
< 	if enc.err != nil {
< 		return enc.err
< 	}
< 	e := newEncodeState()
< 	err := e.marshal(v)
< 	if err != nil {
< 		return err
< 	}
< 
< 	// Terminate each value with a newline.
< 	// This makes the output look a little nicer
< 	// when debugging, and some kind of space
< 	// is required if the encoded value was a number,
< 	// so that the reader knows there aren't more
< 	// digits coming.
< 	e.WriteByte('\n')
< 
< 	if _, err = enc.w.Write(e.Bytes()); err != nil {
< 		enc.err = err
< 	}
< 	encodeStatePool.Put(e)
< 	return err
< }
< 
< // RawMessage is a raw encoded JSON object.
< // It implements Marshaler and Unmarshaler and can
< // be used to delay JSON decoding or precompute a JSON encoding.
< type RawMessage []byte
< 
< // MarshalJSON returns *m as the JSON encoding of m.
< func (m *RawMessage) MarshalJSON() ([]byte, error) {
< 	return *m, nil
< }
< 
< // UnmarshalJSON sets *m to a copy of data.
< func (m *RawMessage) UnmarshalJSON(data []byte) error {
< 	if m == nil {
< 		return errors.New("json.RawMessage: UnmarshalJSON on nil pointer")
< 	}
< 	*m = append((*m)[0:0], data...)
< 	return nil
< }
< 
< var _ Marshaler = (*RawMessage)(nil)
< var _ Unmarshaler = (*RawMessage)(nil)
< 
< // A Token holds a value of one of these types:
< //
< //	Delim, for the four JSON delimiters [ ] { }
< //	bool, for JSON booleans
< //	float64, for JSON numbers
< //	Number, for JSON numbers
< //	string, for JSON string literals
< //	nil, for JSON null
< //
< type Token interface{}
< 
< const (
< 	tokenTopValue = iota
< 	tokenArrayStart
< 	tokenArrayValue
< 	tokenArrayComma
< 	tokenObjectStart
< 	tokenObjectKey
< 	tokenObjectColon
< 	tokenObjectValue
< 	tokenObjectComma
< )
< 
< // advance tokenstate from a separator state to a value state
< func (dec *Decoder) tokenPrepareForDecode() error {
< 	// Note: Not calling peek before switch, to avoid
< 	// putting peek into the standard Decode path.
< 	// peek is only called when using the Token API.
< 	switch dec.tokenState {
< 	case tokenArrayComma:
< 		c, err := dec.peek()
< 		if err != nil {
< 			return err
< 		}
< 		if c != ',' {
< 			return &SyntaxError{"expected comma after array element", 0}
< 		}
< 		dec.scanp++
< 		dec.tokenState = tokenArrayValue
< 	case tokenObjectColon:
< 		c, err := dec.peek()
< 		if err != nil {
< 			return err
< 		}
< 		if c != ':' {
< 			return &SyntaxError{"expected colon after object key", 0}
< 		}
< 		dec.scanp++
< 		dec.tokenState = tokenObjectValue
< 	}
< 	return nil
< }
< 
< func (dec *Decoder) tokenValueAllowed() bool {
< 	switch dec.tokenState {
< 	case tokenTopValue, tokenArrayStart, tokenArrayValue, tokenObjectValue:
< 		return true
< 	}
< 	return false
< }
< 
< func (dec *Decoder) tokenValueEnd() {
< 	switch dec.tokenState {
< 	case tokenArrayStart, tokenArrayValue:
< 		dec.tokenState = tokenArrayComma
< 	case tokenObjectValue:
< 		dec.tokenState = tokenObjectComma
< 	}
< }
< 
< // A Delim is a JSON array or object delimiter, one of [ ] { or }.
< type Delim rune
< 
< func (d Delim) String() string {
< 	return string(d)
< }
< 
< // Token returns the next JSON token in the input stream.
< // At the end of the input stream, Token returns nil, io.EOF.
< //
< // Token guarantees that the delimiters [ ] { } it returns are
< // properly nested and matched: if Token encounters an unexpected
< // delimiter in the input, it will return an error.
< //
< // The input stream consists of basic JSON values—bool, string,
< // number, and null—along with delimiters [ ] { } of type Delim
< // to mark the start and end of arrays and objects.
< // Commas and colons are elided.
< func (dec *Decoder) Token() (Token, error) {
< 	for {
< 		c, err := dec.peek()
< 		if err != nil {
< 			return nil, err
< 		}
< 		switch c {
< 		case '[':
< 			if !dec.tokenValueAllowed() {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenStack = append(dec.tokenStack, dec.tokenState)
< 			dec.tokenState = tokenArrayStart
< 			return Delim('['), nil
< 
< 		case ']':
< 			if dec.tokenState != tokenArrayStart && dec.tokenState != tokenArrayComma {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
< 			dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
< 			dec.tokenValueEnd()
< 			return Delim(']'), nil
< 
< 		case '{':
< 			if !dec.tokenValueAllowed() {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenStack = append(dec.tokenStack, dec.tokenState)
< 			dec.tokenState = tokenObjectStart
< 			return Delim('{'), nil
< 
< 		case '}':
< 			if dec.tokenState != tokenObjectStart && dec.tokenState != tokenObjectComma {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
< 			dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
< 			dec.tokenValueEnd()
< 			return Delim('}'), nil
< 
< 		case ':':
< 			if dec.tokenState != tokenObjectColon {
< 				return dec.tokenError(c)
< 			}
< 			dec.scanp++
< 			dec.tokenState = tokenObjectValue
< 			continue
< 
< 		case ',':
< 			if dec.tokenState == tokenArrayComma {
< 				dec.scanp++
< 				dec.tokenState = tokenArrayValue
< 				continue
< 			}
< 			if dec.tokenState == tokenObjectComma {
< 				dec.scanp++
< 				dec.tokenState = tokenObjectKey
< 				continue
< 			}
< 			return dec.tokenError(c)
< 
< 		case '"':
< 			if dec.tokenState == tokenObjectStart || dec.tokenState == tokenObjectKey {
< 				var x string
< 				old := dec.tokenState
< 				dec.tokenState = tokenTopValue
< 				err := dec.Decode(&x)
< 				dec.tokenState = old
< 				if err != nil {
< 					clearOffset(err)
< 					return nil, err
< 				}
< 				dec.tokenState = tokenObjectColon
< 				return x, nil
< 			}
< 			fallthrough
< 
< 		default:
< 			if !dec.tokenValueAllowed() {
< 				return dec.tokenError(c)
< 			}
< 			var x interface{}
< 			if err := dec.Decode(&x); err != nil {
< 				clearOffset(err)
< 				return nil, err
< 			}
< 			return x, nil
< 		}
< 	}
< }
< 
< func clearOffset(err error) {
< 	if s, ok := err.(*SyntaxError); ok {
< 		s.Offset = 0
< 	}
< }
< 
< func (dec *Decoder) tokenError(c byte) (Token, error) {
< 	var context string
< 	switch dec.tokenState {
< 	case tokenTopValue:
< 		context = " looking for beginning of value"
< 	case tokenArrayStart, tokenArrayValue, tokenObjectValue:
< 		context = " looking for beginning of value"
< 	case tokenArrayComma:
< 		context = " after array element"
< 	case tokenObjectKey:
< 		context = " looking for beginning of object key string"
< 	case tokenObjectColon:
< 		context = " after object key"
< 	case tokenObjectComma:
< 		context = " after object key:value pair"
< 	}
< 	return nil, &SyntaxError{"invalid character " + quoteChar(int(c)) + " " + context, 0}
< }
< 
< // More reports whether there is another element in the
< // current array or object being parsed.
< func (dec *Decoder) More() bool {
< 	c, err := dec.peek()
< 	return err == nil && c != ']' && c != '}'
< }
< 
< func (dec *Decoder) peek() (byte, error) {
< 	var err error
< 	for {
< 		for i := dec.scanp; i < len(dec.buf); i++ {
< 			c := dec.buf[i]
< 			if isSpace(rune(c)) {
< 				continue
< 			}
< 			dec.scanp = i
< 			return c, nil
< 		}
< 		// buffer has been scanned, now report any error
< 		if err != nil {
< 			return 0, err
< 		}
< 		err = dec.refill()
< 	}
< }
< 
< /*
< TODO
< 
< // EncodeToken writes the given JSON token to the stream.
< // It returns an error if the delimiters [ ] { } are not properly used.
< //
< // EncodeToken does not call Flush, because usually it is part of
< // a larger operation such as Encode, and those will call Flush when finished.
< // Callers that create an Encoder and then invoke EncodeToken directly,
< // without using Encode, need to call Flush when finished to ensure that
< // the JSON is written to the underlying writer.
< func (e *Encoder) EncodeToken(t Token) error  {
< 	...
< }
< 
< */
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/tags.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-json/tags.go
1,44d0
< // Copyright 2011 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package json
< 
< import (
< 	"strings"
< )
< 
< // tagOptions is the string following a comma in a struct field's "json"
< // tag, or the empty string. It does not include the leading comma.
< type tagOptions string
< 
< // parseTag splits a struct field's json tag into its name and
< // comma-separated options.
< func parseTag(tag string) (string, tagOptions) {
< 	if idx := strings.Index(tag, ","); idx != -1 {
< 		return tag[:idx], tagOptions(tag[idx+1:])
< 	}
< 	return tag, tagOptions("")
< }
< 
< // Contains reports whether a comma-separated list of options
< // contains a particular substr flag. substr must be surrounded by a
< // string boundary or commas.
< func (o tagOptions) Contains(optionName string) bool {
< 	if len(o) == 0 {
< 		return false
< 	}
< 	s := string(o)
< 	for s != "" {
< 		var next string
< 		i := strings.Index(s, ",")
< 		if i >= 0 {
< 			s, next = s[:i], s[i+1:]
< 		}
< 		if s == optionName {
< 			return true
< 		}
< 		s = next
< 	}
< 	return false
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-semver/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-semver/LICENSE
1,202d0
< 
<                                  Apache License
<                            Version 2.0, January 2004
<                         http://www.apache.org/licenses/
< 
<    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
< 
<    1. Definitions.
< 
<       "License" shall mean the terms and conditions for use, reproduction,
<       and distribution as defined by Sections 1 through 9 of this document.
< 
<       "Licensor" shall mean the copyright owner or entity authorized by
<       the copyright owner that is granting the License.
< 
<       "Legal Entity" shall mean the union of the acting entity and all
<       other entities that control, are controlled by, or are under common
<       control with that entity. For the purposes of this definition,
<       "control" means (i) the power, direct or indirect, to cause the
<       direction or management of such entity, whether by contract or
<       otherwise, or (ii) ownership of fifty percent (50%) or more of the
<       outstanding shares, or (iii) beneficial ownership of such entity.
< 
<       "You" (or "Your") shall mean an individual or Legal Entity
<       exercising permissions granted by this License.
< 
<       "Source" form shall mean the preferred form for making modifications,
<       including but not limited to software source code, documentation
<       source, and configuration files.
< 
<       "Object" form shall mean any form resulting from mechanical
<       transformation or translation of a Source form, including but
<       not limited to compiled object code, generated documentation,
<       and conversions to other media types.
< 
<       "Work" shall mean the work of authorship, whether in Source or
<       Object form, made available under the License, as indicated by a
<       copyright notice that is included in or attached to the work
<       (an example is provided in the Appendix below).
< 
<       "Derivative Works" shall mean any work, whether in Source or Object
<       form, that is based on (or derived from) the Work and for which the
<       editorial revisions, annotations, elaborations, or other modifications
<       represent, as a whole, an original work of authorship. For the purposes
<       of this License, Derivative Works shall not include works that remain
<       separable from, or merely link (or bind by name) to the interfaces of,
<       the Work and Derivative Works thereof.
< 
<       "Contribution" shall mean any work of authorship, including
<       the original version of the Work and any modifications or additions
<       to that Work or Derivative Works thereof, that is intentionally
<       submitted to Licensor for inclusion in the Work by the copyright owner
<       or by an individual or Legal Entity authorized to submit on behalf of
<       the copyright owner. For the purposes of this definition, "submitted"
<       means any form of electronic, verbal, or written communication sent
<       to the Licensor or its representatives, including but not limited to
<       communication on electronic mailing lists, source code control systems,
<       and issue tracking systems that are managed by, or on behalf of, the
<       Licensor for the purpose of discussing and improving the Work, but
<       excluding communication that is conspicuously marked or otherwise
<       designated in writing by the copyright owner as "Not a Contribution."
< 
<       "Contributor" shall mean Licensor and any individual or Legal Entity
<       on behalf of whom a Contribution has been received by Licensor and
<       subsequently incorporated within the Work.
< 
<    2. Grant of Copyright License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       copyright license to reproduce, prepare Derivative Works of,
<       publicly display, publicly perform, sublicense, and distribute the
<       Work and such Derivative Works in Source or Object form.
< 
<    3. Grant of Patent License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       (except as stated in this section) patent license to make, have made,
<       use, offer to sell, sell, import, and otherwise transfer the Work,
<       where such license applies only to those patent claims licensable
<       by such Contributor that are necessarily infringed by their
<       Contribution(s) alone or by combination of their Contribution(s)
<       with the Work to which such Contribution(s) was submitted. If You
<       institute patent litigation against any entity (including a
<       cross-claim or counterclaim in a lawsuit) alleging that the Work
<       or a Contribution incorporated within the Work constitutes direct
<       or contributory patent infringement, then any patent licenses
<       granted to You under this License for that Work shall terminate
<       as of the date such litigation is filed.
< 
<    4. Redistribution. You may reproduce and distribute copies of the
<       Work or Derivative Works thereof in any medium, with or without
<       modifications, and in Source or Object form, provided that You
<       meet the following conditions:
< 
<       (a) You must give any other recipients of the Work or
<           Derivative Works a copy of this License; and
< 
<       (b) You must cause any modified files to carry prominent notices
<           stating that You changed the files; and
< 
<       (c) You must retain, in the Source form of any Derivative Works
<           that You distribute, all copyright, patent, trademark, and
<           attribution notices from the Source form of the Work,
<           excluding those notices that do not pertain to any part of
<           the Derivative Works; and
< 
<       (d) If the Work includes a "NOTICE" text file as part of its
<           distribution, then any Derivative Works that You distribute must
<           include a readable copy of the attribution notices contained
<           within such NOTICE file, excluding those notices that do not
<           pertain to any part of the Derivative Works, in at least one
<           of the following places: within a NOTICE text file distributed
<           as part of the Derivative Works; within the Source form or
<           documentation, if provided along with the Derivative Works; or,
<           within a display generated by the Derivative Works, if and
<           wherever such third-party notices normally appear. The contents
<           of the NOTICE file are for informational purposes only and
<           do not modify the License. You may add Your own attribution
<           notices within Derivative Works that You distribute, alongside
<           or as an addendum to the NOTICE text from the Work, provided
<           that such additional attribution notices cannot be construed
<           as modifying the License.
< 
<       You may add Your own copyright statement to Your modifications and
<       may provide additional or different license terms and conditions
<       for use, reproduction, or distribution of Your modifications, or
<       for any such Derivative Works as a whole, provided Your use,
<       reproduction, and distribution of the Work otherwise complies with
<       the conditions stated in this License.
< 
<    5. Submission of Contributions. Unless You explicitly state otherwise,
<       any Contribution intentionally submitted for inclusion in the Work
<       by You to the Licensor shall be under the terms and conditions of
<       this License, without any additional terms or conditions.
<       Notwithstanding the above, nothing herein shall supersede or modify
<       the terms of any separate license agreement you may have executed
<       with Licensor regarding such Contributions.
< 
<    6. Trademarks. This License does not grant permission to use the trade
<       names, trademarks, service marks, or product names of the Licensor,
<       except as required for reasonable and customary use in describing the
<       origin of the Work and reproducing the content of the NOTICE file.
< 
<    7. Disclaimer of Warranty. Unless required by applicable law or
<       agreed to in writing, Licensor provides the Work (and each
<       Contributor provides its Contributions) on an "AS IS" BASIS,
<       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
<       implied, including, without limitation, any warranties or conditions
<       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
<       PARTICULAR PURPOSE. You are solely responsible for determining the
<       appropriateness of using or redistributing the Work and assume any
<       risks associated with Your exercise of permissions under this License.
< 
<    8. Limitation of Liability. In no event and under no legal theory,
<       whether in tort (including negligence), contract, or otherwise,
<       unless required by applicable law (such as deliberate and grossly
<       negligent acts) or agreed to in writing, shall any Contributor be
<       liable to You for damages, including any direct, indirect, special,
<       incidental, or consequential damages of any character arising as a
<       result of this License or out of the use or inability to use the
<       Work (including but not limited to damages for loss of goodwill,
<       work stoppage, computer failure or malfunction, or any and all
<       other commercial damages or losses), even if such Contributor
<       has been advised of the possibility of such damages.
< 
<    9. Accepting Warranty or Additional Liability. While redistributing
<       the Work or Derivative Works thereof, You may choose to offer,
<       and charge a fee for, acceptance of support, warranty, indemnity,
<       or other liability obligations and/or rights consistent with this
<       License. However, in accepting such obligations, You may act only
<       on Your own behalf and on Your sole responsibility, not on behalf
<       of any other Contributor, and only if You agree to indemnify,
<       defend, and hold each Contributor harmless for any liability
<       incurred by, or claims asserted against, such Contributor by reason
<       of your accepting any such warranty or additional liability.
< 
<    END OF TERMS AND CONDITIONS
< 
<    APPENDIX: How to apply the Apache License to your work.
< 
<       To apply the Apache License to your work, attach the following
<       boilerplate notice, with the fields enclosed by brackets "[]"
<       replaced with your own identifying information. (Don't include
<       the brackets!)  The text should be enclosed in the appropriate
<       comment syntax for the file format. We also recommend that a
<       file or class name and description of purpose be included on the
<       same "printed page" as the copyright notice for easier
<       identification within third-party archives.
< 
<    Copyright [yyyy] [name of copyright owner]
< 
<    Licensed under the Apache License, Version 2.0 (the "License");
<    you may not use this file except in compliance with the License.
<    You may obtain a copy of the License at
< 
<        http://www.apache.org/licenses/LICENSE-2.0
< 
<    Unless required by applicable law or agreed to in writing, software
<    distributed under the License is distributed on an "AS IS" BASIS,
<    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<    See the License for the specific language governing permissions and
<    limitations under the License.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-semver/NOTICE updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-semver/NOTICE
1,5d0
< CoreOS Project
< Copyright 2018 CoreOS, Inc
< 
< This product includes software developed at CoreOS, Inc.
< (http://www.coreos.com/).
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-semver/semver/semver.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-semver/semver/semver.go
1,296d0
< // Copyright 2013-2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< // Semantic Versions http://semver.org
< package semver
< 
< import (
< 	"bytes"
< 	"errors"
< 	"fmt"
< 	"regexp"
< 	"strconv"
< 	"strings"
< )
< 
< type Version struct {
< 	Major      int64
< 	Minor      int64
< 	Patch      int64
< 	PreRelease PreRelease
< 	Metadata   string
< }
< 
< type PreRelease string
< 
< func splitOff(input *string, delim string) (val string) {
< 	parts := strings.SplitN(*input, delim, 2)
< 
< 	if len(parts) == 2 {
< 		*input = parts[0]
< 		val = parts[1]
< 	}
< 
< 	return val
< }
< 
< func New(version string) *Version {
< 	return Must(NewVersion(version))
< }
< 
< func NewVersion(version string) (*Version, error) {
< 	v := Version{}
< 
< 	if err := v.Set(version); err != nil {
< 		return nil, err
< 	}
< 
< 	return &v, nil
< }
< 
< // Must is a helper for wrapping NewVersion and will panic if err is not nil.
< func Must(v *Version, err error) *Version {
< 	if err != nil {
< 		panic(err)
< 	}
< 	return v
< }
< 
< // Set parses and updates v from the given version string. Implements flag.Value
< func (v *Version) Set(version string) error {
< 	metadata := splitOff(&version, "+")
< 	preRelease := PreRelease(splitOff(&version, "-"))
< 	dotParts := strings.SplitN(version, ".", 3)
< 
< 	if len(dotParts) != 3 {
< 		return fmt.Errorf("%s is not in dotted-tri format", version)
< 	}
< 
< 	if err := validateIdentifier(string(preRelease)); err != nil {
< 		return fmt.Errorf("failed to validate pre-release: %v", err)
< 	}
< 
< 	if err := validateIdentifier(metadata); err != nil {
< 		return fmt.Errorf("failed to validate metadata: %v", err)
< 	}
< 
< 	parsed := make([]int64, 3, 3)
< 
< 	for i, v := range dotParts[:3] {
< 		val, err := strconv.ParseInt(v, 10, 64)
< 		parsed[i] = val
< 		if err != nil {
< 			return err
< 		}
< 	}
< 
< 	v.Metadata = metadata
< 	v.PreRelease = preRelease
< 	v.Major = parsed[0]
< 	v.Minor = parsed[1]
< 	v.Patch = parsed[2]
< 	return nil
< }
< 
< func (v Version) String() string {
< 	var buffer bytes.Buffer
< 
< 	fmt.Fprintf(&buffer, "%d.%d.%d", v.Major, v.Minor, v.Patch)
< 
< 	if v.PreRelease != "" {
< 		fmt.Fprintf(&buffer, "-%s", v.PreRelease)
< 	}
< 
< 	if v.Metadata != "" {
< 		fmt.Fprintf(&buffer, "+%s", v.Metadata)
< 	}
< 
< 	return buffer.String()
< }
< 
< func (v *Version) UnmarshalYAML(unmarshal func(interface{}) error) error {
< 	var data string
< 	if err := unmarshal(&data); err != nil {
< 		return err
< 	}
< 	return v.Set(data)
< }
< 
< func (v Version) MarshalJSON() ([]byte, error) {
< 	return []byte(`"` + v.String() + `"`), nil
< }
< 
< func (v *Version) UnmarshalJSON(data []byte) error {
< 	l := len(data)
< 	if l == 0 || string(data) == `""` {
< 		return nil
< 	}
< 	if l < 2 || data[0] != '"' || data[l-1] != '"' {
< 		return errors.New("invalid semver string")
< 	}
< 	return v.Set(string(data[1 : l-1]))
< }
< 
< // Compare tests if v is less than, equal to, or greater than versionB,
< // returning -1, 0, or +1 respectively.
< func (v Version) Compare(versionB Version) int {
< 	if cmp := recursiveCompare(v.Slice(), versionB.Slice()); cmp != 0 {
< 		return cmp
< 	}
< 	return preReleaseCompare(v, versionB)
< }
< 
< // Equal tests if v is equal to versionB.
< func (v Version) Equal(versionB Version) bool {
< 	return v.Compare(versionB) == 0
< }
< 
< // LessThan tests if v is less than versionB.
< func (v Version) LessThan(versionB Version) bool {
< 	return v.Compare(versionB) < 0
< }
< 
< // Slice converts the comparable parts of the semver into a slice of integers.
< func (v Version) Slice() []int64 {
< 	return []int64{v.Major, v.Minor, v.Patch}
< }
< 
< func (p PreRelease) Slice() []string {
< 	preRelease := string(p)
< 	return strings.Split(preRelease, ".")
< }
< 
< func preReleaseCompare(versionA Version, versionB Version) int {
< 	a := versionA.PreRelease
< 	b := versionB.PreRelease
< 
< 	/* Handle the case where if two versions are otherwise equal it is the
< 	 * one without a PreRelease that is greater */
< 	if len(a) == 0 && (len(b) > 0) {
< 		return 1
< 	} else if len(b) == 0 && (len(a) > 0) {
< 		return -1
< 	}
< 
< 	// If there is a prerelease, check and compare each part.
< 	return recursivePreReleaseCompare(a.Slice(), b.Slice())
< }
< 
< func recursiveCompare(versionA []int64, versionB []int64) int {
< 	if len(versionA) == 0 {
< 		return 0
< 	}
< 
< 	a := versionA[0]
< 	b := versionB[0]
< 
< 	if a > b {
< 		return 1
< 	} else if a < b {
< 		return -1
< 	}
< 
< 	return recursiveCompare(versionA[1:], versionB[1:])
< }
< 
< func recursivePreReleaseCompare(versionA []string, versionB []string) int {
< 	// A larger set of pre-release fields has a higher precedence than a smaller set,
< 	// if all of the preceding identifiers are equal.
< 	if len(versionA) == 0 {
< 		if len(versionB) > 0 {
< 			return -1
< 		}
< 		return 0
< 	} else if len(versionB) == 0 {
< 		// We're longer than versionB so return 1.
< 		return 1
< 	}
< 
< 	a := versionA[0]
< 	b := versionB[0]
< 
< 	aInt := false
< 	bInt := false
< 
< 	aI, err := strconv.Atoi(versionA[0])
< 	if err == nil {
< 		aInt = true
< 	}
< 
< 	bI, err := strconv.Atoi(versionB[0])
< 	if err == nil {
< 		bInt = true
< 	}
< 
< 	// Numeric identifiers always have lower precedence than non-numeric identifiers.
< 	if aInt && !bInt {
< 		return -1
< 	} else if !aInt && bInt {
< 		return 1
< 	}
< 
< 	// Handle Integer Comparison
< 	if aInt && bInt {
< 		if aI > bI {
< 			return 1
< 		} else if aI < bI {
< 			return -1
< 		}
< 	}
< 
< 	// Handle String Comparison
< 	if a > b {
< 		return 1
< 	} else if a < b {
< 		return -1
< 	}
< 
< 	return recursivePreReleaseCompare(versionA[1:], versionB[1:])
< }
< 
< // BumpMajor increments the Major field by 1 and resets all other fields to their default values
< func (v *Version) BumpMajor() {
< 	v.Major += 1
< 	v.Minor = 0
< 	v.Patch = 0
< 	v.PreRelease = PreRelease("")
< 	v.Metadata = ""
< }
< 
< // BumpMinor increments the Minor field by 1 and resets all other fields to their default values
< func (v *Version) BumpMinor() {
< 	v.Minor += 1
< 	v.Patch = 0
< 	v.PreRelease = PreRelease("")
< 	v.Metadata = ""
< }
< 
< // BumpPatch increments the Patch field by 1 and resets all other fields to their default values
< func (v *Version) BumpPatch() {
< 	v.Patch += 1
< 	v.PreRelease = PreRelease("")
< 	v.Metadata = ""
< }
< 
< // validateIdentifier makes sure the provided identifier satisfies semver spec
< func validateIdentifier(id string) error {
< 	if id != "" && !reIdentifier.MatchString(id) {
< 		return fmt.Errorf("%s is not a valid semver identifier", id)
< 	}
< 	return nil
< }
< 
< // reIdentifier is a regular expression used to check that pre-release and metadata
< // identifiers satisfy the spec requirements
< var reIdentifier = regexp.MustCompile(`^[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*$`)
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-semver/semver/sort.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-semver/semver/sort.go
1,38d0
< // Copyright 2013-2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package semver
< 
< import (
< 	"sort"
< )
< 
< type Versions []*Version
< 
< func (s Versions) Len() int {
< 	return len(s)
< }
< 
< func (s Versions) Swap(i, j int) {
< 	s[i], s[j] = s[j], s[i]
< }
< 
< func (s Versions) Less(i, j int) bool {
< 	return s[i].LessThan(*s[j])
< }
< 
< // Sort sorts the given slice of Version
< func Sort(versions []*Version) {
< 	sort.Sort(Versions(versions))
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/LICENSE
1,191d0
< Apache License
< Version 2.0, January 2004
< http://www.apache.org/licenses/
< 
< TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
< 
< 1. Definitions.
< 
< "License" shall mean the terms and conditions for use, reproduction, and
< distribution as defined by Sections 1 through 9 of this document.
< 
< "Licensor" shall mean the copyright owner or entity authorized by the copyright
< owner that is granting the License.
< 
< "Legal Entity" shall mean the union of the acting entity and all other entities
< that control, are controlled by, or are under common control with that entity.
< For the purposes of this definition, "control" means (i) the power, direct or
< indirect, to cause the direction or management of such entity, whether by
< contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the
< outstanding shares, or (iii) beneficial ownership of such entity.
< 
< "You" (or "Your") shall mean an individual or Legal Entity exercising
< permissions granted by this License.
< 
< "Source" form shall mean the preferred form for making modifications, including
< but not limited to software source code, documentation source, and configuration
< files.
< 
< "Object" form shall mean any form resulting from mechanical transformation or
< translation of a Source form, including but not limited to compiled object code,
< generated documentation, and conversions to other media types.
< 
< "Work" shall mean the work of authorship, whether in Source or Object form, made
< available under the License, as indicated by a copyright notice that is included
< in or attached to the work (an example is provided in the Appendix below).
< 
< "Derivative Works" shall mean any work, whether in Source or Object form, that
< is based on (or derived from) the Work and for which the editorial revisions,
< annotations, elaborations, or other modifications represent, as a whole, an
< original work of authorship. For the purposes of this License, Derivative Works
< shall not include works that remain separable from, or merely link (or bind by
< name) to the interfaces of, the Work and Derivative Works thereof.
< 
< "Contribution" shall mean any work of authorship, including the original version
< of the Work and any modifications or additions to that Work or Derivative Works
< thereof, that is intentionally submitted to Licensor for inclusion in the Work
< by the copyright owner or by an individual or Legal Entity authorized to submit
< on behalf of the copyright owner. For the purposes of this definition,
< "submitted" means any form of electronic, verbal, or written communication sent
< to the Licensor or its representatives, including but not limited to
< communication on electronic mailing lists, source code control systems, and
< issue tracking systems that are managed by, or on behalf of, the Licensor for
< the purpose of discussing and improving the Work, but excluding communication
< that is conspicuously marked or otherwise designated in writing by the copyright
< owner as "Not a Contribution."
< 
< "Contributor" shall mean Licensor and any individual or Legal Entity on behalf
< of whom a Contribution has been received by Licensor and subsequently
< incorporated within the Work.
< 
< 2. Grant of Copyright License.
< 
< Subject to the terms and conditions of this License, each Contributor hereby
< grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
< irrevocable copyright license to reproduce, prepare Derivative Works of,
< publicly display, publicly perform, sublicense, and distribute the Work and such
< Derivative Works in Source or Object form.
< 
< 3. Grant of Patent License.
< 
< Subject to the terms and conditions of this License, each Contributor hereby
< grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
< irrevocable (except as stated in this section) patent license to make, have
< made, use, offer to sell, sell, import, and otherwise transfer the Work, where
< such license applies only to those patent claims licensable by such Contributor
< that are necessarily infringed by their Contribution(s) alone or by combination
< of their Contribution(s) with the Work to which such Contribution(s) was
< submitted. If You institute patent litigation against any entity (including a
< cross-claim or counterclaim in a lawsuit) alleging that the Work or a
< Contribution incorporated within the Work constitutes direct or contributory
< patent infringement, then any patent licenses granted to You under this License
< for that Work shall terminate as of the date such litigation is filed.
< 
< 4. Redistribution.
< 
< You may reproduce and distribute copies of the Work or Derivative Works thereof
< in any medium, with or without modifications, and in Source or Object form,
< provided that You meet the following conditions:
< 
< You must give any other recipients of the Work or Derivative Works a copy of
< this License; and
< You must cause any modified files to carry prominent notices stating that You
< changed the files; and
< You must retain, in the Source form of any Derivative Works that You distribute,
< all copyright, patent, trademark, and attribution notices from the Source form
< of the Work, excluding those notices that do not pertain to any part of the
< Derivative Works; and
< If the Work includes a "NOTICE" text file as part of its distribution, then any
< Derivative Works that You distribute must include a readable copy of the
< attribution notices contained within such NOTICE file, excluding those notices
< that do not pertain to any part of the Derivative Works, in at least one of the
< following places: within a NOTICE text file distributed as part of the
< Derivative Works; within the Source form or documentation, if provided along
< with the Derivative Works; or, within a display generated by the Derivative
< Works, if and wherever such third-party notices normally appear. The contents of
< the NOTICE file are for informational purposes only and do not modify the
< License. You may add Your own attribution notices within Derivative Works that
< You distribute, alongside or as an addendum to the NOTICE text from the Work,
< provided that such additional attribution notices cannot be construed as
< modifying the License.
< You may add Your own copyright statement to Your modifications and may provide
< additional or different license terms and conditions for use, reproduction, or
< distribution of Your modifications, or for any such Derivative Works as a whole,
< provided Your use, reproduction, and distribution of the Work otherwise complies
< with the conditions stated in this License.
< 
< 5. Submission of Contributions.
< 
< Unless You explicitly state otherwise, any Contribution intentionally submitted
< for inclusion in the Work by You to the Licensor shall be under the terms and
< conditions of this License, without any additional terms or conditions.
< Notwithstanding the above, nothing herein shall supersede or modify the terms of
< any separate license agreement you may have executed with Licensor regarding
< such Contributions.
< 
< 6. Trademarks.
< 
< This License does not grant permission to use the trade names, trademarks,
< service marks, or product names of the Licensor, except as required for
< reasonable and customary use in describing the origin of the Work and
< reproducing the content of the NOTICE file.
< 
< 7. Disclaimer of Warranty.
< 
< Unless required by applicable law or agreed to in writing, Licensor provides the
< Work (and each Contributor provides its Contributions) on an "AS IS" BASIS,
< WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
< including, without limitation, any warranties or conditions of TITLE,
< NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are
< solely responsible for determining the appropriateness of using or
< redistributing the Work and assume any risks associated with Your exercise of
< permissions under this License.
< 
< 8. Limitation of Liability.
< 
< In no event and under no legal theory, whether in tort (including negligence),
< contract, or otherwise, unless required by applicable law (such as deliberate
< and grossly negligent acts) or agreed to in writing, shall any Contributor be
< liable to You for damages, including any direct, indirect, special, incidental,
< or consequential damages of any character arising as a result of this License or
< out of the use or inability to use the Work (including but not limited to
< damages for loss of goodwill, work stoppage, computer failure or malfunction, or
< any and all other commercial damages or losses), even if such Contributor has
< been advised of the possibility of such damages.
< 
< 9. Accepting Warranty or Additional Liability.
< 
< While redistributing the Work or Derivative Works thereof, You may choose to
< offer, and charge a fee for, acceptance of support, warranty, indemnity, or
< other liability obligations and/or rights consistent with this License. However,
< in accepting such obligations, You may act only on Your own behalf and on Your
< sole responsibility, not on behalf of any other Contributor, and only if You
< agree to indemnify, defend, and hold each Contributor harmless for any liability
< incurred by, or claims asserted against, such Contributor by reason of your
< accepting any such warranty or additional liability.
< 
< END OF TERMS AND CONDITIONS
< 
< APPENDIX: How to apply the Apache License to your work
< 
< To apply the Apache License to your work, attach the following boilerplate
< notice, with the fields enclosed by brackets "[]" replaced with your own
< identifying information. (Don't include the brackets!) The text should be
< enclosed in the appropriate comment syntax for the file format. We also
< recommend that a file or class name and description of purpose be included on
< the same "printed page" as the copyright notice for easier identification within
< third-party archives.
< 
<    Copyright [yyyy] [name of copyright owner]
< 
<    Licensed under the Apache License, Version 2.0 (the "License");
<    you may not use this file except in compliance with the License.
<    You may obtain a copy of the License at
< 
<      http://www.apache.org/licenses/LICENSE-2.0
< 
<    Unless required by applicable law or agreed to in writing, software
<    distributed under the License is distributed on an "AS IS" BASIS,
<    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<    See the License for the specific language governing permissions and
<    limitations under the License.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/NOTICE updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/NOTICE
1,5d0
< CoreOS Project
< Copyright 2018 CoreOS, Inc
< 
< This product includes software developed at CoreOS, Inc.
< (http://www.coreos.com/).
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/unit/deserialize.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/unit/deserialize.go
1,278d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package unit
< 
< import (
< 	"bufio"
< 	"bytes"
< 	"errors"
< 	"fmt"
< 	"io"
< 	"strings"
< 	"unicode"
< )
< 
< const (
< 	// SYSTEMD_LINE_MAX mimics the maximum line length that systemd can use.
< 	// On typical systemd platforms (i.e. modern Linux), this will most
< 	// commonly be 2048, so let's use that as a sanity check.
< 	// Technically, we should probably pull this at runtime:
< 	//    SYSTEMD_LINE_MAX = int(C.sysconf(C.__SC_LINE_MAX))
< 	// but this would introduce an (unfortunate) dependency on cgo
< 	SYSTEMD_LINE_MAX = 2048
< 
< 	// SYSTEMD_NEWLINE defines characters that systemd considers indicators
< 	// for a newline.
< 	SYSTEMD_NEWLINE = "\r\n"
< )
< 
< var (
< 	// ErrLineTooLong gets returned when a line is too long for systemd to handle.
< 	ErrLineTooLong = fmt.Errorf("line too long (max %d bytes)", SYSTEMD_LINE_MAX)
< )
< 
< // Deserialize parses a systemd unit file into a list of UnitOption objects.
< func Deserialize(f io.Reader) (opts []*UnitOption, err error) {
< 	lexer, optchan, errchan := newLexer(f)
< 	go lexer.lex()
< 
< 	for opt := range optchan {
< 		opts = append(opts, &(*opt))
< 	}
< 
< 	err = <-errchan
< 	return opts, err
< }
< 
< func newLexer(f io.Reader) (*lexer, <-chan *UnitOption, <-chan error) {
< 	optchan := make(chan *UnitOption)
< 	errchan := make(chan error, 1)
< 	buf := bufio.NewReader(f)
< 
< 	return &lexer{buf, optchan, errchan, ""}, optchan, errchan
< }
< 
< type lexer struct {
< 	buf     *bufio.Reader
< 	optchan chan *UnitOption
< 	errchan chan error
< 	section string
< }
< 
< func (l *lexer) lex() {
< 	defer func() {
< 		close(l.optchan)
< 		close(l.errchan)
< 	}()
< 	next := l.lexNextSection
< 	for next != nil {
< 		if l.buf.Buffered() >= SYSTEMD_LINE_MAX {
< 			// systemd truncates lines longer than LINE_MAX
< 			// https://bugs.freedesktop.org/show_bug.cgi?id=85308
< 			// Rather than allowing this to pass silently, let's
< 			// explicitly gate people from encountering this
< 			line, err := l.buf.Peek(SYSTEMD_LINE_MAX)
< 			if err != nil {
< 				l.errchan <- err
< 				return
< 			}
< 			if !bytes.ContainsAny(line, SYSTEMD_NEWLINE) {
< 				l.errchan <- ErrLineTooLong
< 				return
< 			}
< 		}
< 
< 		var err error
< 		next, err = next()
< 		if err != nil {
< 			l.errchan <- err
< 			return
< 		}
< 	}
< }
< 
< type lexStep func() (lexStep, error)
< 
< func (l *lexer) lexSectionName() (lexStep, error) {
< 	sec, err := l.buf.ReadBytes(']')
< 	if err != nil {
< 		return nil, errors.New("unable to find end of section")
< 	}
< 
< 	return l.lexSectionSuffixFunc(string(sec[:len(sec)-1])), nil
< }
< 
< func (l *lexer) lexSectionSuffixFunc(section string) lexStep {
< 	return func() (lexStep, error) {
< 		garbage, _, err := l.toEOL()
< 		if err != nil {
< 			return nil, err
< 		}
< 
< 		garbage = bytes.TrimSpace(garbage)
< 		if len(garbage) > 0 {
< 			return nil, fmt.Errorf("found garbage after section name %s: %v", l.section, garbage)
< 		}
< 
< 		return l.lexNextSectionOrOptionFunc(section), nil
< 	}
< }
< 
< func (l *lexer) ignoreLineFunc(next lexStep) lexStep {
< 	return func() (lexStep, error) {
< 		for {
< 			line, _, err := l.toEOL()
< 			if err != nil {
< 				return nil, err
< 			}
< 
< 			line = bytes.TrimSuffix(line, []byte{' '})
< 
< 			// lack of continuation means this line has been exhausted
< 			if !bytes.HasSuffix(line, []byte{'\\'}) {
< 				break
< 			}
< 		}
< 
< 		// reached end of buffer, safe to exit
< 		return next, nil
< 	}
< }
< 
< func (l *lexer) lexNextSection() (lexStep, error) {
< 	r, _, err := l.buf.ReadRune()
< 	if err != nil {
< 		if err == io.EOF {
< 			err = nil
< 		}
< 		return nil, err
< 	}
< 
< 	if r == '[' {
< 		return l.lexSectionName, nil
< 	} else if isComment(r) {
< 		return l.ignoreLineFunc(l.lexNextSection), nil
< 	}
< 
< 	return l.lexNextSection, nil
< }
< 
< func (l *lexer) lexNextSectionOrOptionFunc(section string) lexStep {
< 	return func() (lexStep, error) {
< 		r, _, err := l.buf.ReadRune()
< 		if err != nil {
< 			if err == io.EOF {
< 				err = nil
< 			}
< 			return nil, err
< 		}
< 
< 		if unicode.IsSpace(r) {
< 			return l.lexNextSectionOrOptionFunc(section), nil
< 		} else if r == '[' {
< 			return l.lexSectionName, nil
< 		} else if isComment(r) {
< 			return l.ignoreLineFunc(l.lexNextSectionOrOptionFunc(section)), nil
< 		}
< 
< 		l.buf.UnreadRune()
< 		return l.lexOptionNameFunc(section), nil
< 	}
< }
< 
< func (l *lexer) lexOptionNameFunc(section string) lexStep {
< 	return func() (lexStep, error) {
< 		var partial bytes.Buffer
< 		for {
< 			r, _, err := l.buf.ReadRune()
< 			if err != nil {
< 				return nil, err
< 			}
< 
< 			if r == '\n' || r == '\r' {
< 				return nil, errors.New("unexpected newline encountered while parsing option name")
< 			}
< 
< 			if r == '=' {
< 				break
< 			}
< 
< 			partial.WriteRune(r)
< 		}
< 
< 		name := strings.TrimSpace(partial.String())
< 		return l.lexOptionValueFunc(section, name, bytes.Buffer{}), nil
< 	}
< }
< 
< func (l *lexer) lexOptionValueFunc(section, name string, partial bytes.Buffer) lexStep {
< 	return func() (lexStep, error) {
< 		for {
< 			line, eof, err := l.toEOL()
< 			if err != nil {
< 				return nil, err
< 			}
< 
< 			if len(bytes.TrimSpace(line)) == 0 {
< 				break
< 			}
< 
< 			partial.Write(line)
< 
< 			// lack of continuation means this value has been exhausted
< 			idx := bytes.LastIndex(line, []byte{'\\'})
< 			if idx == -1 || idx != (len(line)-1) {
< 				break
< 			}
< 
< 			if !eof {
< 				partial.WriteRune('\n')
< 			}
< 
< 			return l.lexOptionValueFunc(section, name, partial), nil
< 		}
< 
< 		val := partial.String()
< 		if strings.HasSuffix(val, "\n") {
< 			// A newline was added to the end, so the file didn't end with a backslash.
< 			// => Keep the newline
< 			val = strings.TrimSpace(val) + "\n"
< 		} else {
< 			val = strings.TrimSpace(val)
< 		}
< 		l.optchan <- &UnitOption{Section: section, Name: name, Value: val}
< 
< 		return l.lexNextSectionOrOptionFunc(section), nil
< 	}
< }
< 
< // toEOL reads until the end-of-line or end-of-file.
< // Returns (data, EOFfound, error)
< func (l *lexer) toEOL() ([]byte, bool, error) {
< 	line, err := l.buf.ReadBytes('\n')
< 	// ignore EOF here since it's roughly equivalent to EOL
< 	if err != nil && err != io.EOF {
< 		return nil, false, err
< 	}
< 
< 	line = bytes.TrimSuffix(line, []byte{'\r'})
< 	line = bytes.TrimSuffix(line, []byte{'\n'})
< 
< 	return line, err == io.EOF, nil
< }
< 
< func isComment(r rune) bool {
< 	return r == '#' || r == ';'
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/unit/escape.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/unit/escape.go
1,116d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< // Implements systemd-escape [--unescape] [--path]
< 
< package unit
< 
< import (
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< const (
< 	allowed = `:_.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`
< )
< 
< // If isPath is true:
< //   We remove redundant '/'s, the leading '/', and trailing '/'.
< //   If the result is empty, a '/' is inserted.
< //
< // We always:
< //  Replace the following characters with `\x%x`:
< //   Leading `.`
< //   `-`, `\`, and anything not in this set: `:-_.\[0-9a-zA-Z]`
< //  Replace '/' with '-'.
< func escape(unescaped string, isPath bool) string {
< 	e := []byte{}
< 	inSlashes := false
< 	start := true
< 	for i := 0; i < len(unescaped); i++ {
< 		c := unescaped[i]
< 		if isPath {
< 			if c == '/' {
< 				inSlashes = true
< 				continue
< 			} else if inSlashes {
< 				inSlashes = false
< 				if !start {
< 					e = append(e, '-')
< 				}
< 			}
< 		}
< 
< 		if c == '/' {
< 			e = append(e, '-')
< 		} else if start && c == '.' || strings.IndexByte(allowed, c) == -1 {
< 			e = append(e, []byte(fmt.Sprintf(`\x%x`, c))...)
< 		} else {
< 			e = append(e, c)
< 		}
< 		start = false
< 	}
< 	if isPath && len(e) == 0 {
< 		e = append(e, '-')
< 	}
< 	return string(e)
< }
< 
< // If isPath is true:
< //   We always return a string beginning with '/'.
< //
< // We always:
< //  Replace '-' with '/'.
< //  Replace `\x%x` with the value represented in hex.
< func unescape(escaped string, isPath bool) string {
< 	u := []byte{}
< 	for i := 0; i < len(escaped); i++ {
< 		c := escaped[i]
< 		if c == '-' {
< 			c = '/'
< 		} else if c == '\\' && len(escaped)-i >= 4 && escaped[i+1] == 'x' {
< 			n, err := strconv.ParseInt(escaped[i+2:i+4], 16, 8)
< 			if err == nil {
< 				c = byte(n)
< 				i += 3
< 			}
< 		}
< 		u = append(u, c)
< 	}
< 	if isPath && (len(u) == 0 || u[0] != '/') {
< 		u = append([]byte("/"), u...)
< 	}
< 	return string(u)
< }
< 
< // UnitNameEscape escapes a string as `systemd-escape` would
< func UnitNameEscape(unescaped string) string {
< 	return escape(unescaped, false)
< }
< 
< // UnitNameUnescape unescapes a string as `systemd-escape --unescape` would
< func UnitNameUnescape(escaped string) string {
< 	return unescape(escaped, false)
< }
< 
< // UnitNamePathEscape escapes a string as `systemd-escape --path` would
< func UnitNamePathEscape(unescaped string) string {
< 	return escape(unescaped, true)
< }
< 
< // UnitNamePathUnescape unescapes a string as `systemd-escape --path --unescape` would
< func UnitNamePathUnescape(escaped string) string {
< 	return unescape(escaped, true)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/unit/option.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/unit/option.go
1,59d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package unit
< 
< import (
< 	"fmt"
< )
< 
< // UnitOption represents an option in a systemd unit file.
< type UnitOption struct {
< 	Section string
< 	Name    string
< 	Value   string
< }
< 
< // NewUnitOption returns a new UnitOption instance with pre-set values.
< func NewUnitOption(section, name, value string) *UnitOption {
< 	return &UnitOption{Section: section, Name: name, Value: value}
< }
< 
< func (uo *UnitOption) String() string {
< 	return fmt.Sprintf("{Section: %q, Name: %q, Value: %q}", uo.Section, uo.Name, uo.Value)
< }
< 
< // Match compares two UnitOptions and returns true if they are identical.
< func (uo *UnitOption) Match(other *UnitOption) bool {
< 	return uo.Section == other.Section &&
< 		uo.Name == other.Name &&
< 		uo.Value == other.Value
< }
< 
< // AllMatch compares two slices of UnitOptions and returns true if they are
< // identical.
< func AllMatch(u1 []*UnitOption, u2 []*UnitOption) bool {
< 	length := len(u1)
< 	if length != len(u2) {
< 		return false
< 	}
< 
< 	for i := 0; i < length; i++ {
< 		if !u1[i].Match(u2[i]) {
< 			return false
< 		}
< 	}
< 
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/unit/serialize.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/unit/serialize.go
1,75d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package unit
< 
< import (
< 	"bytes"
< 	"io"
< )
< 
< // Serialize encodes all of the given UnitOption objects into a
< // unit file. When serialized the options are sorted in their
< // supplied order but grouped by section.
< func Serialize(opts []*UnitOption) io.Reader {
< 	var buf bytes.Buffer
< 
< 	if len(opts) == 0 {
< 		return &buf
< 	}
< 
< 	// Index of sections -> ordered options
< 	idx := map[string][]*UnitOption{}
< 	// Separately preserve order in which sections were seen
< 	sections := []string{}
< 	for _, opt := range opts {
< 		sec := opt.Section
< 		if _, ok := idx[sec]; !ok {
< 			sections = append(sections, sec)
< 		}
< 		idx[sec] = append(idx[sec], opt)
< 	}
< 
< 	for i, sect := range sections {
< 		writeSectionHeader(&buf, sect)
< 		writeNewline(&buf)
< 
< 		opts := idx[sect]
< 		for _, opt := range opts {
< 			writeOption(&buf, opt)
< 			writeNewline(&buf)
< 		}
< 		if i < len(sections)-1 {
< 			writeNewline(&buf)
< 		}
< 	}
< 
< 	return &buf
< }
< 
< func writeNewline(buf *bytes.Buffer) {
< 	buf.WriteRune('\n')
< }
< 
< func writeSectionHeader(buf *bytes.Buffer, section string) {
< 	buf.WriteRune('[')
< 	buf.WriteString(section)
< 	buf.WriteRune(']')
< }
< 
< func writeOption(buf *bytes.Buffer, opt *UnitOption) {
< 	buf.WriteString(opt.Name)
< 	buf.WriteRune('=')
< 	buf.WriteString(opt.Value)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/LICENSE
1,191d0
< Apache License
< Version 2.0, January 2004
< http://www.apache.org/licenses/
< 
< TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
< 
< 1. Definitions.
< 
< "License" shall mean the terms and conditions for use, reproduction, and
< distribution as defined by Sections 1 through 9 of this document.
< 
< "Licensor" shall mean the copyright owner or entity authorized by the copyright
< owner that is granting the License.
< 
< "Legal Entity" shall mean the union of the acting entity and all other entities
< that control, are controlled by, or are under common control with that entity.
< For the purposes of this definition, "control" means (i) the power, direct or
< indirect, to cause the direction or management of such entity, whether by
< contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the
< outstanding shares, or (iii) beneficial ownership of such entity.
< 
< "You" (or "Your") shall mean an individual or Legal Entity exercising
< permissions granted by this License.
< 
< "Source" form shall mean the preferred form for making modifications, including
< but not limited to software source code, documentation source, and configuration
< files.
< 
< "Object" form shall mean any form resulting from mechanical transformation or
< translation of a Source form, including but not limited to compiled object code,
< generated documentation, and conversions to other media types.
< 
< "Work" shall mean the work of authorship, whether in Source or Object form, made
< available under the License, as indicated by a copyright notice that is included
< in or attached to the work (an example is provided in the Appendix below).
< 
< "Derivative Works" shall mean any work, whether in Source or Object form, that
< is based on (or derived from) the Work and for which the editorial revisions,
< annotations, elaborations, or other modifications represent, as a whole, an
< original work of authorship. For the purposes of this License, Derivative Works
< shall not include works that remain separable from, or merely link (or bind by
< name) to the interfaces of, the Work and Derivative Works thereof.
< 
< "Contribution" shall mean any work of authorship, including the original version
< of the Work and any modifications or additions to that Work or Derivative Works
< thereof, that is intentionally submitted to Licensor for inclusion in the Work
< by the copyright owner or by an individual or Legal Entity authorized to submit
< on behalf of the copyright owner. For the purposes of this definition,
< "submitted" means any form of electronic, verbal, or written communication sent
< to the Licensor or its representatives, including but not limited to
< communication on electronic mailing lists, source code control systems, and
< issue tracking systems that are managed by, or on behalf of, the Licensor for
< the purpose of discussing and improving the Work, but excluding communication
< that is conspicuously marked or otherwise designated in writing by the copyright
< owner as "Not a Contribution."
< 
< "Contributor" shall mean Licensor and any individual or Legal Entity on behalf
< of whom a Contribution has been received by Licensor and subsequently
< incorporated within the Work.
< 
< 2. Grant of Copyright License.
< 
< Subject to the terms and conditions of this License, each Contributor hereby
< grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
< irrevocable copyright license to reproduce, prepare Derivative Works of,
< publicly display, publicly perform, sublicense, and distribute the Work and such
< Derivative Works in Source or Object form.
< 
< 3. Grant of Patent License.
< 
< Subject to the terms and conditions of this License, each Contributor hereby
< grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,
< irrevocable (except as stated in this section) patent license to make, have
< made, use, offer to sell, sell, import, and otherwise transfer the Work, where
< such license applies only to those patent claims licensable by such Contributor
< that are necessarily infringed by their Contribution(s) alone or by combination
< of their Contribution(s) with the Work to which such Contribution(s) was
< submitted. If You institute patent litigation against any entity (including a
< cross-claim or counterclaim in a lawsuit) alleging that the Work or a
< Contribution incorporated within the Work constitutes direct or contributory
< patent infringement, then any patent licenses granted to You under this License
< for that Work shall terminate as of the date such litigation is filed.
< 
< 4. Redistribution.
< 
< You may reproduce and distribute copies of the Work or Derivative Works thereof
< in any medium, with or without modifications, and in Source or Object form,
< provided that You meet the following conditions:
< 
< You must give any other recipients of the Work or Derivative Works a copy of
< this License; and
< You must cause any modified files to carry prominent notices stating that You
< changed the files; and
< You must retain, in the Source form of any Derivative Works that You distribute,
< all copyright, patent, trademark, and attribution notices from the Source form
< of the Work, excluding those notices that do not pertain to any part of the
< Derivative Works; and
< If the Work includes a "NOTICE" text file as part of its distribution, then any
< Derivative Works that You distribute must include a readable copy of the
< attribution notices contained within such NOTICE file, excluding those notices
< that do not pertain to any part of the Derivative Works, in at least one of the
< following places: within a NOTICE text file distributed as part of the
< Derivative Works; within the Source form or documentation, if provided along
< with the Derivative Works; or, within a display generated by the Derivative
< Works, if and wherever such third-party notices normally appear. The contents of
< the NOTICE file are for informational purposes only and do not modify the
< License. You may add Your own attribution notices within Derivative Works that
< You distribute, alongside or as an addendum to the NOTICE text from the Work,
< provided that such additional attribution notices cannot be construed as
< modifying the License.
< You may add Your own copyright statement to Your modifications and may provide
< additional or different license terms and conditions for use, reproduction, or
< distribution of Your modifications, or for any such Derivative Works as a whole,
< provided Your use, reproduction, and distribution of the Work otherwise complies
< with the conditions stated in this License.
< 
< 5. Submission of Contributions.
< 
< Unless You explicitly state otherwise, any Contribution intentionally submitted
< for inclusion in the Work by You to the Licensor shall be under the terms and
< conditions of this License, without any additional terms or conditions.
< Notwithstanding the above, nothing herein shall supersede or modify the terms of
< any separate license agreement you may have executed with Licensor regarding
< such Contributions.
< 
< 6. Trademarks.
< 
< This License does not grant permission to use the trade names, trademarks,
< service marks, or product names of the Licensor, except as required for
< reasonable and customary use in describing the origin of the Work and
< reproducing the content of the NOTICE file.
< 
< 7. Disclaimer of Warranty.
< 
< Unless required by applicable law or agreed to in writing, Licensor provides the
< Work (and each Contributor provides its Contributions) on an "AS IS" BASIS,
< WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,
< including, without limitation, any warranties or conditions of TITLE,
< NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are
< solely responsible for determining the appropriateness of using or
< redistributing the Work and assume any risks associated with Your exercise of
< permissions under this License.
< 
< 8. Limitation of Liability.
< 
< In no event and under no legal theory, whether in tort (including negligence),
< contract, or otherwise, unless required by applicable law (such as deliberate
< and grossly negligent acts) or agreed to in writing, shall any Contributor be
< liable to You for damages, including any direct, indirect, special, incidental,
< or consequential damages of any character arising as a result of this License or
< out of the use or inability to use the Work (including but not limited to
< damages for loss of goodwill, work stoppage, computer failure or malfunction, or
< any and all other commercial damages or losses), even if such Contributor has
< been advised of the possibility of such damages.
< 
< 9. Accepting Warranty or Additional Liability.
< 
< While redistributing the Work or Derivative Works thereof, You may choose to
< offer, and charge a fee for, acceptance of support, warranty, indemnity, or
< other liability obligations and/or rights consistent with this License. However,
< in accepting such obligations, You may act only on Your own behalf and on Your
< sole responsibility, not on behalf of any other Contributor, and only if You
< agree to indemnify, defend, and hold each Contributor harmless for any liability
< incurred by, or claims asserted against, such Contributor by reason of your
< accepting any such warranty or additional liability.
< 
< END OF TERMS AND CONDITIONS
< 
< APPENDIX: How to apply the Apache License to your work
< 
< To apply the Apache License to your work, attach the following boilerplate
< notice, with the fields enclosed by brackets "[]" replaced with your own
< identifying information. (Don't include the brackets!) The text should be
< enclosed in the appropriate comment syntax for the file format. We also
< recommend that a file or class name and description of purpose be included on
< the same "printed page" as the copyright notice for easier identification within
< third-party archives.
< 
<    Copyright [yyyy] [name of copyright owner]
< 
<    Licensed under the Apache License, Version 2.0 (the "License");
<    you may not use this file except in compliance with the License.
<    You may obtain a copy of the License at
< 
<      http://www.apache.org/licenses/LICENSE-2.0
< 
<    Unless required by applicable law or agreed to in writing, software
<    distributed under the License is distributed on an "AS IS" BASIS,
<    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<    See the License for the specific language governing permissions and
<    limitations under the License.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/NOTICE updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/NOTICE
1,5d0
< CoreOS Project
< Copyright 2018 CoreOS, Inc
< 
< This product includes software developed at CoreOS, Inc.
< (http://www.coreos.com/).
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/unit/deserialize.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/unit/deserialize.go
1,278d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package unit
< 
< import (
< 	"bufio"
< 	"bytes"
< 	"errors"
< 	"fmt"
< 	"io"
< 	"strings"
< 	"unicode"
< )
< 
< const (
< 	// SYSTEMD_LINE_MAX mimics the maximum line length that systemd can use.
< 	// On typical systemd platforms (i.e. modern Linux), this will most
< 	// commonly be 2048, so let's use that as a sanity check.
< 	// Technically, we should probably pull this at runtime:
< 	//    SYSTEMD_LINE_MAX = int(C.sysconf(C.__SC_LINE_MAX))
< 	// but this would introduce an (unfortunate) dependency on cgo
< 	SYSTEMD_LINE_MAX = 2048
< 
< 	// SYSTEMD_NEWLINE defines characters that systemd considers indicators
< 	// for a newline.
< 	SYSTEMD_NEWLINE = "\r\n"
< )
< 
< var (
< 	// ErrLineTooLong gets returned when a line is too long for systemd to handle.
< 	ErrLineTooLong = fmt.Errorf("line too long (max %d bytes)", SYSTEMD_LINE_MAX)
< )
< 
< // Deserialize parses a systemd unit file into a list of UnitOption objects.
< func Deserialize(f io.Reader) (opts []*UnitOption, err error) {
< 	lexer, optchan, errchan := newLexer(f)
< 	go lexer.lex()
< 
< 	for opt := range optchan {
< 		opts = append(opts, &(*opt))
< 	}
< 
< 	err = <-errchan
< 	return opts, err
< }
< 
< func newLexer(f io.Reader) (*lexer, <-chan *UnitOption, <-chan error) {
< 	optchan := make(chan *UnitOption)
< 	errchan := make(chan error, 1)
< 	buf := bufio.NewReader(f)
< 
< 	return &lexer{buf, optchan, errchan, ""}, optchan, errchan
< }
< 
< type lexer struct {
< 	buf     *bufio.Reader
< 	optchan chan *UnitOption
< 	errchan chan error
< 	section string
< }
< 
< func (l *lexer) lex() {
< 	defer func() {
< 		close(l.optchan)
< 		close(l.errchan)
< 	}()
< 	next := l.lexNextSection
< 	for next != nil {
< 		if l.buf.Buffered() >= SYSTEMD_LINE_MAX {
< 			// systemd truncates lines longer than LINE_MAX
< 			// https://bugs.freedesktop.org/show_bug.cgi?id=85308
< 			// Rather than allowing this to pass silently, let's
< 			// explicitly gate people from encountering this
< 			line, err := l.buf.Peek(SYSTEMD_LINE_MAX)
< 			if err != nil {
< 				l.errchan <- err
< 				return
< 			}
< 			if !bytes.ContainsAny(line, SYSTEMD_NEWLINE) {
< 				l.errchan <- ErrLineTooLong
< 				return
< 			}
< 		}
< 
< 		var err error
< 		next, err = next()
< 		if err != nil {
< 			l.errchan <- err
< 			return
< 		}
< 	}
< }
< 
< type lexStep func() (lexStep, error)
< 
< func (l *lexer) lexSectionName() (lexStep, error) {
< 	sec, err := l.buf.ReadBytes(']')
< 	if err != nil {
< 		return nil, errors.New("unable to find end of section")
< 	}
< 
< 	return l.lexSectionSuffixFunc(string(sec[:len(sec)-1])), nil
< }
< 
< func (l *lexer) lexSectionSuffixFunc(section string) lexStep {
< 	return func() (lexStep, error) {
< 		garbage, _, err := l.toEOL()
< 		if err != nil {
< 			return nil, err
< 		}
< 
< 		garbage = bytes.TrimSpace(garbage)
< 		if len(garbage) > 0 {
< 			return nil, fmt.Errorf("found garbage after section name %s: %v", l.section, garbage)
< 		}
< 
< 		return l.lexNextSectionOrOptionFunc(section), nil
< 	}
< }
< 
< func (l *lexer) ignoreLineFunc(next lexStep) lexStep {
< 	return func() (lexStep, error) {
< 		for {
< 			line, _, err := l.toEOL()
< 			if err != nil {
< 				return nil, err
< 			}
< 
< 			line = bytes.TrimSuffix(line, []byte{' '})
< 
< 			// lack of continuation means this line has been exhausted
< 			if !bytes.HasSuffix(line, []byte{'\\'}) {
< 				break
< 			}
< 		}
< 
< 		// reached end of buffer, safe to exit
< 		return next, nil
< 	}
< }
< 
< func (l *lexer) lexNextSection() (lexStep, error) {
< 	r, _, err := l.buf.ReadRune()
< 	if err != nil {
< 		if err == io.EOF {
< 			err = nil
< 		}
< 		return nil, err
< 	}
< 
< 	if r == '[' {
< 		return l.lexSectionName, nil
< 	} else if isComment(r) {
< 		return l.ignoreLineFunc(l.lexNextSection), nil
< 	}
< 
< 	return l.lexNextSection, nil
< }
< 
< func (l *lexer) lexNextSectionOrOptionFunc(section string) lexStep {
< 	return func() (lexStep, error) {
< 		r, _, err := l.buf.ReadRune()
< 		if err != nil {
< 			if err == io.EOF {
< 				err = nil
< 			}
< 			return nil, err
< 		}
< 
< 		if unicode.IsSpace(r) {
< 			return l.lexNextSectionOrOptionFunc(section), nil
< 		} else if r == '[' {
< 			return l.lexSectionName, nil
< 		} else if isComment(r) {
< 			return l.ignoreLineFunc(l.lexNextSectionOrOptionFunc(section)), nil
< 		}
< 
< 		l.buf.UnreadRune()
< 		return l.lexOptionNameFunc(section), nil
< 	}
< }
< 
< func (l *lexer) lexOptionNameFunc(section string) lexStep {
< 	return func() (lexStep, error) {
< 		var partial bytes.Buffer
< 		for {
< 			r, _, err := l.buf.ReadRune()
< 			if err != nil {
< 				return nil, err
< 			}
< 
< 			if r == '\n' || r == '\r' {
< 				return nil, errors.New("unexpected newline encountered while parsing option name")
< 			}
< 
< 			if r == '=' {
< 				break
< 			}
< 
< 			partial.WriteRune(r)
< 		}
< 
< 		name := strings.TrimSpace(partial.String())
< 		return l.lexOptionValueFunc(section, name, bytes.Buffer{}), nil
< 	}
< }
< 
< func (l *lexer) lexOptionValueFunc(section, name string, partial bytes.Buffer) lexStep {
< 	return func() (lexStep, error) {
< 		for {
< 			line, eof, err := l.toEOL()
< 			if err != nil {
< 				return nil, err
< 			}
< 
< 			if len(bytes.TrimSpace(line)) == 0 {
< 				break
< 			}
< 
< 			partial.Write(line)
< 
< 			// lack of continuation means this value has been exhausted
< 			idx := bytes.LastIndex(line, []byte{'\\'})
< 			if idx == -1 || idx != (len(line)-1) {
< 				break
< 			}
< 
< 			if !eof {
< 				partial.WriteRune('\n')
< 			}
< 
< 			return l.lexOptionValueFunc(section, name, partial), nil
< 		}
< 
< 		val := partial.String()
< 		if strings.HasSuffix(val, "\n") {
< 			// A newline was added to the end, so the file didn't end with a backslash.
< 			// => Keep the newline
< 			val = strings.TrimSpace(val) + "\n"
< 		} else {
< 			val = strings.TrimSpace(val)
< 		}
< 		l.optchan <- &UnitOption{Section: section, Name: name, Value: val}
< 
< 		return l.lexNextSectionOrOptionFunc(section), nil
< 	}
< }
< 
< // toEOL reads until the end-of-line or end-of-file.
< // Returns (data, EOFfound, error)
< func (l *lexer) toEOL() ([]byte, bool, error) {
< 	line, err := l.buf.ReadBytes('\n')
< 	// ignore EOF here since it's roughly equivalent to EOL
< 	if err != nil && err != io.EOF {
< 		return nil, false, err
< 	}
< 
< 	line = bytes.TrimSuffix(line, []byte{'\r'})
< 	line = bytes.TrimSuffix(line, []byte{'\n'})
< 
< 	return line, err == io.EOF, nil
< }
< 
< func isComment(r rune) bool {
< 	return r == '#' || r == ';'
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/unit/escape.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/unit/escape.go
1,116d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< // Implements systemd-escape [--unescape] [--path]
< 
< package unit
< 
< import (
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< const (
< 	allowed = `:_.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`
< )
< 
< // If isPath is true:
< //   We remove redundant '/'s, the leading '/', and trailing '/'.
< //   If the result is empty, a '/' is inserted.
< //
< // We always:
< //  Replace the following characters with `\x%x`:
< //   Leading `.`
< //   `-`, `\`, and anything not in this set: `:-_.\[0-9a-zA-Z]`
< //  Replace '/' with '-'.
< func escape(unescaped string, isPath bool) string {
< 	e := []byte{}
< 	inSlashes := false
< 	start := true
< 	for i := 0; i < len(unescaped); i++ {
< 		c := unescaped[i]
< 		if isPath {
< 			if c == '/' {
< 				inSlashes = true
< 				continue
< 			} else if inSlashes {
< 				inSlashes = false
< 				if !start {
< 					e = append(e, '-')
< 				}
< 			}
< 		}
< 
< 		if c == '/' {
< 			e = append(e, '-')
< 		} else if start && c == '.' || strings.IndexByte(allowed, c) == -1 {
< 			e = append(e, []byte(fmt.Sprintf(`\x%x`, c))...)
< 		} else {
< 			e = append(e, c)
< 		}
< 		start = false
< 	}
< 	if isPath && len(e) == 0 {
< 		e = append(e, '-')
< 	}
< 	return string(e)
< }
< 
< // If isPath is true:
< //   We always return a string beginning with '/'.
< //
< // We always:
< //  Replace '-' with '/'.
< //  Replace `\x%x` with the value represented in hex.
< func unescape(escaped string, isPath bool) string {
< 	u := []byte{}
< 	for i := 0; i < len(escaped); i++ {
< 		c := escaped[i]
< 		if c == '-' {
< 			c = '/'
< 		} else if c == '\\' && len(escaped)-i >= 4 && escaped[i+1] == 'x' {
< 			n, err := strconv.ParseInt(escaped[i+2:i+4], 16, 8)
< 			if err == nil {
< 				c = byte(n)
< 				i += 3
< 			}
< 		}
< 		u = append(u, c)
< 	}
< 	if isPath && (len(u) == 0 || u[0] != '/') {
< 		u = append([]byte("/"), u...)
< 	}
< 	return string(u)
< }
< 
< // UnitNameEscape escapes a string as `systemd-escape` would
< func UnitNameEscape(unescaped string) string {
< 	return escape(unescaped, false)
< }
< 
< // UnitNameUnescape unescapes a string as `systemd-escape --unescape` would
< func UnitNameUnescape(escaped string) string {
< 	return unescape(escaped, false)
< }
< 
< // UnitNamePathEscape escapes a string as `systemd-escape --path` would
< func UnitNamePathEscape(unescaped string) string {
< 	return escape(unescaped, true)
< }
< 
< // UnitNamePathUnescape unescapes a string as `systemd-escape --path --unescape` would
< func UnitNamePathUnescape(escaped string) string {
< 	return unescape(escaped, true)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/unit/option.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/unit/option.go
1,59d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package unit
< 
< import (
< 	"fmt"
< )
< 
< // UnitOption represents an option in a systemd unit file.
< type UnitOption struct {
< 	Section string
< 	Name    string
< 	Value   string
< }
< 
< // NewUnitOption returns a new UnitOption instance with pre-set values.
< func NewUnitOption(section, name, value string) *UnitOption {
< 	return &UnitOption{Section: section, Name: name, Value: value}
< }
< 
< func (uo *UnitOption) String() string {
< 	return fmt.Sprintf("{Section: %q, Name: %q, Value: %q}", uo.Section, uo.Name, uo.Value)
< }
< 
< // Match compares two UnitOptions and returns true if they are identical.
< func (uo *UnitOption) Match(other *UnitOption) bool {
< 	return uo.Section == other.Section &&
< 		uo.Name == other.Name &&
< 		uo.Value == other.Value
< }
< 
< // AllMatch compares two slices of UnitOptions and returns true if they are
< // identical.
< func AllMatch(u1 []*UnitOption, u2 []*UnitOption) bool {
< 	length := len(u1)
< 	if length != len(u2) {
< 		return false
< 	}
< 
< 	for i := 0; i < length; i++ {
< 		if !u1[i].Match(u2[i]) {
< 			return false
< 		}
< 	}
< 
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/unit/serialize.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/go-systemd/v22/unit/serialize.go
1,75d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package unit
< 
< import (
< 	"bytes"
< 	"io"
< )
< 
< // Serialize encodes all of the given UnitOption objects into a
< // unit file. When serialized the options are sorted in their
< // supplied order but grouped by section.
< func Serialize(opts []*UnitOption) io.Reader {
< 	var buf bytes.Buffer
< 
< 	if len(opts) == 0 {
< 		return &buf
< 	}
< 
< 	// Index of sections -> ordered options
< 	idx := map[string][]*UnitOption{}
< 	// Separately preserve order in which sections were seen
< 	sections := []string{}
< 	for _, opt := range opts {
< 		sec := opt.Section
< 		if _, ok := idx[sec]; !ok {
< 			sections = append(sections, sec)
< 		}
< 		idx[sec] = append(idx[sec], opt)
< 	}
< 
< 	for i, sect := range sections {
< 		writeSectionHeader(&buf, sect)
< 		writeNewline(&buf)
< 
< 		opts := idx[sect]
< 		for _, opt := range opts {
< 			writeOption(&buf, opt)
< 			writeNewline(&buf)
< 		}
< 		if i < len(sections)-1 {
< 			writeNewline(&buf)
< 		}
< 	}
< 
< 	return &buf
< }
< 
< func writeNewline(buf *bytes.Buffer) {
< 	buf.WriteRune('\n')
< }
< 
< func writeSectionHeader(buf *bytes.Buffer, section string) {
< 	buf.WriteRune('[')
< 	buf.WriteString(section)
< 	buf.WriteRune(']')
< }
< 
< func writeOption(buf *bytes.Buffer, opt *UnitOption) {
< 	buf.WriteString(opt.Name)
< 	buf.WriteRune('=')
< 	buf.WriteString(opt.Value)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/LICENSE
1,202d0
< Apache License
<                            Version 2.0, January 2004
<                         http://www.apache.org/licenses/
< 
<    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
< 
<    1. Definitions.
< 
<       "License" shall mean the terms and conditions for use, reproduction,
<       and distribution as defined by Sections 1 through 9 of this document.
< 
<       "Licensor" shall mean the copyright owner or entity authorized by
<       the copyright owner that is granting the License.
< 
<       "Legal Entity" shall mean the union of the acting entity and all
<       other entities that control, are controlled by, or are under common
<       control with that entity. For the purposes of this definition,
<       "control" means (i) the power, direct or indirect, to cause the
<       direction or management of such entity, whether by contract or
<       otherwise, or (ii) ownership of fifty percent (50%) or more of the
<       outstanding shares, or (iii) beneficial ownership of such entity.
< 
<       "You" (or "Your") shall mean an individual or Legal Entity
<       exercising permissions granted by this License.
< 
<       "Source" form shall mean the preferred form for making modifications,
<       including but not limited to software source code, documentation
<       source, and configuration files.
< 
<       "Object" form shall mean any form resulting from mechanical
<       transformation or translation of a Source form, including but
<       not limited to compiled object code, generated documentation,
<       and conversions to other media types.
< 
<       "Work" shall mean the work of authorship, whether in Source or
<       Object form, made available under the License, as indicated by a
<       copyright notice that is included in or attached to the work
<       (an example is provided in the Appendix below).
< 
<       "Derivative Works" shall mean any work, whether in Source or Object
<       form, that is based on (or derived from) the Work and for which the
<       editorial revisions, annotations, elaborations, or other modifications
<       represent, as a whole, an original work of authorship. For the purposes
<       of this License, Derivative Works shall not include works that remain
<       separable from, or merely link (or bind by name) to the interfaces of,
<       the Work and Derivative Works thereof.
< 
<       "Contribution" shall mean any work of authorship, including
<       the original version of the Work and any modifications or additions
<       to that Work or Derivative Works thereof, that is intentionally
<       submitted to Licensor for inclusion in the Work by the copyright owner
<       or by an individual or Legal Entity authorized to submit on behalf of
<       the copyright owner. For the purposes of this definition, "submitted"
<       means any form of electronic, verbal, or written communication sent
<       to the Licensor or its representatives, including but not limited to
<       communication on electronic mailing lists, source code control systems,
<       and issue tracking systems that are managed by, or on behalf of, the
<       Licensor for the purpose of discussing and improving the Work, but
<       excluding communication that is conspicuously marked or otherwise
<       designated in writing by the copyright owner as "Not a Contribution."
< 
<       "Contributor" shall mean Licensor and any individual or Legal Entity
<       on behalf of whom a Contribution has been received by Licensor and
<       subsequently incorporated within the Work.
< 
<    2. Grant of Copyright License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       copyright license to reproduce, prepare Derivative Works of,
<       publicly display, publicly perform, sublicense, and distribute the
<       Work and such Derivative Works in Source or Object form.
< 
<    3. Grant of Patent License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       (except as stated in this section) patent license to make, have made,
<       use, offer to sell, sell, import, and otherwise transfer the Work,
<       where such license applies only to those patent claims licensable
<       by such Contributor that are necessarily infringed by their
<       Contribution(s) alone or by combination of their Contribution(s)
<       with the Work to which such Contribution(s) was submitted. If You
<       institute patent litigation against any entity (including a
<       cross-claim or counterclaim in a lawsuit) alleging that the Work
<       or a Contribution incorporated within the Work constitutes direct
<       or contributory patent infringement, then any patent licenses
<       granted to You under this License for that Work shall terminate
<       as of the date such litigation is filed.
< 
<    4. Redistribution. You may reproduce and distribute copies of the
<       Work or Derivative Works thereof in any medium, with or without
<       modifications, and in Source or Object form, provided that You
<       meet the following conditions:
< 
<       (a) You must give any other recipients of the Work or
<           Derivative Works a copy of this License; and
< 
<       (b) You must cause any modified files to carry prominent notices
<           stating that You changed the files; and
< 
<       (c) You must retain, in the Source form of any Derivative Works
<           that You distribute, all copyright, patent, trademark, and
<           attribution notices from the Source form of the Work,
<           excluding those notices that do not pertain to any part of
<           the Derivative Works; and
< 
<       (d) If the Work includes a "NOTICE" text file as part of its
<           distribution, then any Derivative Works that You distribute must
<           include a readable copy of the attribution notices contained
<           within such NOTICE file, excluding those notices that do not
<           pertain to any part of the Derivative Works, in at least one
<           of the following places: within a NOTICE text file distributed
<           as part of the Derivative Works; within the Source form or
<           documentation, if provided along with the Derivative Works; or,
<           within a display generated by the Derivative Works, if and
<           wherever such third-party notices normally appear. The contents
<           of the NOTICE file are for informational purposes only and
<           do not modify the License. You may add Your own attribution
<           notices within Derivative Works that You distribute, alongside
<           or as an addendum to the NOTICE text from the Work, provided
<           that such additional attribution notices cannot be construed
<           as modifying the License.
< 
<       You may add Your own copyright statement to Your modifications and
<       may provide additional or different license terms and conditions
<       for use, reproduction, or distribution of Your modifications, or
<       for any such Derivative Works as a whole, provided Your use,
<       reproduction, and distribution of the Work otherwise complies with
<       the conditions stated in this License.
< 
<    5. Submission of Contributions. Unless You explicitly state otherwise,
<       any Contribution intentionally submitted for inclusion in the Work
<       by You to the Licensor shall be under the terms and conditions of
<       this License, without any additional terms or conditions.
<       Notwithstanding the above, nothing herein shall supersede or modify
<       the terms of any separate license agreement you may have executed
<       with Licensor regarding such Contributions.
< 
<    6. Trademarks. This License does not grant permission to use the trade
<       names, trademarks, service marks, or product names of the Licensor,
<       except as required for reasonable and customary use in describing the
<       origin of the Work and reproducing the content of the NOTICE file.
< 
<    7. Disclaimer of Warranty. Unless required by applicable law or
<       agreed to in writing, Licensor provides the Work (and each
<       Contributor provides its Contributions) on an "AS IS" BASIS,
<       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
<       implied, including, without limitation, any warranties or conditions
<       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
<       PARTICULAR PURPOSE. You are solely responsible for determining the
<       appropriateness of using or redistributing the Work and assume any
<       risks associated with Your exercise of permissions under this License.
< 
<    8. Limitation of Liability. In no event and under no legal theory,
<       whether in tort (including negligence), contract, or otherwise,
<       unless required by applicable law (such as deliberate and grossly
<       negligent acts) or agreed to in writing, shall any Contributor be
<       liable to You for damages, including any direct, indirect, special,
<       incidental, or consequential damages of any character arising as a
<       result of this License or out of the use or inability to use the
<       Work (including but not limited to damages for loss of goodwill,
<       work stoppage, computer failure or malfunction, or any and all
<       other commercial damages or losses), even if such Contributor
<       has been advised of the possibility of such damages.
< 
<    9. Accepting Warranty or Additional Liability. While redistributing
<       the Work or Derivative Works thereof, You may choose to offer,
<       and charge a fee for, acceptance of support, warranty, indemnity,
<       or other liability obligations and/or rights consistent with this
<       License. However, in accepting such obligations, You may act only
<       on Your own behalf and on Your sole responsibility, not on behalf
<       of any other Contributor, and only if You agree to indemnify,
<       defend, and hold each Contributor harmless for any liability
<       incurred by, or claims asserted against, such Contributor by reason
<       of your accepting any such warranty or additional liability.
< 
<    END OF TERMS AND CONDITIONS
< 
<    APPENDIX: How to apply the Apache License to your work.
< 
<       To apply the Apache License to your work, attach the following
<       boilerplate notice, with the fields enclosed by brackets "{}"
<       replaced with your own identifying information. (Don't include
<       the brackets!)  The text should be enclosed in the appropriate
<       comment syntax for the file format. We also recommend that a
<       file or class name and description of purpose be included on the
<       same "printed page" as the copyright notice for easier
<       identification within third-party archives.
< 
<    Copyright {yyyy} {name of copyright owner}
< 
<    Licensed under the Apache License, Version 2.0 (the "License");
<    you may not use this file except in compliance with the License.
<    You may obtain a copy of the License at
< 
<        http://www.apache.org/licenses/LICENSE-2.0
< 
<    Unless required by applicable law or agreed to in writing, software
<    distributed under the License is distributed on an "AS IS" BASIS,
<    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<    See the License for the specific language governing permissions and
<    limitations under the License.
< 
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/NOTICE updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/NOTICE
1,5d0
< CoreOS Project
< Copyright 2015 CoreOS, Inc
< 
< This product includes software developed at CoreOS, Inc.
< (http://www.coreos.com/).
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/merge/merge.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/merge/merge.go
1,387d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package merge
< 
< import (
< 	"fmt"
< 	"reflect"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< )
< 
< // Rules of Config Merging:
< // 1) Parent and child configs must be the same version/type
< // 2) Only valid configs can be merged
< // 3) It is possible to merge two valid configs and get an invalid config
< // 3) For structs:
< //   a) Members that are structs get merged recursively (i.e. ignition.storage)
< //   b) Members that are primitives get replaced by the child's member (e.g. ignition.storage.files[i].path)
< //   c) Members that are pointers only get replaced by the child's value if the child's value is non-nil (e.g. ignition.config.replace.source)
< //   d) List merging of a list with IgnoreDuplicates: append the lists (e.g. ignition.storage.files[i].append)
< //   e) List merging of a list not merged with other lists: merge any entries with the same Key() and append the others (e.g. ignition.storage.filesystems by path)
< //   f) List merging of a list merged with other lists: (e.g. ignition.storage.{files,links,directories} by path)
< //      - merge entries with the same Key() that are in the same list
< //      - remove entries from the parent with the same Key() that are not in the same list
< //      - append entries that are unique to the child
< 
< const (
< 	TAG_PARENT = "parent"
< 	TAG_CHILD  = "child"
< 	TAG_RESULT = "result"
< )
< 
< // The path to one output field, and its corresponding input.  From.Tag will
< // be TAG_PARENT or TAG_CHILD depending on the origin of the field.
< type Mapping struct {
< 	From path.ContextPath
< 	To   path.ContextPath
< }
< 
< func (m Mapping) String() string {
< 	return fmt.Sprintf("%s:%s → %s", m.From.Tag, m.From, m.To)
< }
< 
< type Transcript struct {
< 	Mappings []Mapping
< }
< 
< func (t Transcript) String() string {
< 	var lines []string
< 	for _, m := range t.Mappings {
< 		lines = append(lines, m.String())
< 	}
< 	return strings.Join(lines, "\n")
< }
< 
< // pathAppendField looks up the JSON field name for field and returns base
< // with that field name appended.
< func pathAppendField(base path.ContextPath, field reflect.StructField) path.ContextPath {
< 	tagName := strings.Split(field.Tag.Get("json"), ",")[0]
< 	if tagName != "" {
< 		return base.Append(tagName)
< 	}
< 	if field.Anonymous {
< 		// field is a struct embedded in another struct (e.g.
< 		// FileEmbedded1).  Pretend it doesn't exist.
< 		return base
< 	}
< 	panic("no JSON struct tag for " + field.Name)
< }
< 
< // appendToSlice is a helper that appends to a slice without returning a new one.
< // panics if len >= cap
< func appendToSlice(s, v reflect.Value) {
< 	s.SetLen(s.Len() + 1)
< 	s.Index(s.Len() - 1).Set(v)
< }
< 
< type handleKey struct {
< 	handle string
< 	key    string
< }
< 
< // structInfo holds information about a struct being processed and has helper methods for querying that
< // information in a way that is more clear what the intent is.
< type structInfo struct {
< 	// set of field names to not do duplicate merging on
< 	ignoreDups map[string]struct{}
< 
< 	// map from field names to a handle indicating all those with the same handle should have duplication
< 	// checking done across all fields that share that handle
< 	mergedKeys map[string]string
< 
< 	// map from each handle + key() to the corresponding item
< 	keysToValues map[handleKey]reflect.Value
< 
< 	// map from each handle + key() to the list it came from
< 	keysToLists map[handleKey]string
< 
< 	// map from each handle + key() to the index within the list
< 	keysToListIndexes map[handleKey]int
< }
< 
< // returns if this field should not do duplicate checking/merging
< func (s structInfo) ignoreField(name string) bool {
< 	_, ignore := s.ignoreDups[name]
< 	return ignore
< }
< 
< // getChildEntryByKey takes the name of a field (not handle) in the parent and a key and looks that entry
< // up in the child. It will look up across all slices that share the same handle. It returns the value,
< // name of the field in the child it was found in, and the list index within that field. The bool indicates
< // whether it was found.
< func (s structInfo) getChildEntryByKey(fieldName, key string) (reflect.Value, string, int, bool) {
< 	handle := fieldName
< 	if tmp, ok := s.mergedKeys[fieldName]; ok {
< 		handle = tmp
< 	}
< 
< 	hkey := handleKey{
< 		handle: handle,
< 		key:    key,
< 	}
< 	if v, ok := s.keysToValues[hkey]; ok {
< 		return v, s.keysToLists[hkey], s.keysToListIndexes[hkey], true
< 	}
< 	return reflect.Value{}, "", 0, false
< }
< 
< func newStructInfo(parent, child reflect.Value) structInfo {
< 	ignoreDups := map[string]struct{}{}
< 	if ignorer, ok := parent.Interface().(util.IgnoresDups); ok {
< 		ignoreDups = ignorer.IgnoreDuplicates()
< 	}
< 
< 	mergedKeys := map[string]string{}
< 	if merger, ok := parent.Interface().(util.MergesKeys); ok {
< 		mergedKeys = merger.MergedKeys()
< 	}
< 
< 	keysToValues := map[handleKey]reflect.Value{}
< 	keysToLists := map[handleKey]string{}
< 	keysToListIndexes := map[handleKey]int{}
< 	for i := 0; i < child.NumField(); i++ {
< 		field := child.Field(i)
< 		if field.Kind() != reflect.Slice {
< 			continue
< 		}
< 
< 		fieldName := child.Type().Field(i).Name
< 		if _, ok := ignoreDups[fieldName]; ok {
< 			continue
< 		}
< 
< 		handle := fieldName
< 		if tmp, ok := mergedKeys[handle]; ok {
< 			handle = tmp
< 		}
< 
< 		for j := 0; j < field.Len(); j++ {
< 			v := field.Index(j)
< 			hkey := handleKey{
< 				handle: handle,
< 				key:    util.CallKey(v),
< 			}
< 			keysToValues[hkey] = v
< 			keysToLists[hkey] = fieldName
< 			keysToListIndexes[hkey] = j
< 		}
< 	}
< 
< 	return structInfo{
< 		ignoreDups:        ignoreDups,
< 		mergedKeys:        mergedKeys,
< 		keysToValues:      keysToValues,
< 		keysToLists:       keysToLists,
< 		keysToListIndexes: keysToListIndexes,
< 	}
< }
< 
< // Deprecated: Use MergeStructTranscribe() instead.
< func MergeStruct(parent, child reflect.Value) reflect.Value {
< 	result, _ := MergeStructTranscribe(parent.Interface(), child.Interface())
< 	return reflect.ValueOf(result)
< }
< 
< // MergeStructTranscribe is intended for use by config/vX_Y/ packages and
< // by generic external translation code.  Most users should use the properly
< // typed wrappers provided by the config/vX_Y/ packages.
< //
< // MergeStructTranscribe merges the specified configs and returns a
< // transcript of the actions taken.  parent and child MUST be the same type.
< func MergeStructTranscribe(parent, child interface{}) (interface{}, Transcript) {
< 	var transcript Transcript
< 	result := mergeStruct(reflect.ValueOf(parent), path.New(TAG_PARENT), reflect.ValueOf(child), path.New(TAG_CHILD), path.New(TAG_RESULT), &transcript)
< 	return result.Interface(), transcript
< }
< 
< // parent and child MUST be the same type
< // we transcribe all leaf fields, and all intermediate structs that wholly
< // originate from either parent or child
< func mergeStruct(parent reflect.Value, parentPath path.ContextPath, child reflect.Value, childPath path.ContextPath, resultPath path.ContextPath, transcript *Transcript) reflect.Value {
< 	// use New() so it's settable, addr-able, etc
< 	result := reflect.New(parent.Type()).Elem()
< 	info := newStructInfo(parent, child)
< 
< 	for i := 0; i < parent.NumField(); i++ {
< 		fieldMeta := parent.Type().Field(i)
< 		parentField := parent.Field(i)
< 		childField := child.Field(i)
< 		resultField := result.Field(i)
< 		parentFieldPath := pathAppendField(parentPath, fieldMeta)
< 		childFieldPath := pathAppendField(childPath, fieldMeta)
< 		resultFieldPath := pathAppendField(resultPath, fieldMeta)
< 
< 		kind := parentField.Kind()
< 		switch {
< 		case util.IsPrimitive(kind):
< 			resultField.Set(childField)
< 			transcribe(childFieldPath, resultFieldPath, resultField, fieldMeta, transcript)
< 		case kind == reflect.Ptr && !parentField.IsNil() && !childField.IsNil() && parentField.Elem().Kind() == reflect.Struct:
< 			// we're not supposed to have struct pointers, but some
< 			// ended up in the Clevis and Luks structs in spec 3.2.0
< 			// https://github.com/coreos/ignition/issues/1132
< 			resultField.Set(mergeStruct(parentField.Elem(), parentFieldPath, childField.Elem(), childFieldPath, resultFieldPath, transcript).Addr())
< 		case kind == reflect.Ptr && childField.IsNil():
< 			resultField.Set(parentField)
< 			transcribe(parentFieldPath, resultFieldPath, resultField, fieldMeta, transcript)
< 		case kind == reflect.Ptr && !childField.IsNil():
< 			resultField.Set(childField)
< 			transcribe(childFieldPath, resultFieldPath, resultField, fieldMeta, transcript)
< 		case kind == reflect.Struct:
< 			resultField.Set(mergeStruct(parentField, parentFieldPath, childField, childFieldPath, resultFieldPath, transcript))
< 		case kind == reflect.Slice && info.ignoreField(fieldMeta.Name):
< 			if parentField.Len()+childField.Len() == 0 {
< 				continue
< 			}
< 			resultField.Set(reflect.MakeSlice(parentField.Type(), 0, parentField.Len()+childField.Len()))
< 			for i := 0; i < parentField.Len(); i++ {
< 				item := parentField.Index(i)
< 				appendToSlice(resultField, item)
< 				transcribe(parentFieldPath.Append(i), resultFieldPath.Append(i), item, fieldMeta, transcript)
< 			}
< 			for i := 0; i < childField.Len(); i++ {
< 				item := childField.Index(i)
< 				appendToSlice(resultField, item)
< 				transcribe(childFieldPath.Append(i), resultFieldPath.Append(parentField.Len()+i), item, fieldMeta, transcript)
< 			}
< 		case kind == reflect.Slice && !info.ignoreField(fieldMeta.Name):
< 			// ooph, this is a doosey
< 			maxlen := parentField.Len() + childField.Len()
< 			if maxlen == 0 {
< 				continue
< 			}
< 			resultField.Set(reflect.MakeSlice(parentField.Type(), 0, parentField.Len()+childField.Len()))
< 			parentKeys := getKeySet(parentField)
< 
< 			// walk parent items
< 			for i := 0; i < parentField.Len(); i++ {
< 				parentItem := parentField.Index(i)
< 				parentItemPath := parentFieldPath.Append(i)
< 				resultItemPath := resultFieldPath.Append(resultField.Len())
< 				key := util.CallKey(parentItem)
< 
< 				if childItem, childList, childListIndex, ok := info.getChildEntryByKey(fieldMeta.Name, key); ok {
< 					if childList == fieldMeta.Name {
< 						// case 1: in child config in same list
< 						childItemPath := childFieldPath.Append(childListIndex)
< 						if childItem.Kind() == reflect.Struct {
< 							// If HTTP header Value is nil, it means that we should remove the
< 							// parent header from the result.
< 							if fieldMeta.Name == "HTTPHeaders" && childItem.FieldByName("Value").IsNil() {
< 								continue
< 							}
< 							appendToSlice(resultField, mergeStruct(parentItem, parentItemPath, childItem, childItemPath, resultItemPath, transcript))
< 						} else if util.IsPrimitive(childItem.Kind()) {
< 							appendToSlice(resultField, childItem)
< 							transcribe(childItemPath, resultItemPath, childItem, fieldMeta, transcript)
< 						} else {
< 							panic("List of pointers or slices or something else weird")
< 						}
< 					} else {
< 						// case 2: in child config in different list. Do nothing since it'll be handled iterating over that list
< 					}
< 				} else {
< 					// case 3: not in child config, append it
< 					appendToSlice(resultField, parentItem)
< 					transcribe(parentItemPath, resultItemPath, parentItem, fieldMeta, transcript)
< 				}
< 			}
< 			// append child items not in parent
< 			for i := 0; i < childField.Len(); i++ {
< 				childItem := childField.Index(i)
< 				childItemPath := childFieldPath.Append(i)
< 				resultItemPath := resultFieldPath.Append(resultField.Len())
< 				key := util.CallKey(childItem)
< 				if _, alreadyMerged := parentKeys[key]; !alreadyMerged {
< 					// We only check the parentMap for this field. If the parent had a matching entry in a different field
< 					// then it would be skipped as case 2 above
< 					appendToSlice(resultField, childItem)
< 					transcribe(childItemPath, resultItemPath, childItem, fieldMeta, transcript)
< 				}
< 			}
< 		default:
< 			panic("unreachable code reached")
< 		}
< 	}
< 
< 	return result
< }
< 
< // transcribe is called by mergeStruct when the latter decides to merge a
< // subtree wholesale from either the parent or child, and thus loses
< // interest in that subtree.  transcribe descends the rest of that subtree,
< // transcribing all of its populated leaves.  It returns true if we
< // transcribed anything.
< func transcribe(fromPath path.ContextPath, toPath path.ContextPath, value reflect.Value, fieldMeta reflect.StructField, transcript *Transcript) bool {
< 	add := func(from, to path.ContextPath) {
< 		transcript.Mappings = append(transcript.Mappings, Mapping{
< 			From: from.Copy(),
< 			To:   to.Copy(),
< 		})
< 	}
< 
< 	kind := value.Kind()
< 	switch {
< 	case util.IsPrimitive(kind):
< 		if value.Interface() == reflect.Zero(value.Type()).Interface() {
< 			return false
< 		}
< 		add(fromPath, toPath)
< 	case kind == reflect.Ptr:
< 		if value.IsNil() {
< 			return false
< 		}
< 		if value.Elem().Kind() == reflect.Struct {
< 			// we're not supposed to have struct pointers, but some
< 			// ended up in the Clevis and Luks structs in spec 3.2.0
< 			// https://github.com/coreos/ignition/issues/1132
< 			return transcribe(fromPath, toPath, value.Elem(), fieldMeta, transcript)
< 		}
< 		add(fromPath, toPath)
< 	case kind == reflect.Struct:
< 		var transcribed bool
< 		for i := 0; i < value.NumField(); i++ {
< 			valueFieldMeta := value.Type().Field(i)
< 			transcribed = transcribe(pathAppendField(fromPath, valueFieldMeta), pathAppendField(toPath, valueFieldMeta), value.Field(i), valueFieldMeta, transcript) || transcribed
< 		}
< 		// embedded structs and empty structs should be invisible
< 		if transcribed && !fieldMeta.Anonymous {
< 			add(fromPath, toPath)
< 		}
< 		return transcribed
< 	case kind == reflect.Slice:
< 		var transcribed bool
< 		for i := 0; i < value.Len(); i++ {
< 			transcribed = transcribe(fromPath.Append(i), toPath.Append(i), value.Index(i), fieldMeta, transcript) || transcribed
< 		}
< 		return transcribed
< 	default:
< 		panic("unreachable code reached")
< 	}
< 	return true
< }
< 
< // getKeySet takes a value of a slice and returns the set of all the Key() values in that slice
< func getKeySet(list reflect.Value) map[string]struct{} {
< 	m := map[string]struct{}{}
< 	for i := 0; i < list.Len(); i++ {
< 		m[util.CallKey(list.Index(i))] = struct{}{}
< 	}
< 	return m
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/shared/errors/errors.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/shared/errors/errors.go
1,109d0
< // Copyright 2018 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< // Package errors includes errors that are used in multiple config versions
< package errors
< 
< import (
< 	"errors"
< 	"fmt"
< )
< 
< var (
< 	// Parsing / general errors
< 	ErrInvalid   = errors.New("config is not valid")
< 	ErrEmpty     = errors.New("not a config (empty)")
< 	ErrDuplicate = errors.New("duplicate entry defined")
< 
< 	// Ignition section errors
< 	ErrInvalidVersion = errors.New("invalid config version (couldn't parse)")
< 	ErrUnknownVersion = errors.New("unsupported config version")
< 
< 	ErrDeprecated         = errors.New("config format deprecated")
< 	ErrCompressionInvalid = errors.New("invalid compression method")
< 
< 	// Storage section errors
< 	ErrFileUsedSymlink           = errors.New("file path includes link in config")
< 	ErrDirectoryUsedSymlink      = errors.New("directory path includes link in config")
< 	ErrLinkUsedSymlink           = errors.New("link path includes link in config")
< 	ErrHardLinkToDirectory       = errors.New("hard link target is a directory")
< 	ErrDiskDeviceRequired        = errors.New("disk device is required")
< 	ErrPartitionNumbersCollide   = errors.New("partition numbers collide")
< 	ErrPartitionsOverlap         = errors.New("partitions overlap")
< 	ErrPartitionsMisaligned      = errors.New("partitions misaligned")
< 	ErrOverwriteAndNilSource     = errors.New("overwrite must be false if source is unspecified")
< 	ErrVerificationAndNilSource  = errors.New("source must be specified if verification is specified")
< 	ErrFilesystemInvalidFormat   = errors.New("invalid filesystem format")
< 	ErrLabelNeedsFormat          = errors.New("filesystem must specify format if label is specified")
< 	ErrFormatNilWithOthers       = errors.New("format cannot be empty when path, label, uuid, or options are specified")
< 	ErrExt4LabelTooLong          = errors.New("filesystem labels cannot be longer than 16 characters when using ext4")
< 	ErrBtrfsLabelTooLong         = errors.New("filesystem labels cannot be longer than 256 characters when using btrfs")
< 	ErrXfsLabelTooLong           = errors.New("filesystem labels cannot be longer than 12 characters when using xfs")
< 	ErrSwapLabelTooLong          = errors.New("filesystem labels cannot be longer than 15 characters when using swap")
< 	ErrVfatLabelTooLong          = errors.New("filesystem labels cannot be longer than 11 characters when using vfat")
< 	ErrLuksLabelTooLong          = errors.New("luks device labels cannot be longer than 47 characters")
< 	ErrLuksNameContainsSlash     = errors.New("device names cannot contain slashes")
< 	ErrInvalidLuksKeyFile        = errors.New("invalid key-file source")
< 	ErrUnknownClevisPin          = errors.New("unsupported clevis pin")
< 	ErrClevisConfigRequired      = errors.New("missing required custom clevis config")
< 	ErrClevisCustomWithOthers    = errors.New("cannot use custom clevis config with tpm2, tang, or threshold")
< 	ErrTangThumbprintRequired    = errors.New("thumbprint is required")
< 	ErrFileIllegalMode           = errors.New("illegal file mode")
< 	ErrBothIDAndNameSet          = errors.New("cannot set both id and name")
< 	ErrLabelTooLong              = errors.New("partition labels may not exceed 36 characters")
< 	ErrDoesntMatchGUIDRegex      = errors.New("doesn't match the form \"01234567-89AB-CDEF-EDCB-A98765432101\"")
< 	ErrLabelContainsColon        = errors.New("partition label will be truncated to text before the colon")
< 	ErrNoPath                    = errors.New("path not specified")
< 	ErrPathRelative              = errors.New("path not absolute")
< 	ErrDirtyPath                 = errors.New("path is not fully simplified")
< 	ErrSparesUnsupportedForLevel = errors.New("spares unsupported for arrays with a level greater than 0")
< 	ErrUnrecognizedRaidLevel     = errors.New("unrecognized raid level")
< 	ErrShouldNotExistWithOthers  = errors.New("shouldExist specified false with other options also specified")
< 	ErrZeroesWithShouldNotExist  = errors.New("shouldExist is false for a partition and other partition(s) has start or size 0")
< 	ErrNeedLabelOrNumber         = errors.New("a partition number >= 1 or a label must be specified")
< 	ErrDuplicateLabels           = errors.New("cannot use the same partition label twice")
< 	ErrInvalidProxy              = errors.New("proxies must be http(s)")
< 	ErrInsecureProxy             = errors.New("insecure plaintext HTTP proxy specified for HTTPS resources")
< 
< 	// Systemd section errors
< 	ErrInvalidSystemdExt       = errors.New("invalid systemd unit extension")
< 	ErrInvalidSystemdDropinExt = errors.New("invalid systemd drop-in extension")
< 	ErrNoSystemdExt            = errors.New("no systemd unit extension")
< 	ErrInvalidInstantiatedUnit = errors.New("invalid systemd instantiated unit")
< 
< 	// Misc errors
< 	ErrSourceRequired                  = errors.New("source is required")
< 	ErrInvalidScheme                   = errors.New("invalid url scheme")
< 	ErrInvalidUrl                      = errors.New("unable to parse url")
< 	ErrInvalidHTTPHeader               = errors.New("unable to parse HTTP header")
< 	ErrEmptyHTTPHeaderName             = errors.New("HTTP header name can't be empty")
< 	ErrUnsupportedSchemeForHTTPHeaders = errors.New("cannot use HTTP headers with this source scheme")
< 	ErrHashMalformed                   = errors.New("malformed hash specifier")
< 	ErrHashWrongSize                   = errors.New("incorrect size for hash sum")
< 	ErrHashUnrecognized                = errors.New("unrecognized hash function")
< 	ErrEngineConfiguration             = errors.New("engine incorrectly configured")
< 
< 	// AWS S3 specific errors
< 	ErrInvalidS3ObjectVersionId = errors.New("invalid S3 object VersionId")
< 
< 	// Obsolete errors, left here for ABI compatibility
< 	ErrFilePermissionsUnset      = errors.New("permissions unset, defaulting to 0644")
< 	ErrDirectoryPermissionsUnset = errors.New("permissions unset, defaulting to 0755")
< )
< 
< // NewNoInstallSectionError produces an error indicating the given unit, named
< // name, is missing an Install section.
< func NewNoInstallSectionError(name string) error {
< 	return fmt.Errorf("unit %q is enabled, but has no install section so enable does nothing", name)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/shared/validations/unit.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/shared/validations/unit.go
1,49d0
< // Copyright 2018 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< // Package validations contains validations shared between multiple config
< // versions.
< package validations
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/go-systemd/v22/unit"
< )
< 
< // ValidateInstallSection is a helper to validate a given unit
< func ValidateInstallSection(name string, enabled bool, contentsEmpty bool, contentSections []*unit.UnitOption) error {
< 	if !enabled {
< 		// install sections don't matter for not-enabled units
< 		return nil
< 	}
< 	if contentsEmpty {
< 		// install sections don't matter if it has no contents, e.g. it's being masked or just has dropins or such
< 		return nil
< 	}
< 	if contentSections == nil {
< 		// Should only happen if the unit could not be parsed, at which point an
< 		// error is probably already in the report so we don't need to double-up on
< 		// errors + warnings.
< 		return nil
< 	}
< 
< 	for _, section := range contentSections {
< 		if section.Section == "Install" {
< 			return nil
< 		}
< 	}
< 
< 	return errors.NewNoInstallSectionError(name)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/util/helpers.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/util/helpers.go
1,35d0
< // Copyright 2018 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package util
< 
< func IntToPtr(x int) *int {
< 	return &x
< }
< 
< func StrToPtr(s string) *string {
< 	return &s
< }
< 
< func BoolToPtr(b bool) *bool {
< 	return &b
< }
< 
< func NilOrEmpty(s *string) bool {
< 	return s == nil || *s == ""
< }
< 
< func NotEmpty(s *string) bool {
< 	return s != nil && *s != ""
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/util/interfaces.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/util/interfaces.go
1,39d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package util
< 
< import (
< 	"reflect"
< )
< 
< type MergesKeys interface {
< 	MergedKeys() map[string]string
< }
< 
< type IgnoresDups interface {
< 	IgnoreDuplicates() map[string]struct{}
< }
< 
< type Keyed interface {
< 	Key() string
< }
< 
< // CallKey is a helper to call the Key() function since this needs to happen a lot
< func CallKey(v reflect.Value) string {
< 	if v.Kind() == reflect.String {
< 		return v.Convert(reflect.TypeOf("")).Interface().(string)
< 	}
< 	return v.Interface().(Keyed).Key()
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/util/parsingErrors.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/util/parsingErrors.go
1,48d0
< // Copyright 2018 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package util
< 
< import (
< 	"encoding/json"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/coreos/vcontext/tree"
< )
< 
< // HandleParseErrors will attempt to unmarshal an invalid rawConfig into "to".
< // If it fails to unmarsh it will generate a report.Report from the errors.
< func HandleParseErrors(rawConfig []byte, to interface{}) (report.Report, error) {
< 	r := report.Report{}
< 	err := json.Unmarshal(rawConfig, to)
< 	if err == nil {
< 		return report.Report{}, nil
< 	}
< 
< 	var node tree.Leaf
< 	switch t := err.(type) {
< 	case *json.SyntaxError:
< 		node.Marker = tree.MarkerFromIndices(t.Offset, -1)
< 	case *json.UnmarshalTypeError:
< 		node.Marker = tree.MarkerFromIndices(t.Offset, -1)
< 	}
< 	tree.FixLineColumn(node, rawConfig)
< 	r.AddOnError(path.ContextPath{Tag: "json"}, err)
< 	r.Correlate(node)
< 
< 	return r, errors.ErrInvalid
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/util/reflection.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/util/reflection.go
1,55d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package util
< 
< import (
< 	"reflect"
< )
< 
< func IsPrimitive(k reflect.Kind) bool {
< 	switch k {
< 	case reflect.Bool,
< 		reflect.Int,
< 		reflect.Int8,
< 		reflect.Int16,
< 		reflect.Int32,
< 		reflect.Int64,
< 		reflect.Uint,
< 		reflect.Uint8,
< 		reflect.Uint16,
< 		reflect.Uint32,
< 		reflect.Uint64,
< 		reflect.Uintptr,
< 		reflect.Float32,
< 		reflect.Float64,
< 		reflect.Complex64,
< 		reflect.Complex128,
< 		reflect.String:
< 		return true
< 	default:
< 		return false
< 	}
< }
< 
< func IsInvalidInConfig(k reflect.Kind) bool {
< 	switch {
< 	case IsPrimitive(k):
< 		return false
< 	case k == reflect.Ptr || k == reflect.Slice || k == reflect.Struct:
< 		return false
< 	default:
< 		return true
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/ca.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/ca.go
1,29d0
< // Copyright 2018 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (c CaReference) Key() string {
< 	return c.Source
< }
< 
< func (ca CaReference) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("source"), validateURL(ca.Source))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/config.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/config.go
1,26d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/go-semver/semver"
< )
< 
< var (
< 	MaxVersion = semver.Version{
< 		Major: 3,
< 		Minor: 0,
< 	}
< )
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/device.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/device.go
1,25d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Device) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validatePath(string(d)))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/directory.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/directory.go
1,26d0
< // Copyright 2017 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Directory) Validate(c path.ContextPath) (r report.Report) {
< 	r.Merge(d.Node.Validate(c))
< 	r.AddOnError(c.Append("mode"), validateMode(d.Mode))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/disk.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/disk.go
1,134d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Disk) Key() string {
< 	return d.Device
< }
< 
< func (n Disk) Validate(c path.ContextPath) (r report.Report) {
< 	if len(n.Device) == 0 {
< 		r.AddOnError(c.Append("device"), errors.ErrDiskDeviceRequired)
< 		return
< 	}
< 	r.AddOnError(c.Append("device"), validatePath(n.Device))
< 
< 	if collides, p := n.partitionNumbersCollide(); collides {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionNumbersCollide)
< 	}
< 	if overlaps, p := n.partitionsOverlap(); overlaps {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionsOverlap)
< 	}
< 	if n.partitionsMixZeroesAndNonexistence() {
< 		r.AddOnError(c.Append("partitions"), errors.ErrZeroesWithShouldNotExist)
< 	}
< 	if collides, p := n.partitionLabelsCollide(); collides {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrDuplicateLabels)
< 	}
< 	return
< }
< 
< // partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique. It also returns the
< // index of the colliding partition
< func (n Disk) partitionNumbersCollide() (bool, int) {
< 	m := map[int][]int{} // from partition number to index into array
< 	for i, p := range n.Partitions {
< 		if p.Number != 0 {
< 			// a number of 0 means next available number, multiple devices can specify this
< 			m[p.Number] = append(m[p.Number], i)
< 		}
< 	}
< 	for _, n := range m {
< 		if len(n) > 1 {
< 			// TODO(vc): return information describing the collision for logging
< 			return true, n[1]
< 		}
< 	}
< 	return false, 0
< }
< 
< func (d Disk) partitionLabelsCollide() (bool, int) {
< 	m := map[string]struct{}{}
< 	for i, p := range d.Partitions {
< 		if p.Label != nil {
< 			// a number of 0 means next available number, multiple devices can specify this
< 			if _, exists := m[*p.Label]; exists {
< 				return true, i
< 			}
< 			m[*p.Label] = struct{}{}
< 		}
< 	}
< 	return false, 0
< }
< 
< // end returns the last sector of a partition. Only used by partitionsOverlap. Requires non-nil Start and Size.
< func (p Partition) end() int {
< 	if *p.SizeMiB == 0 {
< 		// a size of 0 means "fill available", just return the start as the end for those.
< 		return *p.StartMiB
< 	}
< 	return *p.StartMiB + *p.SizeMiB - 1
< }
< 
< // partitionsOverlap returns true if any explicitly dimensioned partitions overlap. It also returns the index of
< // the overlapping partition
< func (n Disk) partitionsOverlap() (bool, int) {
< 	for _, p := range n.Partitions {
< 		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
< 		// We aren't going to check those for overlap since we don't have the disk geometry.
< 		if p.StartMiB == nil || p.SizeMiB == nil || *p.StartMiB == 0 {
< 			continue
< 		}
< 
< 		for i, o := range n.Partitions {
< 			if o.StartMiB == nil || o.SizeMiB == nil || p == o || *o.StartMiB == 0 {
< 				continue
< 			}
< 
< 			// is p.StartMiB within o?
< 			if *p.StartMiB >= *o.StartMiB && *p.StartMiB <= o.end() {
< 				return true, i
< 			}
< 
< 			// is p.end() within o?
< 			if p.end() >= *o.StartMiB && p.end() <= o.end() {
< 				return true, i
< 			}
< 
< 			// do p.StartMiB and p.end() straddle o?
< 			if *p.StartMiB < *o.StartMiB && p.end() > o.end() {
< 				return true, i
< 			}
< 		}
< 	}
< 	return false, 0
< }
< 
< func (n Disk) partitionsMixZeroesAndNonexistence() bool {
< 	hasZero := false
< 	hasShouldNotExist := false
< 	for _, p := range n.Partitions {
< 		hasShouldNotExist = hasShouldNotExist || (p.ShouldExist != nil && !*p.ShouldExist)
< 		hasZero = hasZero || (p.Number == 0)
< 	}
< 	return hasZero && hasShouldNotExist
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/file.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/file.go
1,67d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (f File) Validate(c path.ContextPath) (r report.Report) {
< 	r.Merge(f.Node.Validate(c))
< 	r.AddOnError(c.Append("mode"), validateMode(f.Mode))
< 	r.AddOnError(c.Append("overwrite"), f.validateOverwrite())
< 	return
< }
< 
< func (f File) validateOverwrite() error {
< 	if f.Overwrite != nil && *f.Overwrite && f.Contents.Source == nil {
< 		return errors.ErrOverwriteAndNilSource
< 	}
< 	return nil
< }
< 
< func (f FileEmbedded1) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Append": {},
< 	}
< }
< 
< func (fc FileContents) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("compression"), fc.validateCompression())
< 	r.AddOnError(c.Append("verification", "hash"), fc.validateVerification())
< 	r.AddOnError(c.Append("source"), validateURLNilOK(fc.Source))
< 	return
< }
< 
< func (fc FileContents) validateCompression() error {
< 	if fc.Compression != nil {
< 		switch *fc.Compression {
< 		case "", "gzip":
< 		default:
< 			return errors.ErrCompressionInvalid
< 		}
< 	}
< 	return nil
< }
< 
< func (fc FileContents) validateVerification() error {
< 	if fc.Verification.Hash != nil && fc.Source == nil {
< 		return errors.ErrVerificationAndNilSource
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/filesystem.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/filesystem.go
1,103d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (f Filesystem) Key() string {
< 	return f.Device
< }
< 
< func (f Filesystem) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options": {},
< 	}
< }
< 
< func (f Filesystem) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("path"), f.validatePath())
< 	r.AddOnError(c.Append("device"), validatePath(f.Device))
< 	r.AddOnError(c.Append("format"), f.validateFormat())
< 	r.AddOnError(c.Append("label"), f.validateLabel())
< 	return
< }
< 
< func (f Filesystem) validatePath() error {
< 	return validatePathNilOK(f.Path)
< }
< 
< func (f Filesystem) validateFormat() error {
< 	if util.NilOrEmpty(f.Format) {
< 		if util.NotEmpty(f.Path) ||
< 			util.NotEmpty(f.Label) ||
< 			util.NotEmpty(f.UUID) ||
< 			len(f.Options) != 0 {
< 			return errors.ErrFormatNilWithOthers
< 		}
< 	} else {
< 		switch *f.Format {
< 		case "ext4", "btrfs", "xfs", "swap", "vfat":
< 		default:
< 			return errors.ErrFilesystemInvalidFormat
< 		}
< 	}
< 	return nil
< }
< 
< func (f Filesystem) validateLabel() error {
< 	if util.NilOrEmpty(f.Label) {
< 		return nil
< 	}
< 	if util.NilOrEmpty(f.Format) {
< 		return errors.ErrLabelNeedsFormat
< 	}
< 
< 	switch *f.Format {
< 	case "ext4":
< 		if len(*f.Label) > 16 {
< 			// source: man mkfs.ext4
< 			return errors.ErrExt4LabelTooLong
< 		}
< 	case "btrfs":
< 		if len(*f.Label) > 256 {
< 			// source: man mkfs.btrfs
< 			return errors.ErrBtrfsLabelTooLong
< 		}
< 	case "xfs":
< 		if len(*f.Label) > 12 {
< 			// source: man mkfs.xfs
< 			return errors.ErrXfsLabelTooLong
< 		}
< 	case "swap":
< 		// mkswap's man page does not state a limit on label size, but through
< 		// experimentation it appears that mkswap will truncate long labels to
< 		// 15 characters, so let's enforce that.
< 		if len(*f.Label) > 15 {
< 			return errors.ErrSwapLabelTooLong
< 		}
< 	case "vfat":
< 		if len(*f.Label) > 11 {
< 			// source: man mkfs.fat
< 			return errors.ErrVfatLabelTooLong
< 		}
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/ignition.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/ignition.go
1,54d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/go-semver/semver"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (c ConfigReference) Key() string {
< 	if c.Source == nil {
< 		return ""
< 	}
< 	return *c.Source
< }
< 
< func (cr ConfigReference) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("source"), validateURLNilOK(cr.Source))
< 	return
< }
< 
< func (v Ignition) Semver() (*semver.Version, error) {
< 	return semver.NewVersion(v.Version)
< }
< 
< func (v Ignition) Validate(c path.ContextPath) (r report.Report) {
< 	c = c.Append("version")
< 	tv, err := v.Semver()
< 	if err != nil {
< 		r.AddOnError(c, errors.ErrInvalidVersion)
< 		return
< 	}
< 
< 	if MaxVersion != *tv {
< 		r.AddOnError(c, errors.ErrUnknownVersion)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/mode.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/mode.go
1,26d0
< // Copyright 2017 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< )
< 
< func validateMode(m *int) error {
< 	if m != nil && (*m < 0 || *m > 07777) {
< 		return errors.ErrFileIllegalMode
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/node.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/node.go
1,58d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	vpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (n Node) Key() string {
< 	return n.Path
< }
< 
< func (n Node) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("path"), validatePath(n.Path))
< 	return
< }
< 
< func (n Node) Depth() int {
< 	count := 0
< 	for p := path.Clean(string(n.Path)); p != "/"; count++ {
< 		p = path.Dir(p)
< 	}
< 	return count
< }
< 
< func validateIDorName(id *int, name *string) error {
< 	if id != nil && (name != nil && *name != "") {
< 		return errors.ErrBothIDAndNameSet
< 	}
< 	return nil
< }
< 
< func (nu NodeUser) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validateIDorName(nu.ID, nu.Name))
< 	return
< }
< 
< func (ng NodeGroup) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validateIDorName(ng.ID, ng.Name))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/partition.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/partition.go
1,88d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"fmt"
< 	"regexp"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< const (
< 	guidRegexStr = "^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$"
< )
< 
< var (
< 	guidRegex = regexp.MustCompile(guidRegexStr)
< )
< 
< func (p Partition) Key() string {
< 	if p.Number != 0 {
< 		return fmt.Sprintf("number:%d", p.Number)
< 	} else {
< 		return fmt.Sprintf("label:%s", *p.Label)
< 	}
< }
< 
< func (p Partition) Validate(c path.ContextPath) (r report.Report) {
< 	if p.ShouldExist != nil && !*p.ShouldExist &&
< 		(p.Label != nil || (p.TypeGUID != nil && *p.TypeGUID != "") || (p.GUID != nil && *p.GUID != "") || p.StartMiB != nil || p.SizeMiB != nil) {
< 		r.AddOnError(c, errors.ErrShouldNotExistWithOthers)
< 	}
< 	if p.Number == 0 && p.Label == nil {
< 		r.AddOnError(c, errors.ErrNeedLabelOrNumber)
< 	}
< 
< 	r.AddOnError(c.Append("label"), p.validateLabel())
< 	r.AddOnError(c.Append("guid"), validateGUID(p.GUID))
< 	r.AddOnError(c.Append("typeGuid"), validateGUID(p.TypeGUID))
< 	return
< }
< 
< func (p Partition) validateLabel() error {
< 	if p.Label == nil {
< 		return nil
< 	}
< 	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
< 	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
< 
< 	// XXX(vc): note GPT calls it a name, we're using label for consistency
< 	// with udev naming /dev/disk/by-partlabel/*.
< 	if len(*p.Label) > 36 {
< 		return errors.ErrLabelTooLong
< 	}
< 
< 	// sgdisk uses colons for delimitting compound arguments and does not allow escaping them.
< 	if strings.Contains(*p.Label, ":") {
< 		return errors.ErrLabelContainsColon
< 	}
< 	return nil
< }
< 
< func validateGUID(guidPointer *string) error {
< 	if guidPointer == nil {
< 		return nil
< 	}
< 	guid := *guidPointer
< 	if ok := guidRegex.MatchString(guid); !ok {
< 		return errors.ErrDoesntMatchGUIDRegex
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/passwd.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/passwd.go
1,23d0
< // Copyright 2017 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< func (p PasswdUser) Key() string {
< 	return p.Name
< }
< 
< func (g PasswdGroup) Key() string {
< 	return g.Name
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/path.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/path.go
1,42d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< )
< 
< func validatePath(p string) error {
< 	if p == "" {
< 		return errors.ErrNoPath
< 	}
< 	if !path.IsAbs(p) {
< 		return errors.ErrPathRelative
< 	}
< 	if path.Clean(p) != p {
< 		return errors.ErrDirtyPath
< 	}
< 	return nil
< }
< 
< func validatePathNilOK(p *string) error {
< 	if util.NilOrEmpty(p) {
< 		return nil
< 	}
< 	return validatePath(*p)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/raid.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/raid.go
1,55d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (r Raid) Key() string {
< 	return r.Name
< }
< 
< func (r Raid) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options": {},
< 	}
< }
< 
< func (ra Raid) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("level"), ra.validateLevel())
< 	return
< }
< 
< func (r Raid) validateLevel() error {
< 	switch r.Level {
< 	case "linear", "raid0", "0", "stripe":
< 		if r.Spares != nil && *r.Spares != 0 {
< 			return errors.ErrSparesUnsupportedForLevel
< 		}
< 	case "raid1", "1", "mirror":
< 	case "raid4", "4":
< 	case "raid5", "5":
< 	case "raid6", "6":
< 	case "raid10", "10":
< 	default:
< 		return errors.ErrUnrecognizedRaidLevel
< 	}
< 
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/schema.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/schema.go
1,201d0
< package types
< 
< // generated by "schematyper --package=types config/v3_0/schema/ignition.json -o config/v3_0/types/schema.go --root-type=Config" -- DO NOT EDIT
< 
< type CaReference struct {
< 	Source       string       `json:"source"`
< 	Verification Verification `json:"verification,omitempty"`
< }
< 
< type Config struct {
< 	Ignition Ignition `json:"ignition"`
< 	Passwd   Passwd   `json:"passwd,omitempty"`
< 	Storage  Storage  `json:"storage,omitempty"`
< 	Systemd  Systemd  `json:"systemd,omitempty"`
< }
< 
< type ConfigReference struct {
< 	Source       *string      `json:"source"`
< 	Verification Verification `json:"verification,omitempty"`
< }
< 
< type Device string
< 
< type Directory struct {
< 	Node
< 	DirectoryEmbedded1
< }
< 
< type DirectoryEmbedded1 struct {
< 	Mode *int `json:"mode,omitempty"`
< }
< 
< type Disk struct {
< 	Device     string      `json:"device"`
< 	Partitions []Partition `json:"partitions,omitempty"`
< 	WipeTable  *bool       `json:"wipeTable,omitempty"`
< }
< 
< type Dropin struct {
< 	Contents *string `json:"contents,omitempty"`
< 	Name     string  `json:"name"`
< }
< 
< type File struct {
< 	Node
< 	FileEmbedded1
< }
< 
< type FileContents struct {
< 	Compression  *string      `json:"compression,omitempty"`
< 	Source       *string      `json:"source,omitempty"`
< 	Verification Verification `json:"verification,omitempty"`
< }
< 
< type FileEmbedded1 struct {
< 	Append   []FileContents `json:"append,omitempty"`
< 	Contents FileContents   `json:"contents,omitempty"`
< 	Mode     *int           `json:"mode,omitempty"`
< }
< 
< type Filesystem struct {
< 	Device         string             `json:"device"`
< 	Format         *string            `json:"format,omitempty"`
< 	Label          *string            `json:"label,omitempty"`
< 	Options        []FilesystemOption `json:"options,omitempty"`
< 	Path           *string            `json:"path,omitempty"`
< 	UUID           *string            `json:"uuid,omitempty"`
< 	WipeFilesystem *bool              `json:"wipeFilesystem,omitempty"`
< }
< 
< type FilesystemOption string
< 
< type Group string
< 
< type Ignition struct {
< 	Config   IgnitionConfig `json:"config,omitempty"`
< 	Security Security       `json:"security,omitempty"`
< 	Timeouts Timeouts       `json:"timeouts,omitempty"`
< 	Version  string         `json:"version,omitempty"`
< }
< 
< type IgnitionConfig struct {
< 	Merge   []ConfigReference `json:"merge,omitempty"`
< 	Replace ConfigReference   `json:"replace,omitempty"`
< }
< 
< type Link struct {
< 	Node
< 	LinkEmbedded1
< }
< 
< type LinkEmbedded1 struct {
< 	Hard   *bool  `json:"hard,omitempty"`
< 	Target string `json:"target"`
< }
< 
< type Node struct {
< 	Group     NodeGroup `json:"group,omitempty"`
< 	Overwrite *bool     `json:"overwrite,omitempty"`
< 	Path      string    `json:"path"`
< 	User      NodeUser  `json:"user,omitempty"`
< }
< 
< type NodeGroup struct {
< 	ID   *int    `json:"id,omitempty"`
< 	Name *string `json:"name,omitempty"`
< }
< 
< type NodeUser struct {
< 	ID   *int    `json:"id,omitempty"`
< 	Name *string `json:"name,omitempty"`
< }
< 
< type Partition struct {
< 	GUID               *string `json:"guid,omitempty"`
< 	Label              *string `json:"label,omitempty"`
< 	Number             int     `json:"number,omitempty"`
< 	ShouldExist        *bool   `json:"shouldExist,omitempty"`
< 	SizeMiB            *int    `json:"sizeMiB,omitempty"`
< 	StartMiB           *int    `json:"startMiB,omitempty"`
< 	TypeGUID           *string `json:"typeGuid,omitempty"`
< 	WipePartitionEntry *bool   `json:"wipePartitionEntry,omitempty"`
< }
< 
< type Passwd struct {
< 	Groups []PasswdGroup `json:"groups,omitempty"`
< 	Users  []PasswdUser  `json:"users,omitempty"`
< }
< 
< type PasswdGroup struct {
< 	Gid          *int    `json:"gid,omitempty"`
< 	Name         string  `json:"name"`
< 	PasswordHash *string `json:"passwordHash,omitempty"`
< 	System       *bool   `json:"system,omitempty"`
< }
< 
< type PasswdUser struct {
< 	Gecos             *string            `json:"gecos,omitempty"`
< 	Groups            []Group            `json:"groups,omitempty"`
< 	HomeDir           *string            `json:"homeDir,omitempty"`
< 	Name              string             `json:"name"`
< 	NoCreateHome      *bool              `json:"noCreateHome,omitempty"`
< 	NoLogInit         *bool              `json:"noLogInit,omitempty"`
< 	NoUserGroup       *bool              `json:"noUserGroup,omitempty"`
< 	PasswordHash      *string            `json:"passwordHash,omitempty"`
< 	PrimaryGroup      *string            `json:"primaryGroup,omitempty"`
< 	SSHAuthorizedKeys []SSHAuthorizedKey `json:"sshAuthorizedKeys,omitempty"`
< 	Shell             *string            `json:"shell,omitempty"`
< 	System            *bool              `json:"system,omitempty"`
< 	UID               *int               `json:"uid,omitempty"`
< }
< 
< type Raid struct {
< 	Devices []Device     `json:"devices"`
< 	Level   string       `json:"level"`
< 	Name    string       `json:"name"`
< 	Options []RaidOption `json:"options,omitempty"`
< 	Spares  *int         `json:"spares,omitempty"`
< }
< 
< type RaidOption string
< 
< type SSHAuthorizedKey string
< 
< type Security struct {
< 	TLS TLS `json:"tls,omitempty"`
< }
< 
< type Storage struct {
< 	Directories []Directory  `json:"directories,omitempty"`
< 	Disks       []Disk       `json:"disks,omitempty"`
< 	Files       []File       `json:"files,omitempty"`
< 	Filesystems []Filesystem `json:"filesystems,omitempty"`
< 	Links       []Link       `json:"links,omitempty"`
< 	Raid        []Raid       `json:"raid,omitempty"`
< }
< 
< type Systemd struct {
< 	Units []Unit `json:"units,omitempty"`
< }
< 
< type TLS struct {
< 	CertificateAuthorities []CaReference `json:"certificateAuthorities,omitempty"`
< }
< 
< type Timeouts struct {
< 	HTTPResponseHeaders *int `json:"httpResponseHeaders,omitempty"`
< 	HTTPTotal           *int `json:"httpTotal,omitempty"`
< }
< 
< type Unit struct {
< 	Contents *string  `json:"contents,omitempty"`
< 	Dropins  []Dropin `json:"dropins,omitempty"`
< 	Enabled  *bool    `json:"enabled,omitempty"`
< 	Mask     *bool    `json:"mask,omitempty"`
< 	Name     string   `json:"name"`
< }
< 
< type Verification struct {
< 	Hash *string `json:"hash,omitempty"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/storage.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/storage.go
1,70d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	vpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (s Storage) MergedKeys() map[string]string {
< 	return map[string]string{
< 		"Directories": "Node",
< 		"Files":       "Node",
< 		"Links":       "Node",
< 	}
< }
< 
< func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
< 	for i, d := range s.Directories {
< 		for _, l := range s.Links {
< 			if strings.HasPrefix(d.Path, l.Path+"/") {
< 				r.AddOnError(c.Append("directories", i), errors.ErrDirectoryUsedSymlink)
< 			}
< 		}
< 	}
< 	for i, f := range s.Files {
< 		for _, l := range s.Links {
< 			if strings.HasPrefix(f.Path, l.Path+"/") {
< 				r.AddOnError(c.Append("files", i), errors.ErrFileUsedSymlink)
< 			}
< 		}
< 	}
< 	for i, l1 := range s.Links {
< 		for _, l2 := range s.Links {
< 			if strings.HasPrefix(l1.Path, l2.Path+"/") {
< 				r.AddOnError(c.Append("links", i), errors.ErrLinkUsedSymlink)
< 			}
< 		}
< 		if l1.Hard == nil || !*l1.Hard {
< 			continue
< 		}
< 		target := path.Clean(l1.Target)
< 		if !path.IsAbs(target) {
< 			target = path.Join(l1.Path, l1.Target)
< 		}
< 		for _, d := range s.Directories {
< 			if target == d.Path {
< 				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
< 			}
< 		}
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/unit.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/unit.go
1,82d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"fmt"
< 	"path"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/shared/validations"
< 
< 	"github.com/coreos/go-systemd/v22/unit"
< 	cpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (u Unit) Key() string {
< 	return u.Name
< }
< 
< func (d Dropin) Key() string {
< 	return d.Name
< }
< 
< func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("name"), validateName(u.Name))
< 	c = c.Append("contents")
< 	opts, err := validateUnitContent(u.Contents)
< 	r.AddOnError(c, err)
< 
< 	isEnabled := u.Enabled != nil && *u.Enabled
< 	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, isEnabled, (u.Contents == nil || *u.Contents == ""), opts))
< 
< 	return
< }
< 
< func validateName(name string) error {
< 	switch path.Ext(name) {
< 	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
< 	default:
< 		return errors.ErrInvalidSystemdExt
< 	}
< 	return nil
< }
< 
< func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
< 	_, err := validateUnitContent(d.Contents)
< 	r.AddOnError(c.Append("contents"), err)
< 
< 	switch path.Ext(d.Name) {
< 	case ".conf":
< 	default:
< 		r.AddOnError(c.Append("name"), errors.ErrInvalidSystemdDropinExt)
< 	}
< 
< 	return
< }
< 
< func validateUnitContent(content *string) ([]*unit.UnitOption, error) {
< 	if content == nil {
< 		return []*unit.UnitOption{}, nil
< 	}
< 	c := strings.NewReader(*content)
< 	opts, err := unit.Deserialize(c)
< 	if err != nil {
< 		return nil, fmt.Errorf("invalid unit content: %s", err)
< 	}
< 	return opts, nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/url.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/url.go
1,57d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/vincent-petithory/dataurl"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< )
< 
< func validateURL(s string) error {
< 	u, err := url.Parse(s)
< 	if err != nil {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	switch u.Scheme {
< 	case "http", "https", "tftp":
< 		return nil
< 	case "s3":
< 		if v, ok := u.Query()["versionId"]; ok {
< 			if len(v) == 0 || v[0] == "" {
< 				return errors.ErrInvalidS3ObjectVersionId
< 			}
< 		}
< 		return nil
< 	case "data":
< 		if _, err := dataurl.DecodeString(s); err != nil {
< 			return err
< 		}
< 		return nil
< 	default:
< 		return errors.ErrInvalidScheme
< 	}
< }
< 
< func validateURLNilOK(s *string) error {
< 	if util.NilOrEmpty(s) {
< 		return nil
< 	}
< 	return validateURL(*s)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/verification.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_0/types/verification.go
1,69d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"crypto"
< 	"encoding/hex"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // HashParts will return the sum and function (in that order) of the hash stored
< // in this Verification, or an error if there is an issue during parsing.
< func (v Verification) HashParts() (string, string, error) {
< 	if v.Hash == nil {
< 		// The hash can be nil
< 		return "", "", nil
< 	}
< 	parts := strings.SplitN(*v.Hash, "-", 2)
< 	if len(parts) != 2 {
< 		return "", "", errors.ErrHashMalformed
< 	}
< 
< 	return parts[0], parts[1], nil
< }
< 
< func (v Verification) Validate(c path.ContextPath) (r report.Report) {
< 	c = c.Append("hash")
< 	if v.Hash == nil {
< 		// The hash can be nil
< 		return
< 	}
< 
< 	function, sum, err := v.HashParts()
< 	if err != nil {
< 		r.AddOnError(c, err)
< 		return
< 	}
< 	var hash crypto.Hash
< 	switch function {
< 	case "sha512":
< 		hash = crypto.SHA512
< 	default:
< 		r.AddOnError(c, errors.ErrHashUnrecognized)
< 		return
< 	}
< 
< 	if len(sum) != hex.EncodedLen(hash.Size()) {
< 		r.AddOnError(c, errors.ErrHashWrongSize)
< 	}
< 
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/config.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/config.go
1,26d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/go-semver/semver"
< )
< 
< var (
< 	MaxVersion = semver.Version{
< 		Major: 3,
< 		Minor: 1,
< 	}
< )
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/device.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/device.go
1,25d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Device) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validatePath(string(d)))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/directory.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/directory.go
1,26d0
< // Copyright 2017 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Directory) Validate(c path.ContextPath) (r report.Report) {
< 	r.Merge(d.Node.Validate(c))
< 	r.AddOnError(c.Append("mode"), validateMode(d.Mode))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/disk.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/disk.go
1,134d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Disk) Key() string {
< 	return d.Device
< }
< 
< func (n Disk) Validate(c path.ContextPath) (r report.Report) {
< 	if len(n.Device) == 0 {
< 		r.AddOnError(c.Append("device"), errors.ErrDiskDeviceRequired)
< 		return
< 	}
< 	r.AddOnError(c.Append("device"), validatePath(n.Device))
< 
< 	if collides, p := n.partitionNumbersCollide(); collides {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionNumbersCollide)
< 	}
< 	if overlaps, p := n.partitionsOverlap(); overlaps {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionsOverlap)
< 	}
< 	if n.partitionsMixZeroesAndNonexistence() {
< 		r.AddOnError(c.Append("partitions"), errors.ErrZeroesWithShouldNotExist)
< 	}
< 	if collides, p := n.partitionLabelsCollide(); collides {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrDuplicateLabels)
< 	}
< 	return
< }
< 
< // partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique. It also returns the
< // index of the colliding partition
< func (n Disk) partitionNumbersCollide() (bool, int) {
< 	m := map[int][]int{} // from partition number to index into array
< 	for i, p := range n.Partitions {
< 		if p.Number != 0 {
< 			// a number of 0 means next available number, multiple devices can specify this
< 			m[p.Number] = append(m[p.Number], i)
< 		}
< 	}
< 	for _, n := range m {
< 		if len(n) > 1 {
< 			// TODO(vc): return information describing the collision for logging
< 			return true, n[1]
< 		}
< 	}
< 	return false, 0
< }
< 
< func (d Disk) partitionLabelsCollide() (bool, int) {
< 	m := map[string]struct{}{}
< 	for i, p := range d.Partitions {
< 		if p.Label != nil {
< 			// a number of 0 means next available number, multiple devices can specify this
< 			if _, exists := m[*p.Label]; exists {
< 				return true, i
< 			}
< 			m[*p.Label] = struct{}{}
< 		}
< 	}
< 	return false, 0
< }
< 
< // end returns the last sector of a partition. Only used by partitionsOverlap. Requires non-nil Start and Size.
< func (p Partition) end() int {
< 	if *p.SizeMiB == 0 {
< 		// a size of 0 means "fill available", just return the start as the end for those.
< 		return *p.StartMiB
< 	}
< 	return *p.StartMiB + *p.SizeMiB - 1
< }
< 
< // partitionsOverlap returns true if any explicitly dimensioned partitions overlap. It also returns the index of
< // the overlapping partition
< func (n Disk) partitionsOverlap() (bool, int) {
< 	for _, p := range n.Partitions {
< 		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
< 		// We aren't going to check those for overlap since we don't have the disk geometry.
< 		if p.StartMiB == nil || p.SizeMiB == nil || *p.StartMiB == 0 {
< 			continue
< 		}
< 
< 		for i, o := range n.Partitions {
< 			if o.StartMiB == nil || o.SizeMiB == nil || p == o || *o.StartMiB == 0 {
< 				continue
< 			}
< 
< 			// is p.StartMiB within o?
< 			if *p.StartMiB >= *o.StartMiB && *p.StartMiB <= o.end() {
< 				return true, i
< 			}
< 
< 			// is p.end() within o?
< 			if p.end() >= *o.StartMiB && p.end() <= o.end() {
< 				return true, i
< 			}
< 
< 			// do p.StartMiB and p.end() straddle o?
< 			if *p.StartMiB < *o.StartMiB && p.end() > o.end() {
< 				return true, i
< 			}
< 		}
< 	}
< 	return false, 0
< }
< 
< func (n Disk) partitionsMixZeroesAndNonexistence() bool {
< 	hasZero := false
< 	hasShouldNotExist := false
< 	for _, p := range n.Partitions {
< 		hasShouldNotExist = hasShouldNotExist || (p.ShouldExist != nil && !*p.ShouldExist)
< 		hasZero = hasZero || (p.Number == 0)
< 	}
< 	return hasZero && hasShouldNotExist
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/file.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/file.go
1,42d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (f File) Validate(c path.ContextPath) (r report.Report) {
< 	r.Merge(f.Node.Validate(c))
< 	r.AddOnError(c.Append("mode"), validateMode(f.Mode))
< 	r.AddOnError(c.Append("overwrite"), f.validateOverwrite())
< 	return
< }
< 
< func (f File) validateOverwrite() error {
< 	if f.Overwrite != nil && *f.Overwrite && f.Contents.Source == nil {
< 		return errors.ErrOverwriteAndNilSource
< 	}
< 	return nil
< }
< 
< func (f FileEmbedded1) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Append": {},
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/filesystem.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/filesystem.go
1,104d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (f Filesystem) Key() string {
< 	return f.Device
< }
< 
< func (f Filesystem) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options":      {},
< 		"MountOptions": {},
< 	}
< }
< 
< func (f Filesystem) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("path"), f.validatePath())
< 	r.AddOnError(c.Append("device"), validatePath(f.Device))
< 	r.AddOnError(c.Append("format"), f.validateFormat())
< 	r.AddOnError(c.Append("label"), f.validateLabel())
< 	return
< }
< 
< func (f Filesystem) validatePath() error {
< 	return validatePathNilOK(f.Path)
< }
< 
< func (f Filesystem) validateFormat() error {
< 	if util.NilOrEmpty(f.Format) {
< 		if util.NotEmpty(f.Path) ||
< 			util.NotEmpty(f.Label) ||
< 			util.NotEmpty(f.UUID) ||
< 			len(f.Options) != 0 {
< 			return errors.ErrFormatNilWithOthers
< 		}
< 	} else {
< 		switch *f.Format {
< 		case "ext4", "btrfs", "xfs", "swap", "vfat":
< 		default:
< 			return errors.ErrFilesystemInvalidFormat
< 		}
< 	}
< 	return nil
< }
< 
< func (f Filesystem) validateLabel() error {
< 	if util.NilOrEmpty(f.Label) {
< 		return nil
< 	}
< 	if util.NilOrEmpty(f.Format) {
< 		return errors.ErrLabelNeedsFormat
< 	}
< 
< 	switch *f.Format {
< 	case "ext4":
< 		if len(*f.Label) > 16 {
< 			// source: man mkfs.ext4
< 			return errors.ErrExt4LabelTooLong
< 		}
< 	case "btrfs":
< 		if len(*f.Label) > 256 {
< 			// source: man mkfs.btrfs
< 			return errors.ErrBtrfsLabelTooLong
< 		}
< 	case "xfs":
< 		if len(*f.Label) > 12 {
< 			// source: man mkfs.xfs
< 			return errors.ErrXfsLabelTooLong
< 		}
< 	case "swap":
< 		// mkswap's man page does not state a limit on label size, but through
< 		// experimentation it appears that mkswap will truncate long labels to
< 		// 15 characters, so let's enforce that.
< 		if len(*f.Label) > 15 {
< 			return errors.ErrSwapLabelTooLong
< 		}
< 	case "vfat":
< 		if len(*f.Label) > 11 {
< 			// source: man mkfs.fat
< 			return errors.ErrVfatLabelTooLong
< 		}
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/headers.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/headers.go
1,65d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/http"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // Parse generates standard net/http headers from the data in HTTPHeaders
< func (hs HTTPHeaders) Parse() (http.Header, error) {
< 	headers := http.Header{}
< 	for _, header := range hs {
< 		if header.Name == "" {
< 			return nil, errors.ErrEmptyHTTPHeaderName
< 		}
< 		if header.Value == nil || string(*header.Value) == "" {
< 			return nil, errors.ErrInvalidHTTPHeader
< 		}
< 		headers.Add(header.Name, string(*header.Value))
< 	}
< 	return headers, nil
< }
< 
< func (h HTTPHeader) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("name"), h.validateName())
< 	r.AddOnError(c.Append("value"), h.validateValue())
< 	return
< }
< 
< func (h HTTPHeader) validateName() error {
< 	if h.Name == "" {
< 		return errors.ErrEmptyHTTPHeaderName
< 	}
< 	return nil
< }
< 
< func (h HTTPHeader) validateValue() error {
< 	if h.Value == nil {
< 		return nil
< 	}
< 	if string(*h.Value) == "" {
< 		return errors.ErrInvalidHTTPHeader
< 	}
< 	return nil
< }
< 
< func (h HTTPHeader) Key() string {
< 	return h.Name
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/ignition.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/ignition.go
1,49d0
< // Copyright 2015 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/go-semver/semver"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (v Ignition) Semver() (*semver.Version, error) {
< 	return semver.NewVersion(v.Version)
< }
< 
< func (ic IgnitionConfig) Validate(c path.ContextPath) (r report.Report) {
< 	for i, res := range ic.Merge {
< 		r.AddOnError(c.Append("merge", i), res.validateRequiredSource())
< 	}
< 	return
< }
< 
< func (v Ignition) Validate(c path.ContextPath) (r report.Report) {
< 	c = c.Append("version")
< 	tv, err := v.Semver()
< 	if err != nil {
< 		r.AddOnError(c, errors.ErrInvalidVersion)
< 		return
< 	}
< 
< 	if MaxVersion != *tv {
< 		r.AddOnError(c, errors.ErrUnknownVersion)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/mode.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/mode.go
1,26d0
< // Copyright 2017 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< )
< 
< func validateMode(m *int) error {
< 	if m != nil && (*m < 0 || *m > 07777) {
< 		return errors.ErrFileIllegalMode
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/node.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/node.go
1,58d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	vpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (n Node) Key() string {
< 	return n.Path
< }
< 
< func (n Node) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("path"), validatePath(n.Path))
< 	return
< }
< 
< func (n Node) Depth() int {
< 	count := 0
< 	for p := path.Clean(string(n.Path)); p != "/"; count++ {
< 		p = path.Dir(p)
< 	}
< 	return count
< }
< 
< func validateIDorName(id *int, name *string) error {
< 	if id != nil && (name != nil && *name != "") {
< 		return errors.ErrBothIDAndNameSet
< 	}
< 	return nil
< }
< 
< func (nu NodeUser) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validateIDorName(nu.ID, nu.Name))
< 	return
< }
< 
< func (ng NodeGroup) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validateIDorName(ng.ID, ng.Name))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/partition.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/partition.go
1,88d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"fmt"
< 	"regexp"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< const (
< 	guidRegexStr = "^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$"
< )
< 
< var (
< 	guidRegex = regexp.MustCompile(guidRegexStr)
< )
< 
< func (p Partition) Key() string {
< 	if p.Number != 0 {
< 		return fmt.Sprintf("number:%d", p.Number)
< 	} else {
< 		return fmt.Sprintf("label:%s", *p.Label)
< 	}
< }
< 
< func (p Partition) Validate(c path.ContextPath) (r report.Report) {
< 	if p.ShouldExist != nil && !*p.ShouldExist &&
< 		(p.Label != nil || (p.TypeGUID != nil && *p.TypeGUID != "") || (p.GUID != nil && *p.GUID != "") || p.StartMiB != nil || p.SizeMiB != nil) {
< 		r.AddOnError(c, errors.ErrShouldNotExistWithOthers)
< 	}
< 	if p.Number == 0 && p.Label == nil {
< 		r.AddOnError(c, errors.ErrNeedLabelOrNumber)
< 	}
< 
< 	r.AddOnError(c.Append("label"), p.validateLabel())
< 	r.AddOnError(c.Append("guid"), validateGUID(p.GUID))
< 	r.AddOnError(c.Append("typeGuid"), validateGUID(p.TypeGUID))
< 	return
< }
< 
< func (p Partition) validateLabel() error {
< 	if p.Label == nil {
< 		return nil
< 	}
< 	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
< 	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
< 
< 	// XXX(vc): note GPT calls it a name, we're using label for consistency
< 	// with udev naming /dev/disk/by-partlabel/*.
< 	if len(*p.Label) > 36 {
< 		return errors.ErrLabelTooLong
< 	}
< 
< 	// sgdisk uses colons for delimitting compound arguments and does not allow escaping them.
< 	if strings.Contains(*p.Label, ":") {
< 		return errors.ErrLabelContainsColon
< 	}
< 	return nil
< }
< 
< func validateGUID(guidPointer *string) error {
< 	if guidPointer == nil {
< 		return nil
< 	}
< 	guid := *guidPointer
< 	if ok := guidRegex.MatchString(guid); !ok {
< 		return errors.ErrDoesntMatchGUIDRegex
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/passwd.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/passwd.go
1,23d0
< // Copyright 2017 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< func (p PasswdUser) Key() string {
< 	return p.Name
< }
< 
< func (g PasswdGroup) Key() string {
< 	return g.Name
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/path.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/path.go
1,42d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< )
< 
< func validatePath(p string) error {
< 	if p == "" {
< 		return errors.ErrNoPath
< 	}
< 	if !path.IsAbs(p) {
< 		return errors.ErrPathRelative
< 	}
< 	if path.Clean(p) != p {
< 		return errors.ErrDirtyPath
< 	}
< 	return nil
< }
< 
< func validatePathNilOK(p *string) error {
< 	if util.NilOrEmpty(p) {
< 		return nil
< 	}
< 	return validatePath(*p)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/proxy.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/proxy.go
1,49d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (p Proxy) Validate(c path.ContextPath) (r report.Report) {
< 	validateProxyURL(p.HTTPProxy, c.Append("httpProxy"), &r, true)
< 	validateProxyURL(p.HTTPSProxy, c.Append("httpsProxy"), &r, false)
< 	return
< }
< 
< func validateProxyURL(s *string, p path.ContextPath, r *report.Report, httpOk bool) {
< 	if s == nil {
< 		return
< 	}
< 	u, err := url.Parse(*s)
< 	if err != nil {
< 		r.AddOnError(p, errors.ErrInvalidUrl)
< 		return
< 	}
< 
< 	if u.Scheme != "https" && u.Scheme != "http" {
< 		r.AddOnError(p, errors.ErrInvalidProxy)
< 		return
< 	}
< 	if u.Scheme == "http" && !httpOk {
< 		r.AddOnWarn(p, errors.ErrInsecureProxy)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/raid.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/raid.go
1,55d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (r Raid) Key() string {
< 	return r.Name
< }
< 
< func (r Raid) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options": {},
< 	}
< }
< 
< func (ra Raid) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("level"), ra.validateLevel())
< 	return
< }
< 
< func (r Raid) validateLevel() error {
< 	switch r.Level {
< 	case "linear", "raid0", "0", "stripe":
< 		if r.Spares != nil && *r.Spares != 0 {
< 			return errors.ErrSparesUnsupportedForLevel
< 		}
< 	case "raid1", "1", "mirror":
< 	case "raid4", "4":
< 	case "raid5", "5":
< 	case "raid6", "6":
< 	case "raid10", "10":
< 	default:
< 		return errors.ErrUnrecognizedRaidLevel
< 	}
< 
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/resource.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/resource.go
1,91d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (res Resource) Key() string {
< 	if res.Source == nil {
< 		return ""
< 	}
< 	return *res.Source
< }
< 
< func (res Resource) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("compression"), res.validateCompression())
< 	r.AddOnError(c.Append("verification", "hash"), res.validateVerification())
< 	r.AddOnError(c.Append("source"), validateURLNilOK(res.Source))
< 	r.AddOnError(c.Append("httpHeaders"), res.validateSchemeForHTTPHeaders())
< 	return
< }
< 
< func (res Resource) validateCompression() error {
< 	if res.Compression != nil {
< 		switch *res.Compression {
< 		case "", "gzip":
< 		default:
< 			return errors.ErrCompressionInvalid
< 		}
< 	}
< 	return nil
< }
< 
< func (res Resource) validateVerification() error {
< 	if res.Verification.Hash != nil && res.Source == nil {
< 		return errors.ErrVerificationAndNilSource
< 	}
< 	return nil
< }
< 
< func (res Resource) validateSchemeForHTTPHeaders() error {
< 	if len(res.HTTPHeaders) < 1 {
< 		return nil
< 	}
< 
< 	if util.NilOrEmpty(res.Source) {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	u, err := url.Parse(*res.Source)
< 	if err != nil {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	switch u.Scheme {
< 	case "http", "https":
< 		return nil
< 	default:
< 		return errors.ErrUnsupportedSchemeForHTTPHeaders
< 	}
< }
< 
< // Ensure that the Source is specified and valid.  This is not called by
< // Resource.Validate() because some structs that embed Resource don't
< // require Source to be specified.  Containing structs that require Source
< // should call this function from their Validate().
< func (res Resource) validateRequiredSource() error {
< 	if util.NilOrEmpty(res.Source) {
< 		return errors.ErrSourceRequired
< 	}
< 	return validateURL(*res.Source)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/schema.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/schema.go
1,211d0
< package types
< 
< // generated by "schematyper --package=types config/v3_1/schema/ignition.json -o config/v3_1/types/schema.go --root-type=Config" -- DO NOT EDIT
< 
< type Config struct {
< 	Ignition Ignition `json:"ignition"`
< 	Passwd   Passwd   `json:"passwd,omitempty"`
< 	Storage  Storage  `json:"storage,omitempty"`
< 	Systemd  Systemd  `json:"systemd,omitempty"`
< }
< 
< type Device string
< 
< type Directory struct {
< 	Node
< 	DirectoryEmbedded1
< }
< 
< type DirectoryEmbedded1 struct {
< 	Mode *int `json:"mode,omitempty"`
< }
< 
< type Disk struct {
< 	Device     string      `json:"device"`
< 	Partitions []Partition `json:"partitions,omitempty"`
< 	WipeTable  *bool       `json:"wipeTable,omitempty"`
< }
< 
< type Dropin struct {
< 	Contents *string `json:"contents,omitempty"`
< 	Name     string  `json:"name"`
< }
< 
< type File struct {
< 	Node
< 	FileEmbedded1
< }
< 
< type FileEmbedded1 struct {
< 	Append   []Resource `json:"append,omitempty"`
< 	Contents Resource   `json:"contents,omitempty"`
< 	Mode     *int       `json:"mode,omitempty"`
< }
< 
< type Filesystem struct {
< 	Device         string             `json:"device"`
< 	Format         *string            `json:"format,omitempty"`
< 	Label          *string            `json:"label,omitempty"`
< 	MountOptions   []MountOption      `json:"mountOptions,omitempty"`
< 	Options        []FilesystemOption `json:"options,omitempty"`
< 	Path           *string            `json:"path,omitempty"`
< 	UUID           *string            `json:"uuid,omitempty"`
< 	WipeFilesystem *bool              `json:"wipeFilesystem,omitempty"`
< }
< 
< type FilesystemOption string
< 
< type Group string
< 
< type HTTPHeader struct {
< 	Name  string  `json:"name"`
< 	Value *string `json:"value,omitempty"`
< }
< 
< type HTTPHeaders []HTTPHeader
< 
< type Ignition struct {
< 	Config   IgnitionConfig `json:"config,omitempty"`
< 	Proxy    Proxy          `json:"proxy,omitempty"`
< 	Security Security       `json:"security,omitempty"`
< 	Timeouts Timeouts       `json:"timeouts,omitempty"`
< 	Version  string         `json:"version,omitempty"`
< }
< 
< type IgnitionConfig struct {
< 	Merge   []Resource `json:"merge,omitempty"`
< 	Replace Resource   `json:"replace,omitempty"`
< }
< 
< type Link struct {
< 	Node
< 	LinkEmbedded1
< }
< 
< type LinkEmbedded1 struct {
< 	Hard   *bool  `json:"hard,omitempty"`
< 	Target string `json:"target"`
< }
< 
< type MountOption string
< 
< type NoProxyItem string
< 
< type Node struct {
< 	Group     NodeGroup `json:"group,omitempty"`
< 	Overwrite *bool     `json:"overwrite,omitempty"`
< 	Path      string    `json:"path"`
< 	User      NodeUser  `json:"user,omitempty"`
< }
< 
< type NodeGroup struct {
< 	ID   *int    `json:"id,omitempty"`
< 	Name *string `json:"name,omitempty"`
< }
< 
< type NodeUser struct {
< 	ID   *int    `json:"id,omitempty"`
< 	Name *string `json:"name,omitempty"`
< }
< 
< type Partition struct {
< 	GUID               *string `json:"guid,omitempty"`
< 	Label              *string `json:"label,omitempty"`
< 	Number             int     `json:"number,omitempty"`
< 	ShouldExist        *bool   `json:"shouldExist,omitempty"`
< 	SizeMiB            *int    `json:"sizeMiB,omitempty"`
< 	StartMiB           *int    `json:"startMiB,omitempty"`
< 	TypeGUID           *string `json:"typeGuid,omitempty"`
< 	WipePartitionEntry *bool   `json:"wipePartitionEntry,omitempty"`
< }
< 
< type Passwd struct {
< 	Groups []PasswdGroup `json:"groups,omitempty"`
< 	Users  []PasswdUser  `json:"users,omitempty"`
< }
< 
< type PasswdGroup struct {
< 	Gid          *int    `json:"gid,omitempty"`
< 	Name         string  `json:"name"`
< 	PasswordHash *string `json:"passwordHash,omitempty"`
< 	System       *bool   `json:"system,omitempty"`
< }
< 
< type PasswdUser struct {
< 	Gecos             *string            `json:"gecos,omitempty"`
< 	Groups            []Group            `json:"groups,omitempty"`
< 	HomeDir           *string            `json:"homeDir,omitempty"`
< 	Name              string             `json:"name"`
< 	NoCreateHome      *bool              `json:"noCreateHome,omitempty"`
< 	NoLogInit         *bool              `json:"noLogInit,omitempty"`
< 	NoUserGroup       *bool              `json:"noUserGroup,omitempty"`
< 	PasswordHash      *string            `json:"passwordHash,omitempty"`
< 	PrimaryGroup      *string            `json:"primaryGroup,omitempty"`
< 	SSHAuthorizedKeys []SSHAuthorizedKey `json:"sshAuthorizedKeys,omitempty"`
< 	Shell             *string            `json:"shell,omitempty"`
< 	System            *bool              `json:"system,omitempty"`
< 	UID               *int               `json:"uid,omitempty"`
< }
< 
< type Proxy struct {
< 	HTTPProxy  *string       `json:"httpProxy,omitempty"`
< 	HTTPSProxy *string       `json:"httpsProxy,omitempty"`
< 	NoProxy    []NoProxyItem `json:"noProxy,omitempty"`
< }
< 
< type Raid struct {
< 	Devices []Device     `json:"devices"`
< 	Level   string       `json:"level"`
< 	Name    string       `json:"name"`
< 	Options []RaidOption `json:"options,omitempty"`
< 	Spares  *int         `json:"spares,omitempty"`
< }
< 
< type RaidOption string
< 
< type Resource struct {
< 	Compression  *string      `json:"compression,omitempty"`
< 	HTTPHeaders  HTTPHeaders  `json:"httpHeaders,omitempty"`
< 	Source       *string      `json:"source,omitempty"`
< 	Verification Verification `json:"verification,omitempty"`
< }
< 
< type SSHAuthorizedKey string
< 
< type Security struct {
< 	TLS TLS `json:"tls,omitempty"`
< }
< 
< type Storage struct {
< 	Directories []Directory  `json:"directories,omitempty"`
< 	Disks       []Disk       `json:"disks,omitempty"`
< 	Files       []File       `json:"files,omitempty"`
< 	Filesystems []Filesystem `json:"filesystems,omitempty"`
< 	Links       []Link       `json:"links,omitempty"`
< 	Raid        []Raid       `json:"raid,omitempty"`
< }
< 
< type Systemd struct {
< 	Units []Unit `json:"units,omitempty"`
< }
< 
< type TLS struct {
< 	CertificateAuthorities []Resource `json:"certificateAuthorities,omitempty"`
< }
< 
< type Timeouts struct {
< 	HTTPResponseHeaders *int `json:"httpResponseHeaders,omitempty"`
< 	HTTPTotal           *int `json:"httpTotal,omitempty"`
< }
< 
< type Unit struct {
< 	Contents *string  `json:"contents,omitempty"`
< 	Dropins  []Dropin `json:"dropins,omitempty"`
< 	Enabled  *bool    `json:"enabled,omitempty"`
< 	Mask     *bool    `json:"mask,omitempty"`
< 	Name     string   `json:"name"`
< }
< 
< type Verification struct {
< 	Hash *string `json:"hash,omitempty"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/storage.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/storage.go
1,70d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	vpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (s Storage) MergedKeys() map[string]string {
< 	return map[string]string{
< 		"Directories": "Node",
< 		"Files":       "Node",
< 		"Links":       "Node",
< 	}
< }
< 
< func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
< 	for i, d := range s.Directories {
< 		for _, l := range s.Links {
< 			if strings.HasPrefix(d.Path, l.Path+"/") {
< 				r.AddOnError(c.Append("directories", i), errors.ErrDirectoryUsedSymlink)
< 			}
< 		}
< 	}
< 	for i, f := range s.Files {
< 		for _, l := range s.Links {
< 			if strings.HasPrefix(f.Path, l.Path+"/") {
< 				r.AddOnError(c.Append("files", i), errors.ErrFileUsedSymlink)
< 			}
< 		}
< 	}
< 	for i, l1 := range s.Links {
< 		for _, l2 := range s.Links {
< 			if strings.HasPrefix(l1.Path, l2.Path+"/") {
< 				r.AddOnError(c.Append("links", i), errors.ErrLinkUsedSymlink)
< 			}
< 		}
< 		if l1.Hard == nil || !*l1.Hard {
< 			continue
< 		}
< 		target := path.Clean(l1.Target)
< 		if !path.IsAbs(target) {
< 			target = path.Join(l1.Path, l1.Target)
< 		}
< 		for _, d := range s.Directories {
< 			if target == d.Path {
< 				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
< 			}
< 		}
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/tls.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/tls.go
1,27d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (tls TLS) Validate(c path.ContextPath) (r report.Report) {
< 	for i, ca := range tls.CertificateAuthorities {
< 		r.AddOnError(c.Append("certificateAuthorities", i), ca.validateRequiredSource())
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/unit.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/unit.go
1,82d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"fmt"
< 	"path"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/shared/validations"
< 
< 	"github.com/coreos/go-systemd/v22/unit"
< 	cpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (u Unit) Key() string {
< 	return u.Name
< }
< 
< func (d Dropin) Key() string {
< 	return d.Name
< }
< 
< func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("name"), validateName(u.Name))
< 	c = c.Append("contents")
< 	opts, err := validateUnitContent(u.Contents)
< 	r.AddOnError(c, err)
< 
< 	isEnabled := u.Enabled != nil && *u.Enabled
< 	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, isEnabled, (u.Contents == nil || *u.Contents == ""), opts))
< 
< 	return
< }
< 
< func validateName(name string) error {
< 	switch path.Ext(name) {
< 	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
< 	default:
< 		return errors.ErrInvalidSystemdExt
< 	}
< 	return nil
< }
< 
< func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
< 	_, err := validateUnitContent(d.Contents)
< 	r.AddOnError(c.Append("contents"), err)
< 
< 	switch path.Ext(d.Name) {
< 	case ".conf":
< 	default:
< 		r.AddOnError(c.Append("name"), errors.ErrInvalidSystemdDropinExt)
< 	}
< 
< 	return
< }
< 
< func validateUnitContent(content *string) ([]*unit.UnitOption, error) {
< 	if content == nil {
< 		return []*unit.UnitOption{}, nil
< 	}
< 	c := strings.NewReader(*content)
< 	opts, err := unit.Deserialize(c)
< 	if err != nil {
< 		return nil, fmt.Errorf("invalid unit content: %s", err)
< 	}
< 	return opts, nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/url.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/url.go
1,57d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/vincent-petithory/dataurl"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< )
< 
< func validateURL(s string) error {
< 	u, err := url.Parse(s)
< 	if err != nil {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	switch u.Scheme {
< 	case "http", "https", "tftp":
< 		return nil
< 	case "s3":
< 		if v, ok := u.Query()["versionId"]; ok {
< 			if len(v) == 0 || v[0] == "" {
< 				return errors.ErrInvalidS3ObjectVersionId
< 			}
< 		}
< 		return nil
< 	case "data":
< 		if _, err := dataurl.DecodeString(s); err != nil {
< 			return err
< 		}
< 		return nil
< 	default:
< 		return errors.ErrInvalidScheme
< 	}
< }
< 
< func validateURLNilOK(s *string) error {
< 	if util.NilOrEmpty(s) {
< 		return nil
< 	}
< 	return validateURL(*s)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/verification.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_1/types/verification.go
1,71d0
< // Copyright 2016 CoreOS, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"crypto"
< 	"encoding/hex"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // HashParts will return the sum and function (in that order) of the hash stored
< // in this Verification, or an error if there is an issue during parsing.
< func (v Verification) HashParts() (string, string, error) {
< 	if v.Hash == nil {
< 		// The hash can be nil
< 		return "", "", nil
< 	}
< 	parts := strings.SplitN(*v.Hash, "-", 2)
< 	if len(parts) != 2 {
< 		return "", "", errors.ErrHashMalformed
< 	}
< 
< 	return parts[0], parts[1], nil
< }
< 
< func (v Verification) Validate(c path.ContextPath) (r report.Report) {
< 	c = c.Append("hash")
< 	if v.Hash == nil {
< 		// The hash can be nil
< 		return
< 	}
< 
< 	function, sum, err := v.HashParts()
< 	if err != nil {
< 		r.AddOnError(c, err)
< 		return
< 	}
< 	var hash crypto.Hash
< 	switch function {
< 	case "sha512":
< 		hash = crypto.SHA512
< 	case "sha256":
< 		hash = crypto.SHA256
< 	default:
< 		r.AddOnError(c, errors.ErrHashUnrecognized)
< 		return
< 	}
< 
< 	if len(sum) != hex.EncodedLen(hash.Size()) {
< 		r.AddOnError(c, errors.ErrHashWrongSize)
< 	}
< 
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/config.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/config.go
1,26d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/go-semver/semver"
< )
< 
< var (
< 	MaxVersion = semver.Version{
< 		Major: 3,
< 		Minor: 2,
< 	}
< )
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/custom.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/custom.go
1,41d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (cu Custom) Key() string {
< 	return cu.Pin
< }
< 
< func (cu Custom) Validate(c path.ContextPath) (r report.Report) {
< 	if cu.Pin == "" && cu.Config == "" {
< 		return
< 	}
< 	switch cu.Pin {
< 	case "tpm2", "tang", "sss":
< 	default:
< 		r.AddOnError(c.Append("pin"), errors.ErrUnknownClevisPin)
< 	}
< 	if cu.Config == "" {
< 		r.AddOnError(c.Append("config"), errors.ErrClevisConfigRequired)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/device.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/device.go
1,25d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Device) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validatePath(string(d)))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/directory.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/directory.go
1,26d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Directory) Validate(c path.ContextPath) (r report.Report) {
< 	r.Merge(d.Node.Validate(c))
< 	r.AddOnError(c.Append("mode"), validateMode(d.Mode))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/disk.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/disk.go
1,134d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Disk) Key() string {
< 	return d.Device
< }
< 
< func (n Disk) Validate(c path.ContextPath) (r report.Report) {
< 	if len(n.Device) == 0 {
< 		r.AddOnError(c.Append("device"), errors.ErrDiskDeviceRequired)
< 		return
< 	}
< 	r.AddOnError(c.Append("device"), validatePath(n.Device))
< 
< 	if collides, p := n.partitionNumbersCollide(); collides {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionNumbersCollide)
< 	}
< 	if overlaps, p := n.partitionsOverlap(); overlaps {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionsOverlap)
< 	}
< 	if n.partitionsMixZeroesAndNonexistence() {
< 		r.AddOnError(c.Append("partitions"), errors.ErrZeroesWithShouldNotExist)
< 	}
< 	if collides, p := n.partitionLabelsCollide(); collides {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrDuplicateLabels)
< 	}
< 	return
< }
< 
< // partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique. It also returns the
< // index of the colliding partition
< func (n Disk) partitionNumbersCollide() (bool, int) {
< 	m := map[int][]int{} // from partition number to index into array
< 	for i, p := range n.Partitions {
< 		if p.Number != 0 {
< 			// a number of 0 means next available number, multiple devices can specify this
< 			m[p.Number] = append(m[p.Number], i)
< 		}
< 	}
< 	for _, n := range m {
< 		if len(n) > 1 {
< 			// TODO(vc): return information describing the collision for logging
< 			return true, n[1]
< 		}
< 	}
< 	return false, 0
< }
< 
< func (d Disk) partitionLabelsCollide() (bool, int) {
< 	m := map[string]struct{}{}
< 	for i, p := range d.Partitions {
< 		if p.Label != nil {
< 			// a number of 0 means next available number, multiple devices can specify this
< 			if _, exists := m[*p.Label]; exists {
< 				return true, i
< 			}
< 			m[*p.Label] = struct{}{}
< 		}
< 	}
< 	return false, 0
< }
< 
< // end returns the last sector of a partition. Only used by partitionsOverlap. Requires non-nil Start and Size.
< func (p Partition) end() int {
< 	if *p.SizeMiB == 0 {
< 		// a size of 0 means "fill available", just return the start as the end for those.
< 		return *p.StartMiB
< 	}
< 	return *p.StartMiB + *p.SizeMiB - 1
< }
< 
< // partitionsOverlap returns true if any explicitly dimensioned partitions overlap. It also returns the index of
< // the overlapping partition
< func (n Disk) partitionsOverlap() (bool, int) {
< 	for _, p := range n.Partitions {
< 		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
< 		// We aren't going to check those for overlap since we don't have the disk geometry.
< 		if p.StartMiB == nil || p.SizeMiB == nil || *p.StartMiB == 0 {
< 			continue
< 		}
< 
< 		for i, o := range n.Partitions {
< 			if o.StartMiB == nil || o.SizeMiB == nil || p == o || *o.StartMiB == 0 {
< 				continue
< 			}
< 
< 			// is p.StartMiB within o?
< 			if *p.StartMiB >= *o.StartMiB && *p.StartMiB <= o.end() {
< 				return true, i
< 			}
< 
< 			// is p.end() within o?
< 			if p.end() >= *o.StartMiB && p.end() <= o.end() {
< 				return true, i
< 			}
< 
< 			// do p.StartMiB and p.end() straddle o?
< 			if *p.StartMiB < *o.StartMiB && p.end() > o.end() {
< 				return true, i
< 			}
< 		}
< 	}
< 	return false, 0
< }
< 
< func (n Disk) partitionsMixZeroesAndNonexistence() bool {
< 	hasZero := false
< 	hasShouldNotExist := false
< 	for _, p := range n.Partitions {
< 		hasShouldNotExist = hasShouldNotExist || (p.ShouldExist != nil && !*p.ShouldExist)
< 		hasZero = hasZero || (p.Number == 0)
< 	}
< 	return hasZero && hasShouldNotExist
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/file.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/file.go
1,42d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (f File) Validate(c path.ContextPath) (r report.Report) {
< 	r.Merge(f.Node.Validate(c))
< 	r.AddOnError(c.Append("mode"), validateMode(f.Mode))
< 	r.AddOnError(c.Append("overwrite"), f.validateOverwrite())
< 	return
< }
< 
< func (f File) validateOverwrite() error {
< 	if f.Overwrite != nil && *f.Overwrite && f.Contents.Source == nil {
< 		return errors.ErrOverwriteAndNilSource
< 	}
< 	return nil
< }
< 
< func (f FileEmbedded1) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Append": {},
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/filesystem.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/filesystem.go
1,104d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (f Filesystem) Key() string {
< 	return f.Device
< }
< 
< func (f Filesystem) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options":      {},
< 		"MountOptions": {},
< 	}
< }
< 
< func (f Filesystem) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("path"), f.validatePath())
< 	r.AddOnError(c.Append("device"), validatePath(f.Device))
< 	r.AddOnError(c.Append("format"), f.validateFormat())
< 	r.AddOnError(c.Append("label"), f.validateLabel())
< 	return
< }
< 
< func (f Filesystem) validatePath() error {
< 	return validatePathNilOK(f.Path)
< }
< 
< func (f Filesystem) validateFormat() error {
< 	if util.NilOrEmpty(f.Format) {
< 		if util.NotEmpty(f.Path) ||
< 			util.NotEmpty(f.Label) ||
< 			util.NotEmpty(f.UUID) ||
< 			len(f.Options) != 0 {
< 			return errors.ErrFormatNilWithOthers
< 		}
< 	} else {
< 		switch *f.Format {
< 		case "ext4", "btrfs", "xfs", "swap", "vfat":
< 		default:
< 			return errors.ErrFilesystemInvalidFormat
< 		}
< 	}
< 	return nil
< }
< 
< func (f Filesystem) validateLabel() error {
< 	if util.NilOrEmpty(f.Label) {
< 		return nil
< 	}
< 	if util.NilOrEmpty(f.Format) {
< 		return errors.ErrLabelNeedsFormat
< 	}
< 
< 	switch *f.Format {
< 	case "ext4":
< 		if len(*f.Label) > 16 {
< 			// source: man mkfs.ext4
< 			return errors.ErrExt4LabelTooLong
< 		}
< 	case "btrfs":
< 		if len(*f.Label) > 256 {
< 			// source: man mkfs.btrfs
< 			return errors.ErrBtrfsLabelTooLong
< 		}
< 	case "xfs":
< 		if len(*f.Label) > 12 {
< 			// source: man mkfs.xfs
< 			return errors.ErrXfsLabelTooLong
< 		}
< 	case "swap":
< 		// mkswap's man page does not state a limit on label size, but through
< 		// experimentation it appears that mkswap will truncate long labels to
< 		// 15 characters, so let's enforce that.
< 		if len(*f.Label) > 15 {
< 			return errors.ErrSwapLabelTooLong
< 		}
< 	case "vfat":
< 		if len(*f.Label) > 11 {
< 			// source: man mkfs.fat
< 			return errors.ErrVfatLabelTooLong
< 		}
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/headers.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/headers.go
1,65d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/http"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // Parse generates standard net/http headers from the data in HTTPHeaders
< func (hs HTTPHeaders) Parse() (http.Header, error) {
< 	headers := http.Header{}
< 	for _, header := range hs {
< 		if header.Name == "" {
< 			return nil, errors.ErrEmptyHTTPHeaderName
< 		}
< 		if header.Value == nil || string(*header.Value) == "" {
< 			return nil, errors.ErrInvalidHTTPHeader
< 		}
< 		headers.Add(header.Name, string(*header.Value))
< 	}
< 	return headers, nil
< }
< 
< func (h HTTPHeader) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("name"), h.validateName())
< 	r.AddOnError(c.Append("value"), h.validateValue())
< 	return
< }
< 
< func (h HTTPHeader) validateName() error {
< 	if h.Name == "" {
< 		return errors.ErrEmptyHTTPHeaderName
< 	}
< 	return nil
< }
< 
< func (h HTTPHeader) validateValue() error {
< 	if h.Value == nil {
< 		return nil
< 	}
< 	if string(*h.Value) == "" {
< 		return errors.ErrInvalidHTTPHeader
< 	}
< 	return nil
< }
< 
< func (h HTTPHeader) Key() string {
< 	return h.Name
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/ignition.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/ignition.go
1,49d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/go-semver/semver"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (v Ignition) Semver() (*semver.Version, error) {
< 	return semver.NewVersion(v.Version)
< }
< 
< func (ic IgnitionConfig) Validate(c path.ContextPath) (r report.Report) {
< 	for i, res := range ic.Merge {
< 		r.AddOnError(c.Append("merge", i), res.validateRequiredSource())
< 	}
< 	return
< }
< 
< func (v Ignition) Validate(c path.ContextPath) (r report.Report) {
< 	c = c.Append("version")
< 	tv, err := v.Semver()
< 	if err != nil {
< 		r.AddOnError(c, errors.ErrInvalidVersion)
< 		return
< 	}
< 
< 	if MaxVersion != *tv {
< 		r.AddOnError(c, errors.ErrUnknownVersion)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/luks.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/luks.go
1,73d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (l Luks) Key() string {
< 	return l.Name
< }
< 
< func (l Luks) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options": {},
< 	}
< }
< 
< func (l Luks) Validate(c path.ContextPath) (r report.Report) {
< 	if strings.Contains(l.Name, "/") {
< 		r.AddOnError(c.Append("name"), errors.ErrLuksNameContainsSlash)
< 	}
< 	r.AddOnError(c.Append("label"), l.validateLabel())
< 	if util.NilOrEmpty(l.Device) {
< 		r.AddOnError(c.Append("device"), errors.ErrDiskDeviceRequired)
< 	} else {
< 		r.AddOnError(c.Append("device"), validatePath(*l.Device))
< 	}
< 
< 	if l.Clevis != nil {
< 		if l.Clevis.Custom != nil && (len(l.Clevis.Tang) > 0 || (l.Clevis.Tpm2 != nil && *l.Clevis.Tpm2) || (l.Clevis.Threshold != nil && *l.Clevis.Threshold != 0)) {
< 			r.AddOnError(c.Append("clevis"), errors.ErrClevisCustomWithOthers)
< 		}
< 	}
< 
< 	// fail if a key file is provided and is not valid
< 	if err := validateURLNilOK(l.KeyFile.Source); err != nil {
< 		r.AddOnError(c.Append("keys"), errors.ErrInvalidLuksKeyFile)
< 	}
< 	return
< }
< 
< func (l Luks) validateLabel() error {
< 	if util.NilOrEmpty(l.Label) {
< 		return nil
< 	}
< 
< 	if len(*l.Label) > 47 {
< 		// LUKS2_LABEL_L has a maximum length of 48 (including the null terminator)
< 		// https://gitlab.com/cryptsetup/cryptsetup/-/blob/1633f030e89ad2f11ae649ba9600997a41abd3fc/lib/luks2/luks2.h#L86
< 		return errors.ErrLuksLabelTooLong
< 	}
< 
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/mode.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/mode.go
1,26d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< )
< 
< func validateMode(m *int) error {
< 	if m != nil && (*m < 0 || *m > 07777) {
< 		return errors.ErrFileIllegalMode
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/node.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/node.go
1,58d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	vpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (n Node) Key() string {
< 	return n.Path
< }
< 
< func (n Node) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("path"), validatePath(n.Path))
< 	return
< }
< 
< func (n Node) Depth() int {
< 	count := 0
< 	for p := path.Clean(string(n.Path)); p != "/"; count++ {
< 		p = path.Dir(p)
< 	}
< 	return count
< }
< 
< func validateIDorName(id *int, name *string) error {
< 	if id != nil && (name != nil && *name != "") {
< 		return errors.ErrBothIDAndNameSet
< 	}
< 	return nil
< }
< 
< func (nu NodeUser) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validateIDorName(nu.ID, nu.Name))
< 	return
< }
< 
< func (ng NodeGroup) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validateIDorName(ng.ID, ng.Name))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/partition.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/partition.go
1,88d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"fmt"
< 	"regexp"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< const (
< 	guidRegexStr = "^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$"
< )
< 
< var (
< 	guidRegex = regexp.MustCompile(guidRegexStr)
< )
< 
< func (p Partition) Key() string {
< 	if p.Number != 0 {
< 		return fmt.Sprintf("number:%d", p.Number)
< 	} else {
< 		return fmt.Sprintf("label:%s", *p.Label)
< 	}
< }
< 
< func (p Partition) Validate(c path.ContextPath) (r report.Report) {
< 	if p.ShouldExist != nil && !*p.ShouldExist &&
< 		(p.Label != nil || (p.TypeGUID != nil && *p.TypeGUID != "") || (p.GUID != nil && *p.GUID != "") || p.StartMiB != nil || p.SizeMiB != nil) {
< 		r.AddOnError(c, errors.ErrShouldNotExistWithOthers)
< 	}
< 	if p.Number == 0 && p.Label == nil {
< 		r.AddOnError(c, errors.ErrNeedLabelOrNumber)
< 	}
< 
< 	r.AddOnError(c.Append("label"), p.validateLabel())
< 	r.AddOnError(c.Append("guid"), validateGUID(p.GUID))
< 	r.AddOnError(c.Append("typeGuid"), validateGUID(p.TypeGUID))
< 	return
< }
< 
< func (p Partition) validateLabel() error {
< 	if p.Label == nil {
< 		return nil
< 	}
< 	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
< 	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
< 
< 	// XXX(vc): note GPT calls it a name, we're using label for consistency
< 	// with udev naming /dev/disk/by-partlabel/*.
< 	if len(*p.Label) > 36 {
< 		return errors.ErrLabelTooLong
< 	}
< 
< 	// sgdisk uses colons for delimitting compound arguments and does not allow escaping them.
< 	if strings.Contains(*p.Label, ":") {
< 		return errors.ErrLabelContainsColon
< 	}
< 	return nil
< }
< 
< func validateGUID(guidPointer *string) error {
< 	if guidPointer == nil {
< 		return nil
< 	}
< 	guid := *guidPointer
< 	if ok := guidRegex.MatchString(guid); !ok {
< 		return errors.ErrDoesntMatchGUIDRegex
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/passwd.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/passwd.go
1,23d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< func (p PasswdUser) Key() string {
< 	return p.Name
< }
< 
< func (g PasswdGroup) Key() string {
< 	return g.Name
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/path.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/path.go
1,42d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< )
< 
< func validatePath(p string) error {
< 	if p == "" {
< 		return errors.ErrNoPath
< 	}
< 	if !path.IsAbs(p) {
< 		return errors.ErrPathRelative
< 	}
< 	if path.Clean(p) != p {
< 		return errors.ErrDirtyPath
< 	}
< 	return nil
< }
< 
< func validatePathNilOK(p *string) error {
< 	if util.NilOrEmpty(p) {
< 		return nil
< 	}
< 	return validatePath(*p)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/proxy.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/proxy.go
1,49d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (p Proxy) Validate(c path.ContextPath) (r report.Report) {
< 	validateProxyURL(p.HTTPProxy, c.Append("httpProxy"), &r, true)
< 	validateProxyURL(p.HTTPSProxy, c.Append("httpsProxy"), &r, false)
< 	return
< }
< 
< func validateProxyURL(s *string, p path.ContextPath, r *report.Report, httpOk bool) {
< 	if s == nil {
< 		return
< 	}
< 	u, err := url.Parse(*s)
< 	if err != nil {
< 		r.AddOnError(p, errors.ErrInvalidUrl)
< 		return
< 	}
< 
< 	if u.Scheme != "https" && u.Scheme != "http" {
< 		r.AddOnError(p, errors.ErrInvalidProxy)
< 		return
< 	}
< 	if u.Scheme == "http" && !httpOk {
< 		r.AddOnWarn(p, errors.ErrInsecureProxy)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/raid.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/raid.go
1,55d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (r Raid) Key() string {
< 	return r.Name
< }
< 
< func (r Raid) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options": {},
< 	}
< }
< 
< func (ra Raid) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("level"), ra.validateLevel())
< 	return
< }
< 
< func (r Raid) validateLevel() error {
< 	switch r.Level {
< 	case "linear", "raid0", "0", "stripe":
< 		if r.Spares != nil && *r.Spares != 0 {
< 			return errors.ErrSparesUnsupportedForLevel
< 		}
< 	case "raid1", "1", "mirror":
< 	case "raid4", "4":
< 	case "raid5", "5":
< 	case "raid6", "6":
< 	case "raid10", "10":
< 	default:
< 		return errors.ErrUnrecognizedRaidLevel
< 	}
< 
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/resource.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/resource.go
1,91d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (res Resource) Key() string {
< 	if res.Source == nil {
< 		return ""
< 	}
< 	return *res.Source
< }
< 
< func (res Resource) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("compression"), res.validateCompression())
< 	r.AddOnError(c.Append("verification", "hash"), res.validateVerification())
< 	r.AddOnError(c.Append("source"), validateURLNilOK(res.Source))
< 	r.AddOnError(c.Append("httpHeaders"), res.validateSchemeForHTTPHeaders())
< 	return
< }
< 
< func (res Resource) validateCompression() error {
< 	if res.Compression != nil {
< 		switch *res.Compression {
< 		case "", "gzip":
< 		default:
< 			return errors.ErrCompressionInvalid
< 		}
< 	}
< 	return nil
< }
< 
< func (res Resource) validateVerification() error {
< 	if res.Verification.Hash != nil && res.Source == nil {
< 		return errors.ErrVerificationAndNilSource
< 	}
< 	return nil
< }
< 
< func (res Resource) validateSchemeForHTTPHeaders() error {
< 	if len(res.HTTPHeaders) < 1 {
< 		return nil
< 	}
< 
< 	if util.NilOrEmpty(res.Source) {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	u, err := url.Parse(*res.Source)
< 	if err != nil {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	switch u.Scheme {
< 	case "http", "https":
< 		return nil
< 	default:
< 		return errors.ErrUnsupportedSchemeForHTTPHeaders
< 	}
< }
< 
< // Ensure that the Source is specified and valid.  This is not called by
< // Resource.Validate() because some structs that embed Resource don't
< // require Source to be specified.  Containing structs that require Source
< // should call this function from their Validate().
< func (res Resource) validateRequiredSource() error {
< 	if util.NilOrEmpty(res.Source) {
< 		return errors.ErrSourceRequired
< 	}
< 	return validateURL(*res.Source)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/schema.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/schema.go
1,246d0
< package types
< 
< // generated by "schematyper --package=types config/v3_2/schema/ignition.json -o config/v3_2/types/schema.go --root-type=Config" -- DO NOT EDIT
< 
< type Clevis struct {
< 	Custom    *Custom `json:"custom,omitempty"`
< 	Tang      []Tang  `json:"tang,omitempty"`
< 	Threshold *int    `json:"threshold,omitempty"`
< 	Tpm2      *bool   `json:"tpm2,omitempty"`
< }
< 
< type Config struct {
< 	Ignition Ignition `json:"ignition"`
< 	Passwd   Passwd   `json:"passwd,omitempty"`
< 	Storage  Storage  `json:"storage,omitempty"`
< 	Systemd  Systemd  `json:"systemd,omitempty"`
< }
< 
< type Custom struct {
< 	Config       string `json:"config"`
< 	NeedsNetwork *bool  `json:"needsNetwork,omitempty"`
< 	Pin          string `json:"pin"`
< }
< 
< type Device string
< 
< type Directory struct {
< 	Node
< 	DirectoryEmbedded1
< }
< 
< type DirectoryEmbedded1 struct {
< 	Mode *int `json:"mode,omitempty"`
< }
< 
< type Disk struct {
< 	Device     string      `json:"device"`
< 	Partitions []Partition `json:"partitions,omitempty"`
< 	WipeTable  *bool       `json:"wipeTable,omitempty"`
< }
< 
< type Dropin struct {
< 	Contents *string `json:"contents,omitempty"`
< 	Name     string  `json:"name"`
< }
< 
< type File struct {
< 	Node
< 	FileEmbedded1
< }
< 
< type FileEmbedded1 struct {
< 	Append   []Resource `json:"append,omitempty"`
< 	Contents Resource   `json:"contents,omitempty"`
< 	Mode     *int       `json:"mode,omitempty"`
< }
< 
< type Filesystem struct {
< 	Device         string             `json:"device"`
< 	Format         *string            `json:"format,omitempty"`
< 	Label          *string            `json:"label,omitempty"`
< 	MountOptions   []MountOption      `json:"mountOptions,omitempty"`
< 	Options        []FilesystemOption `json:"options,omitempty"`
< 	Path           *string            `json:"path,omitempty"`
< 	UUID           *string            `json:"uuid,omitempty"`
< 	WipeFilesystem *bool              `json:"wipeFilesystem,omitempty"`
< }
< 
< type FilesystemOption string
< 
< type Group string
< 
< type HTTPHeader struct {
< 	Name  string  `json:"name"`
< 	Value *string `json:"value,omitempty"`
< }
< 
< type HTTPHeaders []HTTPHeader
< 
< type Ignition struct {
< 	Config   IgnitionConfig `json:"config,omitempty"`
< 	Proxy    Proxy          `json:"proxy,omitempty"`
< 	Security Security       `json:"security,omitempty"`
< 	Timeouts Timeouts       `json:"timeouts,omitempty"`
< 	Version  string         `json:"version,omitempty"`
< }
< 
< type IgnitionConfig struct {
< 	Merge   []Resource `json:"merge,omitempty"`
< 	Replace Resource   `json:"replace,omitempty"`
< }
< 
< type Link struct {
< 	Node
< 	LinkEmbedded1
< }
< 
< type LinkEmbedded1 struct {
< 	Hard   *bool  `json:"hard,omitempty"`
< 	Target string `json:"target"`
< }
< 
< type Luks struct {
< 	Clevis     *Clevis      `json:"clevis,omitempty"`
< 	Device     *string      `json:"device,omitempty"`
< 	KeyFile    Resource     `json:"keyFile,omitempty"`
< 	Label      *string      `json:"label,omitempty"`
< 	Name       string       `json:"name"`
< 	Options    []LuksOption `json:"options,omitempty"`
< 	UUID       *string      `json:"uuid,omitempty"`
< 	WipeVolume *bool        `json:"wipeVolume,omitempty"`
< }
< 
< type LuksOption string
< 
< type MountOption string
< 
< type NoProxyItem string
< 
< type Node struct {
< 	Group     NodeGroup `json:"group,omitempty"`
< 	Overwrite *bool     `json:"overwrite,omitempty"`
< 	Path      string    `json:"path"`
< 	User      NodeUser  `json:"user,omitempty"`
< }
< 
< type NodeGroup struct {
< 	ID   *int    `json:"id,omitempty"`
< 	Name *string `json:"name,omitempty"`
< }
< 
< type NodeUser struct {
< 	ID   *int    `json:"id,omitempty"`
< 	Name *string `json:"name,omitempty"`
< }
< 
< type Partition struct {
< 	GUID               *string `json:"guid,omitempty"`
< 	Label              *string `json:"label,omitempty"`
< 	Number             int     `json:"number,omitempty"`
< 	Resize             *bool   `json:"resize,omitempty"`
< 	ShouldExist        *bool   `json:"shouldExist,omitempty"`
< 	SizeMiB            *int    `json:"sizeMiB,omitempty"`
< 	StartMiB           *int    `json:"startMiB,omitempty"`
< 	TypeGUID           *string `json:"typeGuid,omitempty"`
< 	WipePartitionEntry *bool   `json:"wipePartitionEntry,omitempty"`
< }
< 
< type Passwd struct {
< 	Groups []PasswdGroup `json:"groups,omitempty"`
< 	Users  []PasswdUser  `json:"users,omitempty"`
< }
< 
< type PasswdGroup struct {
< 	Gid          *int    `json:"gid,omitempty"`
< 	Name         string  `json:"name"`
< 	PasswordHash *string `json:"passwordHash,omitempty"`
< 	ShouldExist  *bool   `json:"shouldExist,omitempty"`
< 	System       *bool   `json:"system,omitempty"`
< }
< 
< type PasswdUser struct {
< 	Gecos             *string            `json:"gecos,omitempty"`
< 	Groups            []Group            `json:"groups,omitempty"`
< 	HomeDir           *string            `json:"homeDir,omitempty"`
< 	Name              string             `json:"name"`
< 	NoCreateHome      *bool              `json:"noCreateHome,omitempty"`
< 	NoLogInit         *bool              `json:"noLogInit,omitempty"`
< 	NoUserGroup       *bool              `json:"noUserGroup,omitempty"`
< 	PasswordHash      *string            `json:"passwordHash,omitempty"`
< 	PrimaryGroup      *string            `json:"primaryGroup,omitempty"`
< 	SSHAuthorizedKeys []SSHAuthorizedKey `json:"sshAuthorizedKeys,omitempty"`
< 	Shell             *string            `json:"shell,omitempty"`
< 	ShouldExist       *bool              `json:"shouldExist,omitempty"`
< 	System            *bool              `json:"system,omitempty"`
< 	UID               *int               `json:"uid,omitempty"`
< }
< 
< type Proxy struct {
< 	HTTPProxy  *string       `json:"httpProxy,omitempty"`
< 	HTTPSProxy *string       `json:"httpsProxy,omitempty"`
< 	NoProxy    []NoProxyItem `json:"noProxy,omitempty"`
< }
< 
< type Raid struct {
< 	Devices []Device     `json:"devices"`
< 	Level   string       `json:"level"`
< 	Name    string       `json:"name"`
< 	Options []RaidOption `json:"options,omitempty"`
< 	Spares  *int         `json:"spares,omitempty"`
< }
< 
< type RaidOption string
< 
< type Resource struct {
< 	Compression  *string      `json:"compression,omitempty"`
< 	HTTPHeaders  HTTPHeaders  `json:"httpHeaders,omitempty"`
< 	Source       *string      `json:"source,omitempty"`
< 	Verification Verification `json:"verification,omitempty"`
< }
< 
< type SSHAuthorizedKey string
< 
< type Security struct {
< 	TLS TLS `json:"tls,omitempty"`
< }
< 
< type Storage struct {
< 	Directories []Directory  `json:"directories,omitempty"`
< 	Disks       []Disk       `json:"disks,omitempty"`
< 	Files       []File       `json:"files,omitempty"`
< 	Filesystems []Filesystem `json:"filesystems,omitempty"`
< 	Links       []Link       `json:"links,omitempty"`
< 	Luks        []Luks       `json:"luks,omitempty"`
< 	Raid        []Raid       `json:"raid,omitempty"`
< }
< 
< type Systemd struct {
< 	Units []Unit `json:"units,omitempty"`
< }
< 
< type TLS struct {
< 	CertificateAuthorities []Resource `json:"certificateAuthorities,omitempty"`
< }
< 
< type Tang struct {
< 	Thumbprint *string `json:"thumbprint,omitempty"`
< 	URL        string  `json:"url,omitempty"`
< }
< 
< type Timeouts struct {
< 	HTTPResponseHeaders *int `json:"httpResponseHeaders,omitempty"`
< 	HTTPTotal           *int `json:"httpTotal,omitempty"`
< }
< 
< type Unit struct {
< 	Contents *string  `json:"contents,omitempty"`
< 	Dropins  []Dropin `json:"dropins,omitempty"`
< 	Enabled  *bool    `json:"enabled,omitempty"`
< 	Mask     *bool    `json:"mask,omitempty"`
< 	Name     string   `json:"name"`
< }
< 
< type Verification struct {
< 	Hash *string `json:"hash,omitempty"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/storage.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/storage.go
1,70d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	vpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (s Storage) MergedKeys() map[string]string {
< 	return map[string]string{
< 		"Directories": "Node",
< 		"Files":       "Node",
< 		"Links":       "Node",
< 	}
< }
< 
< func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
< 	for i, d := range s.Directories {
< 		for _, l := range s.Links {
< 			if strings.HasPrefix(d.Path, l.Path+"/") {
< 				r.AddOnError(c.Append("directories", i), errors.ErrDirectoryUsedSymlink)
< 			}
< 		}
< 	}
< 	for i, f := range s.Files {
< 		for _, l := range s.Links {
< 			if strings.HasPrefix(f.Path, l.Path+"/") {
< 				r.AddOnError(c.Append("files", i), errors.ErrFileUsedSymlink)
< 			}
< 		}
< 	}
< 	for i, l1 := range s.Links {
< 		for _, l2 := range s.Links {
< 			if strings.HasPrefix(l1.Path, l2.Path+"/") {
< 				r.AddOnError(c.Append("links", i), errors.ErrLinkUsedSymlink)
< 			}
< 		}
< 		if l1.Hard == nil || !*l1.Hard {
< 			continue
< 		}
< 		target := path.Clean(l1.Target)
< 		if !path.IsAbs(target) {
< 			target = path.Join(l1.Path, l1.Target)
< 		}
< 		for _, d := range s.Directories {
< 			if target == d.Path {
< 				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
< 			}
< 		}
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/tang.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/tang.go
1,51d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (t Tang) Key() string {
< 	return t.URL
< }
< 
< func (t Tang) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("url"), validateTangURL(t.URL))
< 	if util.NilOrEmpty(t.Thumbprint) {
< 		r.AddOnError(c.Append("thumbprint"), errors.ErrTangThumbprintRequired)
< 	}
< 	return
< }
< 
< func validateTangURL(s string) error {
< 	u, err := url.Parse(s)
< 	if err != nil {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	switch u.Scheme {
< 	case "http", "https":
< 		return nil
< 	default:
< 		return errors.ErrInvalidScheme
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/tls.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/tls.go
1,27d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (tls TLS) Validate(c path.ContextPath) (r report.Report) {
< 	for i, ca := range tls.CertificateAuthorities {
< 		r.AddOnError(c.Append("certificateAuthorities", i), ca.validateRequiredSource())
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/unit.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/unit.go
1,82d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"fmt"
< 	"path"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/shared/validations"
< 
< 	"github.com/coreos/go-systemd/v22/unit"
< 	cpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (u Unit) Key() string {
< 	return u.Name
< }
< 
< func (d Dropin) Key() string {
< 	return d.Name
< }
< 
< func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("name"), validateName(u.Name))
< 	c = c.Append("contents")
< 	opts, err := validateUnitContent(u.Contents)
< 	r.AddOnError(c, err)
< 
< 	isEnabled := u.Enabled != nil && *u.Enabled
< 	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, isEnabled, (u.Contents == nil || *u.Contents == ""), opts))
< 
< 	return
< }
< 
< func validateName(name string) error {
< 	switch path.Ext(name) {
< 	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
< 	default:
< 		return errors.ErrInvalidSystemdExt
< 	}
< 	return nil
< }
< 
< func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
< 	_, err := validateUnitContent(d.Contents)
< 	r.AddOnError(c.Append("contents"), err)
< 
< 	switch path.Ext(d.Name) {
< 	case ".conf":
< 	default:
< 		r.AddOnError(c.Append("name"), errors.ErrInvalidSystemdDropinExt)
< 	}
< 
< 	return
< }
< 
< func validateUnitContent(content *string) ([]*unit.UnitOption, error) {
< 	if content == nil {
< 		return []*unit.UnitOption{}, nil
< 	}
< 	c := strings.NewReader(*content)
< 	opts, err := unit.Deserialize(c)
< 	if err != nil {
< 		return nil, fmt.Errorf("invalid unit content: %s", err)
< 	}
< 	return opts, nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/url.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/url.go
1,57d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/vincent-petithory/dataurl"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< )
< 
< func validateURL(s string) error {
< 	u, err := url.Parse(s)
< 	if err != nil {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	switch u.Scheme {
< 	case "http", "https", "tftp", "gs":
< 		return nil
< 	case "s3":
< 		if v, ok := u.Query()["versionId"]; ok {
< 			if len(v) == 0 || v[0] == "" {
< 				return errors.ErrInvalidS3ObjectVersionId
< 			}
< 		}
< 		return nil
< 	case "data":
< 		if _, err := dataurl.DecodeString(s); err != nil {
< 			return err
< 		}
< 		return nil
< 	default:
< 		return errors.ErrInvalidScheme
< 	}
< }
< 
< func validateURLNilOK(s *string) error {
< 	if util.NilOrEmpty(s) {
< 		return nil
< 	}
< 	return validateURL(*s)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/verification.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_2/types/verification.go
1,71d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"crypto"
< 	"encoding/hex"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // HashParts will return the sum and function (in that order) of the hash stored
< // in this Verification, or an error if there is an issue during parsing.
< func (v Verification) HashParts() (string, string, error) {
< 	if v.Hash == nil {
< 		// The hash can be nil
< 		return "", "", nil
< 	}
< 	parts := strings.SplitN(*v.Hash, "-", 2)
< 	if len(parts) != 2 {
< 		return "", "", errors.ErrHashMalformed
< 	}
< 
< 	return parts[0], parts[1], nil
< }
< 
< func (v Verification) Validate(c path.ContextPath) (r report.Report) {
< 	c = c.Append("hash")
< 	if v.Hash == nil {
< 		// The hash can be nil
< 		return
< 	}
< 
< 	function, sum, err := v.HashParts()
< 	if err != nil {
< 		r.AddOnError(c, err)
< 		return
< 	}
< 	var hash crypto.Hash
< 	switch function {
< 	case "sha512":
< 		hash = crypto.SHA512
< 	case "sha256":
< 		hash = crypto.SHA256
< 	default:
< 		r.AddOnError(c, errors.ErrHashUnrecognized)
< 		return
< 	}
< 
< 	if len(sum) != hex.EncodedLen(hash.Size()) {
< 		r.AddOnError(c, errors.ErrHashWrongSize)
< 	}
< 
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/config.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/config.go
1,27d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/go-semver/semver"
< )
< 
< var (
< 	MaxVersion = semver.Version{
< 		Major:      3,
< 		Minor:      3,
< 		PreRelease: "experimental",
< 	}
< )
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/custom.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/custom.go
1,41d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (cu Custom) Key() string {
< 	return cu.Pin
< }
< 
< func (cu Custom) Validate(c path.ContextPath) (r report.Report) {
< 	if cu.Pin == "" && cu.Config == "" {
< 		return
< 	}
< 	switch cu.Pin {
< 	case "tpm2", "tang", "sss":
< 	default:
< 		r.AddOnError(c.Append("pin"), errors.ErrUnknownClevisPin)
< 	}
< 	if cu.Config == "" {
< 		r.AddOnError(c.Append("config"), errors.ErrClevisConfigRequired)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/device.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/device.go
1,25d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Device) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validatePath(string(d)))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/directory.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/directory.go
1,26d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Directory) Validate(c path.ContextPath) (r report.Report) {
< 	r.Merge(d.Node.Validate(c))
< 	r.AddOnError(c.Append("mode"), validateMode(d.Mode))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/disk.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/disk.go
1,134d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (d Disk) Key() string {
< 	return d.Device
< }
< 
< func (n Disk) Validate(c path.ContextPath) (r report.Report) {
< 	if len(n.Device) == 0 {
< 		r.AddOnError(c.Append("device"), errors.ErrDiskDeviceRequired)
< 		return
< 	}
< 	r.AddOnError(c.Append("device"), validatePath(n.Device))
< 
< 	if collides, p := n.partitionNumbersCollide(); collides {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionNumbersCollide)
< 	}
< 	if overlaps, p := n.partitionsOverlap(); overlaps {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrPartitionsOverlap)
< 	}
< 	if n.partitionsMixZeroesAndNonexistence() {
< 		r.AddOnError(c.Append("partitions"), errors.ErrZeroesWithShouldNotExist)
< 	}
< 	if collides, p := n.partitionLabelsCollide(); collides {
< 		r.AddOnError(c.Append("partitions", p), errors.ErrDuplicateLabels)
< 	}
< 	return
< }
< 
< // partitionNumbersCollide returns true if partition numbers in n.Partitions are not unique. It also returns the
< // index of the colliding partition
< func (n Disk) partitionNumbersCollide() (bool, int) {
< 	m := map[int][]int{} // from partition number to index into array
< 	for i, p := range n.Partitions {
< 		if p.Number != 0 {
< 			// a number of 0 means next available number, multiple devices can specify this
< 			m[p.Number] = append(m[p.Number], i)
< 		}
< 	}
< 	for _, n := range m {
< 		if len(n) > 1 {
< 			// TODO(vc): return information describing the collision for logging
< 			return true, n[1]
< 		}
< 	}
< 	return false, 0
< }
< 
< func (d Disk) partitionLabelsCollide() (bool, int) {
< 	m := map[string]struct{}{}
< 	for i, p := range d.Partitions {
< 		if p.Label != nil {
< 			// a number of 0 means next available number, multiple devices can specify this
< 			if _, exists := m[*p.Label]; exists {
< 				return true, i
< 			}
< 			m[*p.Label] = struct{}{}
< 		}
< 	}
< 	return false, 0
< }
< 
< // end returns the last sector of a partition. Only used by partitionsOverlap. Requires non-nil Start and Size.
< func (p Partition) end() int {
< 	if *p.SizeMiB == 0 {
< 		// a size of 0 means "fill available", just return the start as the end for those.
< 		return *p.StartMiB
< 	}
< 	return *p.StartMiB + *p.SizeMiB - 1
< }
< 
< // partitionsOverlap returns true if any explicitly dimensioned partitions overlap. It also returns the index of
< // the overlapping partition
< func (n Disk) partitionsOverlap() (bool, int) {
< 	for _, p := range n.Partitions {
< 		// Starts of 0 are placed by sgdisk into the "largest available block" at that time.
< 		// We aren't going to check those for overlap since we don't have the disk geometry.
< 		if p.StartMiB == nil || p.SizeMiB == nil || *p.StartMiB == 0 {
< 			continue
< 		}
< 
< 		for i, o := range n.Partitions {
< 			if o.StartMiB == nil || o.SizeMiB == nil || p == o || *o.StartMiB == 0 {
< 				continue
< 			}
< 
< 			// is p.StartMiB within o?
< 			if *p.StartMiB >= *o.StartMiB && *p.StartMiB <= o.end() {
< 				return true, i
< 			}
< 
< 			// is p.end() within o?
< 			if p.end() >= *o.StartMiB && p.end() <= o.end() {
< 				return true, i
< 			}
< 
< 			// do p.StartMiB and p.end() straddle o?
< 			if *p.StartMiB < *o.StartMiB && p.end() > o.end() {
< 				return true, i
< 			}
< 		}
< 	}
< 	return false, 0
< }
< 
< func (n Disk) partitionsMixZeroesAndNonexistence() bool {
< 	hasZero := false
< 	hasShouldNotExist := false
< 	for _, p := range n.Partitions {
< 		hasShouldNotExist = hasShouldNotExist || (p.ShouldExist != nil && !*p.ShouldExist)
< 		hasZero = hasZero || (p.Number == 0)
< 	}
< 	return hasZero && hasShouldNotExist
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/file.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/file.go
1,42d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (f File) Validate(c path.ContextPath) (r report.Report) {
< 	r.Merge(f.Node.Validate(c))
< 	r.AddOnError(c.Append("mode"), validateMode(f.Mode))
< 	r.AddOnError(c.Append("overwrite"), f.validateOverwrite())
< 	return
< }
< 
< func (f File) validateOverwrite() error {
< 	if f.Overwrite != nil && *f.Overwrite && f.Contents.Source == nil {
< 		return errors.ErrOverwriteAndNilSource
< 	}
< 	return nil
< }
< 
< func (f FileEmbedded1) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Append": {},
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/filesystem.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/filesystem.go
1,104d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (f Filesystem) Key() string {
< 	return f.Device
< }
< 
< func (f Filesystem) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options":      {},
< 		"MountOptions": {},
< 	}
< }
< 
< func (f Filesystem) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("path"), f.validatePath())
< 	r.AddOnError(c.Append("device"), validatePath(f.Device))
< 	r.AddOnError(c.Append("format"), f.validateFormat())
< 	r.AddOnError(c.Append("label"), f.validateLabel())
< 	return
< }
< 
< func (f Filesystem) validatePath() error {
< 	return validatePathNilOK(f.Path)
< }
< 
< func (f Filesystem) validateFormat() error {
< 	if util.NilOrEmpty(f.Format) {
< 		if util.NotEmpty(f.Path) ||
< 			util.NotEmpty(f.Label) ||
< 			util.NotEmpty(f.UUID) ||
< 			len(f.Options) != 0 {
< 			return errors.ErrFormatNilWithOthers
< 		}
< 	} else {
< 		switch *f.Format {
< 		case "ext4", "btrfs", "xfs", "swap", "vfat":
< 		default:
< 			return errors.ErrFilesystemInvalidFormat
< 		}
< 	}
< 	return nil
< }
< 
< func (f Filesystem) validateLabel() error {
< 	if util.NilOrEmpty(f.Label) {
< 		return nil
< 	}
< 	if util.NilOrEmpty(f.Format) {
< 		return errors.ErrLabelNeedsFormat
< 	}
< 
< 	switch *f.Format {
< 	case "ext4":
< 		if len(*f.Label) > 16 {
< 			// source: man mkfs.ext4
< 			return errors.ErrExt4LabelTooLong
< 		}
< 	case "btrfs":
< 		if len(*f.Label) > 256 {
< 			// source: man mkfs.btrfs
< 			return errors.ErrBtrfsLabelTooLong
< 		}
< 	case "xfs":
< 		if len(*f.Label) > 12 {
< 			// source: man mkfs.xfs
< 			return errors.ErrXfsLabelTooLong
< 		}
< 	case "swap":
< 		// mkswap's man page does not state a limit on label size, but through
< 		// experimentation it appears that mkswap will truncate long labels to
< 		// 15 characters, so let's enforce that.
< 		if len(*f.Label) > 15 {
< 			return errors.ErrSwapLabelTooLong
< 		}
< 	case "vfat":
< 		if len(*f.Label) > 11 {
< 			// source: man mkfs.fat
< 			return errors.ErrVfatLabelTooLong
< 		}
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/headers.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/headers.go
1,65d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/http"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // Parse generates standard net/http headers from the data in HTTPHeaders
< func (hs HTTPHeaders) Parse() (http.Header, error) {
< 	headers := http.Header{}
< 	for _, header := range hs {
< 		if header.Name == "" {
< 			return nil, errors.ErrEmptyHTTPHeaderName
< 		}
< 		if header.Value == nil || string(*header.Value) == "" {
< 			return nil, errors.ErrInvalidHTTPHeader
< 		}
< 		headers.Add(header.Name, string(*header.Value))
< 	}
< 	return headers, nil
< }
< 
< func (h HTTPHeader) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("name"), h.validateName())
< 	r.AddOnError(c.Append("value"), h.validateValue())
< 	return
< }
< 
< func (h HTTPHeader) validateName() error {
< 	if h.Name == "" {
< 		return errors.ErrEmptyHTTPHeaderName
< 	}
< 	return nil
< }
< 
< func (h HTTPHeader) validateValue() error {
< 	if h.Value == nil {
< 		return nil
< 	}
< 	if string(*h.Value) == "" {
< 		return errors.ErrInvalidHTTPHeader
< 	}
< 	return nil
< }
< 
< func (h HTTPHeader) Key() string {
< 	return h.Name
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/ignition.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/ignition.go
1,49d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/go-semver/semver"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (v Ignition) Semver() (*semver.Version, error) {
< 	return semver.NewVersion(v.Version)
< }
< 
< func (ic IgnitionConfig) Validate(c path.ContextPath) (r report.Report) {
< 	for i, res := range ic.Merge {
< 		r.AddOnError(c.Append("merge", i), res.validateRequiredSource())
< 	}
< 	return
< }
< 
< func (v Ignition) Validate(c path.ContextPath) (r report.Report) {
< 	c = c.Append("version")
< 	tv, err := v.Semver()
< 	if err != nil {
< 		r.AddOnError(c, errors.ErrInvalidVersion)
< 		return
< 	}
< 
< 	if MaxVersion != *tv {
< 		r.AddOnError(c, errors.ErrUnknownVersion)
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/luks.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/luks.go
1,73d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (l Luks) Key() string {
< 	return l.Name
< }
< 
< func (l Luks) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options": {},
< 	}
< }
< 
< func (l Luks) Validate(c path.ContextPath) (r report.Report) {
< 	if strings.Contains(l.Name, "/") {
< 		r.AddOnError(c.Append("name"), errors.ErrLuksNameContainsSlash)
< 	}
< 	r.AddOnError(c.Append("label"), l.validateLabel())
< 	if util.NilOrEmpty(l.Device) {
< 		r.AddOnError(c.Append("device"), errors.ErrDiskDeviceRequired)
< 	} else {
< 		r.AddOnError(c.Append("device"), validatePath(*l.Device))
< 	}
< 
< 	if l.Clevis != nil {
< 		if l.Clevis.Custom != nil && (len(l.Clevis.Tang) > 0 || (l.Clevis.Tpm2 != nil && *l.Clevis.Tpm2) || (l.Clevis.Threshold != nil && *l.Clevis.Threshold != 0)) {
< 			r.AddOnError(c.Append("clevis"), errors.ErrClevisCustomWithOthers)
< 		}
< 	}
< 
< 	// fail if a key file is provided and is not valid
< 	if err := validateURLNilOK(l.KeyFile.Source); err != nil {
< 		r.AddOnError(c.Append("keys"), errors.ErrInvalidLuksKeyFile)
< 	}
< 	return
< }
< 
< func (l Luks) validateLabel() error {
< 	if util.NilOrEmpty(l.Label) {
< 		return nil
< 	}
< 
< 	if len(*l.Label) > 47 {
< 		// LUKS2_LABEL_L has a maximum length of 48 (including the null terminator)
< 		// https://gitlab.com/cryptsetup/cryptsetup/-/blob/1633f030e89ad2f11ae649ba9600997a41abd3fc/lib/luks2/luks2.h#L86
< 		return errors.ErrLuksLabelTooLong
< 	}
< 
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/mode.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/mode.go
1,26d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< )
< 
< func validateMode(m *int) error {
< 	if m != nil && (*m < 0 || *m > 07777) {
< 		return errors.ErrFileIllegalMode
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/node.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/node.go
1,58d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	vpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (n Node) Key() string {
< 	return n.Path
< }
< 
< func (n Node) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("path"), validatePath(n.Path))
< 	return
< }
< 
< func (n Node) Depth() int {
< 	count := 0
< 	for p := path.Clean(string(n.Path)); p != "/"; count++ {
< 		p = path.Dir(p)
< 	}
< 	return count
< }
< 
< func validateIDorName(id *int, name *string) error {
< 	if id != nil && (name != nil && *name != "") {
< 		return errors.ErrBothIDAndNameSet
< 	}
< 	return nil
< }
< 
< func (nu NodeUser) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validateIDorName(nu.ID, nu.Name))
< 	return
< }
< 
< func (ng NodeGroup) Validate(c vpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c, validateIDorName(ng.ID, ng.Name))
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/partition.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/partition.go
1,88d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"fmt"
< 	"regexp"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< const (
< 	guidRegexStr = "^(|[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12})$"
< )
< 
< var (
< 	guidRegex = regexp.MustCompile(guidRegexStr)
< )
< 
< func (p Partition) Key() string {
< 	if p.Number != 0 {
< 		return fmt.Sprintf("number:%d", p.Number)
< 	} else {
< 		return fmt.Sprintf("label:%s", *p.Label)
< 	}
< }
< 
< func (p Partition) Validate(c path.ContextPath) (r report.Report) {
< 	if p.ShouldExist != nil && !*p.ShouldExist &&
< 		(p.Label != nil || (p.TypeGUID != nil && *p.TypeGUID != "") || (p.GUID != nil && *p.GUID != "") || p.StartMiB != nil || p.SizeMiB != nil) {
< 		r.AddOnError(c, errors.ErrShouldNotExistWithOthers)
< 	}
< 	if p.Number == 0 && p.Label == nil {
< 		r.AddOnError(c, errors.ErrNeedLabelOrNumber)
< 	}
< 
< 	r.AddOnError(c.Append("label"), p.validateLabel())
< 	r.AddOnError(c.Append("guid"), validateGUID(p.GUID))
< 	r.AddOnError(c.Append("typeGuid"), validateGUID(p.TypeGUID))
< 	return
< }
< 
< func (p Partition) validateLabel() error {
< 	if p.Label == nil {
< 		return nil
< 	}
< 	// http://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_entries:
< 	// 56 (0x38) 	72 bytes 	Partition name (36 UTF-16LE code units)
< 
< 	// XXX(vc): note GPT calls it a name, we're using label for consistency
< 	// with udev naming /dev/disk/by-partlabel/*.
< 	if len(*p.Label) > 36 {
< 		return errors.ErrLabelTooLong
< 	}
< 
< 	// sgdisk uses colons for delimitting compound arguments and does not allow escaping them.
< 	if strings.Contains(*p.Label, ":") {
< 		return errors.ErrLabelContainsColon
< 	}
< 	return nil
< }
< 
< func validateGUID(guidPointer *string) error {
< 	if guidPointer == nil {
< 		return nil
< 	}
< 	guid := *guidPointer
< 	if ok := guidRegex.MatchString(guid); !ok {
< 		return errors.ErrDoesntMatchGUIDRegex
< 	}
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/passwd.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/passwd.go
1,23d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< func (p PasswdUser) Key() string {
< 	return p.Name
< }
< 
< func (g PasswdGroup) Key() string {
< 	return g.Name
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/path.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/path.go
1,42d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< )
< 
< func validatePath(p string) error {
< 	if p == "" {
< 		return errors.ErrNoPath
< 	}
< 	if !path.IsAbs(p) {
< 		return errors.ErrPathRelative
< 	}
< 	if path.Clean(p) != p {
< 		return errors.ErrDirtyPath
< 	}
< 	return nil
< }
< 
< func validatePathNilOK(p *string) error {
< 	if util.NilOrEmpty(p) {
< 		return nil
< 	}
< 	return validatePath(*p)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/proxy.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/proxy.go
1,49d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (p Proxy) Validate(c path.ContextPath) (r report.Report) {
< 	validateProxyURL(p.HTTPProxy, c.Append("httpProxy"), &r, true)
< 	validateProxyURL(p.HTTPSProxy, c.Append("httpsProxy"), &r, false)
< 	return
< }
< 
< func validateProxyURL(s *string, p path.ContextPath, r *report.Report, httpOk bool) {
< 	if s == nil {
< 		return
< 	}
< 	u, err := url.Parse(*s)
< 	if err != nil {
< 		r.AddOnError(p, errors.ErrInvalidUrl)
< 		return
< 	}
< 
< 	if u.Scheme != "https" && u.Scheme != "http" {
< 		r.AddOnError(p, errors.ErrInvalidProxy)
< 		return
< 	}
< 	if u.Scheme == "http" && !httpOk {
< 		r.AddOnWarn(p, errors.ErrInsecureProxy)
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/raid.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/raid.go
1,55d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (r Raid) Key() string {
< 	return r.Name
< }
< 
< func (r Raid) IgnoreDuplicates() map[string]struct{} {
< 	return map[string]struct{}{
< 		"Options": {},
< 	}
< }
< 
< func (ra Raid) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("level"), ra.validateLevel())
< 	return
< }
< 
< func (r Raid) validateLevel() error {
< 	switch r.Level {
< 	case "linear", "raid0", "0", "stripe":
< 		if r.Spares != nil && *r.Spares != 0 {
< 			return errors.ErrSparesUnsupportedForLevel
< 		}
< 	case "raid1", "1", "mirror":
< 	case "raid4", "4":
< 	case "raid5", "5":
< 	case "raid6", "6":
< 	case "raid10", "10":
< 	default:
< 		return errors.ErrUnrecognizedRaidLevel
< 	}
< 
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/resource.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/resource.go
1,91d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (res Resource) Key() string {
< 	if res.Source == nil {
< 		return ""
< 	}
< 	return *res.Source
< }
< 
< func (res Resource) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("compression"), res.validateCompression())
< 	r.AddOnError(c.Append("verification", "hash"), res.validateVerification())
< 	r.AddOnError(c.Append("source"), validateURLNilOK(res.Source))
< 	r.AddOnError(c.Append("httpHeaders"), res.validateSchemeForHTTPHeaders())
< 	return
< }
< 
< func (res Resource) validateCompression() error {
< 	if res.Compression != nil {
< 		switch *res.Compression {
< 		case "", "gzip":
< 		default:
< 			return errors.ErrCompressionInvalid
< 		}
< 	}
< 	return nil
< }
< 
< func (res Resource) validateVerification() error {
< 	if res.Verification.Hash != nil && res.Source == nil {
< 		return errors.ErrVerificationAndNilSource
< 	}
< 	return nil
< }
< 
< func (res Resource) validateSchemeForHTTPHeaders() error {
< 	if len(res.HTTPHeaders) < 1 {
< 		return nil
< 	}
< 
< 	if util.NilOrEmpty(res.Source) {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	u, err := url.Parse(*res.Source)
< 	if err != nil {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	switch u.Scheme {
< 	case "http", "https":
< 		return nil
< 	default:
< 		return errors.ErrUnsupportedSchemeForHTTPHeaders
< 	}
< }
< 
< // Ensure that the Source is specified and valid.  This is not called by
< // Resource.Validate() because some structs that embed Resource don't
< // require Source to be specified.  Containing structs that require Source
< // should call this function from their Validate().
< func (res Resource) validateRequiredSource() error {
< 	if util.NilOrEmpty(res.Source) {
< 		return errors.ErrSourceRequired
< 	}
< 	return validateURL(*res.Source)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/schema.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/schema.go
1,246d0
< package types
< 
< // generated by "schematyper --package=types config/v3_3_experimental/schema/ignition.json -o config/v3_3_experimental/types/schema.go --root-type=Config" -- DO NOT EDIT
< 
< type Clevis struct {
< 	Custom    *Custom `json:"custom,omitempty"`
< 	Tang      []Tang  `json:"tang,omitempty"`
< 	Threshold *int    `json:"threshold,omitempty"`
< 	Tpm2      *bool   `json:"tpm2,omitempty"`
< }
< 
< type Config struct {
< 	Ignition Ignition `json:"ignition"`
< 	Passwd   Passwd   `json:"passwd,omitempty"`
< 	Storage  Storage  `json:"storage,omitempty"`
< 	Systemd  Systemd  `json:"systemd,omitempty"`
< }
< 
< type Custom struct {
< 	Config       string `json:"config"`
< 	NeedsNetwork *bool  `json:"needsNetwork,omitempty"`
< 	Pin          string `json:"pin"`
< }
< 
< type Device string
< 
< type Directory struct {
< 	Node
< 	DirectoryEmbedded1
< }
< 
< type DirectoryEmbedded1 struct {
< 	Mode *int `json:"mode,omitempty"`
< }
< 
< type Disk struct {
< 	Device     string      `json:"device"`
< 	Partitions []Partition `json:"partitions,omitempty"`
< 	WipeTable  *bool       `json:"wipeTable,omitempty"`
< }
< 
< type Dropin struct {
< 	Contents *string `json:"contents,omitempty"`
< 	Name     string  `json:"name"`
< }
< 
< type File struct {
< 	Node
< 	FileEmbedded1
< }
< 
< type FileEmbedded1 struct {
< 	Append   []Resource `json:"append,omitempty"`
< 	Contents Resource   `json:"contents,omitempty"`
< 	Mode     *int       `json:"mode,omitempty"`
< }
< 
< type Filesystem struct {
< 	Device         string             `json:"device"`
< 	Format         *string            `json:"format,omitempty"`
< 	Label          *string            `json:"label,omitempty"`
< 	MountOptions   []MountOption      `json:"mountOptions,omitempty"`
< 	Options        []FilesystemOption `json:"options,omitempty"`
< 	Path           *string            `json:"path,omitempty"`
< 	UUID           *string            `json:"uuid,omitempty"`
< 	WipeFilesystem *bool              `json:"wipeFilesystem,omitempty"`
< }
< 
< type FilesystemOption string
< 
< type Group string
< 
< type HTTPHeader struct {
< 	Name  string  `json:"name"`
< 	Value *string `json:"value,omitempty"`
< }
< 
< type HTTPHeaders []HTTPHeader
< 
< type Ignition struct {
< 	Config   IgnitionConfig `json:"config,omitempty"`
< 	Proxy    Proxy          `json:"proxy,omitempty"`
< 	Security Security       `json:"security,omitempty"`
< 	Timeouts Timeouts       `json:"timeouts,omitempty"`
< 	Version  string         `json:"version,omitempty"`
< }
< 
< type IgnitionConfig struct {
< 	Merge   []Resource `json:"merge,omitempty"`
< 	Replace Resource   `json:"replace,omitempty"`
< }
< 
< type Link struct {
< 	Node
< 	LinkEmbedded1
< }
< 
< type LinkEmbedded1 struct {
< 	Hard   *bool  `json:"hard,omitempty"`
< 	Target string `json:"target"`
< }
< 
< type Luks struct {
< 	Clevis     *Clevis      `json:"clevis,omitempty"`
< 	Device     *string      `json:"device,omitempty"`
< 	KeyFile    Resource     `json:"keyFile,omitempty"`
< 	Label      *string      `json:"label,omitempty"`
< 	Name       string       `json:"name"`
< 	Options    []LuksOption `json:"options,omitempty"`
< 	UUID       *string      `json:"uuid,omitempty"`
< 	WipeVolume *bool        `json:"wipeVolume,omitempty"`
< }
< 
< type LuksOption string
< 
< type MountOption string
< 
< type NoProxyItem string
< 
< type Node struct {
< 	Group     NodeGroup `json:"group,omitempty"`
< 	Overwrite *bool     `json:"overwrite,omitempty"`
< 	Path      string    `json:"path"`
< 	User      NodeUser  `json:"user,omitempty"`
< }
< 
< type NodeGroup struct {
< 	ID   *int    `json:"id,omitempty"`
< 	Name *string `json:"name,omitempty"`
< }
< 
< type NodeUser struct {
< 	ID   *int    `json:"id,omitempty"`
< 	Name *string `json:"name,omitempty"`
< }
< 
< type Partition struct {
< 	GUID               *string `json:"guid,omitempty"`
< 	Label              *string `json:"label,omitempty"`
< 	Number             int     `json:"number,omitempty"`
< 	Resize             *bool   `json:"resize,omitempty"`
< 	ShouldExist        *bool   `json:"shouldExist,omitempty"`
< 	SizeMiB            *int    `json:"sizeMiB,omitempty"`
< 	StartMiB           *int    `json:"startMiB,omitempty"`
< 	TypeGUID           *string `json:"typeGuid,omitempty"`
< 	WipePartitionEntry *bool   `json:"wipePartitionEntry,omitempty"`
< }
< 
< type Passwd struct {
< 	Groups []PasswdGroup `json:"groups,omitempty"`
< 	Users  []PasswdUser  `json:"users,omitempty"`
< }
< 
< type PasswdGroup struct {
< 	Gid          *int    `json:"gid,omitempty"`
< 	Name         string  `json:"name"`
< 	PasswordHash *string `json:"passwordHash,omitempty"`
< 	ShouldExist  *bool   `json:"shouldExist,omitempty"`
< 	System       *bool   `json:"system,omitempty"`
< }
< 
< type PasswdUser struct {
< 	Gecos             *string            `json:"gecos,omitempty"`
< 	Groups            []Group            `json:"groups,omitempty"`
< 	HomeDir           *string            `json:"homeDir,omitempty"`
< 	Name              string             `json:"name"`
< 	NoCreateHome      *bool              `json:"noCreateHome,omitempty"`
< 	NoLogInit         *bool              `json:"noLogInit,omitempty"`
< 	NoUserGroup       *bool              `json:"noUserGroup,omitempty"`
< 	PasswordHash      *string            `json:"passwordHash,omitempty"`
< 	PrimaryGroup      *string            `json:"primaryGroup,omitempty"`
< 	SSHAuthorizedKeys []SSHAuthorizedKey `json:"sshAuthorizedKeys,omitempty"`
< 	Shell             *string            `json:"shell,omitempty"`
< 	ShouldExist       *bool              `json:"shouldExist,omitempty"`
< 	System            *bool              `json:"system,omitempty"`
< 	UID               *int               `json:"uid,omitempty"`
< }
< 
< type Proxy struct {
< 	HTTPProxy  *string       `json:"httpProxy,omitempty"`
< 	HTTPSProxy *string       `json:"httpsProxy,omitempty"`
< 	NoProxy    []NoProxyItem `json:"noProxy,omitempty"`
< }
< 
< type Raid struct {
< 	Devices []Device     `json:"devices"`
< 	Level   string       `json:"level"`
< 	Name    string       `json:"name"`
< 	Options []RaidOption `json:"options,omitempty"`
< 	Spares  *int         `json:"spares,omitempty"`
< }
< 
< type RaidOption string
< 
< type Resource struct {
< 	Compression  *string      `json:"compression,omitempty"`
< 	HTTPHeaders  HTTPHeaders  `json:"httpHeaders,omitempty"`
< 	Source       *string      `json:"source,omitempty"`
< 	Verification Verification `json:"verification,omitempty"`
< }
< 
< type SSHAuthorizedKey string
< 
< type Security struct {
< 	TLS TLS `json:"tls,omitempty"`
< }
< 
< type Storage struct {
< 	Directories []Directory  `json:"directories,omitempty"`
< 	Disks       []Disk       `json:"disks,omitempty"`
< 	Files       []File       `json:"files,omitempty"`
< 	Filesystems []Filesystem `json:"filesystems,omitempty"`
< 	Links       []Link       `json:"links,omitempty"`
< 	Luks        []Luks       `json:"luks,omitempty"`
< 	Raid        []Raid       `json:"raid,omitempty"`
< }
< 
< type Systemd struct {
< 	Units []Unit `json:"units,omitempty"`
< }
< 
< type TLS struct {
< 	CertificateAuthorities []Resource `json:"certificateAuthorities,omitempty"`
< }
< 
< type Tang struct {
< 	Thumbprint *string `json:"thumbprint,omitempty"`
< 	URL        string  `json:"url,omitempty"`
< }
< 
< type Timeouts struct {
< 	HTTPResponseHeaders *int `json:"httpResponseHeaders,omitempty"`
< 	HTTPTotal           *int `json:"httpTotal,omitempty"`
< }
< 
< type Unit struct {
< 	Contents *string  `json:"contents,omitempty"`
< 	Dropins  []Dropin `json:"dropins,omitempty"`
< 	Enabled  *bool    `json:"enabled,omitempty"`
< 	Mask     *bool    `json:"mask,omitempty"`
< 	Name     string   `json:"name"`
< }
< 
< type Verification struct {
< 	Hash *string `json:"hash,omitempty"`
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/storage.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/storage.go
1,70d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"path"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	vpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (s Storage) MergedKeys() map[string]string {
< 	return map[string]string{
< 		"Directories": "Node",
< 		"Files":       "Node",
< 		"Links":       "Node",
< 	}
< }
< 
< func (s Storage) Validate(c vpath.ContextPath) (r report.Report) {
< 	for i, d := range s.Directories {
< 		for _, l := range s.Links {
< 			if strings.HasPrefix(d.Path, l.Path+"/") {
< 				r.AddOnError(c.Append("directories", i), errors.ErrDirectoryUsedSymlink)
< 			}
< 		}
< 	}
< 	for i, f := range s.Files {
< 		for _, l := range s.Links {
< 			if strings.HasPrefix(f.Path, l.Path+"/") {
< 				r.AddOnError(c.Append("files", i), errors.ErrFileUsedSymlink)
< 			}
< 		}
< 	}
< 	for i, l1 := range s.Links {
< 		for _, l2 := range s.Links {
< 			if strings.HasPrefix(l1.Path, l2.Path+"/") {
< 				r.AddOnError(c.Append("links", i), errors.ErrLinkUsedSymlink)
< 			}
< 		}
< 		if l1.Hard == nil || !*l1.Hard {
< 			continue
< 		}
< 		target := path.Clean(l1.Target)
< 		if !path.IsAbs(target) {
< 			target = path.Join(l1.Path, l1.Target)
< 		}
< 		for _, d := range s.Directories {
< 			if target == d.Path {
< 				r.AddOnError(c.Append("links", i), errors.ErrHardLinkToDirectory)
< 			}
< 		}
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/tang.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/tang.go
1,51d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (t Tang) Key() string {
< 	return t.URL
< }
< 
< func (t Tang) Validate(c path.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("url"), validateTangURL(t.URL))
< 	if util.NilOrEmpty(t.Thumbprint) {
< 		r.AddOnError(c.Append("thumbprint"), errors.ErrTangThumbprintRequired)
< 	}
< 	return
< }
< 
< func validateTangURL(s string) error {
< 	u, err := url.Parse(s)
< 	if err != nil {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	switch u.Scheme {
< 	case "http", "https":
< 		return nil
< 	default:
< 		return errors.ErrInvalidScheme
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/tls.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/tls.go
1,27d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (tls TLS) Validate(c path.ContextPath) (r report.Report) {
< 	for i, ca := range tls.CertificateAuthorities {
< 		r.AddOnError(c.Append("certificateAuthorities", i), ca.validateRequiredSource())
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/unit.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/unit.go
1,82d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"fmt"
< 	"path"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/shared/validations"
< 
< 	"github.com/coreos/go-systemd/v22/unit"
< 	cpath "github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< func (u Unit) Key() string {
< 	return u.Name
< }
< 
< func (d Dropin) Key() string {
< 	return d.Name
< }
< 
< func (u Unit) Validate(c cpath.ContextPath) (r report.Report) {
< 	r.AddOnError(c.Append("name"), validateName(u.Name))
< 	c = c.Append("contents")
< 	opts, err := validateUnitContent(u.Contents)
< 	r.AddOnError(c, err)
< 
< 	isEnabled := u.Enabled != nil && *u.Enabled
< 	r.AddOnWarn(c, validations.ValidateInstallSection(u.Name, isEnabled, (u.Contents == nil || *u.Contents == ""), opts))
< 
< 	return
< }
< 
< func validateName(name string) error {
< 	switch path.Ext(name) {
< 	case ".service", ".socket", ".device", ".mount", ".automount", ".swap", ".target", ".path", ".timer", ".snapshot", ".slice", ".scope":
< 	default:
< 		return errors.ErrInvalidSystemdExt
< 	}
< 	return nil
< }
< 
< func (d Dropin) Validate(c cpath.ContextPath) (r report.Report) {
< 	_, err := validateUnitContent(d.Contents)
< 	r.AddOnError(c.Append("contents"), err)
< 
< 	switch path.Ext(d.Name) {
< 	case ".conf":
< 	default:
< 		r.AddOnError(c.Append("name"), errors.ErrInvalidSystemdDropinExt)
< 	}
< 
< 	return
< }
< 
< func validateUnitContent(content *string) ([]*unit.UnitOption, error) {
< 	if content == nil {
< 		return []*unit.UnitOption{}, nil
< 	}
< 	c := strings.NewReader(*content)
< 	opts, err := unit.Deserialize(c)
< 	if err != nil {
< 		return nil, fmt.Errorf("invalid unit content: %s", err)
< 	}
< 	return opts, nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/url.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/url.go
1,57d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"net/url"
< 
< 	"github.com/vincent-petithory/dataurl"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< )
< 
< func validateURL(s string) error {
< 	u, err := url.Parse(s)
< 	if err != nil {
< 		return errors.ErrInvalidUrl
< 	}
< 
< 	switch u.Scheme {
< 	case "http", "https", "tftp", "gs":
< 		return nil
< 	case "s3":
< 		if v, ok := u.Query()["versionId"]; ok {
< 			if len(v) == 0 || v[0] == "" {
< 				return errors.ErrInvalidS3ObjectVersionId
< 			}
< 		}
< 		return nil
< 	case "data":
< 		if _, err := dataurl.DecodeString(s); err != nil {
< 			return err
< 		}
< 		return nil
< 	default:
< 		return errors.ErrInvalidScheme
< 	}
< }
< 
< func validateURLNilOK(s *string) error {
< 	if util.NilOrEmpty(s) {
< 		return nil
< 	}
< 	return validateURL(*s)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/verification.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/v3_3_experimental/types/verification.go
1,71d0
< // Copyright 2020 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package types
< 
< import (
< 	"crypto"
< 	"encoding/hex"
< 	"strings"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< // HashParts will return the sum and function (in that order) of the hash stored
< // in this Verification, or an error if there is an issue during parsing.
< func (v Verification) HashParts() (string, string, error) {
< 	if v.Hash == nil {
< 		// The hash can be nil
< 		return "", "", nil
< 	}
< 	parts := strings.SplitN(*v.Hash, "-", 2)
< 	if len(parts) != 2 {
< 		return "", "", errors.ErrHashMalformed
< 	}
< 
< 	return parts[0], parts[1], nil
< }
< 
< func (v Verification) Validate(c path.ContextPath) (r report.Report) {
< 	c = c.Append("hash")
< 	if v.Hash == nil {
< 		// The hash can be nil
< 		return
< 	}
< 
< 	function, sum, err := v.HashParts()
< 	if err != nil {
< 		r.AddOnError(c, err)
< 		return
< 	}
< 	var hash crypto.Hash
< 	switch function {
< 	case "sha512":
< 		hash = crypto.SHA512
< 	case "sha256":
< 		hash = crypto.SHA256
< 	default:
< 		r.AddOnError(c, errors.ErrHashUnrecognized)
< 		return
< 	}
< 
< 	if len(sum) != hex.EncodedLen(hash.Size()) {
< 		r.AddOnError(c, errors.ErrHashWrongSize)
< 	}
< 
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/validate/validate.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/ignition/v2/config/validate/validate.go
1,118d0
< // Copyright 2019 Red Hat, Inc.
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package validate
< 
< import (
< 	"fmt"
< 	"reflect"
< 
< 	"github.com/coreos/ignition/v2/config/shared/errors"
< 	"github.com/coreos/ignition/v2/config/util"
< 
< 	"github.com/coreos/vcontext/json"
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< 	"github.com/coreos/vcontext/tree"
< 	"github.com/coreos/vcontext/validate"
< )
< 
< func ValidateDups(v reflect.Value, c path.ContextPath) (r report.Report) {
< 	if v.Kind() != reflect.Struct {
< 		return
< 	}
< 	dupsLists := map[string]map[string]struct{}{}
< 	ignoreDups := map[string]struct{}{}
< 	if i, ok := v.Interface().(util.IgnoresDups); ok {
< 		ignoreDups = i.IgnoreDuplicates()
< 	}
< 	mergedKeys := map[string]string{}
< 	if m, ok := v.Interface().(util.MergesKeys); ok {
< 		mergedKeys = m.MergedKeys()
< 	}
< 
< 	fields := validate.GetFields(v)
< 	for _, field := range fields {
< 		if field.Type.Kind() != reflect.Slice {
< 			continue
< 		}
< 		if _, ignored := ignoreDups[field.Name]; ignored {
< 			continue
< 		}
< 		dupListName := field.Name
< 		if mergedName, ok := mergedKeys[field.Name]; ok {
< 			dupListName = mergedName
< 		}
< 		dupList := dupsLists[dupListName]
< 		if dupList == nil {
< 			dupsLists[dupListName] = make(map[string]struct{}, field.Value.Len())
< 			dupList = dupsLists[dupListName]
< 		}
< 		for i := 0; i < field.Value.Len(); i++ {
< 			key := util.CallKey(field.Value.Index(i))
< 			if _, isDup := dupList[key]; isDup {
< 				r.AddOnError(c.Append(validate.FieldName(field, c.Tag), i), errors.ErrDuplicate)
< 			}
< 			dupList[key] = struct{}{}
< 		}
< 	}
< 	return
< }
< 
< func ValidateUnusedKeys(v reflect.Value, c path.ContextPath, root tree.Node) (r report.Report) {
< 	if v.Kind() != reflect.Struct {
< 		return
< 	}
< 	node, err := root.Get(c)
< 	if err != nil {
< 		// not every node will have corresponding json
< 		return
< 	}
< 
< 	mapNode, ok := node.(tree.MapNode)
< 	if !ok {
< 		// Something is wrong, we won't be able to report unused keys here, so just warn about it and stop trying
< 		r.AddOnWarn(c, fmt.Errorf("context tree does not match content tree at %s. Line and column reporting may be inconsistent. Unused keys may not be reported.", c.String()))
< 		return
< 	}
< 
< 	fields := validate.GetFields(v)
< 	fieldMap := make(map[string]struct{}, len(fields))
< 	for _, field := range fields {
< 		fieldMap[validate.FieldName(field, c.Tag)] = struct{}{}
< 	}
< 	for key := range mapNode.Keys {
< 		if _, ok := fieldMap[key]; !ok {
< 			r.AddOnWarn(c.Append(tree.Key(key)), fmt.Errorf("Unused key %s", key))
< 		}
< 	}
< 	return
< }
< 
< func ValidateWithContext(cfg interface{}, raw []byte) report.Report {
< 	r := validate.Validate(cfg, "json")
< 	r.Merge(validate.ValidateCustom(cfg, "json", ValidateDups))
< 	if raw == nil {
< 		return r
< 	}
< 
< 	if cxt, err := json.UnmarshalToContext(raw); err == nil {
< 		unusedKeyCheck := func(v reflect.Value, c path.ContextPath) report.Report {
< 			return ValidateUnusedKeys(v, c, cxt)
< 		}
< 		r.Merge(validate.ValidateCustom(cfg, "json", unusedKeyCheck))
< 		r.Correlate(cxt)
< 	}
< 	return r
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/LICENSE
1,202d0
< Apache License
<                            Version 2.0, January 2004
<                         http://www.apache.org/licenses/
< 
<    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
< 
<    1. Definitions.
< 
<       "License" shall mean the terms and conditions for use, reproduction,
<       and distribution as defined by Sections 1 through 9 of this document.
< 
<       "Licensor" shall mean the copyright owner or entity authorized by
<       the copyright owner that is granting the License.
< 
<       "Legal Entity" shall mean the union of the acting entity and all
<       other entities that control, are controlled by, or are under common
<       control with that entity. For the purposes of this definition,
<       "control" means (i) the power, direct or indirect, to cause the
<       direction or management of such entity, whether by contract or
<       otherwise, or (ii) ownership of fifty percent (50%) or more of the
<       outstanding shares, or (iii) beneficial ownership of such entity.
< 
<       "You" (or "Your") shall mean an individual or Legal Entity
<       exercising permissions granted by this License.
< 
<       "Source" form shall mean the preferred form for making modifications,
<       including but not limited to software source code, documentation
<       source, and configuration files.
< 
<       "Object" form shall mean any form resulting from mechanical
<       transformation or translation of a Source form, including but
<       not limited to compiled object code, generated documentation,
<       and conversions to other media types.
< 
<       "Work" shall mean the work of authorship, whether in Source or
<       Object form, made available under the License, as indicated by a
<       copyright notice that is included in or attached to the work
<       (an example is provided in the Appendix below).
< 
<       "Derivative Works" shall mean any work, whether in Source or Object
<       form, that is based on (or derived from) the Work and for which the
<       editorial revisions, annotations, elaborations, or other modifications
<       represent, as a whole, an original work of authorship. For the purposes
<       of this License, Derivative Works shall not include works that remain
<       separable from, or merely link (or bind by name) to the interfaces of,
<       the Work and Derivative Works thereof.
< 
<       "Contribution" shall mean any work of authorship, including
<       the original version of the Work and any modifications or additions
<       to that Work or Derivative Works thereof, that is intentionally
<       submitted to Licensor for inclusion in the Work by the copyright owner
<       or by an individual or Legal Entity authorized to submit on behalf of
<       the copyright owner. For the purposes of this definition, "submitted"
<       means any form of electronic, verbal, or written communication sent
<       to the Licensor or its representatives, including but not limited to
<       communication on electronic mailing lists, source code control systems,
<       and issue tracking systems that are managed by, or on behalf of, the
<       Licensor for the purpose of discussing and improving the Work, but
<       excluding communication that is conspicuously marked or otherwise
<       designated in writing by the copyright owner as "Not a Contribution."
< 
<       "Contributor" shall mean Licensor and any individual or Legal Entity
<       on behalf of whom a Contribution has been received by Licensor and
<       subsequently incorporated within the Work.
< 
<    2. Grant of Copyright License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       copyright license to reproduce, prepare Derivative Works of,
<       publicly display, publicly perform, sublicense, and distribute the
<       Work and such Derivative Works in Source or Object form.
< 
<    3. Grant of Patent License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       (except as stated in this section) patent license to make, have made,
<       use, offer to sell, sell, import, and otherwise transfer the Work,
<       where such license applies only to those patent claims licensable
<       by such Contributor that are necessarily infringed by their
<       Contribution(s) alone or by combination of their Contribution(s)
<       with the Work to which such Contribution(s) was submitted. If You
<       institute patent litigation against any entity (including a
<       cross-claim or counterclaim in a lawsuit) alleging that the Work
<       or a Contribution incorporated within the Work constitutes direct
<       or contributory patent infringement, then any patent licenses
<       granted to You under this License for that Work shall terminate
<       as of the date such litigation is filed.
< 
<    4. Redistribution. You may reproduce and distribute copies of the
<       Work or Derivative Works thereof in any medium, with or without
<       modifications, and in Source or Object form, provided that You
<       meet the following conditions:
< 
<       (a) You must give any other recipients of the Work or
<           Derivative Works a copy of this License; and
< 
<       (b) You must cause any modified files to carry prominent notices
<           stating that You changed the files; and
< 
<       (c) You must retain, in the Source form of any Derivative Works
<           that You distribute, all copyright, patent, trademark, and
<           attribution notices from the Source form of the Work,
<           excluding those notices that do not pertain to any part of
<           the Derivative Works; and
< 
<       (d) If the Work includes a "NOTICE" text file as part of its
<           distribution, then any Derivative Works that You distribute must
<           include a readable copy of the attribution notices contained
<           within such NOTICE file, excluding those notices that do not
<           pertain to any part of the Derivative Works, in at least one
<           of the following places: within a NOTICE text file distributed
<           as part of the Derivative Works; within the Source form or
<           documentation, if provided along with the Derivative Works; or,
<           within a display generated by the Derivative Works, if and
<           wherever such third-party notices normally appear. The contents
<           of the NOTICE file are for informational purposes only and
<           do not modify the License. You may add Your own attribution
<           notices within Derivative Works that You distribute, alongside
<           or as an addendum to the NOTICE text from the Work, provided
<           that such additional attribution notices cannot be construed
<           as modifying the License.
< 
<       You may add Your own copyright statement to Your modifications and
<       may provide additional or different license terms and conditions
<       for use, reproduction, or distribution of Your modifications, or
<       for any such Derivative Works as a whole, provided Your use,
<       reproduction, and distribution of the Work otherwise complies with
<       the conditions stated in this License.
< 
<    5. Submission of Contributions. Unless You explicitly state otherwise,
<       any Contribution intentionally submitted for inclusion in the Work
<       by You to the Licensor shall be under the terms and conditions of
<       this License, without any additional terms or conditions.
<       Notwithstanding the above, nothing herein shall supersede or modify
<       the terms of any separate license agreement you may have executed
<       with Licensor regarding such Contributions.
< 
<    6. Trademarks. This License does not grant permission to use the trade
<       names, trademarks, service marks, or product names of the Licensor,
<       except as required for reasonable and customary use in describing the
<       origin of the Work and reproducing the content of the NOTICE file.
< 
<    7. Disclaimer of Warranty. Unless required by applicable law or
<       agreed to in writing, Licensor provides the Work (and each
<       Contributor provides its Contributions) on an "AS IS" BASIS,
<       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
<       implied, including, without limitation, any warranties or conditions
<       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
<       PARTICULAR PURPOSE. You are solely responsible for determining the
<       appropriateness of using or redistributing the Work and assume any
<       risks associated with Your exercise of permissions under this License.
< 
<    8. Limitation of Liability. In no event and under no legal theory,
<       whether in tort (including negligence), contract, or otherwise,
<       unless required by applicable law (such as deliberate and grossly
<       negligent acts) or agreed to in writing, shall any Contributor be
<       liable to You for damages, including any direct, indirect, special,
<       incidental, or consequential damages of any character arising as a
<       result of this License or out of the use or inability to use the
<       Work (including but not limited to damages for loss of goodwill,
<       work stoppage, computer failure or malfunction, or any and all
<       other commercial damages or losses), even if such Contributor
<       has been advised of the possibility of such damages.
< 
<    9. Accepting Warranty or Additional Liability. While redistributing
<       the Work or Derivative Works thereof, You may choose to offer,
<       and charge a fee for, acceptance of support, warranty, indemnity,
<       or other liability obligations and/or rights consistent with this
<       License. However, in accepting such obligations, You may act only
<       on Your own behalf and on Your sole responsibility, not on behalf
<       of any other Contributor, and only if You agree to indemnify,
<       defend, and hold each Contributor harmless for any liability
<       incurred by, or claims asserted against, such Contributor by reason
<       of your accepting any such warranty or additional liability.
< 
<    END OF TERMS AND CONDITIONS
< 
<    APPENDIX: How to apply the Apache License to your work.
< 
<       To apply the Apache License to your work, attach the following
<       boilerplate notice, with the fields enclosed by brackets "{}"
<       replaced with your own identifying information. (Don't include
<       the brackets!)  The text should be enclosed in the appropriate
<       comment syntax for the file format. We also recommend that a
<       file or class name and description of purpose be included on the
<       same "printed page" as the copyright notice for easier
<       identification within third-party archives.
< 
<    Copyright {yyyy} {name of copyright owner}
< 
<    Licensed under the Apache License, Version 2.0 (the "License");
<    you may not use this file except in compliance with the License.
<    You may obtain a copy of the License at
< 
<        http://www.apache.org/licenses/LICENSE-2.0
< 
<    Unless required by applicable law or agreed to in writing, software
<    distributed under the License is distributed on an "AS IS" BASIS,
<    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<    See the License for the specific language governing permissions and
<    limitations under the License.
< 
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/json/json.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/json/json.go
1,64d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package json
< 
< import (
< 	"github.com/coreos/vcontext/tree"
< 	// todo: rewrite this dep
< 	json "github.com/coreos/go-json"
< )
< 
< func UnmarshalToContext(raw []byte) (tree.Node, error) {
< 	var ast json.Node
< 	if err := json.Unmarshal(raw, &ast); err != nil {
< 		return nil, err
< 	}
< 	node := fromJsonNode(ast)
< 	tree.FixLineColumn(node, raw)
< 	return node, nil
< }
< 
< func fromJsonNode(n json.Node) tree.Node {
< 	m := tree.MarkerFromIndices(int64(n.Start), int64(n.End))
< 
< 	switch v := n.Value.(type) {
< 	case map[string]json.Node:
< 		ret := tree.MapNode{
< 			Marker:   m,
< 			Children: make(map[string]tree.Node, len(v)),
< 			Keys:     make(map[string]tree.Leaf, len(v)),
< 		}
< 		for key, child := range v {
< 			ret.Children[key] = fromJsonNode(child)
< 			ret.Keys[key] = tree.Leaf{
< 				Marker: tree.MarkerFromIndices(int64(child.KeyStart), int64(child.KeyEnd)),
< 			}
< 		}
< 		return ret
< 	case []json.Node:
< 		ret := tree.SliceNode{
< 			Marker:   m,
< 			Children: make([]tree.Node, 0, len(v)),
< 		}
< 		for _, child := range v {
< 			ret.Children = append(ret.Children, fromJsonNode(child))
< 		}
< 		return ret
< 	default:
< 		return tree.Leaf{
< 			Marker: m,
< 		}
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/path/path.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/path/path.go
1,90d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package path
< 
< import (
< 	"fmt"
< 	"strings"
< )
< 
< type ContextPath struct {
< 	Path []interface{}
< 	Tag  string
< }
< 
< // New returns a new ContextPath with the given tag and path. It's a helper since go's
< // literal syntax is quite verbose, especially with []interface{}{...}.
< func New(tag string, path ...interface{}) ContextPath {
< 	return ContextPath{
< 		Tag:  tag,
< 		Path: path,
< 	}
< }
< 
< func (c ContextPath) String() string {
< 	strs := []string{"$"}
< 	for _, e := range c.Path {
< 		strs = append(strs, fmt.Sprintf("%v", e))
< 	}
< 	return strings.Join(strs, ".")
< }
< 
< func (c ContextPath) Append(e ...interface{}) ContextPath {
< 	return ContextPath{
< 		Path: append(c.Path, e...),
< 		Tag:  c.Tag,
< 	}
< }
< 
< func (c ContextPath) Copy() ContextPath {
< 	// make sure to preserve reflect.DeepEqual() equality
< 	var path []interface{}
< 	if c.Path != nil {
< 		path = append(path, c.Path...)
< 	}
< 	return ContextPath{
< 		Path: path,
< 		Tag:  c.Tag,
< 	}
< }
< 
< // Head returns the first element in the path, panics if empty.
< func (c ContextPath) Head() interface{} {
< 	return c.Path[0]
< }
< 
< func (c ContextPath) Tail() ContextPath {
< 	if len(c.Path) == 0 {
< 		return ContextPath{}
< 	}
< 	return ContextPath{
< 		Path: c.Path[1:],
< 		Tag:  c.Tag,
< 	}
< }
< 
< func (c ContextPath) Pop() ContextPath {
< 	if len(c.Path) == 0 {
< 		return ContextPath{}
< 	}
< 	return ContextPath{
< 		Path: c.Path[:c.Len()-1],
< 		Tag:  c.Tag,
< 	}
< }
< 
< func (c ContextPath) Len() int {
< 	return len(c.Path)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/report/report.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/report/report.go
1,153d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package report
< 
< import (
< 	"fmt"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/tree"
< )
< 
< // EntryKind represents an Entry's severity.
< type EntryKind interface {
< 	String() string
< 	IsFatal() bool
< }
< 
< // Report is a collection of information from validating a struct.
< type Report struct {
< 	Entries []Entry
< }
< 
< // Merge adds the entries from child to r.
< func (r *Report) Merge(child Report) {
< 	r.Entries = append(r.Entries, child.Entries...)
< }
< 
< // getDeepestNode returns the deepest node matching the context.
< func getDeepestNode(n tree.Node, c path.ContextPath) tree.Node {
< 	if child, err := n.Get(c); err != nil {
< 		return getDeepestNode(n, c.Pop())
< 	} else {
< 		return child
< 	}
< }
< 
< // Correlate takes a node tree and populates the markers in the report's entries
< // based on the entries' context.
< func (r *Report) Correlate(n tree.Node) {
< 	for i, e := range r.Entries {
< 		r.Entries[i].Marker = getDeepestNode(n, e.Context).GetMarker()
< 	}
< }
< 
< // IsFatal returns true if any entries are fatal.
< func (r Report) IsFatal() bool {
< 	for _, e := range r.Entries {
< 		if e.Kind.IsFatal() {
< 			return true
< 		}
< 	}
< 	return false
< }
< 
< func (r Report) String() string {
< 	str := ""
< 	for _, e := range r.Entries {
< 		str += e.String() + "\n"
< 	}
< 	return str
< }
< 
< // Entry represents one error or message from validation.
< type Entry struct {
< 	// Kind is the severity of the message.
< 	Kind    EntryKind
< 	Message string
< 
< 	// Context is the logical location of the error.
< 	Context path.ContextPath
< 
< 	// Marker is the literal location in a json or yaml blob of the error.
< 	Marker tree.Marker
< }
< 
< func (e Entry) String() string {
< 	at := ""
< 	switch {
< 	case e.Marker.StartP != nil && e.Context.Len() != 0:
< 		at = fmt.Sprintf(" at %s, %s", e.Context.String(), e.Marker.String())
< 	case e.Marker.StartP != nil:
< 		at = fmt.Sprintf(" at %s", e.Marker.String())
< 	case e.Context.Len() != 0:
< 		at = fmt.Sprintf(" at %s", e.Context.String())
< 	}
< 
< 	return fmt.Sprintf("%s%s: %s", e.Kind.String(), at, e.Message)
< }
< 
< // Kind is a default set of EntryKind.
< type Kind int
< 
< const (
< 	Error Kind = iota
< 	Warn  Kind = iota
< 	Info  Kind = iota
< )
< 
< func (k Kind) String() string {
< 	switch k {
< 	case Error:
< 		return "error"
< 	case Warn:
< 		return "warning"
< 	case Info:
< 		return "info"
< 	default:
< 		return "unknown severity"
< 	}
< }
< 
< func (k Kind) IsFatal() bool {
< 	return k == Error
< }
< 
< func (r *Report) AddOn(c path.ContextPath, err error, k EntryKind) {
< 	if err == nil {
< 		return
< 	}
< 	r.Entries = append(r.Entries, Entry{
< 		Message: err.Error(),
< 		Context: c,
< 		Kind:    k,
< 	})
< }
< 
< // AddOnError adds err to report with kind "Error" if err is not nil.
< func (r *Report) AddOnError(c path.ContextPath, err error) {
< 	r.AddOn(c, err, Error)
< 
< }
< 
< // AddOnWarn adds err to report with kind "Warning" if err is not nil.
< func (r *Report) AddOnWarn(c path.ContextPath, err error) {
< 	r.AddOn(c, err, Warn)
< }
< 
< // AddOnInfo adds err to report with kind "Info" if err is not nil.
< func (r *Report) AddOnInfo(c path.ContextPath, err error) {
< 	r.AddOn(c, err, Info)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/tree/tree.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/tree/tree.go
1,216d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package tree
< 
< import (
< 	"errors"
< 	"fmt"
< 	"sort"
< 
< 	"github.com/coreos/vcontext/path"
< )
< 
< var (
< 	ErrBadPath = errors.New("invalid path")
< )
< 
< // Node is generic representation of a json or yaml node.
< type Node interface {
< 	Start() (int64, int64) // line, col
< 	End() (int64, int64)
< 	Get(cxt path.ContextPath) (Node, error)
< 	GetMarker() Marker
< 	pos() []*Pos // just used for iterating through the markers to fill in line and column from index
< }
< 
< // FixLineColumn populates the Line and Column of nodes that only have Index set.
< func FixLineColumn(n Node, source []byte) {
< 	fixLineColumn(n.pos(), source)
< }
< 
< func fixLineColumn(p []*Pos, source []byte) {
< 	sort.Slice(p, func(i, j int) bool {
< 		return p[i].Index < p[j].Index
< 	})
< 	pi := 0
< 	line, col := int64(1), int64(1)
< 	for i, c := range source {
< 		if pi == len(p) {
< 			return
< 		}
< 		for int64(i) == p[pi].Index {
< 			p[pi].Line = line
< 			p[pi].Column = col
< 			pi++
< 			if pi == len(p) {
< 				return
< 			}
< 		}
< 		col++
< 		if c == '\n' {
< 			line++
< 			col = 1
< 		}
< 	}
< }
< 
< // Key is used to differentiate leaves describing the start and end of where
< // a key starts and where a value starts.
< type Key string
< 
< // Pos represents a single location in a string.
< type Pos struct {
< 	Index  int64
< 	Line   int64
< 	Column int64
< }
< 
< func posString(p *Pos) string {
< 	if p == nil {
< 		return ""
< 	}
< 	return fmt.Sprintf("line %d col %d", p.Line, p.Column)
< }
< 
< func posLC(p *Pos) (int64, int64) {
< 	if p == nil {
< 		return 0, 0
< 	}
< 	return p.Line, p.Column
< }
< 
< // Markers are composed of information regarding the start and
< // end of where a Node exists in its source.
< type Marker struct {
< 	StartP *Pos
< 	EndP   *Pos
< }
< 
< func (m Marker) Start() (int64, int64) {
< 	return posLC(m.StartP)
< }
< 
< func (m Marker) End() (int64, int64) {
< 	return posLC(m.EndP)
< }
< 
< func (m Marker) String() string {
< 	// Just do start for now, figure out end later
< 	return posString(m.StartP)
< }
< 
< func (marker Marker) GetMarker() Marker {
< 	return marker
< }
< 
< func MarkerFromIndices(start, end int64) Marker {
< 	m := Marker{}
< 	if start >= 0 {
< 		m.StartP = &Pos{Index: start}
< 	}
< 	if end >= 0 {
< 		m.EndP = &Pos{Index: end}
< 	}
< 	return m
< }
< 
< func appendPos(l []*Pos, p *Pos) []*Pos {
< 	if p != nil {
< 		return append(l, p)
< 	}
< 	return l
< }
< 
< type MapNode struct {
< 	Marker
< 	Children map[string]Node
< 	Keys     map[string]Leaf
< }
< 
< func (m MapNode) Get(cxt path.ContextPath) (Node, error) {
< 	if cxt.Len() == 0 {
< 		return m, nil
< 	}
< 	switch p := cxt.Head().(type) {
< 	case string:
< 		if r, ok := m.Children[p]; ok {
< 			return r.Get(cxt.Tail())
< 		} else {
< 			return nil, ErrBadPath
< 		}
< 	case Key:
< 		if r, ok := m.Keys[string(p)]; ok {
< 			return r.Get(cxt.Tail())
< 		} else {
< 			return nil, ErrBadPath
< 		}
< 	default:
< 		return nil, ErrBadPath
< 	}
< }
< 
< func (m MapNode) pos() []*Pos {
< 	ret := appendPos(nil, m.StartP)
< 	for _, v := range m.Children {
< 		ret = append(ret, v.pos()...)
< 	}
< 	for _, v := range m.Keys {
< 		ret = append(ret, v.pos()...)
< 	}
< 	ret = appendPos(ret, m.EndP)
< 	return ret
< }
< 
< type Leaf struct {
< 	Marker
< }
< 
< func (l Leaf) pos() []*Pos {
< 	return appendPos(appendPos(nil, l.StartP), l.EndP)
< }
< 
< func (k Leaf) Get(ctx path.ContextPath) (Node, error) {
< 	if ctx.Len() == 0 {
< 		return k, nil
< 	}
< 	return nil, ErrBadPath
< }
< 
< type SliceNode struct {
< 	Marker
< 	Children []Node
< }
< 
< func (s SliceNode) Get(ctx path.ContextPath) (Node, error) {
< 	if ctx.Len() == 0 {
< 		return s, nil
< 	}
< 	if i, ok := ctx.Head().(int); ok {
< 		if i >= len(s.Children) {
< 			return nil, ErrBadPath
< 		}
< 		return s.Children[i].Get(ctx.Tail())
< 	}
< 	return nil, ErrBadPath
< }
< 
< func (s SliceNode) pos() []*Pos {
< 	ret := appendPos(nil, s.StartP)
< 	for _, v := range s.Children {
< 		ret = append(ret, v.pos()...)
< 	}
< 	ret = appendPos(ret, s.EndP)
< 	return ret
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/validate/validate.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/validate/validate.go
1,149d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package validate
< 
< import (
< 	"reflect"
< 	"strings"
< 
< 	"github.com/coreos/vcontext/path"
< 	"github.com/coreos/vcontext/report"
< )
< 
< type CustomValidator func(v reflect.Value, c path.ContextPath) report.Report
< 
< // validator is the interface the DefaultValidator function uses when validating types.
< // Most users should implement this interface on types they want to validate.
< type validator interface {
< 	Validate(path.ContextPath) report.Report
< }
< 
< // DefaultValidator checks if the type implements the validator interface and calls the
< // validate function if it does, returning the report.
< func DefaultValidator(v reflect.Value, c path.ContextPath) report.Report {
< 	// first check if this object has Validate(context) defined, but only on value
< 	// recievers. Both pointer and value receivers satisfy a value receiver interface
< 	// so ensure we're not a pointer too.
< 	if obj, ok := v.Interface().(validator); ok && v.Kind() != reflect.Ptr {
< 		return obj.Validate(c)
< 	}
< 	return report.Report{}
< }
< 
< // ValidateCustom validates thing using the custom validation function supplied. Most users will not need this
< // and should use Validate() instead.
< func ValidateCustom(thing interface{}, tag string, customValidator CustomValidator) report.Report {
< 	if thing == nil {
< 		return report.Report{}
< 	}
< 	v := reflect.ValueOf(thing)
< 	ctx := path.ContextPath{Tag: tag}
< 	return validate(ctx, v, customValidator)
< }
< 
< // Validate walks the structs, slices, and pointers in thing and calls any Validate(path.ContextPath) report.Report
< // functions defined on the types, aggregating the results.
< func Validate(thing interface{}, tag string) report.Report {
< 	return ValidateCustom(thing, tag, DefaultValidator)
< }
< 
< func validate(context path.ContextPath, v reflect.Value, validateFunc CustomValidator) (r report.Report) {
< 	if !v.IsValid() {
< 		return
< 	}
< 	if v.Kind() == reflect.Interface {
< 		if v.IsNil() {
< 			return
< 		} else {
< 			v = makeConcrete(v)
< 		}
< 	}
< 
< 	r.Merge(validateFunc(v, context.Copy()))
< 
< 	switch v.Kind() {
< 	case reflect.Struct:
< 		r.Merge(validateStruct(context, v, validateFunc))
< 	case reflect.Slice:
< 		r.Merge(validateSlice(context, v, validateFunc))
< 	case reflect.Ptr:
< 		if !v.IsNil() {
< 			r.Merge(validate(context, v.Elem(), validateFunc))
< 		}
< 	}
< 
< 	return
< }
< 
< // StructField is an extension of go's reflect.StructField that also includes the value.
< type StructField struct {
< 	reflect.StructField
< 	Value reflect.Value
< }
< 
< // makeConcrete takes a value and if it is a value of an interface returns the
< // value of the actual underlying type implementing that interface. If the value
< // is already concrete, it returns the same value.
< func makeConcrete(v reflect.Value) reflect.Value {
< 	return reflect.ValueOf(v.Interface())
< }
< 
< // GetFields takes a value of a struct and flattens all embedded structs in it.
< // If any fields are interfaces, it "dereferences" the interface to its underlying type.
< func GetFields(v reflect.Value) []StructField {
< 	ret := []StructField{}
< 	if v.Kind() != reflect.Struct {
< 		return ret
< 	}
< 
< 	for i := 0; i < v.NumField(); i++ {
< 		field := v.Type().Field(i)
< 		if !field.Anonymous {
< 			ret = append(ret, StructField{
< 				StructField: field,
< 				Value:       v.Field(i),
< 			})
< 		} else {
< 			concrete := makeConcrete(v.Field(i))
< 			ret = append(ret, GetFields(concrete)...)
< 		}
< 	}
< 	return ret
< }
< 
< func FieldName(s StructField, tag string) string {
< 	if tag == "" {
< 		return s.Name
< 	}
< 	tag = s.Tag.Get(tag)
< 	return strings.Split(tag, ",")[0]
< }
< 
< func validateStruct(context path.ContextPath, v reflect.Value, f CustomValidator) (r report.Report) {
< 	fields := GetFields(v)
< 	for _, field := range fields {
< 		fieldContext := context.Append(FieldName(field, context.Tag))
< 		r.Merge(validate(fieldContext, field.Value, f))
< 	}
< 	return
< }
< 
< func validateSlice(context path.ContextPath, v reflect.Value, f CustomValidator) (r report.Report) {
< 	for i := 0; i < v.Len(); i++ {
< 		childContext := context.Append(i)
< 		r.Merge(validate(childContext, v.Index(i), f))
< 	}
< 	return
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/yaml/yaml.go updated/vendor/github.com/coreos/fcct/vendor/github.com/coreos/vcontext/yaml/yaml.go
1,82d0
< // Copyright 2019 Red Hat, Inc
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.)
< 
< package json
< 
< import (
< 	"github.com/coreos/vcontext/tree"
< 
< 	"gopkg.in/yaml.v3"
< )
< 
< func UnmarshalToContext(raw []byte) (tree.Node, error) {
< 	var ast yaml.Node
< 	if err := yaml.Unmarshal(raw, &ast); err != nil {
< 		return nil, err
< 	}
< 	return fromYamlNode(ast), nil
< }
< 
< func fromYamlNode(n yaml.Node) tree.Node {
< 	m := tree.Marker{
< 		StartP: &tree.Pos{
< 			Line:   int64(n.Line),
< 			Column: int64(n.Column),
< 		},
< 	}
< 	switch n.Kind {
< 	case 0:
< 		// empty
< 		return nil
< 	case yaml.DocumentNode:
< 		if len(n.Content) == 0 {
< 			return nil
< 		}
< 		return fromYamlNode(*n.Content[0])
< 	case yaml.MappingNode:
< 		ret := tree.MapNode{
< 			Marker:   m,
< 			Children: make(map[string]tree.Node, len(n.Content)/2),
< 			Keys:     make(map[string]tree.Leaf, len(n.Content)/2),
< 		}
< 		// MappingNodes list keys and values like [k, v, k, v...]
< 		for i := 0; i < len(n.Content); i += 2 {
< 			key := *n.Content[i]
< 			value := *n.Content[i+1]
< 			ret.Keys[key.Value] = tree.Leaf{
< 				Marker: tree.Marker{
< 					StartP: &tree.Pos{
< 						Line:   int64(key.Line),
< 						Column: int64(key.Column),
< 					},
< 				},
< 			}
< 			ret.Children[key.Value] = fromYamlNode(value)
< 		}
< 		return ret
< 	case yaml.SequenceNode:
< 		ret := tree.SliceNode{
< 			Marker:   m,
< 			Children: make([]tree.Node, 0, len(n.Content)),
< 		}
< 		for _, child := range n.Content {
< 			ret.Children = append(ret.Children, fromYamlNode(*child))
< 		}
< 		return ret
< 	default: // scalars and aliases
< 		return tree.Leaf{
< 			Marker: m,
< 		}
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/LICENSE
1,15d0
< ISC License
< 
< Copyright (c) 2012-2016 Dave Collins <dave@davec.name>
< 
< Permission to use, copy, modify, and/or distribute this software for any
< purpose with or without fee is hereby granted, provided that the above
< copyright notice and this permission notice appear in all copies.
< 
< THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
< WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
< MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
< ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
< WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
< ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
< OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/bypass.go updated/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/bypass.go
1,145d0
< // Copyright (c) 2015-2016 Dave Collins <dave@davec.name>
< //
< // Permission to use, copy, modify, and distribute this software for any
< // purpose with or without fee is hereby granted, provided that the above
< // copyright notice and this permission notice appear in all copies.
< //
< // THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
< // WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
< // MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
< // ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
< // WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
< // ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
< // OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
< 
< // NOTE: Due to the following build constraints, this file will only be compiled
< // when the code is not running on Google App Engine, compiled by GopherJS, and
< // "-tags safe" is not added to the go build command line.  The "disableunsafe"
< // tag is deprecated and thus should not be used.
< // Go versions prior to 1.4 are disabled because they use a different layout
< // for interfaces which make the implementation of unsafeReflectValue more complex.
< // +build !js,!appengine,!safe,!disableunsafe,go1.4
< 
< package spew
< 
< import (
< 	"reflect"
< 	"unsafe"
< )
< 
< const (
< 	// UnsafeDisabled is a build-time constant which specifies whether or
< 	// not access to the unsafe package is available.
< 	UnsafeDisabled = false
< 
< 	// ptrSize is the size of a pointer on the current arch.
< 	ptrSize = unsafe.Sizeof((*byte)(nil))
< )
< 
< type flag uintptr
< 
< var (
< 	// flagRO indicates whether the value field of a reflect.Value
< 	// is read-only.
< 	flagRO flag
< 
< 	// flagAddr indicates whether the address of the reflect.Value's
< 	// value may be taken.
< 	flagAddr flag
< )
< 
< // flagKindMask holds the bits that make up the kind
< // part of the flags field. In all the supported versions,
< // it is in the lower 5 bits.
< const flagKindMask = flag(0x1f)
< 
< // Different versions of Go have used different
< // bit layouts for the flags type. This table
< // records the known combinations.
< var okFlags = []struct {
< 	ro, addr flag
< }{{
< 	// From Go 1.4 to 1.5
< 	ro:   1 << 5,
< 	addr: 1 << 7,
< }, {
< 	// Up to Go tip.
< 	ro:   1<<5 | 1<<6,
< 	addr: 1 << 8,
< }}
< 
< var flagValOffset = func() uintptr {
< 	field, ok := reflect.TypeOf(reflect.Value{}).FieldByName("flag")
< 	if !ok {
< 		panic("reflect.Value has no flag field")
< 	}
< 	return field.Offset
< }()
< 
< // flagField returns a pointer to the flag field of a reflect.Value.
< func flagField(v *reflect.Value) *flag {
< 	return (*flag)(unsafe.Pointer(uintptr(unsafe.Pointer(v)) + flagValOffset))
< }
< 
< // unsafeReflectValue converts the passed reflect.Value into a one that bypasses
< // the typical safety restrictions preventing access to unaddressable and
< // unexported data.  It works by digging the raw pointer to the underlying
< // value out of the protected value and generating a new unprotected (unsafe)
< // reflect.Value to it.
< //
< // This allows us to check for implementations of the Stringer and error
< // interfaces to be used for pretty printing ordinarily unaddressable and
< // inaccessible values such as unexported struct fields.
< func unsafeReflectValue(v reflect.Value) reflect.Value {
< 	if !v.IsValid() || (v.CanInterface() && v.CanAddr()) {
< 		return v
< 	}
< 	flagFieldPtr := flagField(&v)
< 	*flagFieldPtr &^= flagRO
< 	*flagFieldPtr |= flagAddr
< 	return v
< }
< 
< // Sanity checks against future reflect package changes
< // to the type or semantics of the Value.flag field.
< func init() {
< 	field, ok := reflect.TypeOf(reflect.Value{}).FieldByName("flag")
< 	if !ok {
< 		panic("reflect.Value has no flag field")
< 	}
< 	if field.Type.Kind() != reflect.TypeOf(flag(0)).Kind() {
< 		panic("reflect.Value flag field has changed kind")
< 	}
< 	type t0 int
< 	var t struct {
< 		A t0
< 		// t0 will have flagEmbedRO set.
< 		t0
< 		// a will have flagStickyRO set
< 		a t0
< 	}
< 	vA := reflect.ValueOf(t).FieldByName("A")
< 	va := reflect.ValueOf(t).FieldByName("a")
< 	vt0 := reflect.ValueOf(t).FieldByName("t0")
< 
< 	// Infer flagRO from the difference between the flags
< 	// for the (otherwise identical) fields in t.
< 	flagPublic := *flagField(&vA)
< 	flagWithRO := *flagField(&va) | *flagField(&vt0)
< 	flagRO = flagPublic ^ flagWithRO
< 
< 	// Infer flagAddr from the difference between a value
< 	// taken from a pointer and not.
< 	vPtrA := reflect.ValueOf(&t).Elem().FieldByName("A")
< 	flagNoPtr := *flagField(&vA)
< 	flagPtr := *flagField(&vPtrA)
< 	flagAddr = flagNoPtr ^ flagPtr
< 
< 	// Check that the inferred flags tally with one of the known versions.
< 	for _, f := range okFlags {
< 		if flagRO == f.ro && flagAddr == f.addr {
< 			return
< 		}
< 	}
< 	panic("reflect.Value read-only flag has changed semantics")
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/bypasssafe.go updated/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/bypasssafe.go
1,38d0
< // Copyright (c) 2015-2016 Dave Collins <dave@davec.name>
< //
< // Permission to use, copy, modify, and distribute this software for any
< // purpose with or without fee is hereby granted, provided that the above
< // copyright notice and this permission notice appear in all copies.
< //
< // THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
< // WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
< // MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
< // ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
< // WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
< // ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
< // OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
< 
< // NOTE: Due to the following build constraints, this file will only be compiled
< // when the code is running on Google App Engine, compiled by GopherJS, or
< // "-tags safe" is added to the go build command line.  The "disableunsafe"
< // tag is deprecated and thus should not be used.
< // +build js appengine safe disableunsafe !go1.4
< 
< package spew
< 
< import "reflect"
< 
< const (
< 	// UnsafeDisabled is a build-time constant which specifies whether or
< 	// not access to the unsafe package is available.
< 	UnsafeDisabled = true
< )
< 
< // unsafeReflectValue typically converts the passed reflect.Value into a one
< // that bypasses the typical safety restrictions preventing access to
< // unaddressable and unexported data.  However, doing this relies on access to
< // the unsafe package.  This is a stub version which simply returns the passed
< // reflect.Value when the unsafe package is not available.
< func unsafeReflectValue(v reflect.Value) reflect.Value {
< 	return v
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/common.go updated/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/common.go
1,341d0
< /*
<  * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
<  *
<  * Permission to use, copy, modify, and distribute this software for any
<  * purpose with or without fee is hereby granted, provided that the above
<  * copyright notice and this permission notice appear in all copies.
<  *
<  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<  */
< 
< package spew
< 
< import (
< 	"bytes"
< 	"fmt"
< 	"io"
< 	"reflect"
< 	"sort"
< 	"strconv"
< )
< 
< // Some constants in the form of bytes to avoid string overhead.  This mirrors
< // the technique used in the fmt package.
< var (
< 	panicBytes            = []byte("(PANIC=")
< 	plusBytes             = []byte("+")
< 	iBytes                = []byte("i")
< 	trueBytes             = []byte("true")
< 	falseBytes            = []byte("false")
< 	interfaceBytes        = []byte("(interface {})")
< 	commaNewlineBytes     = []byte(",\n")
< 	newlineBytes          = []byte("\n")
< 	openBraceBytes        = []byte("{")
< 	openBraceNewlineBytes = []byte("{\n")
< 	closeBraceBytes       = []byte("}")
< 	asteriskBytes         = []byte("*")
< 	colonBytes            = []byte(":")
< 	colonSpaceBytes       = []byte(": ")
< 	openParenBytes        = []byte("(")
< 	closeParenBytes       = []byte(")")
< 	spaceBytes            = []byte(" ")
< 	pointerChainBytes     = []byte("->")
< 	nilAngleBytes         = []byte("<nil>")
< 	maxNewlineBytes       = []byte("<max depth reached>\n")
< 	maxShortBytes         = []byte("<max>")
< 	circularBytes         = []byte("<already shown>")
< 	circularShortBytes    = []byte("<shown>")
< 	invalidAngleBytes     = []byte("<invalid>")
< 	openBracketBytes      = []byte("[")
< 	closeBracketBytes     = []byte("]")
< 	percentBytes          = []byte("%")
< 	precisionBytes        = []byte(".")
< 	openAngleBytes        = []byte("<")
< 	closeAngleBytes       = []byte(">")
< 	openMapBytes          = []byte("map[")
< 	closeMapBytes         = []byte("]")
< 	lenEqualsBytes        = []byte("len=")
< 	capEqualsBytes        = []byte("cap=")
< )
< 
< // hexDigits is used to map a decimal value to a hex digit.
< var hexDigits = "0123456789abcdef"
< 
< // catchPanic handles any panics that might occur during the handleMethods
< // calls.
< func catchPanic(w io.Writer, v reflect.Value) {
< 	if err := recover(); err != nil {
< 		w.Write(panicBytes)
< 		fmt.Fprintf(w, "%v", err)
< 		w.Write(closeParenBytes)
< 	}
< }
< 
< // handleMethods attempts to call the Error and String methods on the underlying
< // type the passed reflect.Value represents and outputes the result to Writer w.
< //
< // It handles panics in any called methods by catching and displaying the error
< // as the formatted value.
< func handleMethods(cs *ConfigState, w io.Writer, v reflect.Value) (handled bool) {
< 	// We need an interface to check if the type implements the error or
< 	// Stringer interface.  However, the reflect package won't give us an
< 	// interface on certain things like unexported struct fields in order
< 	// to enforce visibility rules.  We use unsafe, when it's available,
< 	// to bypass these restrictions since this package does not mutate the
< 	// values.
< 	if !v.CanInterface() {
< 		if UnsafeDisabled {
< 			return false
< 		}
< 
< 		v = unsafeReflectValue(v)
< 	}
< 
< 	// Choose whether or not to do error and Stringer interface lookups against
< 	// the base type or a pointer to the base type depending on settings.
< 	// Technically calling one of these methods with a pointer receiver can
< 	// mutate the value, however, types which choose to satisify an error or
< 	// Stringer interface with a pointer receiver should not be mutating their
< 	// state inside these interface methods.
< 	if !cs.DisablePointerMethods && !UnsafeDisabled && !v.CanAddr() {
< 		v = unsafeReflectValue(v)
< 	}
< 	if v.CanAddr() {
< 		v = v.Addr()
< 	}
< 
< 	// Is it an error or Stringer?
< 	switch iface := v.Interface().(type) {
< 	case error:
< 		defer catchPanic(w, v)
< 		if cs.ContinueOnMethod {
< 			w.Write(openParenBytes)
< 			w.Write([]byte(iface.Error()))
< 			w.Write(closeParenBytes)
< 			w.Write(spaceBytes)
< 			return false
< 		}
< 
< 		w.Write([]byte(iface.Error()))
< 		return true
< 
< 	case fmt.Stringer:
< 		defer catchPanic(w, v)
< 		if cs.ContinueOnMethod {
< 			w.Write(openParenBytes)
< 			w.Write([]byte(iface.String()))
< 			w.Write(closeParenBytes)
< 			w.Write(spaceBytes)
< 			return false
< 		}
< 		w.Write([]byte(iface.String()))
< 		return true
< 	}
< 	return false
< }
< 
< // printBool outputs a boolean value as true or false to Writer w.
< func printBool(w io.Writer, val bool) {
< 	if val {
< 		w.Write(trueBytes)
< 	} else {
< 		w.Write(falseBytes)
< 	}
< }
< 
< // printInt outputs a signed integer value to Writer w.
< func printInt(w io.Writer, val int64, base int) {
< 	w.Write([]byte(strconv.FormatInt(val, base)))
< }
< 
< // printUint outputs an unsigned integer value to Writer w.
< func printUint(w io.Writer, val uint64, base int) {
< 	w.Write([]byte(strconv.FormatUint(val, base)))
< }
< 
< // printFloat outputs a floating point value using the specified precision,
< // which is expected to be 32 or 64bit, to Writer w.
< func printFloat(w io.Writer, val float64, precision int) {
< 	w.Write([]byte(strconv.FormatFloat(val, 'g', -1, precision)))
< }
< 
< // printComplex outputs a complex value using the specified float precision
< // for the real and imaginary parts to Writer w.
< func printComplex(w io.Writer, c complex128, floatPrecision int) {
< 	r := real(c)
< 	w.Write(openParenBytes)
< 	w.Write([]byte(strconv.FormatFloat(r, 'g', -1, floatPrecision)))
< 	i := imag(c)
< 	if i >= 0 {
< 		w.Write(plusBytes)
< 	}
< 	w.Write([]byte(strconv.FormatFloat(i, 'g', -1, floatPrecision)))
< 	w.Write(iBytes)
< 	w.Write(closeParenBytes)
< }
< 
< // printHexPtr outputs a uintptr formatted as hexadecimal with a leading '0x'
< // prefix to Writer w.
< func printHexPtr(w io.Writer, p uintptr) {
< 	// Null pointer.
< 	num := uint64(p)
< 	if num == 0 {
< 		w.Write(nilAngleBytes)
< 		return
< 	}
< 
< 	// Max uint64 is 16 bytes in hex + 2 bytes for '0x' prefix
< 	buf := make([]byte, 18)
< 
< 	// It's simpler to construct the hex string right to left.
< 	base := uint64(16)
< 	i := len(buf) - 1
< 	for num >= base {
< 		buf[i] = hexDigits[num%base]
< 		num /= base
< 		i--
< 	}
< 	buf[i] = hexDigits[num]
< 
< 	// Add '0x' prefix.
< 	i--
< 	buf[i] = 'x'
< 	i--
< 	buf[i] = '0'
< 
< 	// Strip unused leading bytes.
< 	buf = buf[i:]
< 	w.Write(buf)
< }
< 
< // valuesSorter implements sort.Interface to allow a slice of reflect.Value
< // elements to be sorted.
< type valuesSorter struct {
< 	values  []reflect.Value
< 	strings []string // either nil or same len and values
< 	cs      *ConfigState
< }
< 
< // newValuesSorter initializes a valuesSorter instance, which holds a set of
< // surrogate keys on which the data should be sorted.  It uses flags in
< // ConfigState to decide if and how to populate those surrogate keys.
< func newValuesSorter(values []reflect.Value, cs *ConfigState) sort.Interface {
< 	vs := &valuesSorter{values: values, cs: cs}
< 	if canSortSimply(vs.values[0].Kind()) {
< 		return vs
< 	}
< 	if !cs.DisableMethods {
< 		vs.strings = make([]string, len(values))
< 		for i := range vs.values {
< 			b := bytes.Buffer{}
< 			if !handleMethods(cs, &b, vs.values[i]) {
< 				vs.strings = nil
< 				break
< 			}
< 			vs.strings[i] = b.String()
< 		}
< 	}
< 	if vs.strings == nil && cs.SpewKeys {
< 		vs.strings = make([]string, len(values))
< 		for i := range vs.values {
< 			vs.strings[i] = Sprintf("%#v", vs.values[i].Interface())
< 		}
< 	}
< 	return vs
< }
< 
< // canSortSimply tests whether a reflect.Kind is a primitive that can be sorted
< // directly, or whether it should be considered for sorting by surrogate keys
< // (if the ConfigState allows it).
< func canSortSimply(kind reflect.Kind) bool {
< 	// This switch parallels valueSortLess, except for the default case.
< 	switch kind {
< 	case reflect.Bool:
< 		return true
< 	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
< 		return true
< 	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
< 		return true
< 	case reflect.Float32, reflect.Float64:
< 		return true
< 	case reflect.String:
< 		return true
< 	case reflect.Uintptr:
< 		return true
< 	case reflect.Array:
< 		return true
< 	}
< 	return false
< }
< 
< // Len returns the number of values in the slice.  It is part of the
< // sort.Interface implementation.
< func (s *valuesSorter) Len() int {
< 	return len(s.values)
< }
< 
< // Swap swaps the values at the passed indices.  It is part of the
< // sort.Interface implementation.
< func (s *valuesSorter) Swap(i, j int) {
< 	s.values[i], s.values[j] = s.values[j], s.values[i]
< 	if s.strings != nil {
< 		s.strings[i], s.strings[j] = s.strings[j], s.strings[i]
< 	}
< }
< 
< // valueSortLess returns whether the first value should sort before the second
< // value.  It is used by valueSorter.Less as part of the sort.Interface
< // implementation.
< func valueSortLess(a, b reflect.Value) bool {
< 	switch a.Kind() {
< 	case reflect.Bool:
< 		return !a.Bool() && b.Bool()
< 	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
< 		return a.Int() < b.Int()
< 	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
< 		return a.Uint() < b.Uint()
< 	case reflect.Float32, reflect.Float64:
< 		return a.Float() < b.Float()
< 	case reflect.String:
< 		return a.String() < b.String()
< 	case reflect.Uintptr:
< 		return a.Uint() < b.Uint()
< 	case reflect.Array:
< 		// Compare the contents of both arrays.
< 		l := a.Len()
< 		for i := 0; i < l; i++ {
< 			av := a.Index(i)
< 			bv := b.Index(i)
< 			if av.Interface() == bv.Interface() {
< 				continue
< 			}
< 			return valueSortLess(av, bv)
< 		}
< 	}
< 	return a.String() < b.String()
< }
< 
< // Less returns whether the value at index i should sort before the
< // value at index j.  It is part of the sort.Interface implementation.
< func (s *valuesSorter) Less(i, j int) bool {
< 	if s.strings == nil {
< 		return valueSortLess(s.values[i], s.values[j])
< 	}
< 	return s.strings[i] < s.strings[j]
< }
< 
< // sortValues is a sort function that handles both native types and any type that
< // can be converted to error or Stringer.  Other inputs are sorted according to
< // their Value.String() value to ensure display stability.
< func sortValues(values []reflect.Value, cs *ConfigState) {
< 	if len(values) == 0 {
< 		return
< 	}
< 	sort.Sort(newValuesSorter(values, cs))
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/config.go updated/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/config.go
1,306d0
< /*
<  * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
<  *
<  * Permission to use, copy, modify, and distribute this software for any
<  * purpose with or without fee is hereby granted, provided that the above
<  * copyright notice and this permission notice appear in all copies.
<  *
<  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<  */
< 
< package spew
< 
< import (
< 	"bytes"
< 	"fmt"
< 	"io"
< 	"os"
< )
< 
< // ConfigState houses the configuration options used by spew to format and
< // display values.  There is a global instance, Config, that is used to control
< // all top-level Formatter and Dump functionality.  Each ConfigState instance
< // provides methods equivalent to the top-level functions.
< //
< // The zero value for ConfigState provides no indentation.  You would typically
< // want to set it to a space or a tab.
< //
< // Alternatively, you can use NewDefaultConfig to get a ConfigState instance
< // with default settings.  See the documentation of NewDefaultConfig for default
< // values.
< type ConfigState struct {
< 	// Indent specifies the string to use for each indentation level.  The
< 	// global config instance that all top-level functions use set this to a
< 	// single space by default.  If you would like more indentation, you might
< 	// set this to a tab with "\t" or perhaps two spaces with "  ".
< 	Indent string
< 
< 	// MaxDepth controls the maximum number of levels to descend into nested
< 	// data structures.  The default, 0, means there is no limit.
< 	//
< 	// NOTE: Circular data structures are properly detected, so it is not
< 	// necessary to set this value unless you specifically want to limit deeply
< 	// nested data structures.
< 	MaxDepth int
< 
< 	// DisableMethods specifies whether or not error and Stringer interfaces are
< 	// invoked for types that implement them.
< 	DisableMethods bool
< 
< 	// DisablePointerMethods specifies whether or not to check for and invoke
< 	// error and Stringer interfaces on types which only accept a pointer
< 	// receiver when the current type is not a pointer.
< 	//
< 	// NOTE: This might be an unsafe action since calling one of these methods
< 	// with a pointer receiver could technically mutate the value, however,
< 	// in practice, types which choose to satisify an error or Stringer
< 	// interface with a pointer receiver should not be mutating their state
< 	// inside these interface methods.  As a result, this option relies on
< 	// access to the unsafe package, so it will not have any effect when
< 	// running in environments without access to the unsafe package such as
< 	// Google App Engine or with the "safe" build tag specified.
< 	DisablePointerMethods bool
< 
< 	// DisablePointerAddresses specifies whether to disable the printing of
< 	// pointer addresses. This is useful when diffing data structures in tests.
< 	DisablePointerAddresses bool
< 
< 	// DisableCapacities specifies whether to disable the printing of capacities
< 	// for arrays, slices, maps and channels. This is useful when diffing
< 	// data structures in tests.
< 	DisableCapacities bool
< 
< 	// ContinueOnMethod specifies whether or not recursion should continue once
< 	// a custom error or Stringer interface is invoked.  The default, false,
< 	// means it will print the results of invoking the custom error or Stringer
< 	// interface and return immediately instead of continuing to recurse into
< 	// the internals of the data type.
< 	//
< 	// NOTE: This flag does not have any effect if method invocation is disabled
< 	// via the DisableMethods or DisablePointerMethods options.
< 	ContinueOnMethod bool
< 
< 	// SortKeys specifies map keys should be sorted before being printed. Use
< 	// this to have a more deterministic, diffable output.  Note that only
< 	// native types (bool, int, uint, floats, uintptr and string) and types
< 	// that support the error or Stringer interfaces (if methods are
< 	// enabled) are supported, with other types sorted according to the
< 	// reflect.Value.String() output which guarantees display stability.
< 	SortKeys bool
< 
< 	// SpewKeys specifies that, as a last resort attempt, map keys should
< 	// be spewed to strings and sorted by those strings.  This is only
< 	// considered if SortKeys is true.
< 	SpewKeys bool
< }
< 
< // Config is the active configuration of the top-level functions.
< // The configuration can be changed by modifying the contents of spew.Config.
< var Config = ConfigState{Indent: " "}
< 
< // Errorf is a wrapper for fmt.Errorf that treats each argument as if it were
< // passed with a Formatter interface returned by c.NewFormatter.  It returns
< // the formatted string as a value that satisfies error.  See NewFormatter
< // for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Errorf(format, c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Errorf(format string, a ...interface{}) (err error) {
< 	return fmt.Errorf(format, c.convertArgs(a)...)
< }
< 
< // Fprint is a wrapper for fmt.Fprint that treats each argument as if it were
< // passed with a Formatter interface returned by c.NewFormatter.  It returns
< // the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Fprint(w, c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Fprint(w io.Writer, a ...interface{}) (n int, err error) {
< 	return fmt.Fprint(w, c.convertArgs(a)...)
< }
< 
< // Fprintf is a wrapper for fmt.Fprintf that treats each argument as if it were
< // passed with a Formatter interface returned by c.NewFormatter.  It returns
< // the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Fprintf(w, format, c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
< 	return fmt.Fprintf(w, format, c.convertArgs(a)...)
< }
< 
< // Fprintln is a wrapper for fmt.Fprintln that treats each argument as if it
< // passed with a Formatter interface returned by c.NewFormatter.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Fprintln(w, c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Fprintln(w io.Writer, a ...interface{}) (n int, err error) {
< 	return fmt.Fprintln(w, c.convertArgs(a)...)
< }
< 
< // Print is a wrapper for fmt.Print that treats each argument as if it were
< // passed with a Formatter interface returned by c.NewFormatter.  It returns
< // the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Print(c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Print(a ...interface{}) (n int, err error) {
< 	return fmt.Print(c.convertArgs(a)...)
< }
< 
< // Printf is a wrapper for fmt.Printf that treats each argument as if it were
< // passed with a Formatter interface returned by c.NewFormatter.  It returns
< // the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Printf(format, c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Printf(format string, a ...interface{}) (n int, err error) {
< 	return fmt.Printf(format, c.convertArgs(a)...)
< }
< 
< // Println is a wrapper for fmt.Println that treats each argument as if it were
< // passed with a Formatter interface returned by c.NewFormatter.  It returns
< // the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Println(c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Println(a ...interface{}) (n int, err error) {
< 	return fmt.Println(c.convertArgs(a)...)
< }
< 
< // Sprint is a wrapper for fmt.Sprint that treats each argument as if it were
< // passed with a Formatter interface returned by c.NewFormatter.  It returns
< // the resulting string.  See NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Sprint(c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Sprint(a ...interface{}) string {
< 	return fmt.Sprint(c.convertArgs(a)...)
< }
< 
< // Sprintf is a wrapper for fmt.Sprintf that treats each argument as if it were
< // passed with a Formatter interface returned by c.NewFormatter.  It returns
< // the resulting string.  See NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Sprintf(format, c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Sprintf(format string, a ...interface{}) string {
< 	return fmt.Sprintf(format, c.convertArgs(a)...)
< }
< 
< // Sprintln is a wrapper for fmt.Sprintln that treats each argument as if it
< // were passed with a Formatter interface returned by c.NewFormatter.  It
< // returns the resulting string.  See NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Sprintln(c.NewFormatter(a), c.NewFormatter(b))
< func (c *ConfigState) Sprintln(a ...interface{}) string {
< 	return fmt.Sprintln(c.convertArgs(a)...)
< }
< 
< /*
< NewFormatter returns a custom formatter that satisfies the fmt.Formatter
< interface.  As a result, it integrates cleanly with standard fmt package
< printing functions.  The formatter is useful for inline printing of smaller data
< types similar to the standard %v format specifier.
< 
< The custom formatter only responds to the %v (most compact), %+v (adds pointer
< addresses), %#v (adds types), and %#+v (adds types and pointer addresses) verb
< combinations.  Any other verbs such as %x and %q will be sent to the the
< standard fmt package for formatting.  In addition, the custom formatter ignores
< the width and precision arguments (however they will still work on the format
< specifiers not handled by the custom formatter).
< 
< Typically this function shouldn't be called directly.  It is much easier to make
< use of the custom formatter by calling one of the convenience functions such as
< c.Printf, c.Println, or c.Printf.
< */
< func (c *ConfigState) NewFormatter(v interface{}) fmt.Formatter {
< 	return newFormatter(c, v)
< }
< 
< // Fdump formats and displays the passed arguments to io.Writer w.  It formats
< // exactly the same as Dump.
< func (c *ConfigState) Fdump(w io.Writer, a ...interface{}) {
< 	fdump(c, w, a...)
< }
< 
< /*
< Dump displays the passed parameters to standard out with newlines, customizable
< indentation, and additional debug information such as complete types and all
< pointer addresses used to indirect to the final value.  It provides the
< following features over the built-in printing facilities provided by the fmt
< package:
< 
< 	* Pointers are dereferenced and followed
< 	* Circular data structures are detected and handled properly
< 	* Custom Stringer/error interfaces are optionally invoked, including
< 	  on unexported types
< 	* Custom types which only implement the Stringer/error interfaces via
< 	  a pointer receiver are optionally invoked when passing non-pointer
< 	  variables
< 	* Byte arrays and slices are dumped like the hexdump -C command which
< 	  includes offsets, byte values in hex, and ASCII output
< 
< The configuration options are controlled by modifying the public members
< of c.  See ConfigState for options documentation.
< 
< See Fdump if you would prefer dumping to an arbitrary io.Writer or Sdump to
< get the formatted result as a string.
< */
< func (c *ConfigState) Dump(a ...interface{}) {
< 	fdump(c, os.Stdout, a...)
< }
< 
< // Sdump returns a string with the passed arguments formatted exactly the same
< // as Dump.
< func (c *ConfigState) Sdump(a ...interface{}) string {
< 	var buf bytes.Buffer
< 	fdump(c, &buf, a...)
< 	return buf.String()
< }
< 
< // convertArgs accepts a slice of arguments and returns a slice of the same
< // length with each argument converted to a spew Formatter interface using
< // the ConfigState associated with s.
< func (c *ConfigState) convertArgs(args []interface{}) (formatters []interface{}) {
< 	formatters = make([]interface{}, len(args))
< 	for index, arg := range args {
< 		formatters[index] = newFormatter(c, arg)
< 	}
< 	return formatters
< }
< 
< // NewDefaultConfig returns a ConfigState with the following default settings.
< //
< // 	Indent: " "
< // 	MaxDepth: 0
< // 	DisableMethods: false
< // 	DisablePointerMethods: false
< // 	ContinueOnMethod: false
< // 	SortKeys: false
< func NewDefaultConfig() *ConfigState {
< 	return &ConfigState{Indent: " "}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/doc.go updated/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/doc.go
1,211d0
< /*
<  * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
<  *
<  * Permission to use, copy, modify, and distribute this software for any
<  * purpose with or without fee is hereby granted, provided that the above
<  * copyright notice and this permission notice appear in all copies.
<  *
<  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<  */
< 
< /*
< Package spew implements a deep pretty printer for Go data structures to aid in
< debugging.
< 
< A quick overview of the additional features spew provides over the built-in
< printing facilities for Go data types are as follows:
< 
< 	* Pointers are dereferenced and followed
< 	* Circular data structures are detected and handled properly
< 	* Custom Stringer/error interfaces are optionally invoked, including
< 	  on unexported types
< 	* Custom types which only implement the Stringer/error interfaces via
< 	  a pointer receiver are optionally invoked when passing non-pointer
< 	  variables
< 	* Byte arrays and slices are dumped like the hexdump -C command which
< 	  includes offsets, byte values in hex, and ASCII output (only when using
< 	  Dump style)
< 
< There are two different approaches spew allows for dumping Go data structures:
< 
< 	* Dump style which prints with newlines, customizable indentation,
< 	  and additional debug information such as types and all pointer addresses
< 	  used to indirect to the final value
< 	* A custom Formatter interface that integrates cleanly with the standard fmt
< 	  package and replaces %v, %+v, %#v, and %#+v to provide inline printing
< 	  similar to the default %v while providing the additional functionality
< 	  outlined above and passing unsupported format verbs such as %x and %q
< 	  along to fmt
< 
< Quick Start
< 
< This section demonstrates how to quickly get started with spew.  See the
< sections below for further details on formatting and configuration options.
< 
< To dump a variable with full newlines, indentation, type, and pointer
< information use Dump, Fdump, or Sdump:
< 	spew.Dump(myVar1, myVar2, ...)
< 	spew.Fdump(someWriter, myVar1, myVar2, ...)
< 	str := spew.Sdump(myVar1, myVar2, ...)
< 
< Alternatively, if you would prefer to use format strings with a compacted inline
< printing style, use the convenience wrappers Printf, Fprintf, etc with
< %v (most compact), %+v (adds pointer addresses), %#v (adds types), or
< %#+v (adds types and pointer addresses):
< 	spew.Printf("myVar1: %v -- myVar2: %+v", myVar1, myVar2)
< 	spew.Printf("myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
< 	spew.Fprintf(someWriter, "myVar1: %v -- myVar2: %+v", myVar1, myVar2)
< 	spew.Fprintf(someWriter, "myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
< 
< Configuration Options
< 
< Configuration of spew is handled by fields in the ConfigState type.  For
< convenience, all of the top-level functions use a global state available
< via the spew.Config global.
< 
< It is also possible to create a ConfigState instance that provides methods
< equivalent to the top-level functions.  This allows concurrent configuration
< options.  See the ConfigState documentation for more details.
< 
< The following configuration options are available:
< 	* Indent
< 		String to use for each indentation level for Dump functions.
< 		It is a single space by default.  A popular alternative is "\t".
< 
< 	* MaxDepth
< 		Maximum number of levels to descend into nested data structures.
< 		There is no limit by default.
< 
< 	* DisableMethods
< 		Disables invocation of error and Stringer interface methods.
< 		Method invocation is enabled by default.
< 
< 	* DisablePointerMethods
< 		Disables invocation of error and Stringer interface methods on types
< 		which only accept pointer receivers from non-pointer variables.
< 		Pointer method invocation is enabled by default.
< 
< 	* DisablePointerAddresses
< 		DisablePointerAddresses specifies whether to disable the printing of
< 		pointer addresses. This is useful when diffing data structures in tests.
< 
< 	* DisableCapacities
< 		DisableCapacities specifies whether to disable the printing of
< 		capacities for arrays, slices, maps and channels. This is useful when
< 		diffing data structures in tests.
< 
< 	* ContinueOnMethod
< 		Enables recursion into types after invoking error and Stringer interface
< 		methods. Recursion after method invocation is disabled by default.
< 
< 	* SortKeys
< 		Specifies map keys should be sorted before being printed. Use
< 		this to have a more deterministic, diffable output.  Note that
< 		only native types (bool, int, uint, floats, uintptr and string)
< 		and types which implement error or Stringer interfaces are
< 		supported with other types sorted according to the
< 		reflect.Value.String() output which guarantees display
< 		stability.  Natural map order is used by default.
< 
< 	* SpewKeys
< 		Specifies that, as a last resort attempt, map keys should be
< 		spewed to strings and sorted by those strings.  This is only
< 		considered if SortKeys is true.
< 
< Dump Usage
< 
< Simply call spew.Dump with a list of variables you want to dump:
< 
< 	spew.Dump(myVar1, myVar2, ...)
< 
< You may also call spew.Fdump if you would prefer to output to an arbitrary
< io.Writer.  For example, to dump to standard error:
< 
< 	spew.Fdump(os.Stderr, myVar1, myVar2, ...)
< 
< A third option is to call spew.Sdump to get the formatted output as a string:
< 
< 	str := spew.Sdump(myVar1, myVar2, ...)
< 
< Sample Dump Output
< 
< See the Dump example for details on the setup of the types and variables being
< shown here.
< 
< 	(main.Foo) {
< 	 unexportedField: (*main.Bar)(0xf84002e210)({
< 	  flag: (main.Flag) flagTwo,
< 	  data: (uintptr) <nil>
< 	 }),
< 	 ExportedField: (map[interface {}]interface {}) (len=1) {
< 	  (string) (len=3) "one": (bool) true
< 	 }
< 	}
< 
< Byte (and uint8) arrays and slices are displayed uniquely like the hexdump -C
< command as shown.
< 	([]uint8) (len=32 cap=32) {
< 	 00000000  11 12 13 14 15 16 17 18  19 1a 1b 1c 1d 1e 1f 20  |............... |
< 	 00000010  21 22 23 24 25 26 27 28  29 2a 2b 2c 2d 2e 2f 30  |!"#$%&'()*+,-./0|
< 	 00000020  31 32                                             |12|
< 	}
< 
< Custom Formatter
< 
< Spew provides a custom formatter that implements the fmt.Formatter interface
< so that it integrates cleanly with standard fmt package printing functions. The
< formatter is useful for inline printing of smaller data types similar to the
< standard %v format specifier.
< 
< The custom formatter only responds to the %v (most compact), %+v (adds pointer
< addresses), %#v (adds types), or %#+v (adds types and pointer addresses) verb
< combinations.  Any other verbs such as %x and %q will be sent to the the
< standard fmt package for formatting.  In addition, the custom formatter ignores
< the width and precision arguments (however they will still work on the format
< specifiers not handled by the custom formatter).
< 
< Custom Formatter Usage
< 
< The simplest way to make use of the spew custom formatter is to call one of the
< convenience functions such as spew.Printf, spew.Println, or spew.Printf.  The
< functions have syntax you are most likely already familiar with:
< 
< 	spew.Printf("myVar1: %v -- myVar2: %+v", myVar1, myVar2)
< 	spew.Printf("myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
< 	spew.Println(myVar, myVar2)
< 	spew.Fprintf(os.Stderr, "myVar1: %v -- myVar2: %+v", myVar1, myVar2)
< 	spew.Fprintf(os.Stderr, "myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
< 
< See the Index for the full list convenience functions.
< 
< Sample Formatter Output
< 
< Double pointer to a uint8:
< 	  %v: <**>5
< 	 %+v: <**>(0xf8400420d0->0xf8400420c8)5
< 	 %#v: (**uint8)5
< 	%#+v: (**uint8)(0xf8400420d0->0xf8400420c8)5
< 
< Pointer to circular struct with a uint8 field and a pointer to itself:
< 	  %v: <*>{1 <*><shown>}
< 	 %+v: <*>(0xf84003e260){ui8:1 c:<*>(0xf84003e260)<shown>}
< 	 %#v: (*main.circular){ui8:(uint8)1 c:(*main.circular)<shown>}
< 	%#+v: (*main.circular)(0xf84003e260){ui8:(uint8)1 c:(*main.circular)(0xf84003e260)<shown>}
< 
< See the Printf example for details on the setup of variables being shown
< here.
< 
< Errors
< 
< Since it is possible for custom Stringer/error interfaces to panic, spew
< detects them and handles them internally by printing the panic information
< inline with the output.  Since spew is intended to provide deep pretty printing
< capabilities on structures, it intentionally does not return any errors.
< */
< package spew
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/dump.go updated/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/dump.go
1,509d0
< /*
<  * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
<  *
<  * Permission to use, copy, modify, and distribute this software for any
<  * purpose with or without fee is hereby granted, provided that the above
<  * copyright notice and this permission notice appear in all copies.
<  *
<  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<  */
< 
< package spew
< 
< import (
< 	"bytes"
< 	"encoding/hex"
< 	"fmt"
< 	"io"
< 	"os"
< 	"reflect"
< 	"regexp"
< 	"strconv"
< 	"strings"
< )
< 
< var (
< 	// uint8Type is a reflect.Type representing a uint8.  It is used to
< 	// convert cgo types to uint8 slices for hexdumping.
< 	uint8Type = reflect.TypeOf(uint8(0))
< 
< 	// cCharRE is a regular expression that matches a cgo char.
< 	// It is used to detect character arrays to hexdump them.
< 	cCharRE = regexp.MustCompile(`^.*\._Ctype_char$`)
< 
< 	// cUnsignedCharRE is a regular expression that matches a cgo unsigned
< 	// char.  It is used to detect unsigned character arrays to hexdump
< 	// them.
< 	cUnsignedCharRE = regexp.MustCompile(`^.*\._Ctype_unsignedchar$`)
< 
< 	// cUint8tCharRE is a regular expression that matches a cgo uint8_t.
< 	// It is used to detect uint8_t arrays to hexdump them.
< 	cUint8tCharRE = regexp.MustCompile(`^.*\._Ctype_uint8_t$`)
< )
< 
< // dumpState contains information about the state of a dump operation.
< type dumpState struct {
< 	w                io.Writer
< 	depth            int
< 	pointers         map[uintptr]int
< 	ignoreNextType   bool
< 	ignoreNextIndent bool
< 	cs               *ConfigState
< }
< 
< // indent performs indentation according to the depth level and cs.Indent
< // option.
< func (d *dumpState) indent() {
< 	if d.ignoreNextIndent {
< 		d.ignoreNextIndent = false
< 		return
< 	}
< 	d.w.Write(bytes.Repeat([]byte(d.cs.Indent), d.depth))
< }
< 
< // unpackValue returns values inside of non-nil interfaces when possible.
< // This is useful for data types like structs, arrays, slices, and maps which
< // can contain varying types packed inside an interface.
< func (d *dumpState) unpackValue(v reflect.Value) reflect.Value {
< 	if v.Kind() == reflect.Interface && !v.IsNil() {
< 		v = v.Elem()
< 	}
< 	return v
< }
< 
< // dumpPtr handles formatting of pointers by indirecting them as necessary.
< func (d *dumpState) dumpPtr(v reflect.Value) {
< 	// Remove pointers at or below the current depth from map used to detect
< 	// circular refs.
< 	for k, depth := range d.pointers {
< 		if depth >= d.depth {
< 			delete(d.pointers, k)
< 		}
< 	}
< 
< 	// Keep list of all dereferenced pointers to show later.
< 	pointerChain := make([]uintptr, 0)
< 
< 	// Figure out how many levels of indirection there are by dereferencing
< 	// pointers and unpacking interfaces down the chain while detecting circular
< 	// references.
< 	nilFound := false
< 	cycleFound := false
< 	indirects := 0
< 	ve := v
< 	for ve.Kind() == reflect.Ptr {
< 		if ve.IsNil() {
< 			nilFound = true
< 			break
< 		}
< 		indirects++
< 		addr := ve.Pointer()
< 		pointerChain = append(pointerChain, addr)
< 		if pd, ok := d.pointers[addr]; ok && pd < d.depth {
< 			cycleFound = true
< 			indirects--
< 			break
< 		}
< 		d.pointers[addr] = d.depth
< 
< 		ve = ve.Elem()
< 		if ve.Kind() == reflect.Interface {
< 			if ve.IsNil() {
< 				nilFound = true
< 				break
< 			}
< 			ve = ve.Elem()
< 		}
< 	}
< 
< 	// Display type information.
< 	d.w.Write(openParenBytes)
< 	d.w.Write(bytes.Repeat(asteriskBytes, indirects))
< 	d.w.Write([]byte(ve.Type().String()))
< 	d.w.Write(closeParenBytes)
< 
< 	// Display pointer information.
< 	if !d.cs.DisablePointerAddresses && len(pointerChain) > 0 {
< 		d.w.Write(openParenBytes)
< 		for i, addr := range pointerChain {
< 			if i > 0 {
< 				d.w.Write(pointerChainBytes)
< 			}
< 			printHexPtr(d.w, addr)
< 		}
< 		d.w.Write(closeParenBytes)
< 	}
< 
< 	// Display dereferenced value.
< 	d.w.Write(openParenBytes)
< 	switch {
< 	case nilFound:
< 		d.w.Write(nilAngleBytes)
< 
< 	case cycleFound:
< 		d.w.Write(circularBytes)
< 
< 	default:
< 		d.ignoreNextType = true
< 		d.dump(ve)
< 	}
< 	d.w.Write(closeParenBytes)
< }
< 
< // dumpSlice handles formatting of arrays and slices.  Byte (uint8 under
< // reflection) arrays and slices are dumped in hexdump -C fashion.
< func (d *dumpState) dumpSlice(v reflect.Value) {
< 	// Determine whether this type should be hex dumped or not.  Also,
< 	// for types which should be hexdumped, try to use the underlying data
< 	// first, then fall back to trying to convert them to a uint8 slice.
< 	var buf []uint8
< 	doConvert := false
< 	doHexDump := false
< 	numEntries := v.Len()
< 	if numEntries > 0 {
< 		vt := v.Index(0).Type()
< 		vts := vt.String()
< 		switch {
< 		// C types that need to be converted.
< 		case cCharRE.MatchString(vts):
< 			fallthrough
< 		case cUnsignedCharRE.MatchString(vts):
< 			fallthrough
< 		case cUint8tCharRE.MatchString(vts):
< 			doConvert = true
< 
< 		// Try to use existing uint8 slices and fall back to converting
< 		// and copying if that fails.
< 		case vt.Kind() == reflect.Uint8:
< 			// We need an addressable interface to convert the type
< 			// to a byte slice.  However, the reflect package won't
< 			// give us an interface on certain things like
< 			// unexported struct fields in order to enforce
< 			// visibility rules.  We use unsafe, when available, to
< 			// bypass these restrictions since this package does not
< 			// mutate the values.
< 			vs := v
< 			if !vs.CanInterface() || !vs.CanAddr() {
< 				vs = unsafeReflectValue(vs)
< 			}
< 			if !UnsafeDisabled {
< 				vs = vs.Slice(0, numEntries)
< 
< 				// Use the existing uint8 slice if it can be
< 				// type asserted.
< 				iface := vs.Interface()
< 				if slice, ok := iface.([]uint8); ok {
< 					buf = slice
< 					doHexDump = true
< 					break
< 				}
< 			}
< 
< 			// The underlying data needs to be converted if it can't
< 			// be type asserted to a uint8 slice.
< 			doConvert = true
< 		}
< 
< 		// Copy and convert the underlying type if needed.
< 		if doConvert && vt.ConvertibleTo(uint8Type) {
< 			// Convert and copy each element into a uint8 byte
< 			// slice.
< 			buf = make([]uint8, numEntries)
< 			for i := 0; i < numEntries; i++ {
< 				vv := v.Index(i)
< 				buf[i] = uint8(vv.Convert(uint8Type).Uint())
< 			}
< 			doHexDump = true
< 		}
< 	}
< 
< 	// Hexdump the entire slice as needed.
< 	if doHexDump {
< 		indent := strings.Repeat(d.cs.Indent, d.depth)
< 		str := indent + hex.Dump(buf)
< 		str = strings.Replace(str, "\n", "\n"+indent, -1)
< 		str = strings.TrimRight(str, d.cs.Indent)
< 		d.w.Write([]byte(str))
< 		return
< 	}
< 
< 	// Recursively call dump for each item.
< 	for i := 0; i < numEntries; i++ {
< 		d.dump(d.unpackValue(v.Index(i)))
< 		if i < (numEntries - 1) {
< 			d.w.Write(commaNewlineBytes)
< 		} else {
< 			d.w.Write(newlineBytes)
< 		}
< 	}
< }
< 
< // dump is the main workhorse for dumping a value.  It uses the passed reflect
< // value to figure out what kind of object we are dealing with and formats it
< // appropriately.  It is a recursive function, however circular data structures
< // are detected and handled properly.
< func (d *dumpState) dump(v reflect.Value) {
< 	// Handle invalid reflect values immediately.
< 	kind := v.Kind()
< 	if kind == reflect.Invalid {
< 		d.w.Write(invalidAngleBytes)
< 		return
< 	}
< 
< 	// Handle pointers specially.
< 	if kind == reflect.Ptr {
< 		d.indent()
< 		d.dumpPtr(v)
< 		return
< 	}
< 
< 	// Print type information unless already handled elsewhere.
< 	if !d.ignoreNextType {
< 		d.indent()
< 		d.w.Write(openParenBytes)
< 		d.w.Write([]byte(v.Type().String()))
< 		d.w.Write(closeParenBytes)
< 		d.w.Write(spaceBytes)
< 	}
< 	d.ignoreNextType = false
< 
< 	// Display length and capacity if the built-in len and cap functions
< 	// work with the value's kind and the len/cap itself is non-zero.
< 	valueLen, valueCap := 0, 0
< 	switch v.Kind() {
< 	case reflect.Array, reflect.Slice, reflect.Chan:
< 		valueLen, valueCap = v.Len(), v.Cap()
< 	case reflect.Map, reflect.String:
< 		valueLen = v.Len()
< 	}
< 	if valueLen != 0 || !d.cs.DisableCapacities && valueCap != 0 {
< 		d.w.Write(openParenBytes)
< 		if valueLen != 0 {
< 			d.w.Write(lenEqualsBytes)
< 			printInt(d.w, int64(valueLen), 10)
< 		}
< 		if !d.cs.DisableCapacities && valueCap != 0 {
< 			if valueLen != 0 {
< 				d.w.Write(spaceBytes)
< 			}
< 			d.w.Write(capEqualsBytes)
< 			printInt(d.w, int64(valueCap), 10)
< 		}
< 		d.w.Write(closeParenBytes)
< 		d.w.Write(spaceBytes)
< 	}
< 
< 	// Call Stringer/error interfaces if they exist and the handle methods flag
< 	// is enabled
< 	if !d.cs.DisableMethods {
< 		if (kind != reflect.Invalid) && (kind != reflect.Interface) {
< 			if handled := handleMethods(d.cs, d.w, v); handled {
< 				return
< 			}
< 		}
< 	}
< 
< 	switch kind {
< 	case reflect.Invalid:
< 		// Do nothing.  We should never get here since invalid has already
< 		// been handled above.
< 
< 	case reflect.Bool:
< 		printBool(d.w, v.Bool())
< 
< 	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
< 		printInt(d.w, v.Int(), 10)
< 
< 	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
< 		printUint(d.w, v.Uint(), 10)
< 
< 	case reflect.Float32:
< 		printFloat(d.w, v.Float(), 32)
< 
< 	case reflect.Float64:
< 		printFloat(d.w, v.Float(), 64)
< 
< 	case reflect.Complex64:
< 		printComplex(d.w, v.Complex(), 32)
< 
< 	case reflect.Complex128:
< 		printComplex(d.w, v.Complex(), 64)
< 
< 	case reflect.Slice:
< 		if v.IsNil() {
< 			d.w.Write(nilAngleBytes)
< 			break
< 		}
< 		fallthrough
< 
< 	case reflect.Array:
< 		d.w.Write(openBraceNewlineBytes)
< 		d.depth++
< 		if (d.cs.MaxDepth != 0) && (d.depth > d.cs.MaxDepth) {
< 			d.indent()
< 			d.w.Write(maxNewlineBytes)
< 		} else {
< 			d.dumpSlice(v)
< 		}
< 		d.depth--
< 		d.indent()
< 		d.w.Write(closeBraceBytes)
< 
< 	case reflect.String:
< 		d.w.Write([]byte(strconv.Quote(v.String())))
< 
< 	case reflect.Interface:
< 		// The only time we should get here is for nil interfaces due to
< 		// unpackValue calls.
< 		if v.IsNil() {
< 			d.w.Write(nilAngleBytes)
< 		}
< 
< 	case reflect.Ptr:
< 		// Do nothing.  We should never get here since pointers have already
< 		// been handled above.
< 
< 	case reflect.Map:
< 		// nil maps should be indicated as different than empty maps
< 		if v.IsNil() {
< 			d.w.Write(nilAngleBytes)
< 			break
< 		}
< 
< 		d.w.Write(openBraceNewlineBytes)
< 		d.depth++
< 		if (d.cs.MaxDepth != 0) && (d.depth > d.cs.MaxDepth) {
< 			d.indent()
< 			d.w.Write(maxNewlineBytes)
< 		} else {
< 			numEntries := v.Len()
< 			keys := v.MapKeys()
< 			if d.cs.SortKeys {
< 				sortValues(keys, d.cs)
< 			}
< 			for i, key := range keys {
< 				d.dump(d.unpackValue(key))
< 				d.w.Write(colonSpaceBytes)
< 				d.ignoreNextIndent = true
< 				d.dump(d.unpackValue(v.MapIndex(key)))
< 				if i < (numEntries - 1) {
< 					d.w.Write(commaNewlineBytes)
< 				} else {
< 					d.w.Write(newlineBytes)
< 				}
< 			}
< 		}
< 		d.depth--
< 		d.indent()
< 		d.w.Write(closeBraceBytes)
< 
< 	case reflect.Struct:
< 		d.w.Write(openBraceNewlineBytes)
< 		d.depth++
< 		if (d.cs.MaxDepth != 0) && (d.depth > d.cs.MaxDepth) {
< 			d.indent()
< 			d.w.Write(maxNewlineBytes)
< 		} else {
< 			vt := v.Type()
< 			numFields := v.NumField()
< 			for i := 0; i < numFields; i++ {
< 				d.indent()
< 				vtf := vt.Field(i)
< 				d.w.Write([]byte(vtf.Name))
< 				d.w.Write(colonSpaceBytes)
< 				d.ignoreNextIndent = true
< 				d.dump(d.unpackValue(v.Field(i)))
< 				if i < (numFields - 1) {
< 					d.w.Write(commaNewlineBytes)
< 				} else {
< 					d.w.Write(newlineBytes)
< 				}
< 			}
< 		}
< 		d.depth--
< 		d.indent()
< 		d.w.Write(closeBraceBytes)
< 
< 	case reflect.Uintptr:
< 		printHexPtr(d.w, uintptr(v.Uint()))
< 
< 	case reflect.UnsafePointer, reflect.Chan, reflect.Func:
< 		printHexPtr(d.w, v.Pointer())
< 
< 	// There were not any other types at the time this code was written, but
< 	// fall back to letting the default fmt package handle it in case any new
< 	// types are added.
< 	default:
< 		if v.CanInterface() {
< 			fmt.Fprintf(d.w, "%v", v.Interface())
< 		} else {
< 			fmt.Fprintf(d.w, "%v", v.String())
< 		}
< 	}
< }
< 
< // fdump is a helper function to consolidate the logic from the various public
< // methods which take varying writers and config states.
< func fdump(cs *ConfigState, w io.Writer, a ...interface{}) {
< 	for _, arg := range a {
< 		if arg == nil {
< 			w.Write(interfaceBytes)
< 			w.Write(spaceBytes)
< 			w.Write(nilAngleBytes)
< 			w.Write(newlineBytes)
< 			continue
< 		}
< 
< 		d := dumpState{w: w, cs: cs}
< 		d.pointers = make(map[uintptr]int)
< 		d.dump(reflect.ValueOf(arg))
< 		d.w.Write(newlineBytes)
< 	}
< }
< 
< // Fdump formats and displays the passed arguments to io.Writer w.  It formats
< // exactly the same as Dump.
< func Fdump(w io.Writer, a ...interface{}) {
< 	fdump(&Config, w, a...)
< }
< 
< // Sdump returns a string with the passed arguments formatted exactly the same
< // as Dump.
< func Sdump(a ...interface{}) string {
< 	var buf bytes.Buffer
< 	fdump(&Config, &buf, a...)
< 	return buf.String()
< }
< 
< /*
< Dump displays the passed parameters to standard out with newlines, customizable
< indentation, and additional debug information such as complete types and all
< pointer addresses used to indirect to the final value.  It provides the
< following features over the built-in printing facilities provided by the fmt
< package:
< 
< 	* Pointers are dereferenced and followed
< 	* Circular data structures are detected and handled properly
< 	* Custom Stringer/error interfaces are optionally invoked, including
< 	  on unexported types
< 	* Custom types which only implement the Stringer/error interfaces via
< 	  a pointer receiver are optionally invoked when passing non-pointer
< 	  variables
< 	* Byte arrays and slices are dumped like the hexdump -C command which
< 	  includes offsets, byte values in hex, and ASCII output
< 
< The configuration options are controlled by an exported package global,
< spew.Config.  See ConfigState for options documentation.
< 
< See Fdump if you would prefer dumping to an arbitrary io.Writer or Sdump to
< get the formatted result as a string.
< */
< func Dump(a ...interface{}) {
< 	fdump(&Config, os.Stdout, a...)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/format.go updated/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/format.go
1,419d0
< /*
<  * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
<  *
<  * Permission to use, copy, modify, and distribute this software for any
<  * purpose with or without fee is hereby granted, provided that the above
<  * copyright notice and this permission notice appear in all copies.
<  *
<  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<  */
< 
< package spew
< 
< import (
< 	"bytes"
< 	"fmt"
< 	"reflect"
< 	"strconv"
< 	"strings"
< )
< 
< // supportedFlags is a list of all the character flags supported by fmt package.
< const supportedFlags = "0-+# "
< 
< // formatState implements the fmt.Formatter interface and contains information
< // about the state of a formatting operation.  The NewFormatter function can
< // be used to get a new Formatter which can be used directly as arguments
< // in standard fmt package printing calls.
< type formatState struct {
< 	value          interface{}
< 	fs             fmt.State
< 	depth          int
< 	pointers       map[uintptr]int
< 	ignoreNextType bool
< 	cs             *ConfigState
< }
< 
< // buildDefaultFormat recreates the original format string without precision
< // and width information to pass in to fmt.Sprintf in the case of an
< // unrecognized type.  Unless new types are added to the language, this
< // function won't ever be called.
< func (f *formatState) buildDefaultFormat() (format string) {
< 	buf := bytes.NewBuffer(percentBytes)
< 
< 	for _, flag := range supportedFlags {
< 		if f.fs.Flag(int(flag)) {
< 			buf.WriteRune(flag)
< 		}
< 	}
< 
< 	buf.WriteRune('v')
< 
< 	format = buf.String()
< 	return format
< }
< 
< // constructOrigFormat recreates the original format string including precision
< // and width information to pass along to the standard fmt package.  This allows
< // automatic deferral of all format strings this package doesn't support.
< func (f *formatState) constructOrigFormat(verb rune) (format string) {
< 	buf := bytes.NewBuffer(percentBytes)
< 
< 	for _, flag := range supportedFlags {
< 		if f.fs.Flag(int(flag)) {
< 			buf.WriteRune(flag)
< 		}
< 	}
< 
< 	if width, ok := f.fs.Width(); ok {
< 		buf.WriteString(strconv.Itoa(width))
< 	}
< 
< 	if precision, ok := f.fs.Precision(); ok {
< 		buf.Write(precisionBytes)
< 		buf.WriteString(strconv.Itoa(precision))
< 	}
< 
< 	buf.WriteRune(verb)
< 
< 	format = buf.String()
< 	return format
< }
< 
< // unpackValue returns values inside of non-nil interfaces when possible and
< // ensures that types for values which have been unpacked from an interface
< // are displayed when the show types flag is also set.
< // This is useful for data types like structs, arrays, slices, and maps which
< // can contain varying types packed inside an interface.
< func (f *formatState) unpackValue(v reflect.Value) reflect.Value {
< 	if v.Kind() == reflect.Interface {
< 		f.ignoreNextType = false
< 		if !v.IsNil() {
< 			v = v.Elem()
< 		}
< 	}
< 	return v
< }
< 
< // formatPtr handles formatting of pointers by indirecting them as necessary.
< func (f *formatState) formatPtr(v reflect.Value) {
< 	// Display nil if top level pointer is nil.
< 	showTypes := f.fs.Flag('#')
< 	if v.IsNil() && (!showTypes || f.ignoreNextType) {
< 		f.fs.Write(nilAngleBytes)
< 		return
< 	}
< 
< 	// Remove pointers at or below the current depth from map used to detect
< 	// circular refs.
< 	for k, depth := range f.pointers {
< 		if depth >= f.depth {
< 			delete(f.pointers, k)
< 		}
< 	}
< 
< 	// Keep list of all dereferenced pointers to possibly show later.
< 	pointerChain := make([]uintptr, 0)
< 
< 	// Figure out how many levels of indirection there are by derferencing
< 	// pointers and unpacking interfaces down the chain while detecting circular
< 	// references.
< 	nilFound := false
< 	cycleFound := false
< 	indirects := 0
< 	ve := v
< 	for ve.Kind() == reflect.Ptr {
< 		if ve.IsNil() {
< 			nilFound = true
< 			break
< 		}
< 		indirects++
< 		addr := ve.Pointer()
< 		pointerChain = append(pointerChain, addr)
< 		if pd, ok := f.pointers[addr]; ok && pd < f.depth {
< 			cycleFound = true
< 			indirects--
< 			break
< 		}
< 		f.pointers[addr] = f.depth
< 
< 		ve = ve.Elem()
< 		if ve.Kind() == reflect.Interface {
< 			if ve.IsNil() {
< 				nilFound = true
< 				break
< 			}
< 			ve = ve.Elem()
< 		}
< 	}
< 
< 	// Display type or indirection level depending on flags.
< 	if showTypes && !f.ignoreNextType {
< 		f.fs.Write(openParenBytes)
< 		f.fs.Write(bytes.Repeat(asteriskBytes, indirects))
< 		f.fs.Write([]byte(ve.Type().String()))
< 		f.fs.Write(closeParenBytes)
< 	} else {
< 		if nilFound || cycleFound {
< 			indirects += strings.Count(ve.Type().String(), "*")
< 		}
< 		f.fs.Write(openAngleBytes)
< 		f.fs.Write([]byte(strings.Repeat("*", indirects)))
< 		f.fs.Write(closeAngleBytes)
< 	}
< 
< 	// Display pointer information depending on flags.
< 	if f.fs.Flag('+') && (len(pointerChain) > 0) {
< 		f.fs.Write(openParenBytes)
< 		for i, addr := range pointerChain {
< 			if i > 0 {
< 				f.fs.Write(pointerChainBytes)
< 			}
< 			printHexPtr(f.fs, addr)
< 		}
< 		f.fs.Write(closeParenBytes)
< 	}
< 
< 	// Display dereferenced value.
< 	switch {
< 	case nilFound:
< 		f.fs.Write(nilAngleBytes)
< 
< 	case cycleFound:
< 		f.fs.Write(circularShortBytes)
< 
< 	default:
< 		f.ignoreNextType = true
< 		f.format(ve)
< 	}
< }
< 
< // format is the main workhorse for providing the Formatter interface.  It
< // uses the passed reflect value to figure out what kind of object we are
< // dealing with and formats it appropriately.  It is a recursive function,
< // however circular data structures are detected and handled properly.
< func (f *formatState) format(v reflect.Value) {
< 	// Handle invalid reflect values immediately.
< 	kind := v.Kind()
< 	if kind == reflect.Invalid {
< 		f.fs.Write(invalidAngleBytes)
< 		return
< 	}
< 
< 	// Handle pointers specially.
< 	if kind == reflect.Ptr {
< 		f.formatPtr(v)
< 		return
< 	}
< 
< 	// Print type information unless already handled elsewhere.
< 	if !f.ignoreNextType && f.fs.Flag('#') {
< 		f.fs.Write(openParenBytes)
< 		f.fs.Write([]byte(v.Type().String()))
< 		f.fs.Write(closeParenBytes)
< 	}
< 	f.ignoreNextType = false
< 
< 	// Call Stringer/error interfaces if they exist and the handle methods
< 	// flag is enabled.
< 	if !f.cs.DisableMethods {
< 		if (kind != reflect.Invalid) && (kind != reflect.Interface) {
< 			if handled := handleMethods(f.cs, f.fs, v); handled {
< 				return
< 			}
< 		}
< 	}
< 
< 	switch kind {
< 	case reflect.Invalid:
< 		// Do nothing.  We should never get here since invalid has already
< 		// been handled above.
< 
< 	case reflect.Bool:
< 		printBool(f.fs, v.Bool())
< 
< 	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
< 		printInt(f.fs, v.Int(), 10)
< 
< 	case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
< 		printUint(f.fs, v.Uint(), 10)
< 
< 	case reflect.Float32:
< 		printFloat(f.fs, v.Float(), 32)
< 
< 	case reflect.Float64:
< 		printFloat(f.fs, v.Float(), 64)
< 
< 	case reflect.Complex64:
< 		printComplex(f.fs, v.Complex(), 32)
< 
< 	case reflect.Complex128:
< 		printComplex(f.fs, v.Complex(), 64)
< 
< 	case reflect.Slice:
< 		if v.IsNil() {
< 			f.fs.Write(nilAngleBytes)
< 			break
< 		}
< 		fallthrough
< 
< 	case reflect.Array:
< 		f.fs.Write(openBracketBytes)
< 		f.depth++
< 		if (f.cs.MaxDepth != 0) && (f.depth > f.cs.MaxDepth) {
< 			f.fs.Write(maxShortBytes)
< 		} else {
< 			numEntries := v.Len()
< 			for i := 0; i < numEntries; i++ {
< 				if i > 0 {
< 					f.fs.Write(spaceBytes)
< 				}
< 				f.ignoreNextType = true
< 				f.format(f.unpackValue(v.Index(i)))
< 			}
< 		}
< 		f.depth--
< 		f.fs.Write(closeBracketBytes)
< 
< 	case reflect.String:
< 		f.fs.Write([]byte(v.String()))
< 
< 	case reflect.Interface:
< 		// The only time we should get here is for nil interfaces due to
< 		// unpackValue calls.
< 		if v.IsNil() {
< 			f.fs.Write(nilAngleBytes)
< 		}
< 
< 	case reflect.Ptr:
< 		// Do nothing.  We should never get here since pointers have already
< 		// been handled above.
< 
< 	case reflect.Map:
< 		// nil maps should be indicated as different than empty maps
< 		if v.IsNil() {
< 			f.fs.Write(nilAngleBytes)
< 			break
< 		}
< 
< 		f.fs.Write(openMapBytes)
< 		f.depth++
< 		if (f.cs.MaxDepth != 0) && (f.depth > f.cs.MaxDepth) {
< 			f.fs.Write(maxShortBytes)
< 		} else {
< 			keys := v.MapKeys()
< 			if f.cs.SortKeys {
< 				sortValues(keys, f.cs)
< 			}
< 			for i, key := range keys {
< 				if i > 0 {
< 					f.fs.Write(spaceBytes)
< 				}
< 				f.ignoreNextType = true
< 				f.format(f.unpackValue(key))
< 				f.fs.Write(colonBytes)
< 				f.ignoreNextType = true
< 				f.format(f.unpackValue(v.MapIndex(key)))
< 			}
< 		}
< 		f.depth--
< 		f.fs.Write(closeMapBytes)
< 
< 	case reflect.Struct:
< 		numFields := v.NumField()
< 		f.fs.Write(openBraceBytes)
< 		f.depth++
< 		if (f.cs.MaxDepth != 0) && (f.depth > f.cs.MaxDepth) {
< 			f.fs.Write(maxShortBytes)
< 		} else {
< 			vt := v.Type()
< 			for i := 0; i < numFields; i++ {
< 				if i > 0 {
< 					f.fs.Write(spaceBytes)
< 				}
< 				vtf := vt.Field(i)
< 				if f.fs.Flag('+') || f.fs.Flag('#') {
< 					f.fs.Write([]byte(vtf.Name))
< 					f.fs.Write(colonBytes)
< 				}
< 				f.format(f.unpackValue(v.Field(i)))
< 			}
< 		}
< 		f.depth--
< 		f.fs.Write(closeBraceBytes)
< 
< 	case reflect.Uintptr:
< 		printHexPtr(f.fs, uintptr(v.Uint()))
< 
< 	case reflect.UnsafePointer, reflect.Chan, reflect.Func:
< 		printHexPtr(f.fs, v.Pointer())
< 
< 	// There were not any other types at the time this code was written, but
< 	// fall back to letting the default fmt package handle it if any get added.
< 	default:
< 		format := f.buildDefaultFormat()
< 		if v.CanInterface() {
< 			fmt.Fprintf(f.fs, format, v.Interface())
< 		} else {
< 			fmt.Fprintf(f.fs, format, v.String())
< 		}
< 	}
< }
< 
< // Format satisfies the fmt.Formatter interface. See NewFormatter for usage
< // details.
< func (f *formatState) Format(fs fmt.State, verb rune) {
< 	f.fs = fs
< 
< 	// Use standard formatting for verbs that are not v.
< 	if verb != 'v' {
< 		format := f.constructOrigFormat(verb)
< 		fmt.Fprintf(fs, format, f.value)
< 		return
< 	}
< 
< 	if f.value == nil {
< 		if fs.Flag('#') {
< 			fs.Write(interfaceBytes)
< 		}
< 		fs.Write(nilAngleBytes)
< 		return
< 	}
< 
< 	f.format(reflect.ValueOf(f.value))
< }
< 
< // newFormatter is a helper function to consolidate the logic from the various
< // public methods which take varying config states.
< func newFormatter(cs *ConfigState, v interface{}) fmt.Formatter {
< 	fs := &formatState{value: v, cs: cs}
< 	fs.pointers = make(map[uintptr]int)
< 	return fs
< }
< 
< /*
< NewFormatter returns a custom formatter that satisfies the fmt.Formatter
< interface.  As a result, it integrates cleanly with standard fmt package
< printing functions.  The formatter is useful for inline printing of smaller data
< types similar to the standard %v format specifier.
< 
< The custom formatter only responds to the %v (most compact), %+v (adds pointer
< addresses), %#v (adds types), or %#+v (adds types and pointer addresses) verb
< combinations.  Any other verbs such as %x and %q will be sent to the the
< standard fmt package for formatting.  In addition, the custom formatter ignores
< the width and precision arguments (however they will still work on the format
< specifiers not handled by the custom formatter).
< 
< Typically this function shouldn't be called directly.  It is much easier to make
< use of the custom formatter by calling one of the convenience functions such as
< Printf, Println, or Fprintf.
< */
< func NewFormatter(v interface{}) fmt.Formatter {
< 	return newFormatter(&Config, v)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/spew.go updated/vendor/github.com/coreos/fcct/vendor/github.com/davecgh/go-spew/spew/spew.go
1,148d0
< /*
<  * Copyright (c) 2013-2016 Dave Collins <dave@davec.name>
<  *
<  * Permission to use, copy, modify, and distribute this software for any
<  * purpose with or without fee is hereby granted, provided that the above
<  * copyright notice and this permission notice appear in all copies.
<  *
<  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
<  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
<  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
<  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
<  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
<  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
<  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
<  */
< 
< package spew
< 
< import (
< 	"fmt"
< 	"io"
< )
< 
< // Errorf is a wrapper for fmt.Errorf that treats each argument as if it were
< // passed with a default Formatter interface returned by NewFormatter.  It
< // returns the formatted string as a value that satisfies error.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Errorf(format, spew.NewFormatter(a), spew.NewFormatter(b))
< func Errorf(format string, a ...interface{}) (err error) {
< 	return fmt.Errorf(format, convertArgs(a)...)
< }
< 
< // Fprint is a wrapper for fmt.Fprint that treats each argument as if it were
< // passed with a default Formatter interface returned by NewFormatter.  It
< // returns the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Fprint(w, spew.NewFormatter(a), spew.NewFormatter(b))
< func Fprint(w io.Writer, a ...interface{}) (n int, err error) {
< 	return fmt.Fprint(w, convertArgs(a)...)
< }
< 
< // Fprintf is a wrapper for fmt.Fprintf that treats each argument as if it were
< // passed with a default Formatter interface returned by NewFormatter.  It
< // returns the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Fprintf(w, format, spew.NewFormatter(a), spew.NewFormatter(b))
< func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) {
< 	return fmt.Fprintf(w, format, convertArgs(a)...)
< }
< 
< // Fprintln is a wrapper for fmt.Fprintln that treats each argument as if it
< // passed with a default Formatter interface returned by NewFormatter.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Fprintln(w, spew.NewFormatter(a), spew.NewFormatter(b))
< func Fprintln(w io.Writer, a ...interface{}) (n int, err error) {
< 	return fmt.Fprintln(w, convertArgs(a)...)
< }
< 
< // Print is a wrapper for fmt.Print that treats each argument as if it were
< // passed with a default Formatter interface returned by NewFormatter.  It
< // returns the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Print(spew.NewFormatter(a), spew.NewFormatter(b))
< func Print(a ...interface{}) (n int, err error) {
< 	return fmt.Print(convertArgs(a)...)
< }
< 
< // Printf is a wrapper for fmt.Printf that treats each argument as if it were
< // passed with a default Formatter interface returned by NewFormatter.  It
< // returns the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Printf(format, spew.NewFormatter(a), spew.NewFormatter(b))
< func Printf(format string, a ...interface{}) (n int, err error) {
< 	return fmt.Printf(format, convertArgs(a)...)
< }
< 
< // Println is a wrapper for fmt.Println that treats each argument as if it were
< // passed with a default Formatter interface returned by NewFormatter.  It
< // returns the number of bytes written and any write error encountered.  See
< // NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Println(spew.NewFormatter(a), spew.NewFormatter(b))
< func Println(a ...interface{}) (n int, err error) {
< 	return fmt.Println(convertArgs(a)...)
< }
< 
< // Sprint is a wrapper for fmt.Sprint that treats each argument as if it were
< // passed with a default Formatter interface returned by NewFormatter.  It
< // returns the resulting string.  See NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Sprint(spew.NewFormatter(a), spew.NewFormatter(b))
< func Sprint(a ...interface{}) string {
< 	return fmt.Sprint(convertArgs(a)...)
< }
< 
< // Sprintf is a wrapper for fmt.Sprintf that treats each argument as if it were
< // passed with a default Formatter interface returned by NewFormatter.  It
< // returns the resulting string.  See NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Sprintf(format, spew.NewFormatter(a), spew.NewFormatter(b))
< func Sprintf(format string, a ...interface{}) string {
< 	return fmt.Sprintf(format, convertArgs(a)...)
< }
< 
< // Sprintln is a wrapper for fmt.Sprintln that treats each argument as if it
< // were passed with a default Formatter interface returned by NewFormatter.  It
< // returns the resulting string.  See NewFormatter for formatting details.
< //
< // This function is shorthand for the following syntax:
< //
< //	fmt.Sprintln(spew.NewFormatter(a), spew.NewFormatter(b))
< func Sprintln(a ...interface{}) string {
< 	return fmt.Sprintln(convertArgs(a)...)
< }
< 
< // convertArgs accepts a slice of arguments and returns a slice of the same
< // length with each argument converted to a default spew Formatter interface.
< func convertArgs(args []interface{}) (formatters []interface{}) {
< 	formatters = make([]interface{}, len(args))
< 	for index, arg := range args {
< 		formatters[index] = NewFormatter(arg)
< 	}
< 	return formatters
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/pmezard/go-difflib/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/pmezard/go-difflib/LICENSE
1,27d0
< Copyright (c) 2013, Patrick Mezard
< All rights reserved.
< 
< Redistribution and use in source and binary forms, with or without
< modification, are permitted provided that the following conditions are
< met:
< 
<     Redistributions of source code must retain the above copyright
< notice, this list of conditions and the following disclaimer.
<     Redistributions in binary form must reproduce the above copyright
< notice, this list of conditions and the following disclaimer in the
< documentation and/or other materials provided with the distribution.
<     The names of its contributors may not be used to endorse or promote
< products derived from this software without specific prior written
< permission.
< 
< THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
< IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
< TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
< PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
< HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
< SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
< TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
< PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
< LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
< NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
< SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/pmezard/go-difflib/difflib/difflib.go updated/vendor/github.com/coreos/fcct/vendor/github.com/pmezard/go-difflib/difflib/difflib.go
1,772d0
< // Package difflib is a partial port of Python difflib module.
< //
< // It provides tools to compare sequences of strings and generate textual diffs.
< //
< // The following class and functions have been ported:
< //
< // - SequenceMatcher
< //
< // - unified_diff
< //
< // - context_diff
< //
< // Getting unified diffs was the main goal of the port. Keep in mind this code
< // is mostly suitable to output text differences in a human friendly way, there
< // are no guarantees generated diffs are consumable by patch(1).
< package difflib
< 
< import (
< 	"bufio"
< 	"bytes"
< 	"fmt"
< 	"io"
< 	"strings"
< )
< 
< func min(a, b int) int {
< 	if a < b {
< 		return a
< 	}
< 	return b
< }
< 
< func max(a, b int) int {
< 	if a > b {
< 		return a
< 	}
< 	return b
< }
< 
< func calculateRatio(matches, length int) float64 {
< 	if length > 0 {
< 		return 2.0 * float64(matches) / float64(length)
< 	}
< 	return 1.0
< }
< 
< type Match struct {
< 	A    int
< 	B    int
< 	Size int
< }
< 
< type OpCode struct {
< 	Tag byte
< 	I1  int
< 	I2  int
< 	J1  int
< 	J2  int
< }
< 
< // SequenceMatcher compares sequence of strings. The basic
< // algorithm predates, and is a little fancier than, an algorithm
< // published in the late 1980's by Ratcliff and Obershelp under the
< // hyperbolic name "gestalt pattern matching".  The basic idea is to find
< // the longest contiguous matching subsequence that contains no "junk"
< // elements (R-O doesn't address junk).  The same idea is then applied
< // recursively to the pieces of the sequences to the left and to the right
< // of the matching subsequence.  This does not yield minimal edit
< // sequences, but does tend to yield matches that "look right" to people.
< //
< // SequenceMatcher tries to compute a "human-friendly diff" between two
< // sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the
< // longest *contiguous* & junk-free matching subsequence.  That's what
< // catches peoples' eyes.  The Windows(tm) windiff has another interesting
< // notion, pairing up elements that appear uniquely in each sequence.
< // That, and the method here, appear to yield more intuitive difference
< // reports than does diff.  This method appears to be the least vulnerable
< // to synching up on blocks of "junk lines", though (like blank lines in
< // ordinary text files, or maybe "<P>" lines in HTML files).  That may be
< // because this is the only method of the 3 that has a *concept* of
< // "junk" <wink>.
< //
< // Timing:  Basic R-O is cubic time worst case and quadratic time expected
< // case.  SequenceMatcher is quadratic time for the worst case and has
< // expected-case behavior dependent in a complicated way on how many
< // elements the sequences have in common; best case time is linear.
< type SequenceMatcher struct {
< 	a              []string
< 	b              []string
< 	b2j            map[string][]int
< 	IsJunk         func(string) bool
< 	autoJunk       bool
< 	bJunk          map[string]struct{}
< 	matchingBlocks []Match
< 	fullBCount     map[string]int
< 	bPopular       map[string]struct{}
< 	opCodes        []OpCode
< }
< 
< func NewMatcher(a, b []string) *SequenceMatcher {
< 	m := SequenceMatcher{autoJunk: true}
< 	m.SetSeqs(a, b)
< 	return &m
< }
< 
< func NewMatcherWithJunk(a, b []string, autoJunk bool,
< 	isJunk func(string) bool) *SequenceMatcher {
< 
< 	m := SequenceMatcher{IsJunk: isJunk, autoJunk: autoJunk}
< 	m.SetSeqs(a, b)
< 	return &m
< }
< 
< // Set two sequences to be compared.
< func (m *SequenceMatcher) SetSeqs(a, b []string) {
< 	m.SetSeq1(a)
< 	m.SetSeq2(b)
< }
< 
< // Set the first sequence to be compared. The second sequence to be compared is
< // not changed.
< //
< // SequenceMatcher computes and caches detailed information about the second
< // sequence, so if you want to compare one sequence S against many sequences,
< // use .SetSeq2(s) once and call .SetSeq1(x) repeatedly for each of the other
< // sequences.
< //
< // See also SetSeqs() and SetSeq2().
< func (m *SequenceMatcher) SetSeq1(a []string) {
< 	if &a == &m.a {
< 		return
< 	}
< 	m.a = a
< 	m.matchingBlocks = nil
< 	m.opCodes = nil
< }
< 
< // Set the second sequence to be compared. The first sequence to be compared is
< // not changed.
< func (m *SequenceMatcher) SetSeq2(b []string) {
< 	if &b == &m.b {
< 		return
< 	}
< 	m.b = b
< 	m.matchingBlocks = nil
< 	m.opCodes = nil
< 	m.fullBCount = nil
< 	m.chainB()
< }
< 
< func (m *SequenceMatcher) chainB() {
< 	// Populate line -> index mapping
< 	b2j := map[string][]int{}
< 	for i, s := range m.b {
< 		indices := b2j[s]
< 		indices = append(indices, i)
< 		b2j[s] = indices
< 	}
< 
< 	// Purge junk elements
< 	m.bJunk = map[string]struct{}{}
< 	if m.IsJunk != nil {
< 		junk := m.bJunk
< 		for s, _ := range b2j {
< 			if m.IsJunk(s) {
< 				junk[s] = struct{}{}
< 			}
< 		}
< 		for s, _ := range junk {
< 			delete(b2j, s)
< 		}
< 	}
< 
< 	// Purge remaining popular elements
< 	popular := map[string]struct{}{}
< 	n := len(m.b)
< 	if m.autoJunk && n >= 200 {
< 		ntest := n/100 + 1
< 		for s, indices := range b2j {
< 			if len(indices) > ntest {
< 				popular[s] = struct{}{}
< 			}
< 		}
< 		for s, _ := range popular {
< 			delete(b2j, s)
< 		}
< 	}
< 	m.bPopular = popular
< 	m.b2j = b2j
< }
< 
< func (m *SequenceMatcher) isBJunk(s string) bool {
< 	_, ok := m.bJunk[s]
< 	return ok
< }
< 
< // Find longest matching block in a[alo:ahi] and b[blo:bhi].
< //
< // If IsJunk is not defined:
< //
< // Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where
< //     alo <= i <= i+k <= ahi
< //     blo <= j <= j+k <= bhi
< // and for all (i',j',k') meeting those conditions,
< //     k >= k'
< //     i <= i'
< //     and if i == i', j <= j'
< //
< // In other words, of all maximal matching blocks, return one that
< // starts earliest in a, and of all those maximal matching blocks that
< // start earliest in a, return the one that starts earliest in b.
< //
< // If IsJunk is defined, first the longest matching block is
< // determined as above, but with the additional restriction that no
< // junk element appears in the block.  Then that block is extended as
< // far as possible by matching (only) junk elements on both sides.  So
< // the resulting block never matches on junk except as identical junk
< // happens to be adjacent to an "interesting" match.
< //
< // If no blocks match, return (alo, blo, 0).
< func (m *SequenceMatcher) findLongestMatch(alo, ahi, blo, bhi int) Match {
< 	// CAUTION:  stripping common prefix or suffix would be incorrect.
< 	// E.g.,
< 	//    ab
< 	//    acab
< 	// Longest matching block is "ab", but if common prefix is
< 	// stripped, it's "a" (tied with "b").  UNIX(tm) diff does so
< 	// strip, so ends up claiming that ab is changed to acab by
< 	// inserting "ca" in the middle.  That's minimal but unintuitive:
< 	// "it's obvious" that someone inserted "ac" at the front.
< 	// Windiff ends up at the same place as diff, but by pairing up
< 	// the unique 'b's and then matching the first two 'a's.
< 	besti, bestj, bestsize := alo, blo, 0
< 
< 	// find longest junk-free match
< 	// during an iteration of the loop, j2len[j] = length of longest
< 	// junk-free match ending with a[i-1] and b[j]
< 	j2len := map[int]int{}
< 	for i := alo; i != ahi; i++ {
< 		// look at all instances of a[i] in b; note that because
< 		// b2j has no junk keys, the loop is skipped if a[i] is junk
< 		newj2len := map[int]int{}
< 		for _, j := range m.b2j[m.a[i]] {
< 			// a[i] matches b[j]
< 			if j < blo {
< 				continue
< 			}
< 			if j >= bhi {
< 				break
< 			}
< 			k := j2len[j-1] + 1
< 			newj2len[j] = k
< 			if k > bestsize {
< 				besti, bestj, bestsize = i-k+1, j-k+1, k
< 			}
< 		}
< 		j2len = newj2len
< 	}
< 
< 	// Extend the best by non-junk elements on each end.  In particular,
< 	// "popular" non-junk elements aren't in b2j, which greatly speeds
< 	// the inner loop above, but also means "the best" match so far
< 	// doesn't contain any junk *or* popular non-junk elements.
< 	for besti > alo && bestj > blo && !m.isBJunk(m.b[bestj-1]) &&
< 		m.a[besti-1] == m.b[bestj-1] {
< 		besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
< 	}
< 	for besti+bestsize < ahi && bestj+bestsize < bhi &&
< 		!m.isBJunk(m.b[bestj+bestsize]) &&
< 		m.a[besti+bestsize] == m.b[bestj+bestsize] {
< 		bestsize += 1
< 	}
< 
< 	// Now that we have a wholly interesting match (albeit possibly
< 	// empty!), we may as well suck up the matching junk on each
< 	// side of it too.  Can't think of a good reason not to, and it
< 	// saves post-processing the (possibly considerable) expense of
< 	// figuring out what to do with it.  In the case of an empty
< 	// interesting match, this is clearly the right thing to do,
< 	// because no other kind of match is possible in the regions.
< 	for besti > alo && bestj > blo && m.isBJunk(m.b[bestj-1]) &&
< 		m.a[besti-1] == m.b[bestj-1] {
< 		besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
< 	}
< 	for besti+bestsize < ahi && bestj+bestsize < bhi &&
< 		m.isBJunk(m.b[bestj+bestsize]) &&
< 		m.a[besti+bestsize] == m.b[bestj+bestsize] {
< 		bestsize += 1
< 	}
< 
< 	return Match{A: besti, B: bestj, Size: bestsize}
< }
< 
< // Return list of triples describing matching subsequences.
< //
< // Each triple is of the form (i, j, n), and means that
< // a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in
< // i and in j. It's also guaranteed that if (i, j, n) and (i', j', n') are
< // adjacent triples in the list, and the second is not the last triple in the
< // list, then i+n != i' or j+n != j'. IOW, adjacent triples never describe
< // adjacent equal blocks.
< //
< // The last triple is a dummy, (len(a), len(b), 0), and is the only
< // triple with n==0.
< func (m *SequenceMatcher) GetMatchingBlocks() []Match {
< 	if m.matchingBlocks != nil {
< 		return m.matchingBlocks
< 	}
< 
< 	var matchBlocks func(alo, ahi, blo, bhi int, matched []Match) []Match
< 	matchBlocks = func(alo, ahi, blo, bhi int, matched []Match) []Match {
< 		match := m.findLongestMatch(alo, ahi, blo, bhi)
< 		i, j, k := match.A, match.B, match.Size
< 		if match.Size > 0 {
< 			if alo < i && blo < j {
< 				matched = matchBlocks(alo, i, blo, j, matched)
< 			}
< 			matched = append(matched, match)
< 			if i+k < ahi && j+k < bhi {
< 				matched = matchBlocks(i+k, ahi, j+k, bhi, matched)
< 			}
< 		}
< 		return matched
< 	}
< 	matched := matchBlocks(0, len(m.a), 0, len(m.b), nil)
< 
< 	// It's possible that we have adjacent equal blocks in the
< 	// matching_blocks list now.
< 	nonAdjacent := []Match{}
< 	i1, j1, k1 := 0, 0, 0
< 	for _, b := range matched {
< 		// Is this block adjacent to i1, j1, k1?
< 		i2, j2, k2 := b.A, b.B, b.Size
< 		if i1+k1 == i2 && j1+k1 == j2 {
< 			// Yes, so collapse them -- this just increases the length of
< 			// the first block by the length of the second, and the first
< 			// block so lengthened remains the block to compare against.
< 			k1 += k2
< 		} else {
< 			// Not adjacent.  Remember the first block (k1==0 means it's
< 			// the dummy we started with), and make the second block the
< 			// new block to compare against.
< 			if k1 > 0 {
< 				nonAdjacent = append(nonAdjacent, Match{i1, j1, k1})
< 			}
< 			i1, j1, k1 = i2, j2, k2
< 		}
< 	}
< 	if k1 > 0 {
< 		nonAdjacent = append(nonAdjacent, Match{i1, j1, k1})
< 	}
< 
< 	nonAdjacent = append(nonAdjacent, Match{len(m.a), len(m.b), 0})
< 	m.matchingBlocks = nonAdjacent
< 	return m.matchingBlocks
< }
< 
< // Return list of 5-tuples describing how to turn a into b.
< //
< // Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple
< // has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the
< // tuple preceding it, and likewise for j1 == the previous j2.
< //
< // The tags are characters, with these meanings:
< //
< // 'r' (replace):  a[i1:i2] should be replaced by b[j1:j2]
< //
< // 'd' (delete):   a[i1:i2] should be deleted, j1==j2 in this case.
< //
< // 'i' (insert):   b[j1:j2] should be inserted at a[i1:i1], i1==i2 in this case.
< //
< // 'e' (equal):    a[i1:i2] == b[j1:j2]
< func (m *SequenceMatcher) GetOpCodes() []OpCode {
< 	if m.opCodes != nil {
< 		return m.opCodes
< 	}
< 	i, j := 0, 0
< 	matching := m.GetMatchingBlocks()
< 	opCodes := make([]OpCode, 0, len(matching))
< 	for _, m := range matching {
< 		//  invariant:  we've pumped out correct diffs to change
< 		//  a[:i] into b[:j], and the next matching block is
< 		//  a[ai:ai+size] == b[bj:bj+size]. So we need to pump
< 		//  out a diff to change a[i:ai] into b[j:bj], pump out
< 		//  the matching block, and move (i,j) beyond the match
< 		ai, bj, size := m.A, m.B, m.Size
< 		tag := byte(0)
< 		if i < ai && j < bj {
< 			tag = 'r'
< 		} else if i < ai {
< 			tag = 'd'
< 		} else if j < bj {
< 			tag = 'i'
< 		}
< 		if tag > 0 {
< 			opCodes = append(opCodes, OpCode{tag, i, ai, j, bj})
< 		}
< 		i, j = ai+size, bj+size
< 		// the list of matching blocks is terminated by a
< 		// sentinel with size 0
< 		if size > 0 {
< 			opCodes = append(opCodes, OpCode{'e', ai, i, bj, j})
< 		}
< 	}
< 	m.opCodes = opCodes
< 	return m.opCodes
< }
< 
< // Isolate change clusters by eliminating ranges with no changes.
< //
< // Return a generator of groups with up to n lines of context.
< // Each group is in the same format as returned by GetOpCodes().
< func (m *SequenceMatcher) GetGroupedOpCodes(n int) [][]OpCode {
< 	if n < 0 {
< 		n = 3
< 	}
< 	codes := m.GetOpCodes()
< 	if len(codes) == 0 {
< 		codes = []OpCode{OpCode{'e', 0, 1, 0, 1}}
< 	}
< 	// Fixup leading and trailing groups if they show no changes.
< 	if codes[0].Tag == 'e' {
< 		c := codes[0]
< 		i1, i2, j1, j2 := c.I1, c.I2, c.J1, c.J2
< 		codes[0] = OpCode{c.Tag, max(i1, i2-n), i2, max(j1, j2-n), j2}
< 	}
< 	if codes[len(codes)-1].Tag == 'e' {
< 		c := codes[len(codes)-1]
< 		i1, i2, j1, j2 := c.I1, c.I2, c.J1, c.J2
< 		codes[len(codes)-1] = OpCode{c.Tag, i1, min(i2, i1+n), j1, min(j2, j1+n)}
< 	}
< 	nn := n + n
< 	groups := [][]OpCode{}
< 	group := []OpCode{}
< 	for _, c := range codes {
< 		i1, i2, j1, j2 := c.I1, c.I2, c.J1, c.J2
< 		// End the current group and start a new one whenever
< 		// there is a large range with no changes.
< 		if c.Tag == 'e' && i2-i1 > nn {
< 			group = append(group, OpCode{c.Tag, i1, min(i2, i1+n),
< 				j1, min(j2, j1+n)})
< 			groups = append(groups, group)
< 			group = []OpCode{}
< 			i1, j1 = max(i1, i2-n), max(j1, j2-n)
< 		}
< 		group = append(group, OpCode{c.Tag, i1, i2, j1, j2})
< 	}
< 	if len(group) > 0 && !(len(group) == 1 && group[0].Tag == 'e') {
< 		groups = append(groups, group)
< 	}
< 	return groups
< }
< 
< // Return a measure of the sequences' similarity (float in [0,1]).
< //
< // Where T is the total number of elements in both sequences, and
< // M is the number of matches, this is 2.0*M / T.
< // Note that this is 1 if the sequences are identical, and 0 if
< // they have nothing in common.
< //
< // .Ratio() is expensive to compute if you haven't already computed
< // .GetMatchingBlocks() or .GetOpCodes(), in which case you may
< // want to try .QuickRatio() or .RealQuickRation() first to get an
< // upper bound.
< func (m *SequenceMatcher) Ratio() float64 {
< 	matches := 0
< 	for _, m := range m.GetMatchingBlocks() {
< 		matches += m.Size
< 	}
< 	return calculateRatio(matches, len(m.a)+len(m.b))
< }
< 
< // Return an upper bound on ratio() relatively quickly.
< //
< // This isn't defined beyond that it is an upper bound on .Ratio(), and
< // is faster to compute.
< func (m *SequenceMatcher) QuickRatio() float64 {
< 	// viewing a and b as multisets, set matches to the cardinality
< 	// of their intersection; this counts the number of matches
< 	// without regard to order, so is clearly an upper bound
< 	if m.fullBCount == nil {
< 		m.fullBCount = map[string]int{}
< 		for _, s := range m.b {
< 			m.fullBCount[s] = m.fullBCount[s] + 1
< 		}
< 	}
< 
< 	// avail[x] is the number of times x appears in 'b' less the
< 	// number of times we've seen it in 'a' so far ... kinda
< 	avail := map[string]int{}
< 	matches := 0
< 	for _, s := range m.a {
< 		n, ok := avail[s]
< 		if !ok {
< 			n = m.fullBCount[s]
< 		}
< 		avail[s] = n - 1
< 		if n > 0 {
< 			matches += 1
< 		}
< 	}
< 	return calculateRatio(matches, len(m.a)+len(m.b))
< }
< 
< // Return an upper bound on ratio() very quickly.
< //
< // This isn't defined beyond that it is an upper bound on .Ratio(), and
< // is faster to compute than either .Ratio() or .QuickRatio().
< func (m *SequenceMatcher) RealQuickRatio() float64 {
< 	la, lb := len(m.a), len(m.b)
< 	return calculateRatio(min(la, lb), la+lb)
< }
< 
< // Convert range to the "ed" format
< func formatRangeUnified(start, stop int) string {
< 	// Per the diff spec at http://www.unix.org/single_unix_specification/
< 	beginning := start + 1 // lines start numbering with one
< 	length := stop - start
< 	if length == 1 {
< 		return fmt.Sprintf("%d", beginning)
< 	}
< 	if length == 0 {
< 		beginning -= 1 // empty ranges begin at line just before the range
< 	}
< 	return fmt.Sprintf("%d,%d", beginning, length)
< }
< 
< // Unified diff parameters
< type UnifiedDiff struct {
< 	A        []string // First sequence lines
< 	FromFile string   // First file name
< 	FromDate string   // First file time
< 	B        []string // Second sequence lines
< 	ToFile   string   // Second file name
< 	ToDate   string   // Second file time
< 	Eol      string   // Headers end of line, defaults to LF
< 	Context  int      // Number of context lines
< }
< 
< // Compare two sequences of lines; generate the delta as a unified diff.
< //
< // Unified diffs are a compact way of showing line changes and a few
< // lines of context.  The number of context lines is set by 'n' which
< // defaults to three.
< //
< // By default, the diff control lines (those with ---, +++, or @@) are
< // created with a trailing newline.  This is helpful so that inputs
< // created from file.readlines() result in diffs that are suitable for
< // file.writelines() since both the inputs and outputs have trailing
< // newlines.
< //
< // For inputs that do not have trailing newlines, set the lineterm
< // argument to "" so that the output will be uniformly newline free.
< //
< // The unidiff format normally has a header for filenames and modification
< // times.  Any or all of these may be specified using strings for
< // 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.
< // The modification times are normally expressed in the ISO 8601 format.
< func WriteUnifiedDiff(writer io.Writer, diff UnifiedDiff) error {
< 	buf := bufio.NewWriter(writer)
< 	defer buf.Flush()
< 	wf := func(format string, args ...interface{}) error {
< 		_, err := buf.WriteString(fmt.Sprintf(format, args...))
< 		return err
< 	}
< 	ws := func(s string) error {
< 		_, err := buf.WriteString(s)
< 		return err
< 	}
< 
< 	if len(diff.Eol) == 0 {
< 		diff.Eol = "\n"
< 	}
< 
< 	started := false
< 	m := NewMatcher(diff.A, diff.B)
< 	for _, g := range m.GetGroupedOpCodes(diff.Context) {
< 		if !started {
< 			started = true
< 			fromDate := ""
< 			if len(diff.FromDate) > 0 {
< 				fromDate = "\t" + diff.FromDate
< 			}
< 			toDate := ""
< 			if len(diff.ToDate) > 0 {
< 				toDate = "\t" + diff.ToDate
< 			}
< 			if diff.FromFile != "" || diff.ToFile != "" {
< 				err := wf("--- %s%s%s", diff.FromFile, fromDate, diff.Eol)
< 				if err != nil {
< 					return err
< 				}
< 				err = wf("+++ %s%s%s", diff.ToFile, toDate, diff.Eol)
< 				if err != nil {
< 					return err
< 				}
< 			}
< 		}
< 		first, last := g[0], g[len(g)-1]
< 		range1 := formatRangeUnified(first.I1, last.I2)
< 		range2 := formatRangeUnified(first.J1, last.J2)
< 		if err := wf("@@ -%s +%s @@%s", range1, range2, diff.Eol); err != nil {
< 			return err
< 		}
< 		for _, c := range g {
< 			i1, i2, j1, j2 := c.I1, c.I2, c.J1, c.J2
< 			if c.Tag == 'e' {
< 				for _, line := range diff.A[i1:i2] {
< 					if err := ws(" " + line); err != nil {
< 						return err
< 					}
< 				}
< 				continue
< 			}
< 			if c.Tag == 'r' || c.Tag == 'd' {
< 				for _, line := range diff.A[i1:i2] {
< 					if err := ws("-" + line); err != nil {
< 						return err
< 					}
< 				}
< 			}
< 			if c.Tag == 'r' || c.Tag == 'i' {
< 				for _, line := range diff.B[j1:j2] {
< 					if err := ws("+" + line); err != nil {
< 						return err
< 					}
< 				}
< 			}
< 		}
< 	}
< 	return nil
< }
< 
< // Like WriteUnifiedDiff but returns the diff a string.
< func GetUnifiedDiffString(diff UnifiedDiff) (string, error) {
< 	w := &bytes.Buffer{}
< 	err := WriteUnifiedDiff(w, diff)
< 	return string(w.Bytes()), err
< }
< 
< // Convert range to the "ed" format.
< func formatRangeContext(start, stop int) string {
< 	// Per the diff spec at http://www.unix.org/single_unix_specification/
< 	beginning := start + 1 // lines start numbering with one
< 	length := stop - start
< 	if length == 0 {
< 		beginning -= 1 // empty ranges begin at line just before the range
< 	}
< 	if length <= 1 {
< 		return fmt.Sprintf("%d", beginning)
< 	}
< 	return fmt.Sprintf("%d,%d", beginning, beginning+length-1)
< }
< 
< type ContextDiff UnifiedDiff
< 
< // Compare two sequences of lines; generate the delta as a context diff.
< //
< // Context diffs are a compact way of showing line changes and a few
< // lines of context. The number of context lines is set by diff.Context
< // which defaults to three.
< //
< // By default, the diff control lines (those with *** or ---) are
< // created with a trailing newline.
< //
< // For inputs that do not have trailing newlines, set the diff.Eol
< // argument to "" so that the output will be uniformly newline free.
< //
< // The context diff format normally has a header for filenames and
< // modification times.  Any or all of these may be specified using
< // strings for diff.FromFile, diff.ToFile, diff.FromDate, diff.ToDate.
< // The modification times are normally expressed in the ISO 8601 format.
< // If not specified, the strings default to blanks.
< func WriteContextDiff(writer io.Writer, diff ContextDiff) error {
< 	buf := bufio.NewWriter(writer)
< 	defer buf.Flush()
< 	var diffErr error
< 	wf := func(format string, args ...interface{}) {
< 		_, err := buf.WriteString(fmt.Sprintf(format, args...))
< 		if diffErr == nil && err != nil {
< 			diffErr = err
< 		}
< 	}
< 	ws := func(s string) {
< 		_, err := buf.WriteString(s)
< 		if diffErr == nil && err != nil {
< 			diffErr = err
< 		}
< 	}
< 
< 	if len(diff.Eol) == 0 {
< 		diff.Eol = "\n"
< 	}
< 
< 	prefix := map[byte]string{
< 		'i': "+ ",
< 		'd': "- ",
< 		'r': "! ",
< 		'e': "  ",
< 	}
< 
< 	started := false
< 	m := NewMatcher(diff.A, diff.B)
< 	for _, g := range m.GetGroupedOpCodes(diff.Context) {
< 		if !started {
< 			started = true
< 			fromDate := ""
< 			if len(diff.FromDate) > 0 {
< 				fromDate = "\t" + diff.FromDate
< 			}
< 			toDate := ""
< 			if len(diff.ToDate) > 0 {
< 				toDate = "\t" + diff.ToDate
< 			}
< 			if diff.FromFile != "" || diff.ToFile != "" {
< 				wf("*** %s%s%s", diff.FromFile, fromDate, diff.Eol)
< 				wf("--- %s%s%s", diff.ToFile, toDate, diff.Eol)
< 			}
< 		}
< 
< 		first, last := g[0], g[len(g)-1]
< 		ws("***************" + diff.Eol)
< 
< 		range1 := formatRangeContext(first.I1, last.I2)
< 		wf("*** %s ****%s", range1, diff.Eol)
< 		for _, c := range g {
< 			if c.Tag == 'r' || c.Tag == 'd' {
< 				for _, cc := range g {
< 					if cc.Tag == 'i' {
< 						continue
< 					}
< 					for _, line := range diff.A[cc.I1:cc.I2] {
< 						ws(prefix[cc.Tag] + line)
< 					}
< 				}
< 				break
< 			}
< 		}
< 
< 		range2 := formatRangeContext(first.J1, last.J2)
< 		wf("--- %s ----%s", range2, diff.Eol)
< 		for _, c := range g {
< 			if c.Tag == 'r' || c.Tag == 'i' {
< 				for _, cc := range g {
< 					if cc.Tag == 'd' {
< 						continue
< 					}
< 					for _, line := range diff.B[cc.J1:cc.J2] {
< 						ws(prefix[cc.Tag] + line)
< 					}
< 				}
< 				break
< 			}
< 		}
< 	}
< 	return diffErr
< }
< 
< // Like WriteContextDiff but returns the diff a string.
< func GetContextDiffString(diff ContextDiff) (string, error) {
< 	w := &bytes.Buffer{}
< 	err := WriteContextDiff(w, diff)
< 	return string(w.Bytes()), err
< }
< 
< // Split a string on "\n" while preserving them. The output can be used
< // as input for UnifiedDiff and ContextDiff structures.
< func SplitLines(s string) []string {
< 	lines := strings.SplitAfter(s, "\n")
< 	lines[len(lines)-1] += "\n"
< 	return lines
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/.gitignore updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/.gitignore
1,2d0
< .idea/*
< 
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/.travis.yml updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/.travis.yml
1,22d0
< sudo: false
< 
< language: go
< 
< go:
<   - 1.9.x
<   - 1.10.x
<   - 1.11.x
<   - tip
< 
< matrix:
<   allow_failures:
<     - go: tip
< 
< install:
<   - go get golang.org/x/lint/golint
<   - export PATH=$GOPATH/bin:$PATH
<   - go install ./...
< 
< script:
<   - verify/all.sh -v
<   - go test ./...
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/LICENSE
1,28d0
< Copyright (c) 2012 Alex Ogier. All rights reserved.
< Copyright (c) 2012 The Go Authors. All rights reserved.
< 
< Redistribution and use in source and binary forms, with or without
< modification, are permitted provided that the following conditions are
< met:
< 
<    * Redistributions of source code must retain the above copyright
< notice, this list of conditions and the following disclaimer.
<    * Redistributions in binary form must reproduce the above
< copyright notice, this list of conditions and the following disclaimer
< in the documentation and/or other materials provided with the
< distribution.
<    * Neither the name of Google Inc. nor the names of its
< contributors may be used to endorse or promote products derived from
< this software without specific prior written permission.
< 
< THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
< "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
< LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
< A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
< OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
< SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
< LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
< DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
< THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
< (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
< OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/README.md updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/README.md
1,296d0
< [![Build Status](https://travis-ci.org/spf13/pflag.svg?branch=master)](https://travis-ci.org/spf13/pflag)
< [![Go Report Card](https://goreportcard.com/badge/github.com/spf13/pflag)](https://goreportcard.com/report/github.com/spf13/pflag)
< [![GoDoc](https://godoc.org/github.com/spf13/pflag?status.svg)](https://godoc.org/github.com/spf13/pflag)
< 
< ## Description
< 
< pflag is a drop-in replacement for Go's flag package, implementing
< POSIX/GNU-style --flags.
< 
< pflag is compatible with the [GNU extensions to the POSIX recommendations
< for command-line options][1]. For a more precise description, see the
< "Command-line flag syntax" section below.
< 
< [1]: http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
< 
< pflag is available under the same style of BSD license as the Go language,
< which can be found in the LICENSE file.
< 
< ## Installation
< 
< pflag is available using the standard `go get` command.
< 
< Install by running:
< 
<     go get github.com/spf13/pflag
< 
< Run tests by running:
< 
<     go test github.com/spf13/pflag
< 
< ## Usage
< 
< pflag is a drop-in replacement of Go's native flag package. If you import
< pflag under the name "flag" then all code should continue to function
< with no changes.
< 
< ``` go
< import flag "github.com/spf13/pflag"
< ```
< 
< There is one exception to this: if you directly instantiate the Flag struct
< there is one more field "Shorthand" that you will need to set.
< Most code never instantiates this struct directly, and instead uses
< functions such as String(), BoolVar(), and Var(), and is therefore
< unaffected.
< 
< Define flags using flag.String(), Bool(), Int(), etc.
< 
< This declares an integer flag, -flagname, stored in the pointer ip, with type *int.
< 
< ``` go
< var ip *int = flag.Int("flagname", 1234, "help message for flagname")
< ```
< 
< If you like, you can bind the flag to a variable using the Var() functions.
< 
< ``` go
< var flagvar int
< func init() {
<     flag.IntVar(&flagvar, "flagname", 1234, "help message for flagname")
< }
< ```
< 
< Or you can create custom flags that satisfy the Value interface (with
< pointer receivers) and couple them to flag parsing by
< 
< ``` go
< flag.Var(&flagVal, "name", "help message for flagname")
< ```
< 
< For such flags, the default value is just the initial value of the variable.
< 
< After all flags are defined, call
< 
< ``` go
< flag.Parse()
< ```
< 
< to parse the command line into the defined flags.
< 
< Flags may then be used directly. If you're using the flags themselves,
< they are all pointers; if you bind to variables, they're values.
< 
< ``` go
< fmt.Println("ip has value ", *ip)
< fmt.Println("flagvar has value ", flagvar)
< ```
< 
< There are helper functions available to get the value stored in a Flag if you have a FlagSet but find
< it difficult to keep up with all of the pointers in your code.
< If you have a pflag.FlagSet with a flag called 'flagname' of type int you
< can use GetInt() to get the int value. But notice that 'flagname' must exist
< and it must be an int. GetString("flagname") will fail.
< 
< ``` go
< i, err := flagset.GetInt("flagname")
< ```
< 
< After parsing, the arguments after the flag are available as the
< slice flag.Args() or individually as flag.Arg(i).
< The arguments are indexed from 0 through flag.NArg()-1.
< 
< The pflag package also defines some new functions that are not in flag,
< that give one-letter shorthands for flags. You can use these by appending
< 'P' to the name of any function that defines a flag.
< 
< ``` go
< var ip = flag.IntP("flagname", "f", 1234, "help message")
< var flagvar bool
< func init() {
< 	flag.BoolVarP(&flagvar, "boolname", "b", true, "help message")
< }
< flag.VarP(&flagVal, "varname", "v", "help message")
< ```
< 
< Shorthand letters can be used with single dashes on the command line.
< Boolean shorthand flags can be combined with other shorthand flags.
< 
< The default set of command-line flags is controlled by
< top-level functions.  The FlagSet type allows one to define
< independent sets of flags, such as to implement subcommands
< in a command-line interface. The methods of FlagSet are
< analogous to the top-level functions for the command-line
< flag set.
< 
< ## Setting no option default values for flags
< 
< After you create a flag it is possible to set the pflag.NoOptDefVal for
< the given flag. Doing this changes the meaning of the flag slightly. If
< a flag has a NoOptDefVal and the flag is set on the command line without
< an option the flag will be set to the NoOptDefVal. For example given:
< 
< ``` go
< var ip = flag.IntP("flagname", "f", 1234, "help message")
< flag.Lookup("flagname").NoOptDefVal = "4321"
< ```
< 
< Would result in something like
< 
< | Parsed Arguments | Resulting Value |
< | -------------    | -------------   |
< | --flagname=1357  | ip=1357         |
< | --flagname       | ip=4321         |
< | [nothing]        | ip=1234         |
< 
< ## Command line flag syntax
< 
< ```
< --flag    // boolean flags, or flags with no option default values
< --flag x  // only on flags without a default value
< --flag=x
< ```
< 
< Unlike the flag package, a single dash before an option means something
< different than a double dash. Single dashes signify a series of shorthand
< letters for flags. All but the last shorthand letter must be boolean flags
< or a flag with a default value
< 
< ```
< // boolean or flags where the 'no option default value' is set
< -f
< -f=true
< -abc
< but
< -b true is INVALID
< 
< // non-boolean and flags without a 'no option default value'
< -n 1234
< -n=1234
< -n1234
< 
< // mixed
< -abcs "hello"
< -absd="hello"
< -abcs1234
< ```
< 
< Flag parsing stops after the terminator "--". Unlike the flag package,
< flags can be interspersed with arguments anywhere on the command line
< before this terminator.
< 
< Integer flags accept 1234, 0664, 0x1234 and may be negative.
< Boolean flags (in their long form) accept 1, 0, t, f, true, false,
< TRUE, FALSE, True, False.
< Duration flags accept any input valid for time.ParseDuration.
< 
< ## Mutating or "Normalizing" Flag names
< 
< It is possible to set a custom flag name 'normalization function.' It allows flag names to be mutated both when created in the code and when used on the command line to some 'normalized' form. The 'normalized' form is used for comparison. Two examples of using the custom normalization func follow.
< 
< **Example #1**: You want -, _, and . in flags to compare the same. aka --my-flag == --my_flag == --my.flag
< 
< ``` go
< func wordSepNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName {
< 	from := []string{"-", "_"}
< 	to := "."
< 	for _, sep := range from {
< 		name = strings.Replace(name, sep, to, -1)
< 	}
< 	return pflag.NormalizedName(name)
< }
< 
< myFlagSet.SetNormalizeFunc(wordSepNormalizeFunc)
< ```
< 
< **Example #2**: You want to alias two flags. aka --old-flag-name == --new-flag-name
< 
< ``` go
< func aliasNormalizeFunc(f *pflag.FlagSet, name string) pflag.NormalizedName {
< 	switch name {
< 	case "old-flag-name":
< 		name = "new-flag-name"
< 		break
< 	}
< 	return pflag.NormalizedName(name)
< }
< 
< myFlagSet.SetNormalizeFunc(aliasNormalizeFunc)
< ```
< 
< ## Deprecating a flag or its shorthand
< It is possible to deprecate a flag, or just its shorthand. Deprecating a flag/shorthand hides it from help text and prints a usage message when the deprecated flag/shorthand is used.
< 
< **Example #1**: You want to deprecate a flag named "badflag" as well as inform the users what flag they should use instead.
< ```go
< // deprecate a flag by specifying its name and a usage message
< flags.MarkDeprecated("badflag", "please use --good-flag instead")
< ```
< This hides "badflag" from help text, and prints `Flag --badflag has been deprecated, please use --good-flag instead` when "badflag" is used.
< 
< **Example #2**: You want to keep a flag name "noshorthandflag" but deprecate its shortname "n".
< ```go
< // deprecate a flag shorthand by specifying its flag name and a usage message
< flags.MarkShorthandDeprecated("noshorthandflag", "please use --noshorthandflag only")
< ```
< This hides the shortname "n" from help text, and prints `Flag shorthand -n has been deprecated, please use --noshorthandflag only` when the shorthand "n" is used.
< 
< Note that usage message is essential here, and it should not be empty.
< 
< ## Hidden flags
< It is possible to mark a flag as hidden, meaning it will still function as normal, however will not show up in usage/help text.
< 
< **Example**: You have a flag named "secretFlag" that you need for internal use only and don't want it showing up in help text, or for its usage text to be available.
< ```go
< // hide a flag by specifying its name
< flags.MarkHidden("secretFlag")
< ```
< 
< ## Disable sorting of flags
< `pflag` allows you to disable sorting of flags for help and usage message.
< 
< **Example**:
< ```go
< flags.BoolP("verbose", "v", false, "verbose output")
< flags.String("coolflag", "yeaah", "it's really cool flag")
< flags.Int("usefulflag", 777, "sometimes it's very useful")
< flags.SortFlags = false
< flags.PrintDefaults()
< ```
< **Output**:
< ```
<   -v, --verbose           verbose output
<       --coolflag string   it's really cool flag (default "yeaah")
<       --usefulflag int    sometimes it's very useful (default 777)
< ```
< 
< 
< ## Supporting Go flags when using pflag
< In order to support flags defined using Go's `flag` package, they must be added to the `pflag` flagset. This is usually necessary
< to support flags defined by third-party dependencies (e.g. `golang/glog`).
< 
< **Example**: You want to add the Go flags to the `CommandLine` flagset
< ```go
< import (
< 	goflag "flag"
< 	flag "github.com/spf13/pflag"
< )
< 
< var ip *int = flag.Int("flagname", 1234, "help message for flagname")
< 
< func main() {
< 	flag.CommandLine.AddGoFlagSet(goflag.CommandLine)
< 	flag.Parse()
< }
< ```
< 
< ## More info
< 
< You can see the full reference documentation of the pflag package
< [at godoc.org][3], or through go's standard documentation system by
< running `godoc -http=:6060` and browsing to
< [http://localhost:6060/pkg/github.com/spf13/pflag][2] after
< installation.
< 
< [2]: http://localhost:6060/pkg/github.com/spf13/pflag
< [3]: http://godoc.org/github.com/spf13/pflag
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/bool.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/bool.go
1,94d0
< package pflag
< 
< import "strconv"
< 
< // optional interface to indicate boolean flags that can be
< // supplied without "=value" text
< type boolFlag interface {
< 	Value
< 	IsBoolFlag() bool
< }
< 
< // -- bool Value
< type boolValue bool
< 
< func newBoolValue(val bool, p *bool) *boolValue {
< 	*p = val
< 	return (*boolValue)(p)
< }
< 
< func (b *boolValue) Set(s string) error {
< 	v, err := strconv.ParseBool(s)
< 	*b = boolValue(v)
< 	return err
< }
< 
< func (b *boolValue) Type() string {
< 	return "bool"
< }
< 
< func (b *boolValue) String() string { return strconv.FormatBool(bool(*b)) }
< 
< func (b *boolValue) IsBoolFlag() bool { return true }
< 
< func boolConv(sval string) (interface{}, error) {
< 	return strconv.ParseBool(sval)
< }
< 
< // GetBool return the bool value of a flag with the given name
< func (f *FlagSet) GetBool(name string) (bool, error) {
< 	val, err := f.getFlagType(name, "bool", boolConv)
< 	if err != nil {
< 		return false, err
< 	}
< 	return val.(bool), nil
< }
< 
< // BoolVar defines a bool flag with specified name, default value, and usage string.
< // The argument p points to a bool variable in which to store the value of the flag.
< func (f *FlagSet) BoolVar(p *bool, name string, value bool, usage string) {
< 	f.BoolVarP(p, name, "", value, usage)
< }
< 
< // BoolVarP is like BoolVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) BoolVarP(p *bool, name, shorthand string, value bool, usage string) {
< 	flag := f.VarPF(newBoolValue(value, p), name, shorthand, usage)
< 	flag.NoOptDefVal = "true"
< }
< 
< // BoolVar defines a bool flag with specified name, default value, and usage string.
< // The argument p points to a bool variable in which to store the value of the flag.
< func BoolVar(p *bool, name string, value bool, usage string) {
< 	BoolVarP(p, name, "", value, usage)
< }
< 
< // BoolVarP is like BoolVar, but accepts a shorthand letter that can be used after a single dash.
< func BoolVarP(p *bool, name, shorthand string, value bool, usage string) {
< 	flag := CommandLine.VarPF(newBoolValue(value, p), name, shorthand, usage)
< 	flag.NoOptDefVal = "true"
< }
< 
< // Bool defines a bool flag with specified name, default value, and usage string.
< // The return value is the address of a bool variable that stores the value of the flag.
< func (f *FlagSet) Bool(name string, value bool, usage string) *bool {
< 	return f.BoolP(name, "", value, usage)
< }
< 
< // BoolP is like Bool, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) BoolP(name, shorthand string, value bool, usage string) *bool {
< 	p := new(bool)
< 	f.BoolVarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Bool defines a bool flag with specified name, default value, and usage string.
< // The return value is the address of a bool variable that stores the value of the flag.
< func Bool(name string, value bool, usage string) *bool {
< 	return BoolP(name, "", value, usage)
< }
< 
< // BoolP is like Bool, but accepts a shorthand letter that can be used after a single dash.
< func BoolP(name, shorthand string, value bool, usage string) *bool {
< 	b := CommandLine.BoolP(name, shorthand, value, usage)
< 	return b
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/bool_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/bool_slice.go
1,185d0
< package pflag
< 
< import (
< 	"io"
< 	"strconv"
< 	"strings"
< )
< 
< // -- boolSlice Value
< type boolSliceValue struct {
< 	value   *[]bool
< 	changed bool
< }
< 
< func newBoolSliceValue(val []bool, p *[]bool) *boolSliceValue {
< 	bsv := new(boolSliceValue)
< 	bsv.value = p
< 	*bsv.value = val
< 	return bsv
< }
< 
< // Set converts, and assigns, the comma-separated boolean argument string representation as the []bool value of this flag.
< // If Set is called on a flag that already has a []bool assigned, the newly converted values will be appended.
< func (s *boolSliceValue) Set(val string) error {
< 
< 	// remove all quote characters
< 	rmQuote := strings.NewReplacer(`"`, "", `'`, "", "`", "")
< 
< 	// read flag arguments with CSV parser
< 	boolStrSlice, err := readAsCSV(rmQuote.Replace(val))
< 	if err != nil && err != io.EOF {
< 		return err
< 	}
< 
< 	// parse boolean values into slice
< 	out := make([]bool, 0, len(boolStrSlice))
< 	for _, boolStr := range boolStrSlice {
< 		b, err := strconv.ParseBool(strings.TrimSpace(boolStr))
< 		if err != nil {
< 			return err
< 		}
< 		out = append(out, b)
< 	}
< 
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		*s.value = append(*s.value, out...)
< 	}
< 
< 	s.changed = true
< 
< 	return nil
< }
< 
< // Type returns a string that uniquely represents this flag's type.
< func (s *boolSliceValue) Type() string {
< 	return "boolSlice"
< }
< 
< // String defines a "native" format for this boolean slice flag value.
< func (s *boolSliceValue) String() string {
< 
< 	boolStrSlice := make([]string, len(*s.value))
< 	for i, b := range *s.value {
< 		boolStrSlice[i] = strconv.FormatBool(b)
< 	}
< 
< 	out, _ := writeAsCSV(boolStrSlice)
< 
< 	return "[" + out + "]"
< }
< 
< func (s *boolSliceValue) fromString(val string) (bool, error) {
< 	return strconv.ParseBool(val)
< }
< 
< func (s *boolSliceValue) toString(val bool) string {
< 	return strconv.FormatBool(val)
< }
< 
< func (s *boolSliceValue) Append(val string) error {
< 	i, err := s.fromString(val)
< 	if err != nil {
< 		return err
< 	}
< 	*s.value = append(*s.value, i)
< 	return nil
< }
< 
< func (s *boolSliceValue) Replace(val []string) error {
< 	out := make([]bool, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i], err = s.fromString(d)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *boolSliceValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = s.toString(d)
< 	}
< 	return out
< }
< 
< func boolSliceConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// Empty string would cause a slice with one (empty) entry
< 	if len(val) == 0 {
< 		return []bool{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make([]bool, len(ss))
< 	for i, t := range ss {
< 		var err error
< 		out[i], err = strconv.ParseBool(t)
< 		if err != nil {
< 			return nil, err
< 		}
< 	}
< 	return out, nil
< }
< 
< // GetBoolSlice returns the []bool value of a flag with the given name.
< func (f *FlagSet) GetBoolSlice(name string) ([]bool, error) {
< 	val, err := f.getFlagType(name, "boolSlice", boolSliceConv)
< 	if err != nil {
< 		return []bool{}, err
< 	}
< 	return val.([]bool), nil
< }
< 
< // BoolSliceVar defines a boolSlice flag with specified name, default value, and usage string.
< // The argument p points to a []bool variable in which to store the value of the flag.
< func (f *FlagSet) BoolSliceVar(p *[]bool, name string, value []bool, usage string) {
< 	f.VarP(newBoolSliceValue(value, p), name, "", usage)
< }
< 
< // BoolSliceVarP is like BoolSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) BoolSliceVarP(p *[]bool, name, shorthand string, value []bool, usage string) {
< 	f.VarP(newBoolSliceValue(value, p), name, shorthand, usage)
< }
< 
< // BoolSliceVar defines a []bool flag with specified name, default value, and usage string.
< // The argument p points to a []bool variable in which to store the value of the flag.
< func BoolSliceVar(p *[]bool, name string, value []bool, usage string) {
< 	CommandLine.VarP(newBoolSliceValue(value, p), name, "", usage)
< }
< 
< // BoolSliceVarP is like BoolSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func BoolSliceVarP(p *[]bool, name, shorthand string, value []bool, usage string) {
< 	CommandLine.VarP(newBoolSliceValue(value, p), name, shorthand, usage)
< }
< 
< // BoolSlice defines a []bool flag with specified name, default value, and usage string.
< // The return value is the address of a []bool variable that stores the value of the flag.
< func (f *FlagSet) BoolSlice(name string, value []bool, usage string) *[]bool {
< 	p := []bool{}
< 	f.BoolSliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // BoolSliceP is like BoolSlice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) BoolSliceP(name, shorthand string, value []bool, usage string) *[]bool {
< 	p := []bool{}
< 	f.BoolSliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // BoolSlice defines a []bool flag with specified name, default value, and usage string.
< // The return value is the address of a []bool variable that stores the value of the flag.
< func BoolSlice(name string, value []bool, usage string) *[]bool {
< 	return CommandLine.BoolSliceP(name, "", value, usage)
< }
< 
< // BoolSliceP is like BoolSlice, but accepts a shorthand letter that can be used after a single dash.
< func BoolSliceP(name, shorthand string, value []bool, usage string) *[]bool {
< 	return CommandLine.BoolSliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/bytes.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/bytes.go
1,209d0
< package pflag
< 
< import (
< 	"encoding/base64"
< 	"encoding/hex"
< 	"fmt"
< 	"strings"
< )
< 
< // BytesHex adapts []byte for use as a flag. Value of flag is HEX encoded
< type bytesHexValue []byte
< 
< // String implements pflag.Value.String.
< func (bytesHex bytesHexValue) String() string {
< 	return fmt.Sprintf("%X", []byte(bytesHex))
< }
< 
< // Set implements pflag.Value.Set.
< func (bytesHex *bytesHexValue) Set(value string) error {
< 	bin, err := hex.DecodeString(strings.TrimSpace(value))
< 
< 	if err != nil {
< 		return err
< 	}
< 
< 	*bytesHex = bin
< 
< 	return nil
< }
< 
< // Type implements pflag.Value.Type.
< func (*bytesHexValue) Type() string {
< 	return "bytesHex"
< }
< 
< func newBytesHexValue(val []byte, p *[]byte) *bytesHexValue {
< 	*p = val
< 	return (*bytesHexValue)(p)
< }
< 
< func bytesHexConv(sval string) (interface{}, error) {
< 
< 	bin, err := hex.DecodeString(sval)
< 
< 	if err == nil {
< 		return bin, nil
< 	}
< 
< 	return nil, fmt.Errorf("invalid string being converted to Bytes: %s %s", sval, err)
< }
< 
< // GetBytesHex return the []byte value of a flag with the given name
< func (f *FlagSet) GetBytesHex(name string) ([]byte, error) {
< 	val, err := f.getFlagType(name, "bytesHex", bytesHexConv)
< 
< 	if err != nil {
< 		return []byte{}, err
< 	}
< 
< 	return val.([]byte), nil
< }
< 
< // BytesHexVar defines an []byte flag with specified name, default value, and usage string.
< // The argument p points to an []byte variable in which to store the value of the flag.
< func (f *FlagSet) BytesHexVar(p *[]byte, name string, value []byte, usage string) {
< 	f.VarP(newBytesHexValue(value, p), name, "", usage)
< }
< 
< // BytesHexVarP is like BytesHexVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) BytesHexVarP(p *[]byte, name, shorthand string, value []byte, usage string) {
< 	f.VarP(newBytesHexValue(value, p), name, shorthand, usage)
< }
< 
< // BytesHexVar defines an []byte flag with specified name, default value, and usage string.
< // The argument p points to an []byte variable in which to store the value of the flag.
< func BytesHexVar(p *[]byte, name string, value []byte, usage string) {
< 	CommandLine.VarP(newBytesHexValue(value, p), name, "", usage)
< }
< 
< // BytesHexVarP is like BytesHexVar, but accepts a shorthand letter that can be used after a single dash.
< func BytesHexVarP(p *[]byte, name, shorthand string, value []byte, usage string) {
< 	CommandLine.VarP(newBytesHexValue(value, p), name, shorthand, usage)
< }
< 
< // BytesHex defines an []byte flag with specified name, default value, and usage string.
< // The return value is the address of an []byte variable that stores the value of the flag.
< func (f *FlagSet) BytesHex(name string, value []byte, usage string) *[]byte {
< 	p := new([]byte)
< 	f.BytesHexVarP(p, name, "", value, usage)
< 	return p
< }
< 
< // BytesHexP is like BytesHex, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) BytesHexP(name, shorthand string, value []byte, usage string) *[]byte {
< 	p := new([]byte)
< 	f.BytesHexVarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // BytesHex defines an []byte flag with specified name, default value, and usage string.
< // The return value is the address of an []byte variable that stores the value of the flag.
< func BytesHex(name string, value []byte, usage string) *[]byte {
< 	return CommandLine.BytesHexP(name, "", value, usage)
< }
< 
< // BytesHexP is like BytesHex, but accepts a shorthand letter that can be used after a single dash.
< func BytesHexP(name, shorthand string, value []byte, usage string) *[]byte {
< 	return CommandLine.BytesHexP(name, shorthand, value, usage)
< }
< 
< // BytesBase64 adapts []byte for use as a flag. Value of flag is Base64 encoded
< type bytesBase64Value []byte
< 
< // String implements pflag.Value.String.
< func (bytesBase64 bytesBase64Value) String() string {
< 	return base64.StdEncoding.EncodeToString([]byte(bytesBase64))
< }
< 
< // Set implements pflag.Value.Set.
< func (bytesBase64 *bytesBase64Value) Set(value string) error {
< 	bin, err := base64.StdEncoding.DecodeString(strings.TrimSpace(value))
< 
< 	if err != nil {
< 		return err
< 	}
< 
< 	*bytesBase64 = bin
< 
< 	return nil
< }
< 
< // Type implements pflag.Value.Type.
< func (*bytesBase64Value) Type() string {
< 	return "bytesBase64"
< }
< 
< func newBytesBase64Value(val []byte, p *[]byte) *bytesBase64Value {
< 	*p = val
< 	return (*bytesBase64Value)(p)
< }
< 
< func bytesBase64ValueConv(sval string) (interface{}, error) {
< 
< 	bin, err := base64.StdEncoding.DecodeString(sval)
< 	if err == nil {
< 		return bin, nil
< 	}
< 
< 	return nil, fmt.Errorf("invalid string being converted to Bytes: %s %s", sval, err)
< }
< 
< // GetBytesBase64 return the []byte value of a flag with the given name
< func (f *FlagSet) GetBytesBase64(name string) ([]byte, error) {
< 	val, err := f.getFlagType(name, "bytesBase64", bytesBase64ValueConv)
< 
< 	if err != nil {
< 		return []byte{}, err
< 	}
< 
< 	return val.([]byte), nil
< }
< 
< // BytesBase64Var defines an []byte flag with specified name, default value, and usage string.
< // The argument p points to an []byte variable in which to store the value of the flag.
< func (f *FlagSet) BytesBase64Var(p *[]byte, name string, value []byte, usage string) {
< 	f.VarP(newBytesBase64Value(value, p), name, "", usage)
< }
< 
< // BytesBase64VarP is like BytesBase64Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) BytesBase64VarP(p *[]byte, name, shorthand string, value []byte, usage string) {
< 	f.VarP(newBytesBase64Value(value, p), name, shorthand, usage)
< }
< 
< // BytesBase64Var defines an []byte flag with specified name, default value, and usage string.
< // The argument p points to an []byte variable in which to store the value of the flag.
< func BytesBase64Var(p *[]byte, name string, value []byte, usage string) {
< 	CommandLine.VarP(newBytesBase64Value(value, p), name, "", usage)
< }
< 
< // BytesBase64VarP is like BytesBase64Var, but accepts a shorthand letter that can be used after a single dash.
< func BytesBase64VarP(p *[]byte, name, shorthand string, value []byte, usage string) {
< 	CommandLine.VarP(newBytesBase64Value(value, p), name, shorthand, usage)
< }
< 
< // BytesBase64 defines an []byte flag with specified name, default value, and usage string.
< // The return value is the address of an []byte variable that stores the value of the flag.
< func (f *FlagSet) BytesBase64(name string, value []byte, usage string) *[]byte {
< 	p := new([]byte)
< 	f.BytesBase64VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // BytesBase64P is like BytesBase64, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) BytesBase64P(name, shorthand string, value []byte, usage string) *[]byte {
< 	p := new([]byte)
< 	f.BytesBase64VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // BytesBase64 defines an []byte flag with specified name, default value, and usage string.
< // The return value is the address of an []byte variable that stores the value of the flag.
< func BytesBase64(name string, value []byte, usage string) *[]byte {
< 	return CommandLine.BytesBase64P(name, "", value, usage)
< }
< 
< // BytesBase64P is like BytesBase64, but accepts a shorthand letter that can be used after a single dash.
< func BytesBase64P(name, shorthand string, value []byte, usage string) *[]byte {
< 	return CommandLine.BytesBase64P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/count.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/count.go
1,96d0
< package pflag
< 
< import "strconv"
< 
< // -- count Value
< type countValue int
< 
< func newCountValue(val int, p *int) *countValue {
< 	*p = val
< 	return (*countValue)(p)
< }
< 
< func (i *countValue) Set(s string) error {
< 	// "+1" means that no specific value was passed, so increment
< 	if s == "+1" {
< 		*i = countValue(*i + 1)
< 		return nil
< 	}
< 	v, err := strconv.ParseInt(s, 0, 0)
< 	*i = countValue(v)
< 	return err
< }
< 
< func (i *countValue) Type() string {
< 	return "count"
< }
< 
< func (i *countValue) String() string { return strconv.Itoa(int(*i)) }
< 
< func countConv(sval string) (interface{}, error) {
< 	i, err := strconv.Atoi(sval)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return i, nil
< }
< 
< // GetCount return the int value of a flag with the given name
< func (f *FlagSet) GetCount(name string) (int, error) {
< 	val, err := f.getFlagType(name, "count", countConv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(int), nil
< }
< 
< // CountVar defines a count flag with specified name, default value, and usage string.
< // The argument p points to an int variable in which to store the value of the flag.
< // A count flag will add 1 to its value every time it is found on the command line
< func (f *FlagSet) CountVar(p *int, name string, usage string) {
< 	f.CountVarP(p, name, "", usage)
< }
< 
< // CountVarP is like CountVar only take a shorthand for the flag name.
< func (f *FlagSet) CountVarP(p *int, name, shorthand string, usage string) {
< 	flag := f.VarPF(newCountValue(0, p), name, shorthand, usage)
< 	flag.NoOptDefVal = "+1"
< }
< 
< // CountVar like CountVar only the flag is placed on the CommandLine instead of a given flag set
< func CountVar(p *int, name string, usage string) {
< 	CommandLine.CountVar(p, name, usage)
< }
< 
< // CountVarP is like CountVar only take a shorthand for the flag name.
< func CountVarP(p *int, name, shorthand string, usage string) {
< 	CommandLine.CountVarP(p, name, shorthand, usage)
< }
< 
< // Count defines a count flag with specified name, default value, and usage string.
< // The return value is the address of an int variable that stores the value of the flag.
< // A count flag will add 1 to its value every time it is found on the command line
< func (f *FlagSet) Count(name string, usage string) *int {
< 	p := new(int)
< 	f.CountVarP(p, name, "", usage)
< 	return p
< }
< 
< // CountP is like Count only takes a shorthand for the flag name.
< func (f *FlagSet) CountP(name, shorthand string, usage string) *int {
< 	p := new(int)
< 	f.CountVarP(p, name, shorthand, usage)
< 	return p
< }
< 
< // Count defines a count flag with specified name, default value, and usage string.
< // The return value is the address of an int variable that stores the value of the flag.
< // A count flag will add 1 to its value evey time it is found on the command line
< func Count(name string, usage string) *int {
< 	return CommandLine.CountP(name, "", usage)
< }
< 
< // CountP is like Count only takes a shorthand for the flag name.
< func CountP(name, shorthand string, usage string) *int {
< 	return CommandLine.CountP(name, shorthand, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/duration.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/duration.go
1,86d0
< package pflag
< 
< import (
< 	"time"
< )
< 
< // -- time.Duration Value
< type durationValue time.Duration
< 
< func newDurationValue(val time.Duration, p *time.Duration) *durationValue {
< 	*p = val
< 	return (*durationValue)(p)
< }
< 
< func (d *durationValue) Set(s string) error {
< 	v, err := time.ParseDuration(s)
< 	*d = durationValue(v)
< 	return err
< }
< 
< func (d *durationValue) Type() string {
< 	return "duration"
< }
< 
< func (d *durationValue) String() string { return (*time.Duration)(d).String() }
< 
< func durationConv(sval string) (interface{}, error) {
< 	return time.ParseDuration(sval)
< }
< 
< // GetDuration return the duration value of a flag with the given name
< func (f *FlagSet) GetDuration(name string) (time.Duration, error) {
< 	val, err := f.getFlagType(name, "duration", durationConv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(time.Duration), nil
< }
< 
< // DurationVar defines a time.Duration flag with specified name, default value, and usage string.
< // The argument p points to a time.Duration variable in which to store the value of the flag.
< func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string) {
< 	f.VarP(newDurationValue(value, p), name, "", usage)
< }
< 
< // DurationVarP is like DurationVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) DurationVarP(p *time.Duration, name, shorthand string, value time.Duration, usage string) {
< 	f.VarP(newDurationValue(value, p), name, shorthand, usage)
< }
< 
< // DurationVar defines a time.Duration flag with specified name, default value, and usage string.
< // The argument p points to a time.Duration variable in which to store the value of the flag.
< func DurationVar(p *time.Duration, name string, value time.Duration, usage string) {
< 	CommandLine.VarP(newDurationValue(value, p), name, "", usage)
< }
< 
< // DurationVarP is like DurationVar, but accepts a shorthand letter that can be used after a single dash.
< func DurationVarP(p *time.Duration, name, shorthand string, value time.Duration, usage string) {
< 	CommandLine.VarP(newDurationValue(value, p), name, shorthand, usage)
< }
< 
< // Duration defines a time.Duration flag with specified name, default value, and usage string.
< // The return value is the address of a time.Duration variable that stores the value of the flag.
< func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration {
< 	p := new(time.Duration)
< 	f.DurationVarP(p, name, "", value, usage)
< 	return p
< }
< 
< // DurationP is like Duration, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) DurationP(name, shorthand string, value time.Duration, usage string) *time.Duration {
< 	p := new(time.Duration)
< 	f.DurationVarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Duration defines a time.Duration flag with specified name, default value, and usage string.
< // The return value is the address of a time.Duration variable that stores the value of the flag.
< func Duration(name string, value time.Duration, usage string) *time.Duration {
< 	return CommandLine.DurationP(name, "", value, usage)
< }
< 
< // DurationP is like Duration, but accepts a shorthand letter that can be used after a single dash.
< func DurationP(name, shorthand string, value time.Duration, usage string) *time.Duration {
< 	return CommandLine.DurationP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/duration_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/duration_slice.go
1,166d0
< package pflag
< 
< import (
< 	"fmt"
< 	"strings"
< 	"time"
< )
< 
< // -- durationSlice Value
< type durationSliceValue struct {
< 	value   *[]time.Duration
< 	changed bool
< }
< 
< func newDurationSliceValue(val []time.Duration, p *[]time.Duration) *durationSliceValue {
< 	dsv := new(durationSliceValue)
< 	dsv.value = p
< 	*dsv.value = val
< 	return dsv
< }
< 
< func (s *durationSliceValue) Set(val string) error {
< 	ss := strings.Split(val, ",")
< 	out := make([]time.Duration, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		out[i], err = time.ParseDuration(d)
< 		if err != nil {
< 			return err
< 		}
< 
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		*s.value = append(*s.value, out...)
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *durationSliceValue) Type() string {
< 	return "durationSlice"
< }
< 
< func (s *durationSliceValue) String() string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = fmt.Sprintf("%s", d)
< 	}
< 	return "[" + strings.Join(out, ",") + "]"
< }
< 
< func (s *durationSliceValue) fromString(val string) (time.Duration, error) {
< 	return time.ParseDuration(val)
< }
< 
< func (s *durationSliceValue) toString(val time.Duration) string {
< 	return fmt.Sprintf("%s", val)
< }
< 
< func (s *durationSliceValue) Append(val string) error {
< 	i, err := s.fromString(val)
< 	if err != nil {
< 		return err
< 	}
< 	*s.value = append(*s.value, i)
< 	return nil
< }
< 
< func (s *durationSliceValue) Replace(val []string) error {
< 	out := make([]time.Duration, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i], err = s.fromString(d)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *durationSliceValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = s.toString(d)
< 	}
< 	return out
< }
< 
< func durationSliceConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// Empty string would cause a slice with one (empty) entry
< 	if len(val) == 0 {
< 		return []time.Duration{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make([]time.Duration, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		out[i], err = time.ParseDuration(d)
< 		if err != nil {
< 			return nil, err
< 		}
< 
< 	}
< 	return out, nil
< }
< 
< // GetDurationSlice returns the []time.Duration value of a flag with the given name
< func (f *FlagSet) GetDurationSlice(name string) ([]time.Duration, error) {
< 	val, err := f.getFlagType(name, "durationSlice", durationSliceConv)
< 	if err != nil {
< 		return []time.Duration{}, err
< 	}
< 	return val.([]time.Duration), nil
< }
< 
< // DurationSliceVar defines a durationSlice flag with specified name, default value, and usage string.
< // The argument p points to a []time.Duration variable in which to store the value of the flag.
< func (f *FlagSet) DurationSliceVar(p *[]time.Duration, name string, value []time.Duration, usage string) {
< 	f.VarP(newDurationSliceValue(value, p), name, "", usage)
< }
< 
< // DurationSliceVarP is like DurationSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) DurationSliceVarP(p *[]time.Duration, name, shorthand string, value []time.Duration, usage string) {
< 	f.VarP(newDurationSliceValue(value, p), name, shorthand, usage)
< }
< 
< // DurationSliceVar defines a duration[] flag with specified name, default value, and usage string.
< // The argument p points to a duration[] variable in which to store the value of the flag.
< func DurationSliceVar(p *[]time.Duration, name string, value []time.Duration, usage string) {
< 	CommandLine.VarP(newDurationSliceValue(value, p), name, "", usage)
< }
< 
< // DurationSliceVarP is like DurationSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func DurationSliceVarP(p *[]time.Duration, name, shorthand string, value []time.Duration, usage string) {
< 	CommandLine.VarP(newDurationSliceValue(value, p), name, shorthand, usage)
< }
< 
< // DurationSlice defines a []time.Duration flag with specified name, default value, and usage string.
< // The return value is the address of a []time.Duration variable that stores the value of the flag.
< func (f *FlagSet) DurationSlice(name string, value []time.Duration, usage string) *[]time.Duration {
< 	p := []time.Duration{}
< 	f.DurationSliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // DurationSliceP is like DurationSlice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) DurationSliceP(name, shorthand string, value []time.Duration, usage string) *[]time.Duration {
< 	p := []time.Duration{}
< 	f.DurationSliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // DurationSlice defines a []time.Duration flag with specified name, default value, and usage string.
< // The return value is the address of a []time.Duration variable that stores the value of the flag.
< func DurationSlice(name string, value []time.Duration, usage string) *[]time.Duration {
< 	return CommandLine.DurationSliceP(name, "", value, usage)
< }
< 
< // DurationSliceP is like DurationSlice, but accepts a shorthand letter that can be used after a single dash.
< func DurationSliceP(name, shorthand string, value []time.Duration, usage string) *[]time.Duration {
< 	return CommandLine.DurationSliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/flag.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/flag.go
1,1239d0
< // Copyright 2009 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< /*
< Package pflag is a drop-in replacement for Go's flag package, implementing
< POSIX/GNU-style --flags.
< 
< pflag is compatible with the GNU extensions to the POSIX recommendations
< for command-line options. See
< http://www.gnu.org/software/libc/manual/html_node/Argument-Syntax.html
< 
< Usage:
< 
< pflag is a drop-in replacement of Go's native flag package. If you import
< pflag under the name "flag" then all code should continue to function
< with no changes.
< 
< 	import flag "github.com/spf13/pflag"
< 
< There is one exception to this: if you directly instantiate the Flag struct
< there is one more field "Shorthand" that you will need to set.
< Most code never instantiates this struct directly, and instead uses
< functions such as String(), BoolVar(), and Var(), and is therefore
< unaffected.
< 
< Define flags using flag.String(), Bool(), Int(), etc.
< 
< This declares an integer flag, -flagname, stored in the pointer ip, with type *int.
< 	var ip = flag.Int("flagname", 1234, "help message for flagname")
< If you like, you can bind the flag to a variable using the Var() functions.
< 	var flagvar int
< 	func init() {
< 		flag.IntVar(&flagvar, "flagname", 1234, "help message for flagname")
< 	}
< Or you can create custom flags that satisfy the Value interface (with
< pointer receivers) and couple them to flag parsing by
< 	flag.Var(&flagVal, "name", "help message for flagname")
< For such flags, the default value is just the initial value of the variable.
< 
< After all flags are defined, call
< 	flag.Parse()
< to parse the command line into the defined flags.
< 
< Flags may then be used directly. If you're using the flags themselves,
< they are all pointers; if you bind to variables, they're values.
< 	fmt.Println("ip has value ", *ip)
< 	fmt.Println("flagvar has value ", flagvar)
< 
< After parsing, the arguments after the flag are available as the
< slice flag.Args() or individually as flag.Arg(i).
< The arguments are indexed from 0 through flag.NArg()-1.
< 
< The pflag package also defines some new functions that are not in flag,
< that give one-letter shorthands for flags. You can use these by appending
< 'P' to the name of any function that defines a flag.
< 	var ip = flag.IntP("flagname", "f", 1234, "help message")
< 	var flagvar bool
< 	func init() {
< 		flag.BoolVarP(&flagvar, "boolname", "b", true, "help message")
< 	}
< 	flag.VarP(&flagval, "varname", "v", "help message")
< Shorthand letters can be used with single dashes on the command line.
< Boolean shorthand flags can be combined with other shorthand flags.
< 
< Command line flag syntax:
< 	--flag    // boolean flags only
< 	--flag=x
< 
< Unlike the flag package, a single dash before an option means something
< different than a double dash. Single dashes signify a series of shorthand
< letters for flags. All but the last shorthand letter must be boolean flags.
< 	// boolean flags
< 	-f
< 	-abc
< 	// non-boolean flags
< 	-n 1234
< 	-Ifile
< 	// mixed
< 	-abcs "hello"
< 	-abcn1234
< 
< Flag parsing stops after the terminator "--". Unlike the flag package,
< flags can be interspersed with arguments anywhere on the command line
< before this terminator.
< 
< Integer flags accept 1234, 0664, 0x1234 and may be negative.
< Boolean flags (in their long form) accept 1, 0, t, f, true, false,
< TRUE, FALSE, True, False.
< Duration flags accept any input valid for time.ParseDuration.
< 
< The default set of command-line flags is controlled by
< top-level functions.  The FlagSet type allows one to define
< independent sets of flags, such as to implement subcommands
< in a command-line interface. The methods of FlagSet are
< analogous to the top-level functions for the command-line
< flag set.
< */
< package pflag
< 
< import (
< 	"bytes"
< 	"errors"
< 	goflag "flag"
< 	"fmt"
< 	"io"
< 	"os"
< 	"sort"
< 	"strings"
< )
< 
< // ErrHelp is the error returned if the flag -help is invoked but no such flag is defined.
< var ErrHelp = errors.New("pflag: help requested")
< 
< // ErrorHandling defines how to handle flag parsing errors.
< type ErrorHandling int
< 
< const (
< 	// ContinueOnError will return an err from Parse() if an error is found
< 	ContinueOnError ErrorHandling = iota
< 	// ExitOnError will call os.Exit(2) if an error is found when parsing
< 	ExitOnError
< 	// PanicOnError will panic() if an error is found when parsing flags
< 	PanicOnError
< )
< 
< // ParseErrorsWhitelist defines the parsing errors that can be ignored
< type ParseErrorsWhitelist struct {
< 	// UnknownFlags will ignore unknown flags errors and continue parsing rest of the flags
< 	UnknownFlags bool
< }
< 
< // NormalizedName is a flag name that has been normalized according to rules
< // for the FlagSet (e.g. making '-' and '_' equivalent).
< type NormalizedName string
< 
< // A FlagSet represents a set of defined flags.
< type FlagSet struct {
< 	// Usage is the function called when an error occurs while parsing flags.
< 	// The field is a function (not a method) that may be changed to point to
< 	// a custom error handler.
< 	Usage func()
< 
< 	// SortFlags is used to indicate, if user wants to have sorted flags in
< 	// help/usage messages.
< 	SortFlags bool
< 
< 	// ParseErrorsWhitelist is used to configure a whitelist of errors
< 	ParseErrorsWhitelist ParseErrorsWhitelist
< 
< 	name              string
< 	parsed            bool
< 	actual            map[NormalizedName]*Flag
< 	orderedActual     []*Flag
< 	sortedActual      []*Flag
< 	formal            map[NormalizedName]*Flag
< 	orderedFormal     []*Flag
< 	sortedFormal      []*Flag
< 	shorthands        map[byte]*Flag
< 	args              []string // arguments after flags
< 	argsLenAtDash     int      // len(args) when a '--' was located when parsing, or -1 if no --
< 	errorHandling     ErrorHandling
< 	output            io.Writer // nil means stderr; use out() accessor
< 	interspersed      bool      // allow interspersed option/non-option args
< 	normalizeNameFunc func(f *FlagSet, name string) NormalizedName
< 
< 	addedGoFlagSets []*goflag.FlagSet
< }
< 
< // A Flag represents the state of a flag.
< type Flag struct {
< 	Name                string              // name as it appears on command line
< 	Shorthand           string              // one-letter abbreviated flag
< 	Usage               string              // help message
< 	Value               Value               // value as set
< 	DefValue            string              // default value (as text); for usage message
< 	Changed             bool                // If the user set the value (or if left to default)
< 	NoOptDefVal         string              // default value (as text); if the flag is on the command line without any options
< 	Deprecated          string              // If this flag is deprecated, this string is the new or now thing to use
< 	Hidden              bool                // used by cobra.Command to allow flags to be hidden from help/usage text
< 	ShorthandDeprecated string              // If the shorthand of this flag is deprecated, this string is the new or now thing to use
< 	Annotations         map[string][]string // used by cobra.Command bash autocomple code
< }
< 
< // Value is the interface to the dynamic value stored in a flag.
< // (The default value is represented as a string.)
< type Value interface {
< 	String() string
< 	Set(string) error
< 	Type() string
< }
< 
< // SliceValue is a secondary interface to all flags which hold a list
< // of values.  This allows full control over the value of list flags,
< // and avoids complicated marshalling and unmarshalling to csv.
< type SliceValue interface {
< 	// Append adds the specified value to the end of the flag value list.
< 	Append(string) error
< 	// Replace will fully overwrite any data currently in the flag value list.
< 	Replace([]string) error
< 	// GetSlice returns the flag value list as an array of strings.
< 	GetSlice() []string
< }
< 
< // sortFlags returns the flags as a slice in lexicographical sorted order.
< func sortFlags(flags map[NormalizedName]*Flag) []*Flag {
< 	list := make(sort.StringSlice, len(flags))
< 	i := 0
< 	for k := range flags {
< 		list[i] = string(k)
< 		i++
< 	}
< 	list.Sort()
< 	result := make([]*Flag, len(list))
< 	for i, name := range list {
< 		result[i] = flags[NormalizedName(name)]
< 	}
< 	return result
< }
< 
< // SetNormalizeFunc allows you to add a function which can translate flag names.
< // Flags added to the FlagSet will be translated and then when anything tries to
< // look up the flag that will also be translated. So it would be possible to create
< // a flag named "getURL" and have it translated to "geturl".  A user could then pass
< // "--getUrl" which may also be translated to "geturl" and everything will work.
< func (f *FlagSet) SetNormalizeFunc(n func(f *FlagSet, name string) NormalizedName) {
< 	f.normalizeNameFunc = n
< 	f.sortedFormal = f.sortedFormal[:0]
< 	for fname, flag := range f.formal {
< 		nname := f.normalizeFlagName(flag.Name)
< 		if fname == nname {
< 			continue
< 		}
< 		flag.Name = string(nname)
< 		delete(f.formal, fname)
< 		f.formal[nname] = flag
< 		if _, set := f.actual[fname]; set {
< 			delete(f.actual, fname)
< 			f.actual[nname] = flag
< 		}
< 	}
< }
< 
< // GetNormalizeFunc returns the previously set NormalizeFunc of a function which
< // does no translation, if not set previously.
< func (f *FlagSet) GetNormalizeFunc() func(f *FlagSet, name string) NormalizedName {
< 	if f.normalizeNameFunc != nil {
< 		return f.normalizeNameFunc
< 	}
< 	return func(f *FlagSet, name string) NormalizedName { return NormalizedName(name) }
< }
< 
< func (f *FlagSet) normalizeFlagName(name string) NormalizedName {
< 	n := f.GetNormalizeFunc()
< 	return n(f, name)
< }
< 
< func (f *FlagSet) out() io.Writer {
< 	if f.output == nil {
< 		return os.Stderr
< 	}
< 	return f.output
< }
< 
< // SetOutput sets the destination for usage and error messages.
< // If output is nil, os.Stderr is used.
< func (f *FlagSet) SetOutput(output io.Writer) {
< 	f.output = output
< }
< 
< // VisitAll visits the flags in lexicographical order or
< // in primordial order if f.SortFlags is false, calling fn for each.
< // It visits all flags, even those not set.
< func (f *FlagSet) VisitAll(fn func(*Flag)) {
< 	if len(f.formal) == 0 {
< 		return
< 	}
< 
< 	var flags []*Flag
< 	if f.SortFlags {
< 		if len(f.formal) != len(f.sortedFormal) {
< 			f.sortedFormal = sortFlags(f.formal)
< 		}
< 		flags = f.sortedFormal
< 	} else {
< 		flags = f.orderedFormal
< 	}
< 
< 	for _, flag := range flags {
< 		fn(flag)
< 	}
< }
< 
< // HasFlags returns a bool to indicate if the FlagSet has any flags defined.
< func (f *FlagSet) HasFlags() bool {
< 	return len(f.formal) > 0
< }
< 
< // HasAvailableFlags returns a bool to indicate if the FlagSet has any flags
< // that are not hidden.
< func (f *FlagSet) HasAvailableFlags() bool {
< 	for _, flag := range f.formal {
< 		if !flag.Hidden {
< 			return true
< 		}
< 	}
< 	return false
< }
< 
< // VisitAll visits the command-line flags in lexicographical order or
< // in primordial order if f.SortFlags is false, calling fn for each.
< // It visits all flags, even those not set.
< func VisitAll(fn func(*Flag)) {
< 	CommandLine.VisitAll(fn)
< }
< 
< // Visit visits the flags in lexicographical order or
< // in primordial order if f.SortFlags is false, calling fn for each.
< // It visits only those flags that have been set.
< func (f *FlagSet) Visit(fn func(*Flag)) {
< 	if len(f.actual) == 0 {
< 		return
< 	}
< 
< 	var flags []*Flag
< 	if f.SortFlags {
< 		if len(f.actual) != len(f.sortedActual) {
< 			f.sortedActual = sortFlags(f.actual)
< 		}
< 		flags = f.sortedActual
< 	} else {
< 		flags = f.orderedActual
< 	}
< 
< 	for _, flag := range flags {
< 		fn(flag)
< 	}
< }
< 
< // Visit visits the command-line flags in lexicographical order or
< // in primordial order if f.SortFlags is false, calling fn for each.
< // It visits only those flags that have been set.
< func Visit(fn func(*Flag)) {
< 	CommandLine.Visit(fn)
< }
< 
< // Lookup returns the Flag structure of the named flag, returning nil if none exists.
< func (f *FlagSet) Lookup(name string) *Flag {
< 	return f.lookup(f.normalizeFlagName(name))
< }
< 
< // ShorthandLookup returns the Flag structure of the short handed flag,
< // returning nil if none exists.
< // It panics, if len(name) > 1.
< func (f *FlagSet) ShorthandLookup(name string) *Flag {
< 	if name == "" {
< 		return nil
< 	}
< 	if len(name) > 1 {
< 		msg := fmt.Sprintf("can not look up shorthand which is more than one ASCII character: %q", name)
< 		fmt.Fprintf(f.out(), msg)
< 		panic(msg)
< 	}
< 	c := name[0]
< 	return f.shorthands[c]
< }
< 
< // lookup returns the Flag structure of the named flag, returning nil if none exists.
< func (f *FlagSet) lookup(name NormalizedName) *Flag {
< 	return f.formal[name]
< }
< 
< // func to return a given type for a given flag name
< func (f *FlagSet) getFlagType(name string, ftype string, convFunc func(sval string) (interface{}, error)) (interface{}, error) {
< 	flag := f.Lookup(name)
< 	if flag == nil {
< 		err := fmt.Errorf("flag accessed but not defined: %s", name)
< 		return nil, err
< 	}
< 
< 	if flag.Value.Type() != ftype {
< 		err := fmt.Errorf("trying to get %s value of flag of type %s", ftype, flag.Value.Type())
< 		return nil, err
< 	}
< 
< 	sval := flag.Value.String()
< 	result, err := convFunc(sval)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return result, nil
< }
< 
< // ArgsLenAtDash will return the length of f.Args at the moment when a -- was
< // found during arg parsing. This allows your program to know which args were
< // before the -- and which came after.
< func (f *FlagSet) ArgsLenAtDash() int {
< 	return f.argsLenAtDash
< }
< 
< // MarkDeprecated indicated that a flag is deprecated in your program. It will
< // continue to function but will not show up in help or usage messages. Using
< // this flag will also print the given usageMessage.
< func (f *FlagSet) MarkDeprecated(name string, usageMessage string) error {
< 	flag := f.Lookup(name)
< 	if flag == nil {
< 		return fmt.Errorf("flag %q does not exist", name)
< 	}
< 	if usageMessage == "" {
< 		return fmt.Errorf("deprecated message for flag %q must be set", name)
< 	}
< 	flag.Deprecated = usageMessage
< 	flag.Hidden = true
< 	return nil
< }
< 
< // MarkShorthandDeprecated will mark the shorthand of a flag deprecated in your
< // program. It will continue to function but will not show up in help or usage
< // messages. Using this flag will also print the given usageMessage.
< func (f *FlagSet) MarkShorthandDeprecated(name string, usageMessage string) error {
< 	flag := f.Lookup(name)
< 	if flag == nil {
< 		return fmt.Errorf("flag %q does not exist", name)
< 	}
< 	if usageMessage == "" {
< 		return fmt.Errorf("deprecated message for flag %q must be set", name)
< 	}
< 	flag.ShorthandDeprecated = usageMessage
< 	return nil
< }
< 
< // MarkHidden sets a flag to 'hidden' in your program. It will continue to
< // function but will not show up in help or usage messages.
< func (f *FlagSet) MarkHidden(name string) error {
< 	flag := f.Lookup(name)
< 	if flag == nil {
< 		return fmt.Errorf("flag %q does not exist", name)
< 	}
< 	flag.Hidden = true
< 	return nil
< }
< 
< // Lookup returns the Flag structure of the named command-line flag,
< // returning nil if none exists.
< func Lookup(name string) *Flag {
< 	return CommandLine.Lookup(name)
< }
< 
< // ShorthandLookup returns the Flag structure of the short handed flag,
< // returning nil if none exists.
< func ShorthandLookup(name string) *Flag {
< 	return CommandLine.ShorthandLookup(name)
< }
< 
< // Set sets the value of the named flag.
< func (f *FlagSet) Set(name, value string) error {
< 	normalName := f.normalizeFlagName(name)
< 	flag, ok := f.formal[normalName]
< 	if !ok {
< 		return fmt.Errorf("no such flag -%v", name)
< 	}
< 
< 	err := flag.Value.Set(value)
< 	if err != nil {
< 		var flagName string
< 		if flag.Shorthand != "" && flag.ShorthandDeprecated == "" {
< 			flagName = fmt.Sprintf("-%s, --%s", flag.Shorthand, flag.Name)
< 		} else {
< 			flagName = fmt.Sprintf("--%s", flag.Name)
< 		}
< 		return fmt.Errorf("invalid argument %q for %q flag: %v", value, flagName, err)
< 	}
< 
< 	if !flag.Changed {
< 		if f.actual == nil {
< 			f.actual = make(map[NormalizedName]*Flag)
< 		}
< 		f.actual[normalName] = flag
< 		f.orderedActual = append(f.orderedActual, flag)
< 
< 		flag.Changed = true
< 	}
< 
< 	if flag.Deprecated != "" {
< 		fmt.Fprintf(f.out(), "Flag --%s has been deprecated, %s\n", flag.Name, flag.Deprecated)
< 	}
< 	return nil
< }
< 
< // SetAnnotation allows one to set arbitrary annotations on a flag in the FlagSet.
< // This is sometimes used by spf13/cobra programs which want to generate additional
< // bash completion information.
< func (f *FlagSet) SetAnnotation(name, key string, values []string) error {
< 	normalName := f.normalizeFlagName(name)
< 	flag, ok := f.formal[normalName]
< 	if !ok {
< 		return fmt.Errorf("no such flag -%v", name)
< 	}
< 	if flag.Annotations == nil {
< 		flag.Annotations = map[string][]string{}
< 	}
< 	flag.Annotations[key] = values
< 	return nil
< }
< 
< // Changed returns true if the flag was explicitly set during Parse() and false
< // otherwise
< func (f *FlagSet) Changed(name string) bool {
< 	flag := f.Lookup(name)
< 	// If a flag doesn't exist, it wasn't changed....
< 	if flag == nil {
< 		return false
< 	}
< 	return flag.Changed
< }
< 
< // Set sets the value of the named command-line flag.
< func Set(name, value string) error {
< 	return CommandLine.Set(name, value)
< }
< 
< // PrintDefaults prints, to standard error unless configured
< // otherwise, the default values of all defined flags in the set.
< func (f *FlagSet) PrintDefaults() {
< 	usages := f.FlagUsages()
< 	fmt.Fprint(f.out(), usages)
< }
< 
< // defaultIsZeroValue returns true if the default value for this flag represents
< // a zero value.
< func (f *Flag) defaultIsZeroValue() bool {
< 	switch f.Value.(type) {
< 	case boolFlag:
< 		return f.DefValue == "false"
< 	case *durationValue:
< 		// Beginning in Go 1.7, duration zero values are "0s"
< 		return f.DefValue == "0" || f.DefValue == "0s"
< 	case *intValue, *int8Value, *int32Value, *int64Value, *uintValue, *uint8Value, *uint16Value, *uint32Value, *uint64Value, *countValue, *float32Value, *float64Value:
< 		return f.DefValue == "0"
< 	case *stringValue:
< 		return f.DefValue == ""
< 	case *ipValue, *ipMaskValue, *ipNetValue:
< 		return f.DefValue == "<nil>"
< 	case *intSliceValue, *stringSliceValue, *stringArrayValue:
< 		return f.DefValue == "[]"
< 	default:
< 		switch f.Value.String() {
< 		case "false":
< 			return true
< 		case "<nil>":
< 			return true
< 		case "":
< 			return true
< 		case "0":
< 			return true
< 		}
< 		return false
< 	}
< }
< 
< // UnquoteUsage extracts a back-quoted name from the usage
< // string for a flag and returns it and the un-quoted usage.
< // Given "a `name` to show" it returns ("name", "a name to show").
< // If there are no back quotes, the name is an educated guess of the
< // type of the flag's value, or the empty string if the flag is boolean.
< func UnquoteUsage(flag *Flag) (name string, usage string) {
< 	// Look for a back-quoted name, but avoid the strings package.
< 	usage = flag.Usage
< 	for i := 0; i < len(usage); i++ {
< 		if usage[i] == '`' {
< 			for j := i + 1; j < len(usage); j++ {
< 				if usage[j] == '`' {
< 					name = usage[i+1 : j]
< 					usage = usage[:i] + name + usage[j+1:]
< 					return name, usage
< 				}
< 			}
< 			break // Only one back quote; use type name.
< 		}
< 	}
< 
< 	name = flag.Value.Type()
< 	switch name {
< 	case "bool":
< 		name = ""
< 	case "float64":
< 		name = "float"
< 	case "int64":
< 		name = "int"
< 	case "uint64":
< 		name = "uint"
< 	case "stringSlice":
< 		name = "strings"
< 	case "intSlice":
< 		name = "ints"
< 	case "uintSlice":
< 		name = "uints"
< 	case "boolSlice":
< 		name = "bools"
< 	}
< 
< 	return
< }
< 
< // Splits the string `s` on whitespace into an initial substring up to
< // `i` runes in length and the remainder. Will go `slop` over `i` if
< // that encompasses the entire string (which allows the caller to
< // avoid short orphan words on the final line).
< func wrapN(i, slop int, s string) (string, string) {
< 	if i+slop > len(s) {
< 		return s, ""
< 	}
< 
< 	w := strings.LastIndexAny(s[:i], " \t\n")
< 	if w <= 0 {
< 		return s, ""
< 	}
< 	nlPos := strings.LastIndex(s[:i], "\n")
< 	if nlPos > 0 && nlPos < w {
< 		return s[:nlPos], s[nlPos+1:]
< 	}
< 	return s[:w], s[w+1:]
< }
< 
< // Wraps the string `s` to a maximum width `w` with leading indent
< // `i`. The first line is not indented (this is assumed to be done by
< // caller). Pass `w` == 0 to do no wrapping
< func wrap(i, w int, s string) string {
< 	if w == 0 {
< 		return strings.Replace(s, "\n", "\n"+strings.Repeat(" ", i), -1)
< 	}
< 
< 	// space between indent i and end of line width w into which
< 	// we should wrap the text.
< 	wrap := w - i
< 
< 	var r, l string
< 
< 	// Not enough space for sensible wrapping. Wrap as a block on
< 	// the next line instead.
< 	if wrap < 24 {
< 		i = 16
< 		wrap = w - i
< 		r += "\n" + strings.Repeat(" ", i)
< 	}
< 	// If still not enough space then don't even try to wrap.
< 	if wrap < 24 {
< 		return strings.Replace(s, "\n", r, -1)
< 	}
< 
< 	// Try to avoid short orphan words on the final line, by
< 	// allowing wrapN to go a bit over if that would fit in the
< 	// remainder of the line.
< 	slop := 5
< 	wrap = wrap - slop
< 
< 	// Handle first line, which is indented by the caller (or the
< 	// special case above)
< 	l, s = wrapN(wrap, slop, s)
< 	r = r + strings.Replace(l, "\n", "\n"+strings.Repeat(" ", i), -1)
< 
< 	// Now wrap the rest
< 	for s != "" {
< 		var t string
< 
< 		t, s = wrapN(wrap, slop, s)
< 		r = r + "\n" + strings.Repeat(" ", i) + strings.Replace(t, "\n", "\n"+strings.Repeat(" ", i), -1)
< 	}
< 
< 	return r
< 
< }
< 
< // FlagUsagesWrapped returns a string containing the usage information
< // for all flags in the FlagSet. Wrapped to `cols` columns (0 for no
< // wrapping)
< func (f *FlagSet) FlagUsagesWrapped(cols int) string {
< 	buf := new(bytes.Buffer)
< 
< 	lines := make([]string, 0, len(f.formal))
< 
< 	maxlen := 0
< 	f.VisitAll(func(flag *Flag) {
< 		if flag.Hidden {
< 			return
< 		}
< 
< 		line := ""
< 		if flag.Shorthand != "" && flag.ShorthandDeprecated == "" {
< 			line = fmt.Sprintf("  -%s, --%s", flag.Shorthand, flag.Name)
< 		} else {
< 			line = fmt.Sprintf("      --%s", flag.Name)
< 		}
< 
< 		varname, usage := UnquoteUsage(flag)
< 		if varname != "" {
< 			line += " " + varname
< 		}
< 		if flag.NoOptDefVal != "" {
< 			switch flag.Value.Type() {
< 			case "string":
< 				line += fmt.Sprintf("[=\"%s\"]", flag.NoOptDefVal)
< 			case "bool":
< 				if flag.NoOptDefVal != "true" {
< 					line += fmt.Sprintf("[=%s]", flag.NoOptDefVal)
< 				}
< 			case "count":
< 				if flag.NoOptDefVal != "+1" {
< 					line += fmt.Sprintf("[=%s]", flag.NoOptDefVal)
< 				}
< 			default:
< 				line += fmt.Sprintf("[=%s]", flag.NoOptDefVal)
< 			}
< 		}
< 
< 		// This special character will be replaced with spacing once the
< 		// correct alignment is calculated
< 		line += "\x00"
< 		if len(line) > maxlen {
< 			maxlen = len(line)
< 		}
< 
< 		line += usage
< 		if !flag.defaultIsZeroValue() {
< 			if flag.Value.Type() == "string" {
< 				line += fmt.Sprintf(" (default %q)", flag.DefValue)
< 			} else {
< 				line += fmt.Sprintf(" (default %s)", flag.DefValue)
< 			}
< 		}
< 		if len(flag.Deprecated) != 0 {
< 			line += fmt.Sprintf(" (DEPRECATED: %s)", flag.Deprecated)
< 		}
< 
< 		lines = append(lines, line)
< 	})
< 
< 	for _, line := range lines {
< 		sidx := strings.Index(line, "\x00")
< 		spacing := strings.Repeat(" ", maxlen-sidx)
< 		// maxlen + 2 comes from + 1 for the \x00 and + 1 for the (deliberate) off-by-one in maxlen-sidx
< 		fmt.Fprintln(buf, line[:sidx], spacing, wrap(maxlen+2, cols, line[sidx+1:]))
< 	}
< 
< 	return buf.String()
< }
< 
< // FlagUsages returns a string containing the usage information for all flags in
< // the FlagSet
< func (f *FlagSet) FlagUsages() string {
< 	return f.FlagUsagesWrapped(0)
< }
< 
< // PrintDefaults prints to standard error the default values of all defined command-line flags.
< func PrintDefaults() {
< 	CommandLine.PrintDefaults()
< }
< 
< // defaultUsage is the default function to print a usage message.
< func defaultUsage(f *FlagSet) {
< 	fmt.Fprintf(f.out(), "Usage of %s:\n", f.name)
< 	f.PrintDefaults()
< }
< 
< // NOTE: Usage is not just defaultUsage(CommandLine)
< // because it serves (via godoc flag Usage) as the example
< // for how to write your own usage function.
< 
< // Usage prints to standard error a usage message documenting all defined command-line flags.
< // The function is a variable that may be changed to point to a custom function.
< // By default it prints a simple header and calls PrintDefaults; for details about the
< // format of the output and how to control it, see the documentation for PrintDefaults.
< var Usage = func() {
< 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", os.Args[0])
< 	PrintDefaults()
< }
< 
< // NFlag returns the number of flags that have been set.
< func (f *FlagSet) NFlag() int { return len(f.actual) }
< 
< // NFlag returns the number of command-line flags that have been set.
< func NFlag() int { return len(CommandLine.actual) }
< 
< // Arg returns the i'th argument.  Arg(0) is the first remaining argument
< // after flags have been processed.
< func (f *FlagSet) Arg(i int) string {
< 	if i < 0 || i >= len(f.args) {
< 		return ""
< 	}
< 	return f.args[i]
< }
< 
< // Arg returns the i'th command-line argument.  Arg(0) is the first remaining argument
< // after flags have been processed.
< func Arg(i int) string {
< 	return CommandLine.Arg(i)
< }
< 
< // NArg is the number of arguments remaining after flags have been processed.
< func (f *FlagSet) NArg() int { return len(f.args) }
< 
< // NArg is the number of arguments remaining after flags have been processed.
< func NArg() int { return len(CommandLine.args) }
< 
< // Args returns the non-flag arguments.
< func (f *FlagSet) Args() []string { return f.args }
< 
< // Args returns the non-flag command-line arguments.
< func Args() []string { return CommandLine.args }
< 
< // Var defines a flag with the specified name and usage string. The type and
< // value of the flag are represented by the first argument, of type Value, which
< // typically holds a user-defined implementation of Value. For instance, the
< // caller could create a flag that turns a comma-separated string into a slice
< // of strings by giving the slice the methods of Value; in particular, Set would
< // decompose the comma-separated string into the slice.
< func (f *FlagSet) Var(value Value, name string, usage string) {
< 	f.VarP(value, name, "", usage)
< }
< 
< // VarPF is like VarP, but returns the flag created
< func (f *FlagSet) VarPF(value Value, name, shorthand, usage string) *Flag {
< 	// Remember the default value as a string; it won't change.
< 	flag := &Flag{
< 		Name:      name,
< 		Shorthand: shorthand,
< 		Usage:     usage,
< 		Value:     value,
< 		DefValue:  value.String(),
< 	}
< 	f.AddFlag(flag)
< 	return flag
< }
< 
< // VarP is like Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) VarP(value Value, name, shorthand, usage string) {
< 	f.VarPF(value, name, shorthand, usage)
< }
< 
< // AddFlag will add the flag to the FlagSet
< func (f *FlagSet) AddFlag(flag *Flag) {
< 	normalizedFlagName := f.normalizeFlagName(flag.Name)
< 
< 	_, alreadyThere := f.formal[normalizedFlagName]
< 	if alreadyThere {
< 		msg := fmt.Sprintf("%s flag redefined: %s", f.name, flag.Name)
< 		fmt.Fprintln(f.out(), msg)
< 		panic(msg) // Happens only if flags are declared with identical names
< 	}
< 	if f.formal == nil {
< 		f.formal = make(map[NormalizedName]*Flag)
< 	}
< 
< 	flag.Name = string(normalizedFlagName)
< 	f.formal[normalizedFlagName] = flag
< 	f.orderedFormal = append(f.orderedFormal, flag)
< 
< 	if flag.Shorthand == "" {
< 		return
< 	}
< 	if len(flag.Shorthand) > 1 {
< 		msg := fmt.Sprintf("%q shorthand is more than one ASCII character", flag.Shorthand)
< 		fmt.Fprintf(f.out(), msg)
< 		panic(msg)
< 	}
< 	if f.shorthands == nil {
< 		f.shorthands = make(map[byte]*Flag)
< 	}
< 	c := flag.Shorthand[0]
< 	used, alreadyThere := f.shorthands[c]
< 	if alreadyThere {
< 		msg := fmt.Sprintf("unable to redefine %q shorthand in %q flagset: it's already used for %q flag", c, f.name, used.Name)
< 		fmt.Fprintf(f.out(), msg)
< 		panic(msg)
< 	}
< 	f.shorthands[c] = flag
< }
< 
< // AddFlagSet adds one FlagSet to another. If a flag is already present in f
< // the flag from newSet will be ignored.
< func (f *FlagSet) AddFlagSet(newSet *FlagSet) {
< 	if newSet == nil {
< 		return
< 	}
< 	newSet.VisitAll(func(flag *Flag) {
< 		if f.Lookup(flag.Name) == nil {
< 			f.AddFlag(flag)
< 		}
< 	})
< }
< 
< // Var defines a flag with the specified name and usage string. The type and
< // value of the flag are represented by the first argument, of type Value, which
< // typically holds a user-defined implementation of Value. For instance, the
< // caller could create a flag that turns a comma-separated string into a slice
< // of strings by giving the slice the methods of Value; in particular, Set would
< // decompose the comma-separated string into the slice.
< func Var(value Value, name string, usage string) {
< 	CommandLine.VarP(value, name, "", usage)
< }
< 
< // VarP is like Var, but accepts a shorthand letter that can be used after a single dash.
< func VarP(value Value, name, shorthand, usage string) {
< 	CommandLine.VarP(value, name, shorthand, usage)
< }
< 
< // failf prints to standard error a formatted error and usage message and
< // returns the error.
< func (f *FlagSet) failf(format string, a ...interface{}) error {
< 	err := fmt.Errorf(format, a...)
< 	if f.errorHandling != ContinueOnError {
< 		fmt.Fprintln(f.out(), err)
< 		f.usage()
< 	}
< 	return err
< }
< 
< // usage calls the Usage method for the flag set, or the usage function if
< // the flag set is CommandLine.
< func (f *FlagSet) usage() {
< 	if f == CommandLine {
< 		Usage()
< 	} else if f.Usage == nil {
< 		defaultUsage(f)
< 	} else {
< 		f.Usage()
< 	}
< }
< 
< //--unknown (args will be empty)
< //--unknown --next-flag ... (args will be --next-flag ...)
< //--unknown arg ... (args will be arg ...)
< func stripUnknownFlagValue(args []string) []string {
< 	if len(args) == 0 {
< 		//--unknown
< 		return args
< 	}
< 
< 	first := args[0]
< 	if len(first) > 0 && first[0] == '-' {
< 		//--unknown --next-flag ...
< 		return args
< 	}
< 
< 	//--unknown arg ... (args will be arg ...)
< 	if len(args) > 1 {
< 		return args[1:]
< 	}
< 	return nil
< }
< 
< func (f *FlagSet) parseLongArg(s string, args []string, fn parseFunc) (a []string, err error) {
< 	a = args
< 	name := s[2:]
< 	if len(name) == 0 || name[0] == '-' || name[0] == '=' {
< 		err = f.failf("bad flag syntax: %s", s)
< 		return
< 	}
< 
< 	split := strings.SplitN(name, "=", 2)
< 	name = split[0]
< 	flag, exists := f.formal[f.normalizeFlagName(name)]
< 
< 	if !exists {
< 		switch {
< 		case name == "help":
< 			f.usage()
< 			return a, ErrHelp
< 		case f.ParseErrorsWhitelist.UnknownFlags:
< 			// --unknown=unknownval arg ...
< 			// we do not want to lose arg in this case
< 			if len(split) >= 2 {
< 				return a, nil
< 			}
< 
< 			return stripUnknownFlagValue(a), nil
< 		default:
< 			err = f.failf("unknown flag: --%s", name)
< 			return
< 		}
< 	}
< 
< 	var value string
< 	if len(split) == 2 {
< 		// '--flag=arg'
< 		value = split[1]
< 	} else if flag.NoOptDefVal != "" {
< 		// '--flag' (arg was optional)
< 		value = flag.NoOptDefVal
< 	} else if len(a) > 0 {
< 		// '--flag arg'
< 		value = a[0]
< 		a = a[1:]
< 	} else {
< 		// '--flag' (arg was required)
< 		err = f.failf("flag needs an argument: %s", s)
< 		return
< 	}
< 
< 	err = fn(flag, value)
< 	if err != nil {
< 		f.failf(err.Error())
< 	}
< 	return
< }
< 
< func (f *FlagSet) parseSingleShortArg(shorthands string, args []string, fn parseFunc) (outShorts string, outArgs []string, err error) {
< 	outArgs = args
< 
< 	if strings.HasPrefix(shorthands, "test.") {
< 		return
< 	}
< 
< 	outShorts = shorthands[1:]
< 	c := shorthands[0]
< 
< 	flag, exists := f.shorthands[c]
< 	if !exists {
< 		switch {
< 		case c == 'h':
< 			f.usage()
< 			err = ErrHelp
< 			return
< 		case f.ParseErrorsWhitelist.UnknownFlags:
< 			// '-f=arg arg ...'
< 			// we do not want to lose arg in this case
< 			if len(shorthands) > 2 && shorthands[1] == '=' {
< 				outShorts = ""
< 				return
< 			}
< 
< 			outArgs = stripUnknownFlagValue(outArgs)
< 			return
< 		default:
< 			err = f.failf("unknown shorthand flag: %q in -%s", c, shorthands)
< 			return
< 		}
< 	}
< 
< 	var value string
< 	if len(shorthands) > 2 && shorthands[1] == '=' {
< 		// '-f=arg'
< 		value = shorthands[2:]
< 		outShorts = ""
< 	} else if flag.NoOptDefVal != "" {
< 		// '-f' (arg was optional)
< 		value = flag.NoOptDefVal
< 	} else if len(shorthands) > 1 {
< 		// '-farg'
< 		value = shorthands[1:]
< 		outShorts = ""
< 	} else if len(args) > 0 {
< 		// '-f arg'
< 		value = args[0]
< 		outArgs = args[1:]
< 	} else {
< 		// '-f' (arg was required)
< 		err = f.failf("flag needs an argument: %q in -%s", c, shorthands)
< 		return
< 	}
< 
< 	if flag.ShorthandDeprecated != "" {
< 		fmt.Fprintf(f.out(), "Flag shorthand -%s has been deprecated, %s\n", flag.Shorthand, flag.ShorthandDeprecated)
< 	}
< 
< 	err = fn(flag, value)
< 	if err != nil {
< 		f.failf(err.Error())
< 	}
< 	return
< }
< 
< func (f *FlagSet) parseShortArg(s string, args []string, fn parseFunc) (a []string, err error) {
< 	a = args
< 	shorthands := s[1:]
< 
< 	// "shorthands" can be a series of shorthand letters of flags (e.g. "-vvv").
< 	for len(shorthands) > 0 {
< 		shorthands, a, err = f.parseSingleShortArg(shorthands, args, fn)
< 		if err != nil {
< 			return
< 		}
< 	}
< 
< 	return
< }
< 
< func (f *FlagSet) parseArgs(args []string, fn parseFunc) (err error) {
< 	for len(args) > 0 {
< 		s := args[0]
< 		args = args[1:]
< 		if len(s) == 0 || s[0] != '-' || len(s) == 1 {
< 			if !f.interspersed {
< 				f.args = append(f.args, s)
< 				f.args = append(f.args, args...)
< 				return nil
< 			}
< 			f.args = append(f.args, s)
< 			continue
< 		}
< 
< 		if s[1] == '-' {
< 			if len(s) == 2 { // "--" terminates the flags
< 				f.argsLenAtDash = len(f.args)
< 				f.args = append(f.args, args...)
< 				break
< 			}
< 			args, err = f.parseLongArg(s, args, fn)
< 		} else {
< 			args, err = f.parseShortArg(s, args, fn)
< 		}
< 		if err != nil {
< 			return
< 		}
< 	}
< 	return
< }
< 
< // Parse parses flag definitions from the argument list, which should not
< // include the command name.  Must be called after all flags in the FlagSet
< // are defined and before flags are accessed by the program.
< // The return value will be ErrHelp if -help was set but not defined.
< func (f *FlagSet) Parse(arguments []string) error {
< 	if f.addedGoFlagSets != nil {
< 		for _, goFlagSet := range f.addedGoFlagSets {
< 			goFlagSet.Parse(nil)
< 		}
< 	}
< 	f.parsed = true
< 
< 	if len(arguments) < 0 {
< 		return nil
< 	}
< 
< 	f.args = make([]string, 0, len(arguments))
< 
< 	set := func(flag *Flag, value string) error {
< 		return f.Set(flag.Name, value)
< 	}
< 
< 	err := f.parseArgs(arguments, set)
< 	if err != nil {
< 		switch f.errorHandling {
< 		case ContinueOnError:
< 			return err
< 		case ExitOnError:
< 			fmt.Println(err)
< 			os.Exit(2)
< 		case PanicOnError:
< 			panic(err)
< 		}
< 	}
< 	return nil
< }
< 
< type parseFunc func(flag *Flag, value string) error
< 
< // ParseAll parses flag definitions from the argument list, which should not
< // include the command name. The arguments for fn are flag and value. Must be
< // called after all flags in the FlagSet are defined and before flags are
< // accessed by the program. The return value will be ErrHelp if -help was set
< // but not defined.
< func (f *FlagSet) ParseAll(arguments []string, fn func(flag *Flag, value string) error) error {
< 	f.parsed = true
< 	f.args = make([]string, 0, len(arguments))
< 
< 	err := f.parseArgs(arguments, fn)
< 	if err != nil {
< 		switch f.errorHandling {
< 		case ContinueOnError:
< 			return err
< 		case ExitOnError:
< 			os.Exit(2)
< 		case PanicOnError:
< 			panic(err)
< 		}
< 	}
< 	return nil
< }
< 
< // Parsed reports whether f.Parse has been called.
< func (f *FlagSet) Parsed() bool {
< 	return f.parsed
< }
< 
< // Parse parses the command-line flags from os.Args[1:].  Must be called
< // after all flags are defined and before flags are accessed by the program.
< func Parse() {
< 	// Ignore errors; CommandLine is set for ExitOnError.
< 	CommandLine.Parse(os.Args[1:])
< }
< 
< // ParseAll parses the command-line flags from os.Args[1:] and called fn for each.
< // The arguments for fn are flag and value. Must be called after all flags are
< // defined and before flags are accessed by the program.
< func ParseAll(fn func(flag *Flag, value string) error) {
< 	// Ignore errors; CommandLine is set for ExitOnError.
< 	CommandLine.ParseAll(os.Args[1:], fn)
< }
< 
< // SetInterspersed sets whether to support interspersed option/non-option arguments.
< func SetInterspersed(interspersed bool) {
< 	CommandLine.SetInterspersed(interspersed)
< }
< 
< // Parsed returns true if the command-line flags have been parsed.
< func Parsed() bool {
< 	return CommandLine.Parsed()
< }
< 
< // CommandLine is the default set of command-line flags, parsed from os.Args.
< var CommandLine = NewFlagSet(os.Args[0], ExitOnError)
< 
< // NewFlagSet returns a new, empty flag set with the specified name,
< // error handling property and SortFlags set to true.
< func NewFlagSet(name string, errorHandling ErrorHandling) *FlagSet {
< 	f := &FlagSet{
< 		name:          name,
< 		errorHandling: errorHandling,
< 		argsLenAtDash: -1,
< 		interspersed:  true,
< 		SortFlags:     true,
< 	}
< 	return f
< }
< 
< // SetInterspersed sets whether to support interspersed option/non-option arguments.
< func (f *FlagSet) SetInterspersed(interspersed bool) {
< 	f.interspersed = interspersed
< }
< 
< // Init sets the name and error handling property for a flag set.
< // By default, the zero FlagSet uses an empty name and the
< // ContinueOnError error handling policy.
< func (f *FlagSet) Init(name string, errorHandling ErrorHandling) {
< 	f.name = name
< 	f.errorHandling = errorHandling
< 	f.argsLenAtDash = -1
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/float32.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/float32.go
1,88d0
< package pflag
< 
< import "strconv"
< 
< // -- float32 Value
< type float32Value float32
< 
< func newFloat32Value(val float32, p *float32) *float32Value {
< 	*p = val
< 	return (*float32Value)(p)
< }
< 
< func (f *float32Value) Set(s string) error {
< 	v, err := strconv.ParseFloat(s, 32)
< 	*f = float32Value(v)
< 	return err
< }
< 
< func (f *float32Value) Type() string {
< 	return "float32"
< }
< 
< func (f *float32Value) String() string { return strconv.FormatFloat(float64(*f), 'g', -1, 32) }
< 
< func float32Conv(sval string) (interface{}, error) {
< 	v, err := strconv.ParseFloat(sval, 32)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return float32(v), nil
< }
< 
< // GetFloat32 return the float32 value of a flag with the given name
< func (f *FlagSet) GetFloat32(name string) (float32, error) {
< 	val, err := f.getFlagType(name, "float32", float32Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(float32), nil
< }
< 
< // Float32Var defines a float32 flag with specified name, default value, and usage string.
< // The argument p points to a float32 variable in which to store the value of the flag.
< func (f *FlagSet) Float32Var(p *float32, name string, value float32, usage string) {
< 	f.VarP(newFloat32Value(value, p), name, "", usage)
< }
< 
< // Float32VarP is like Float32Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Float32VarP(p *float32, name, shorthand string, value float32, usage string) {
< 	f.VarP(newFloat32Value(value, p), name, shorthand, usage)
< }
< 
< // Float32Var defines a float32 flag with specified name, default value, and usage string.
< // The argument p points to a float32 variable in which to store the value of the flag.
< func Float32Var(p *float32, name string, value float32, usage string) {
< 	CommandLine.VarP(newFloat32Value(value, p), name, "", usage)
< }
< 
< // Float32VarP is like Float32Var, but accepts a shorthand letter that can be used after a single dash.
< func Float32VarP(p *float32, name, shorthand string, value float32, usage string) {
< 	CommandLine.VarP(newFloat32Value(value, p), name, shorthand, usage)
< }
< 
< // Float32 defines a float32 flag with specified name, default value, and usage string.
< // The return value is the address of a float32 variable that stores the value of the flag.
< func (f *FlagSet) Float32(name string, value float32, usage string) *float32 {
< 	p := new(float32)
< 	f.Float32VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Float32P is like Float32, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Float32P(name, shorthand string, value float32, usage string) *float32 {
< 	p := new(float32)
< 	f.Float32VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Float32 defines a float32 flag with specified name, default value, and usage string.
< // The return value is the address of a float32 variable that stores the value of the flag.
< func Float32(name string, value float32, usage string) *float32 {
< 	return CommandLine.Float32P(name, "", value, usage)
< }
< 
< // Float32P is like Float32, but accepts a shorthand letter that can be used after a single dash.
< func Float32P(name, shorthand string, value float32, usage string) *float32 {
< 	return CommandLine.Float32P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/float32_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/float32_slice.go
1,174d0
< package pflag
< 
< import (
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< // -- float32Slice Value
< type float32SliceValue struct {
< 	value   *[]float32
< 	changed bool
< }
< 
< func newFloat32SliceValue(val []float32, p *[]float32) *float32SliceValue {
< 	isv := new(float32SliceValue)
< 	isv.value = p
< 	*isv.value = val
< 	return isv
< }
< 
< func (s *float32SliceValue) Set(val string) error {
< 	ss := strings.Split(val, ",")
< 	out := make([]float32, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		var temp64 float64
< 		temp64, err = strconv.ParseFloat(d, 32)
< 		if err != nil {
< 			return err
< 		}
< 		out[i] = float32(temp64)
< 
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		*s.value = append(*s.value, out...)
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *float32SliceValue) Type() string {
< 	return "float32Slice"
< }
< 
< func (s *float32SliceValue) String() string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = fmt.Sprintf("%f", d)
< 	}
< 	return "[" + strings.Join(out, ",") + "]"
< }
< 
< func (s *float32SliceValue) fromString(val string) (float32, error) {
< 	t64, err := strconv.ParseFloat(val, 32)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return float32(t64), nil
< }
< 
< func (s *float32SliceValue) toString(val float32) string {
< 	return fmt.Sprintf("%f", val)
< }
< 
< func (s *float32SliceValue) Append(val string) error {
< 	i, err := s.fromString(val)
< 	if err != nil {
< 		return err
< 	}
< 	*s.value = append(*s.value, i)
< 	return nil
< }
< 
< func (s *float32SliceValue) Replace(val []string) error {
< 	out := make([]float32, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i], err = s.fromString(d)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *float32SliceValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = s.toString(d)
< 	}
< 	return out
< }
< 
< func float32SliceConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// Empty string would cause a slice with one (empty) entry
< 	if len(val) == 0 {
< 		return []float32{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make([]float32, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		var temp64 float64
< 		temp64, err = strconv.ParseFloat(d, 32)
< 		if err != nil {
< 			return nil, err
< 		}
< 		out[i] = float32(temp64)
< 
< 	}
< 	return out, nil
< }
< 
< // GetFloat32Slice return the []float32 value of a flag with the given name
< func (f *FlagSet) GetFloat32Slice(name string) ([]float32, error) {
< 	val, err := f.getFlagType(name, "float32Slice", float32SliceConv)
< 	if err != nil {
< 		return []float32{}, err
< 	}
< 	return val.([]float32), nil
< }
< 
< // Float32SliceVar defines a float32Slice flag with specified name, default value, and usage string.
< // The argument p points to a []float32 variable in which to store the value of the flag.
< func (f *FlagSet) Float32SliceVar(p *[]float32, name string, value []float32, usage string) {
< 	f.VarP(newFloat32SliceValue(value, p), name, "", usage)
< }
< 
< // Float32SliceVarP is like Float32SliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Float32SliceVarP(p *[]float32, name, shorthand string, value []float32, usage string) {
< 	f.VarP(newFloat32SliceValue(value, p), name, shorthand, usage)
< }
< 
< // Float32SliceVar defines a float32[] flag with specified name, default value, and usage string.
< // The argument p points to a float32[] variable in which to store the value of the flag.
< func Float32SliceVar(p *[]float32, name string, value []float32, usage string) {
< 	CommandLine.VarP(newFloat32SliceValue(value, p), name, "", usage)
< }
< 
< // Float32SliceVarP is like Float32SliceVar, but accepts a shorthand letter that can be used after a single dash.
< func Float32SliceVarP(p *[]float32, name, shorthand string, value []float32, usage string) {
< 	CommandLine.VarP(newFloat32SliceValue(value, p), name, shorthand, usage)
< }
< 
< // Float32Slice defines a []float32 flag with specified name, default value, and usage string.
< // The return value is the address of a []float32 variable that stores the value of the flag.
< func (f *FlagSet) Float32Slice(name string, value []float32, usage string) *[]float32 {
< 	p := []float32{}
< 	f.Float32SliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // Float32SliceP is like Float32Slice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Float32SliceP(name, shorthand string, value []float32, usage string) *[]float32 {
< 	p := []float32{}
< 	f.Float32SliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // Float32Slice defines a []float32 flag with specified name, default value, and usage string.
< // The return value is the address of a []float32 variable that stores the value of the flag.
< func Float32Slice(name string, value []float32, usage string) *[]float32 {
< 	return CommandLine.Float32SliceP(name, "", value, usage)
< }
< 
< // Float32SliceP is like Float32Slice, but accepts a shorthand letter that can be used after a single dash.
< func Float32SliceP(name, shorthand string, value []float32, usage string) *[]float32 {
< 	return CommandLine.Float32SliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/float64.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/float64.go
1,84d0
< package pflag
< 
< import "strconv"
< 
< // -- float64 Value
< type float64Value float64
< 
< func newFloat64Value(val float64, p *float64) *float64Value {
< 	*p = val
< 	return (*float64Value)(p)
< }
< 
< func (f *float64Value) Set(s string) error {
< 	v, err := strconv.ParseFloat(s, 64)
< 	*f = float64Value(v)
< 	return err
< }
< 
< func (f *float64Value) Type() string {
< 	return "float64"
< }
< 
< func (f *float64Value) String() string { return strconv.FormatFloat(float64(*f), 'g', -1, 64) }
< 
< func float64Conv(sval string) (interface{}, error) {
< 	return strconv.ParseFloat(sval, 64)
< }
< 
< // GetFloat64 return the float64 value of a flag with the given name
< func (f *FlagSet) GetFloat64(name string) (float64, error) {
< 	val, err := f.getFlagType(name, "float64", float64Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(float64), nil
< }
< 
< // Float64Var defines a float64 flag with specified name, default value, and usage string.
< // The argument p points to a float64 variable in which to store the value of the flag.
< func (f *FlagSet) Float64Var(p *float64, name string, value float64, usage string) {
< 	f.VarP(newFloat64Value(value, p), name, "", usage)
< }
< 
< // Float64VarP is like Float64Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Float64VarP(p *float64, name, shorthand string, value float64, usage string) {
< 	f.VarP(newFloat64Value(value, p), name, shorthand, usage)
< }
< 
< // Float64Var defines a float64 flag with specified name, default value, and usage string.
< // The argument p points to a float64 variable in which to store the value of the flag.
< func Float64Var(p *float64, name string, value float64, usage string) {
< 	CommandLine.VarP(newFloat64Value(value, p), name, "", usage)
< }
< 
< // Float64VarP is like Float64Var, but accepts a shorthand letter that can be used after a single dash.
< func Float64VarP(p *float64, name, shorthand string, value float64, usage string) {
< 	CommandLine.VarP(newFloat64Value(value, p), name, shorthand, usage)
< }
< 
< // Float64 defines a float64 flag with specified name, default value, and usage string.
< // The return value is the address of a float64 variable that stores the value of the flag.
< func (f *FlagSet) Float64(name string, value float64, usage string) *float64 {
< 	p := new(float64)
< 	f.Float64VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Float64P is like Float64, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Float64P(name, shorthand string, value float64, usage string) *float64 {
< 	p := new(float64)
< 	f.Float64VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Float64 defines a float64 flag with specified name, default value, and usage string.
< // The return value is the address of a float64 variable that stores the value of the flag.
< func Float64(name string, value float64, usage string) *float64 {
< 	return CommandLine.Float64P(name, "", value, usage)
< }
< 
< // Float64P is like Float64, but accepts a shorthand letter that can be used after a single dash.
< func Float64P(name, shorthand string, value float64, usage string) *float64 {
< 	return CommandLine.Float64P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/float64_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/float64_slice.go
1,166d0
< package pflag
< 
< import (
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< // -- float64Slice Value
< type float64SliceValue struct {
< 	value   *[]float64
< 	changed bool
< }
< 
< func newFloat64SliceValue(val []float64, p *[]float64) *float64SliceValue {
< 	isv := new(float64SliceValue)
< 	isv.value = p
< 	*isv.value = val
< 	return isv
< }
< 
< func (s *float64SliceValue) Set(val string) error {
< 	ss := strings.Split(val, ",")
< 	out := make([]float64, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		out[i], err = strconv.ParseFloat(d, 64)
< 		if err != nil {
< 			return err
< 		}
< 
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		*s.value = append(*s.value, out...)
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *float64SliceValue) Type() string {
< 	return "float64Slice"
< }
< 
< func (s *float64SliceValue) String() string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = fmt.Sprintf("%f", d)
< 	}
< 	return "[" + strings.Join(out, ",") + "]"
< }
< 
< func (s *float64SliceValue) fromString(val string) (float64, error) {
< 	return strconv.ParseFloat(val, 64)
< }
< 
< func (s *float64SliceValue) toString(val float64) string {
< 	return fmt.Sprintf("%f", val)
< }
< 
< func (s *float64SliceValue) Append(val string) error {
< 	i, err := s.fromString(val)
< 	if err != nil {
< 		return err
< 	}
< 	*s.value = append(*s.value, i)
< 	return nil
< }
< 
< func (s *float64SliceValue) Replace(val []string) error {
< 	out := make([]float64, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i], err = s.fromString(d)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *float64SliceValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = s.toString(d)
< 	}
< 	return out
< }
< 
< func float64SliceConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// Empty string would cause a slice with one (empty) entry
< 	if len(val) == 0 {
< 		return []float64{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make([]float64, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		out[i], err = strconv.ParseFloat(d, 64)
< 		if err != nil {
< 			return nil, err
< 		}
< 
< 	}
< 	return out, nil
< }
< 
< // GetFloat64Slice return the []float64 value of a flag with the given name
< func (f *FlagSet) GetFloat64Slice(name string) ([]float64, error) {
< 	val, err := f.getFlagType(name, "float64Slice", float64SliceConv)
< 	if err != nil {
< 		return []float64{}, err
< 	}
< 	return val.([]float64), nil
< }
< 
< // Float64SliceVar defines a float64Slice flag with specified name, default value, and usage string.
< // The argument p points to a []float64 variable in which to store the value of the flag.
< func (f *FlagSet) Float64SliceVar(p *[]float64, name string, value []float64, usage string) {
< 	f.VarP(newFloat64SliceValue(value, p), name, "", usage)
< }
< 
< // Float64SliceVarP is like Float64SliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Float64SliceVarP(p *[]float64, name, shorthand string, value []float64, usage string) {
< 	f.VarP(newFloat64SliceValue(value, p), name, shorthand, usage)
< }
< 
< // Float64SliceVar defines a float64[] flag with specified name, default value, and usage string.
< // The argument p points to a float64[] variable in which to store the value of the flag.
< func Float64SliceVar(p *[]float64, name string, value []float64, usage string) {
< 	CommandLine.VarP(newFloat64SliceValue(value, p), name, "", usage)
< }
< 
< // Float64SliceVarP is like Float64SliceVar, but accepts a shorthand letter that can be used after a single dash.
< func Float64SliceVarP(p *[]float64, name, shorthand string, value []float64, usage string) {
< 	CommandLine.VarP(newFloat64SliceValue(value, p), name, shorthand, usage)
< }
< 
< // Float64Slice defines a []float64 flag with specified name, default value, and usage string.
< // The return value is the address of a []float64 variable that stores the value of the flag.
< func (f *FlagSet) Float64Slice(name string, value []float64, usage string) *[]float64 {
< 	p := []float64{}
< 	f.Float64SliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // Float64SliceP is like Float64Slice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Float64SliceP(name, shorthand string, value []float64, usage string) *[]float64 {
< 	p := []float64{}
< 	f.Float64SliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // Float64Slice defines a []float64 flag with specified name, default value, and usage string.
< // The return value is the address of a []float64 variable that stores the value of the flag.
< func Float64Slice(name string, value []float64, usage string) *[]float64 {
< 	return CommandLine.Float64SliceP(name, "", value, usage)
< }
< 
< // Float64SliceP is like Float64Slice, but accepts a shorthand letter that can be used after a single dash.
< func Float64SliceP(name, shorthand string, value []float64, usage string) *[]float64 {
< 	return CommandLine.Float64SliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/go.mod updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/go.mod
1,3d0
< module github.com/spf13/pflag
< 
< go 1.12
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/golangflag.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/golangflag.go
1,105d0
< // Copyright 2009 The Go Authors. All rights reserved.
< // Use of this source code is governed by a BSD-style
< // license that can be found in the LICENSE file.
< 
< package pflag
< 
< import (
< 	goflag "flag"
< 	"reflect"
< 	"strings"
< )
< 
< // flagValueWrapper implements pflag.Value around a flag.Value.  The main
< // difference here is the addition of the Type method that returns a string
< // name of the type.  As this is generally unknown, we approximate that with
< // reflection.
< type flagValueWrapper struct {
< 	inner    goflag.Value
< 	flagType string
< }
< 
< // We are just copying the boolFlag interface out of goflag as that is what
< // they use to decide if a flag should get "true" when no arg is given.
< type goBoolFlag interface {
< 	goflag.Value
< 	IsBoolFlag() bool
< }
< 
< func wrapFlagValue(v goflag.Value) Value {
< 	// If the flag.Value happens to also be a pflag.Value, just use it directly.
< 	if pv, ok := v.(Value); ok {
< 		return pv
< 	}
< 
< 	pv := &flagValueWrapper{
< 		inner: v,
< 	}
< 
< 	t := reflect.TypeOf(v)
< 	if t.Kind() == reflect.Interface || t.Kind() == reflect.Ptr {
< 		t = t.Elem()
< 	}
< 
< 	pv.flagType = strings.TrimSuffix(t.Name(), "Value")
< 	return pv
< }
< 
< func (v *flagValueWrapper) String() string {
< 	return v.inner.String()
< }
< 
< func (v *flagValueWrapper) Set(s string) error {
< 	return v.inner.Set(s)
< }
< 
< func (v *flagValueWrapper) Type() string {
< 	return v.flagType
< }
< 
< // PFlagFromGoFlag will return a *pflag.Flag given a *flag.Flag
< // If the *flag.Flag.Name was a single character (ex: `v`) it will be accessiblei
< // with both `-v` and `--v` in flags. If the golang flag was more than a single
< // character (ex: `verbose`) it will only be accessible via `--verbose`
< func PFlagFromGoFlag(goflag *goflag.Flag) *Flag {
< 	// Remember the default value as a string; it won't change.
< 	flag := &Flag{
< 		Name:  goflag.Name,
< 		Usage: goflag.Usage,
< 		Value: wrapFlagValue(goflag.Value),
< 		// Looks like golang flags don't set DefValue correctly  :-(
< 		//DefValue: goflag.DefValue,
< 		DefValue: goflag.Value.String(),
< 	}
< 	// Ex: if the golang flag was -v, allow both -v and --v to work
< 	if len(flag.Name) == 1 {
< 		flag.Shorthand = flag.Name
< 	}
< 	if fv, ok := goflag.Value.(goBoolFlag); ok && fv.IsBoolFlag() {
< 		flag.NoOptDefVal = "true"
< 	}
< 	return flag
< }
< 
< // AddGoFlag will add the given *flag.Flag to the pflag.FlagSet
< func (f *FlagSet) AddGoFlag(goflag *goflag.Flag) {
< 	if f.Lookup(goflag.Name) != nil {
< 		return
< 	}
< 	newflag := PFlagFromGoFlag(goflag)
< 	f.AddFlag(newflag)
< }
< 
< // AddGoFlagSet will add the given *flag.FlagSet to the pflag.FlagSet
< func (f *FlagSet) AddGoFlagSet(newSet *goflag.FlagSet) {
< 	if newSet == nil {
< 		return
< 	}
< 	newSet.VisitAll(func(goflag *goflag.Flag) {
< 		f.AddGoFlag(goflag)
< 	})
< 	if f.addedGoFlagSets == nil {
< 		f.addedGoFlagSets = make([]*goflag.FlagSet, 0)
< 	}
< 	f.addedGoFlagSets = append(f.addedGoFlagSets, newSet)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int.go
1,84d0
< package pflag
< 
< import "strconv"
< 
< // -- int Value
< type intValue int
< 
< func newIntValue(val int, p *int) *intValue {
< 	*p = val
< 	return (*intValue)(p)
< }
< 
< func (i *intValue) Set(s string) error {
< 	v, err := strconv.ParseInt(s, 0, 64)
< 	*i = intValue(v)
< 	return err
< }
< 
< func (i *intValue) Type() string {
< 	return "int"
< }
< 
< func (i *intValue) String() string { return strconv.Itoa(int(*i)) }
< 
< func intConv(sval string) (interface{}, error) {
< 	return strconv.Atoi(sval)
< }
< 
< // GetInt return the int value of a flag with the given name
< func (f *FlagSet) GetInt(name string) (int, error) {
< 	val, err := f.getFlagType(name, "int", intConv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(int), nil
< }
< 
< // IntVar defines an int flag with specified name, default value, and usage string.
< // The argument p points to an int variable in which to store the value of the flag.
< func (f *FlagSet) IntVar(p *int, name string, value int, usage string) {
< 	f.VarP(newIntValue(value, p), name, "", usage)
< }
< 
< // IntVarP is like IntVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IntVarP(p *int, name, shorthand string, value int, usage string) {
< 	f.VarP(newIntValue(value, p), name, shorthand, usage)
< }
< 
< // IntVar defines an int flag with specified name, default value, and usage string.
< // The argument p points to an int variable in which to store the value of the flag.
< func IntVar(p *int, name string, value int, usage string) {
< 	CommandLine.VarP(newIntValue(value, p), name, "", usage)
< }
< 
< // IntVarP is like IntVar, but accepts a shorthand letter that can be used after a single dash.
< func IntVarP(p *int, name, shorthand string, value int, usage string) {
< 	CommandLine.VarP(newIntValue(value, p), name, shorthand, usage)
< }
< 
< // Int defines an int flag with specified name, default value, and usage string.
< // The return value is the address of an int variable that stores the value of the flag.
< func (f *FlagSet) Int(name string, value int, usage string) *int {
< 	p := new(int)
< 	f.IntVarP(p, name, "", value, usage)
< 	return p
< }
< 
< // IntP is like Int, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IntP(name, shorthand string, value int, usage string) *int {
< 	p := new(int)
< 	f.IntVarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Int defines an int flag with specified name, default value, and usage string.
< // The return value is the address of an int variable that stores the value of the flag.
< func Int(name string, value int, usage string) *int {
< 	return CommandLine.IntP(name, "", value, usage)
< }
< 
< // IntP is like Int, but accepts a shorthand letter that can be used after a single dash.
< func IntP(name, shorthand string, value int, usage string) *int {
< 	return CommandLine.IntP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int16.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int16.go
1,88d0
< package pflag
< 
< import "strconv"
< 
< // -- int16 Value
< type int16Value int16
< 
< func newInt16Value(val int16, p *int16) *int16Value {
< 	*p = val
< 	return (*int16Value)(p)
< }
< 
< func (i *int16Value) Set(s string) error {
< 	v, err := strconv.ParseInt(s, 0, 16)
< 	*i = int16Value(v)
< 	return err
< }
< 
< func (i *int16Value) Type() string {
< 	return "int16"
< }
< 
< func (i *int16Value) String() string { return strconv.FormatInt(int64(*i), 10) }
< 
< func int16Conv(sval string) (interface{}, error) {
< 	v, err := strconv.ParseInt(sval, 0, 16)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return int16(v), nil
< }
< 
< // GetInt16 returns the int16 value of a flag with the given name
< func (f *FlagSet) GetInt16(name string) (int16, error) {
< 	val, err := f.getFlagType(name, "int16", int16Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(int16), nil
< }
< 
< // Int16Var defines an int16 flag with specified name, default value, and usage string.
< // The argument p points to an int16 variable in which to store the value of the flag.
< func (f *FlagSet) Int16Var(p *int16, name string, value int16, usage string) {
< 	f.VarP(newInt16Value(value, p), name, "", usage)
< }
< 
< // Int16VarP is like Int16Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int16VarP(p *int16, name, shorthand string, value int16, usage string) {
< 	f.VarP(newInt16Value(value, p), name, shorthand, usage)
< }
< 
< // Int16Var defines an int16 flag with specified name, default value, and usage string.
< // The argument p points to an int16 variable in which to store the value of the flag.
< func Int16Var(p *int16, name string, value int16, usage string) {
< 	CommandLine.VarP(newInt16Value(value, p), name, "", usage)
< }
< 
< // Int16VarP is like Int16Var, but accepts a shorthand letter that can be used after a single dash.
< func Int16VarP(p *int16, name, shorthand string, value int16, usage string) {
< 	CommandLine.VarP(newInt16Value(value, p), name, shorthand, usage)
< }
< 
< // Int16 defines an int16 flag with specified name, default value, and usage string.
< // The return value is the address of an int16 variable that stores the value of the flag.
< func (f *FlagSet) Int16(name string, value int16, usage string) *int16 {
< 	p := new(int16)
< 	f.Int16VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Int16P is like Int16, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int16P(name, shorthand string, value int16, usage string) *int16 {
< 	p := new(int16)
< 	f.Int16VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Int16 defines an int16 flag with specified name, default value, and usage string.
< // The return value is the address of an int16 variable that stores the value of the flag.
< func Int16(name string, value int16, usage string) *int16 {
< 	return CommandLine.Int16P(name, "", value, usage)
< }
< 
< // Int16P is like Int16, but accepts a shorthand letter that can be used after a single dash.
< func Int16P(name, shorthand string, value int16, usage string) *int16 {
< 	return CommandLine.Int16P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int32.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int32.go
1,88d0
< package pflag
< 
< import "strconv"
< 
< // -- int32 Value
< type int32Value int32
< 
< func newInt32Value(val int32, p *int32) *int32Value {
< 	*p = val
< 	return (*int32Value)(p)
< }
< 
< func (i *int32Value) Set(s string) error {
< 	v, err := strconv.ParseInt(s, 0, 32)
< 	*i = int32Value(v)
< 	return err
< }
< 
< func (i *int32Value) Type() string {
< 	return "int32"
< }
< 
< func (i *int32Value) String() string { return strconv.FormatInt(int64(*i), 10) }
< 
< func int32Conv(sval string) (interface{}, error) {
< 	v, err := strconv.ParseInt(sval, 0, 32)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return int32(v), nil
< }
< 
< // GetInt32 return the int32 value of a flag with the given name
< func (f *FlagSet) GetInt32(name string) (int32, error) {
< 	val, err := f.getFlagType(name, "int32", int32Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(int32), nil
< }
< 
< // Int32Var defines an int32 flag with specified name, default value, and usage string.
< // The argument p points to an int32 variable in which to store the value of the flag.
< func (f *FlagSet) Int32Var(p *int32, name string, value int32, usage string) {
< 	f.VarP(newInt32Value(value, p), name, "", usage)
< }
< 
< // Int32VarP is like Int32Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int32VarP(p *int32, name, shorthand string, value int32, usage string) {
< 	f.VarP(newInt32Value(value, p), name, shorthand, usage)
< }
< 
< // Int32Var defines an int32 flag with specified name, default value, and usage string.
< // The argument p points to an int32 variable in which to store the value of the flag.
< func Int32Var(p *int32, name string, value int32, usage string) {
< 	CommandLine.VarP(newInt32Value(value, p), name, "", usage)
< }
< 
< // Int32VarP is like Int32Var, but accepts a shorthand letter that can be used after a single dash.
< func Int32VarP(p *int32, name, shorthand string, value int32, usage string) {
< 	CommandLine.VarP(newInt32Value(value, p), name, shorthand, usage)
< }
< 
< // Int32 defines an int32 flag with specified name, default value, and usage string.
< // The return value is the address of an int32 variable that stores the value of the flag.
< func (f *FlagSet) Int32(name string, value int32, usage string) *int32 {
< 	p := new(int32)
< 	f.Int32VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Int32P is like Int32, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int32P(name, shorthand string, value int32, usage string) *int32 {
< 	p := new(int32)
< 	f.Int32VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Int32 defines an int32 flag with specified name, default value, and usage string.
< // The return value is the address of an int32 variable that stores the value of the flag.
< func Int32(name string, value int32, usage string) *int32 {
< 	return CommandLine.Int32P(name, "", value, usage)
< }
< 
< // Int32P is like Int32, but accepts a shorthand letter that can be used after a single dash.
< func Int32P(name, shorthand string, value int32, usage string) *int32 {
< 	return CommandLine.Int32P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int32_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int32_slice.go
1,174d0
< package pflag
< 
< import (
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< // -- int32Slice Value
< type int32SliceValue struct {
< 	value   *[]int32
< 	changed bool
< }
< 
< func newInt32SliceValue(val []int32, p *[]int32) *int32SliceValue {
< 	isv := new(int32SliceValue)
< 	isv.value = p
< 	*isv.value = val
< 	return isv
< }
< 
< func (s *int32SliceValue) Set(val string) error {
< 	ss := strings.Split(val, ",")
< 	out := make([]int32, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		var temp64 int64
< 		temp64, err = strconv.ParseInt(d, 0, 32)
< 		if err != nil {
< 			return err
< 		}
< 		out[i] = int32(temp64)
< 
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		*s.value = append(*s.value, out...)
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *int32SliceValue) Type() string {
< 	return "int32Slice"
< }
< 
< func (s *int32SliceValue) String() string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = fmt.Sprintf("%d", d)
< 	}
< 	return "[" + strings.Join(out, ",") + "]"
< }
< 
< func (s *int32SliceValue) fromString(val string) (int32, error) {
< 	t64, err := strconv.ParseInt(val, 0, 32)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return int32(t64), nil
< }
< 
< func (s *int32SliceValue) toString(val int32) string {
< 	return fmt.Sprintf("%d", val)
< }
< 
< func (s *int32SliceValue) Append(val string) error {
< 	i, err := s.fromString(val)
< 	if err != nil {
< 		return err
< 	}
< 	*s.value = append(*s.value, i)
< 	return nil
< }
< 
< func (s *int32SliceValue) Replace(val []string) error {
< 	out := make([]int32, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i], err = s.fromString(d)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *int32SliceValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = s.toString(d)
< 	}
< 	return out
< }
< 
< func int32SliceConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// Empty string would cause a slice with one (empty) entry
< 	if len(val) == 0 {
< 		return []int32{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make([]int32, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		var temp64 int64
< 		temp64, err = strconv.ParseInt(d, 0, 32)
< 		if err != nil {
< 			return nil, err
< 		}
< 		out[i] = int32(temp64)
< 
< 	}
< 	return out, nil
< }
< 
< // GetInt32Slice return the []int32 value of a flag with the given name
< func (f *FlagSet) GetInt32Slice(name string) ([]int32, error) {
< 	val, err := f.getFlagType(name, "int32Slice", int32SliceConv)
< 	if err != nil {
< 		return []int32{}, err
< 	}
< 	return val.([]int32), nil
< }
< 
< // Int32SliceVar defines a int32Slice flag with specified name, default value, and usage string.
< // The argument p points to a []int32 variable in which to store the value of the flag.
< func (f *FlagSet) Int32SliceVar(p *[]int32, name string, value []int32, usage string) {
< 	f.VarP(newInt32SliceValue(value, p), name, "", usage)
< }
< 
< // Int32SliceVarP is like Int32SliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int32SliceVarP(p *[]int32, name, shorthand string, value []int32, usage string) {
< 	f.VarP(newInt32SliceValue(value, p), name, shorthand, usage)
< }
< 
< // Int32SliceVar defines a int32[] flag with specified name, default value, and usage string.
< // The argument p points to a int32[] variable in which to store the value of the flag.
< func Int32SliceVar(p *[]int32, name string, value []int32, usage string) {
< 	CommandLine.VarP(newInt32SliceValue(value, p), name, "", usage)
< }
< 
< // Int32SliceVarP is like Int32SliceVar, but accepts a shorthand letter that can be used after a single dash.
< func Int32SliceVarP(p *[]int32, name, shorthand string, value []int32, usage string) {
< 	CommandLine.VarP(newInt32SliceValue(value, p), name, shorthand, usage)
< }
< 
< // Int32Slice defines a []int32 flag with specified name, default value, and usage string.
< // The return value is the address of a []int32 variable that stores the value of the flag.
< func (f *FlagSet) Int32Slice(name string, value []int32, usage string) *[]int32 {
< 	p := []int32{}
< 	f.Int32SliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // Int32SliceP is like Int32Slice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int32SliceP(name, shorthand string, value []int32, usage string) *[]int32 {
< 	p := []int32{}
< 	f.Int32SliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // Int32Slice defines a []int32 flag with specified name, default value, and usage string.
< // The return value is the address of a []int32 variable that stores the value of the flag.
< func Int32Slice(name string, value []int32, usage string) *[]int32 {
< 	return CommandLine.Int32SliceP(name, "", value, usage)
< }
< 
< // Int32SliceP is like Int32Slice, but accepts a shorthand letter that can be used after a single dash.
< func Int32SliceP(name, shorthand string, value []int32, usage string) *[]int32 {
< 	return CommandLine.Int32SliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int64.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int64.go
1,84d0
< package pflag
< 
< import "strconv"
< 
< // -- int64 Value
< type int64Value int64
< 
< func newInt64Value(val int64, p *int64) *int64Value {
< 	*p = val
< 	return (*int64Value)(p)
< }
< 
< func (i *int64Value) Set(s string) error {
< 	v, err := strconv.ParseInt(s, 0, 64)
< 	*i = int64Value(v)
< 	return err
< }
< 
< func (i *int64Value) Type() string {
< 	return "int64"
< }
< 
< func (i *int64Value) String() string { return strconv.FormatInt(int64(*i), 10) }
< 
< func int64Conv(sval string) (interface{}, error) {
< 	return strconv.ParseInt(sval, 0, 64)
< }
< 
< // GetInt64 return the int64 value of a flag with the given name
< func (f *FlagSet) GetInt64(name string) (int64, error) {
< 	val, err := f.getFlagType(name, "int64", int64Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(int64), nil
< }
< 
< // Int64Var defines an int64 flag with specified name, default value, and usage string.
< // The argument p points to an int64 variable in which to store the value of the flag.
< func (f *FlagSet) Int64Var(p *int64, name string, value int64, usage string) {
< 	f.VarP(newInt64Value(value, p), name, "", usage)
< }
< 
< // Int64VarP is like Int64Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int64VarP(p *int64, name, shorthand string, value int64, usage string) {
< 	f.VarP(newInt64Value(value, p), name, shorthand, usage)
< }
< 
< // Int64Var defines an int64 flag with specified name, default value, and usage string.
< // The argument p points to an int64 variable in which to store the value of the flag.
< func Int64Var(p *int64, name string, value int64, usage string) {
< 	CommandLine.VarP(newInt64Value(value, p), name, "", usage)
< }
< 
< // Int64VarP is like Int64Var, but accepts a shorthand letter that can be used after a single dash.
< func Int64VarP(p *int64, name, shorthand string, value int64, usage string) {
< 	CommandLine.VarP(newInt64Value(value, p), name, shorthand, usage)
< }
< 
< // Int64 defines an int64 flag with specified name, default value, and usage string.
< // The return value is the address of an int64 variable that stores the value of the flag.
< func (f *FlagSet) Int64(name string, value int64, usage string) *int64 {
< 	p := new(int64)
< 	f.Int64VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Int64P is like Int64, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int64P(name, shorthand string, value int64, usage string) *int64 {
< 	p := new(int64)
< 	f.Int64VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Int64 defines an int64 flag with specified name, default value, and usage string.
< // The return value is the address of an int64 variable that stores the value of the flag.
< func Int64(name string, value int64, usage string) *int64 {
< 	return CommandLine.Int64P(name, "", value, usage)
< }
< 
< // Int64P is like Int64, but accepts a shorthand letter that can be used after a single dash.
< func Int64P(name, shorthand string, value int64, usage string) *int64 {
< 	return CommandLine.Int64P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int64_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int64_slice.go
1,166d0
< package pflag
< 
< import (
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< // -- int64Slice Value
< type int64SliceValue struct {
< 	value   *[]int64
< 	changed bool
< }
< 
< func newInt64SliceValue(val []int64, p *[]int64) *int64SliceValue {
< 	isv := new(int64SliceValue)
< 	isv.value = p
< 	*isv.value = val
< 	return isv
< }
< 
< func (s *int64SliceValue) Set(val string) error {
< 	ss := strings.Split(val, ",")
< 	out := make([]int64, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		out[i], err = strconv.ParseInt(d, 0, 64)
< 		if err != nil {
< 			return err
< 		}
< 
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		*s.value = append(*s.value, out...)
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *int64SliceValue) Type() string {
< 	return "int64Slice"
< }
< 
< func (s *int64SliceValue) String() string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = fmt.Sprintf("%d", d)
< 	}
< 	return "[" + strings.Join(out, ",") + "]"
< }
< 
< func (s *int64SliceValue) fromString(val string) (int64, error) {
< 	return strconv.ParseInt(val, 0, 64)
< }
< 
< func (s *int64SliceValue) toString(val int64) string {
< 	return fmt.Sprintf("%d", val)
< }
< 
< func (s *int64SliceValue) Append(val string) error {
< 	i, err := s.fromString(val)
< 	if err != nil {
< 		return err
< 	}
< 	*s.value = append(*s.value, i)
< 	return nil
< }
< 
< func (s *int64SliceValue) Replace(val []string) error {
< 	out := make([]int64, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i], err = s.fromString(d)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *int64SliceValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = s.toString(d)
< 	}
< 	return out
< }
< 
< func int64SliceConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// Empty string would cause a slice with one (empty) entry
< 	if len(val) == 0 {
< 		return []int64{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make([]int64, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		out[i], err = strconv.ParseInt(d, 0, 64)
< 		if err != nil {
< 			return nil, err
< 		}
< 
< 	}
< 	return out, nil
< }
< 
< // GetInt64Slice return the []int64 value of a flag with the given name
< func (f *FlagSet) GetInt64Slice(name string) ([]int64, error) {
< 	val, err := f.getFlagType(name, "int64Slice", int64SliceConv)
< 	if err != nil {
< 		return []int64{}, err
< 	}
< 	return val.([]int64), nil
< }
< 
< // Int64SliceVar defines a int64Slice flag with specified name, default value, and usage string.
< // The argument p points to a []int64 variable in which to store the value of the flag.
< func (f *FlagSet) Int64SliceVar(p *[]int64, name string, value []int64, usage string) {
< 	f.VarP(newInt64SliceValue(value, p), name, "", usage)
< }
< 
< // Int64SliceVarP is like Int64SliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int64SliceVarP(p *[]int64, name, shorthand string, value []int64, usage string) {
< 	f.VarP(newInt64SliceValue(value, p), name, shorthand, usage)
< }
< 
< // Int64SliceVar defines a int64[] flag with specified name, default value, and usage string.
< // The argument p points to a int64[] variable in which to store the value of the flag.
< func Int64SliceVar(p *[]int64, name string, value []int64, usage string) {
< 	CommandLine.VarP(newInt64SliceValue(value, p), name, "", usage)
< }
< 
< // Int64SliceVarP is like Int64SliceVar, but accepts a shorthand letter that can be used after a single dash.
< func Int64SliceVarP(p *[]int64, name, shorthand string, value []int64, usage string) {
< 	CommandLine.VarP(newInt64SliceValue(value, p), name, shorthand, usage)
< }
< 
< // Int64Slice defines a []int64 flag with specified name, default value, and usage string.
< // The return value is the address of a []int64 variable that stores the value of the flag.
< func (f *FlagSet) Int64Slice(name string, value []int64, usage string) *[]int64 {
< 	p := []int64{}
< 	f.Int64SliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // Int64SliceP is like Int64Slice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int64SliceP(name, shorthand string, value []int64, usage string) *[]int64 {
< 	p := []int64{}
< 	f.Int64SliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // Int64Slice defines a []int64 flag with specified name, default value, and usage string.
< // The return value is the address of a []int64 variable that stores the value of the flag.
< func Int64Slice(name string, value []int64, usage string) *[]int64 {
< 	return CommandLine.Int64SliceP(name, "", value, usage)
< }
< 
< // Int64SliceP is like Int64Slice, but accepts a shorthand letter that can be used after a single dash.
< func Int64SliceP(name, shorthand string, value []int64, usage string) *[]int64 {
< 	return CommandLine.Int64SliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int8.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int8.go
1,88d0
< package pflag
< 
< import "strconv"
< 
< // -- int8 Value
< type int8Value int8
< 
< func newInt8Value(val int8, p *int8) *int8Value {
< 	*p = val
< 	return (*int8Value)(p)
< }
< 
< func (i *int8Value) Set(s string) error {
< 	v, err := strconv.ParseInt(s, 0, 8)
< 	*i = int8Value(v)
< 	return err
< }
< 
< func (i *int8Value) Type() string {
< 	return "int8"
< }
< 
< func (i *int8Value) String() string { return strconv.FormatInt(int64(*i), 10) }
< 
< func int8Conv(sval string) (interface{}, error) {
< 	v, err := strconv.ParseInt(sval, 0, 8)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return int8(v), nil
< }
< 
< // GetInt8 return the int8 value of a flag with the given name
< func (f *FlagSet) GetInt8(name string) (int8, error) {
< 	val, err := f.getFlagType(name, "int8", int8Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(int8), nil
< }
< 
< // Int8Var defines an int8 flag with specified name, default value, and usage string.
< // The argument p points to an int8 variable in which to store the value of the flag.
< func (f *FlagSet) Int8Var(p *int8, name string, value int8, usage string) {
< 	f.VarP(newInt8Value(value, p), name, "", usage)
< }
< 
< // Int8VarP is like Int8Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int8VarP(p *int8, name, shorthand string, value int8, usage string) {
< 	f.VarP(newInt8Value(value, p), name, shorthand, usage)
< }
< 
< // Int8Var defines an int8 flag with specified name, default value, and usage string.
< // The argument p points to an int8 variable in which to store the value of the flag.
< func Int8Var(p *int8, name string, value int8, usage string) {
< 	CommandLine.VarP(newInt8Value(value, p), name, "", usage)
< }
< 
< // Int8VarP is like Int8Var, but accepts a shorthand letter that can be used after a single dash.
< func Int8VarP(p *int8, name, shorthand string, value int8, usage string) {
< 	CommandLine.VarP(newInt8Value(value, p), name, shorthand, usage)
< }
< 
< // Int8 defines an int8 flag with specified name, default value, and usage string.
< // The return value is the address of an int8 variable that stores the value of the flag.
< func (f *FlagSet) Int8(name string, value int8, usage string) *int8 {
< 	p := new(int8)
< 	f.Int8VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Int8P is like Int8, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Int8P(name, shorthand string, value int8, usage string) *int8 {
< 	p := new(int8)
< 	f.Int8VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Int8 defines an int8 flag with specified name, default value, and usage string.
< // The return value is the address of an int8 variable that stores the value of the flag.
< func Int8(name string, value int8, usage string) *int8 {
< 	return CommandLine.Int8P(name, "", value, usage)
< }
< 
< // Int8P is like Int8, but accepts a shorthand letter that can be used after a single dash.
< func Int8P(name, shorthand string, value int8, usage string) *int8 {
< 	return CommandLine.Int8P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/int_slice.go
1,158d0
< package pflag
< 
< import (
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< // -- intSlice Value
< type intSliceValue struct {
< 	value   *[]int
< 	changed bool
< }
< 
< func newIntSliceValue(val []int, p *[]int) *intSliceValue {
< 	isv := new(intSliceValue)
< 	isv.value = p
< 	*isv.value = val
< 	return isv
< }
< 
< func (s *intSliceValue) Set(val string) error {
< 	ss := strings.Split(val, ",")
< 	out := make([]int, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		out[i], err = strconv.Atoi(d)
< 		if err != nil {
< 			return err
< 		}
< 
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		*s.value = append(*s.value, out...)
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *intSliceValue) Type() string {
< 	return "intSlice"
< }
< 
< func (s *intSliceValue) String() string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = fmt.Sprintf("%d", d)
< 	}
< 	return "[" + strings.Join(out, ",") + "]"
< }
< 
< func (s *intSliceValue) Append(val string) error {
< 	i, err := strconv.Atoi(val)
< 	if err != nil {
< 		return err
< 	}
< 	*s.value = append(*s.value, i)
< 	return nil
< }
< 
< func (s *intSliceValue) Replace(val []string) error {
< 	out := make([]int, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i], err = strconv.Atoi(d)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *intSliceValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = strconv.Itoa(d)
< 	}
< 	return out
< }
< 
< func intSliceConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// Empty string would cause a slice with one (empty) entry
< 	if len(val) == 0 {
< 		return []int{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make([]int, len(ss))
< 	for i, d := range ss {
< 		var err error
< 		out[i], err = strconv.Atoi(d)
< 		if err != nil {
< 			return nil, err
< 		}
< 
< 	}
< 	return out, nil
< }
< 
< // GetIntSlice return the []int value of a flag with the given name
< func (f *FlagSet) GetIntSlice(name string) ([]int, error) {
< 	val, err := f.getFlagType(name, "intSlice", intSliceConv)
< 	if err != nil {
< 		return []int{}, err
< 	}
< 	return val.([]int), nil
< }
< 
< // IntSliceVar defines a intSlice flag with specified name, default value, and usage string.
< // The argument p points to a []int variable in which to store the value of the flag.
< func (f *FlagSet) IntSliceVar(p *[]int, name string, value []int, usage string) {
< 	f.VarP(newIntSliceValue(value, p), name, "", usage)
< }
< 
< // IntSliceVarP is like IntSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IntSliceVarP(p *[]int, name, shorthand string, value []int, usage string) {
< 	f.VarP(newIntSliceValue(value, p), name, shorthand, usage)
< }
< 
< // IntSliceVar defines a int[] flag with specified name, default value, and usage string.
< // The argument p points to a int[] variable in which to store the value of the flag.
< func IntSliceVar(p *[]int, name string, value []int, usage string) {
< 	CommandLine.VarP(newIntSliceValue(value, p), name, "", usage)
< }
< 
< // IntSliceVarP is like IntSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func IntSliceVarP(p *[]int, name, shorthand string, value []int, usage string) {
< 	CommandLine.VarP(newIntSliceValue(value, p), name, shorthand, usage)
< }
< 
< // IntSlice defines a []int flag with specified name, default value, and usage string.
< // The return value is the address of a []int variable that stores the value of the flag.
< func (f *FlagSet) IntSlice(name string, value []int, usage string) *[]int {
< 	p := []int{}
< 	f.IntSliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // IntSliceP is like IntSlice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IntSliceP(name, shorthand string, value []int, usage string) *[]int {
< 	p := []int{}
< 	f.IntSliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // IntSlice defines a []int flag with specified name, default value, and usage string.
< // The return value is the address of a []int variable that stores the value of the flag.
< func IntSlice(name string, value []int, usage string) *[]int {
< 	return CommandLine.IntSliceP(name, "", value, usage)
< }
< 
< // IntSliceP is like IntSlice, but accepts a shorthand letter that can be used after a single dash.
< func IntSliceP(name, shorthand string, value []int, usage string) *[]int {
< 	return CommandLine.IntSliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/ip.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/ip.go
1,94d0
< package pflag
< 
< import (
< 	"fmt"
< 	"net"
< 	"strings"
< )
< 
< // -- net.IP value
< type ipValue net.IP
< 
< func newIPValue(val net.IP, p *net.IP) *ipValue {
< 	*p = val
< 	return (*ipValue)(p)
< }
< 
< func (i *ipValue) String() string { return net.IP(*i).String() }
< func (i *ipValue) Set(s string) error {
< 	ip := net.ParseIP(strings.TrimSpace(s))
< 	if ip == nil {
< 		return fmt.Errorf("failed to parse IP: %q", s)
< 	}
< 	*i = ipValue(ip)
< 	return nil
< }
< 
< func (i *ipValue) Type() string {
< 	return "ip"
< }
< 
< func ipConv(sval string) (interface{}, error) {
< 	ip := net.ParseIP(sval)
< 	if ip != nil {
< 		return ip, nil
< 	}
< 	return nil, fmt.Errorf("invalid string being converted to IP address: %s", sval)
< }
< 
< // GetIP return the net.IP value of a flag with the given name
< func (f *FlagSet) GetIP(name string) (net.IP, error) {
< 	val, err := f.getFlagType(name, "ip", ipConv)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return val.(net.IP), nil
< }
< 
< // IPVar defines an net.IP flag with specified name, default value, and usage string.
< // The argument p points to an net.IP variable in which to store the value of the flag.
< func (f *FlagSet) IPVar(p *net.IP, name string, value net.IP, usage string) {
< 	f.VarP(newIPValue(value, p), name, "", usage)
< }
< 
< // IPVarP is like IPVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IPVarP(p *net.IP, name, shorthand string, value net.IP, usage string) {
< 	f.VarP(newIPValue(value, p), name, shorthand, usage)
< }
< 
< // IPVar defines an net.IP flag with specified name, default value, and usage string.
< // The argument p points to an net.IP variable in which to store the value of the flag.
< func IPVar(p *net.IP, name string, value net.IP, usage string) {
< 	CommandLine.VarP(newIPValue(value, p), name, "", usage)
< }
< 
< // IPVarP is like IPVar, but accepts a shorthand letter that can be used after a single dash.
< func IPVarP(p *net.IP, name, shorthand string, value net.IP, usage string) {
< 	CommandLine.VarP(newIPValue(value, p), name, shorthand, usage)
< }
< 
< // IP defines an net.IP flag with specified name, default value, and usage string.
< // The return value is the address of an net.IP variable that stores the value of the flag.
< func (f *FlagSet) IP(name string, value net.IP, usage string) *net.IP {
< 	p := new(net.IP)
< 	f.IPVarP(p, name, "", value, usage)
< 	return p
< }
< 
< // IPP is like IP, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IPP(name, shorthand string, value net.IP, usage string) *net.IP {
< 	p := new(net.IP)
< 	f.IPVarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // IP defines an net.IP flag with specified name, default value, and usage string.
< // The return value is the address of an net.IP variable that stores the value of the flag.
< func IP(name string, value net.IP, usage string) *net.IP {
< 	return CommandLine.IPP(name, "", value, usage)
< }
< 
< // IPP is like IP, but accepts a shorthand letter that can be used after a single dash.
< func IPP(name, shorthand string, value net.IP, usage string) *net.IP {
< 	return CommandLine.IPP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/ip_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/ip_slice.go
1,186d0
< package pflag
< 
< import (
< 	"fmt"
< 	"io"
< 	"net"
< 	"strings"
< )
< 
< // -- ipSlice Value
< type ipSliceValue struct {
< 	value   *[]net.IP
< 	changed bool
< }
< 
< func newIPSliceValue(val []net.IP, p *[]net.IP) *ipSliceValue {
< 	ipsv := new(ipSliceValue)
< 	ipsv.value = p
< 	*ipsv.value = val
< 	return ipsv
< }
< 
< // Set converts, and assigns, the comma-separated IP argument string representation as the []net.IP value of this flag.
< // If Set is called on a flag that already has a []net.IP assigned, the newly converted values will be appended.
< func (s *ipSliceValue) Set(val string) error {
< 
< 	// remove all quote characters
< 	rmQuote := strings.NewReplacer(`"`, "", `'`, "", "`", "")
< 
< 	// read flag arguments with CSV parser
< 	ipStrSlice, err := readAsCSV(rmQuote.Replace(val))
< 	if err != nil && err != io.EOF {
< 		return err
< 	}
< 
< 	// parse ip values into slice
< 	out := make([]net.IP, 0, len(ipStrSlice))
< 	for _, ipStr := range ipStrSlice {
< 		ip := net.ParseIP(strings.TrimSpace(ipStr))
< 		if ip == nil {
< 			return fmt.Errorf("invalid string being converted to IP address: %s", ipStr)
< 		}
< 		out = append(out, ip)
< 	}
< 
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		*s.value = append(*s.value, out...)
< 	}
< 
< 	s.changed = true
< 
< 	return nil
< }
< 
< // Type returns a string that uniquely represents this flag's type.
< func (s *ipSliceValue) Type() string {
< 	return "ipSlice"
< }
< 
< // String defines a "native" format for this net.IP slice flag value.
< func (s *ipSliceValue) String() string {
< 
< 	ipStrSlice := make([]string, len(*s.value))
< 	for i, ip := range *s.value {
< 		ipStrSlice[i] = ip.String()
< 	}
< 
< 	out, _ := writeAsCSV(ipStrSlice)
< 
< 	return "[" + out + "]"
< }
< 
< func (s *ipSliceValue) fromString(val string) (net.IP, error) {
< 	return net.ParseIP(strings.TrimSpace(val)), nil
< }
< 
< func (s *ipSliceValue) toString(val net.IP) string {
< 	return val.String()
< }
< 
< func (s *ipSliceValue) Append(val string) error {
< 	i, err := s.fromString(val)
< 	if err != nil {
< 		return err
< 	}
< 	*s.value = append(*s.value, i)
< 	return nil
< }
< 
< func (s *ipSliceValue) Replace(val []string) error {
< 	out := make([]net.IP, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i], err = s.fromString(d)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *ipSliceValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = s.toString(d)
< 	}
< 	return out
< }
< 
< func ipSliceConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// Empty string would cause a slice with one (empty) entry
< 	if len(val) == 0 {
< 		return []net.IP{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make([]net.IP, len(ss))
< 	for i, sval := range ss {
< 		ip := net.ParseIP(strings.TrimSpace(sval))
< 		if ip == nil {
< 			return nil, fmt.Errorf("invalid string being converted to IP address: %s", sval)
< 		}
< 		out[i] = ip
< 	}
< 	return out, nil
< }
< 
< // GetIPSlice returns the []net.IP value of a flag with the given name
< func (f *FlagSet) GetIPSlice(name string) ([]net.IP, error) {
< 	val, err := f.getFlagType(name, "ipSlice", ipSliceConv)
< 	if err != nil {
< 		return []net.IP{}, err
< 	}
< 	return val.([]net.IP), nil
< }
< 
< // IPSliceVar defines a ipSlice flag with specified name, default value, and usage string.
< // The argument p points to a []net.IP variable in which to store the value of the flag.
< func (f *FlagSet) IPSliceVar(p *[]net.IP, name string, value []net.IP, usage string) {
< 	f.VarP(newIPSliceValue(value, p), name, "", usage)
< }
< 
< // IPSliceVarP is like IPSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IPSliceVarP(p *[]net.IP, name, shorthand string, value []net.IP, usage string) {
< 	f.VarP(newIPSliceValue(value, p), name, shorthand, usage)
< }
< 
< // IPSliceVar defines a []net.IP flag with specified name, default value, and usage string.
< // The argument p points to a []net.IP variable in which to store the value of the flag.
< func IPSliceVar(p *[]net.IP, name string, value []net.IP, usage string) {
< 	CommandLine.VarP(newIPSliceValue(value, p), name, "", usage)
< }
< 
< // IPSliceVarP is like IPSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func IPSliceVarP(p *[]net.IP, name, shorthand string, value []net.IP, usage string) {
< 	CommandLine.VarP(newIPSliceValue(value, p), name, shorthand, usage)
< }
< 
< // IPSlice defines a []net.IP flag with specified name, default value, and usage string.
< // The return value is the address of a []net.IP variable that stores the value of that flag.
< func (f *FlagSet) IPSlice(name string, value []net.IP, usage string) *[]net.IP {
< 	p := []net.IP{}
< 	f.IPSliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // IPSliceP is like IPSlice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IPSliceP(name, shorthand string, value []net.IP, usage string) *[]net.IP {
< 	p := []net.IP{}
< 	f.IPSliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // IPSlice defines a []net.IP flag with specified name, default value, and usage string.
< // The return value is the address of a []net.IP variable that stores the value of the flag.
< func IPSlice(name string, value []net.IP, usage string) *[]net.IP {
< 	return CommandLine.IPSliceP(name, "", value, usage)
< }
< 
< // IPSliceP is like IPSlice, but accepts a shorthand letter that can be used after a single dash.
< func IPSliceP(name, shorthand string, value []net.IP, usage string) *[]net.IP {
< 	return CommandLine.IPSliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/ipmask.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/ipmask.go
1,122d0
< package pflag
< 
< import (
< 	"fmt"
< 	"net"
< 	"strconv"
< )
< 
< // -- net.IPMask value
< type ipMaskValue net.IPMask
< 
< func newIPMaskValue(val net.IPMask, p *net.IPMask) *ipMaskValue {
< 	*p = val
< 	return (*ipMaskValue)(p)
< }
< 
< func (i *ipMaskValue) String() string { return net.IPMask(*i).String() }
< func (i *ipMaskValue) Set(s string) error {
< 	ip := ParseIPv4Mask(s)
< 	if ip == nil {
< 		return fmt.Errorf("failed to parse IP mask: %q", s)
< 	}
< 	*i = ipMaskValue(ip)
< 	return nil
< }
< 
< func (i *ipMaskValue) Type() string {
< 	return "ipMask"
< }
< 
< // ParseIPv4Mask written in IP form (e.g. 255.255.255.0).
< // This function should really belong to the net package.
< func ParseIPv4Mask(s string) net.IPMask {
< 	mask := net.ParseIP(s)
< 	if mask == nil {
< 		if len(s) != 8 {
< 			return nil
< 		}
< 		// net.IPMask.String() actually outputs things like ffffff00
< 		// so write a horrible parser for that as well  :-(
< 		m := []int{}
< 		for i := 0; i < 4; i++ {
< 			b := "0x" + s[2*i:2*i+2]
< 			d, err := strconv.ParseInt(b, 0, 0)
< 			if err != nil {
< 				return nil
< 			}
< 			m = append(m, int(d))
< 		}
< 		s := fmt.Sprintf("%d.%d.%d.%d", m[0], m[1], m[2], m[3])
< 		mask = net.ParseIP(s)
< 		if mask == nil {
< 			return nil
< 		}
< 	}
< 	return net.IPv4Mask(mask[12], mask[13], mask[14], mask[15])
< }
< 
< func parseIPv4Mask(sval string) (interface{}, error) {
< 	mask := ParseIPv4Mask(sval)
< 	if mask == nil {
< 		return nil, fmt.Errorf("unable to parse %s as net.IPMask", sval)
< 	}
< 	return mask, nil
< }
< 
< // GetIPv4Mask return the net.IPv4Mask value of a flag with the given name
< func (f *FlagSet) GetIPv4Mask(name string) (net.IPMask, error) {
< 	val, err := f.getFlagType(name, "ipMask", parseIPv4Mask)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return val.(net.IPMask), nil
< }
< 
< // IPMaskVar defines an net.IPMask flag with specified name, default value, and usage string.
< // The argument p points to an net.IPMask variable in which to store the value of the flag.
< func (f *FlagSet) IPMaskVar(p *net.IPMask, name string, value net.IPMask, usage string) {
< 	f.VarP(newIPMaskValue(value, p), name, "", usage)
< }
< 
< // IPMaskVarP is like IPMaskVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IPMaskVarP(p *net.IPMask, name, shorthand string, value net.IPMask, usage string) {
< 	f.VarP(newIPMaskValue(value, p), name, shorthand, usage)
< }
< 
< // IPMaskVar defines an net.IPMask flag with specified name, default value, and usage string.
< // The argument p points to an net.IPMask variable in which to store the value of the flag.
< func IPMaskVar(p *net.IPMask, name string, value net.IPMask, usage string) {
< 	CommandLine.VarP(newIPMaskValue(value, p), name, "", usage)
< }
< 
< // IPMaskVarP is like IPMaskVar, but accepts a shorthand letter that can be used after a single dash.
< func IPMaskVarP(p *net.IPMask, name, shorthand string, value net.IPMask, usage string) {
< 	CommandLine.VarP(newIPMaskValue(value, p), name, shorthand, usage)
< }
< 
< // IPMask defines an net.IPMask flag with specified name, default value, and usage string.
< // The return value is the address of an net.IPMask variable that stores the value of the flag.
< func (f *FlagSet) IPMask(name string, value net.IPMask, usage string) *net.IPMask {
< 	p := new(net.IPMask)
< 	f.IPMaskVarP(p, name, "", value, usage)
< 	return p
< }
< 
< // IPMaskP is like IPMask, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IPMaskP(name, shorthand string, value net.IPMask, usage string) *net.IPMask {
< 	p := new(net.IPMask)
< 	f.IPMaskVarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // IPMask defines an net.IPMask flag with specified name, default value, and usage string.
< // The return value is the address of an net.IPMask variable that stores the value of the flag.
< func IPMask(name string, value net.IPMask, usage string) *net.IPMask {
< 	return CommandLine.IPMaskP(name, "", value, usage)
< }
< 
< // IPMaskP is like IP, but accepts a shorthand letter that can be used after a single dash.
< func IPMaskP(name, shorthand string, value net.IPMask, usage string) *net.IPMask {
< 	return CommandLine.IPMaskP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/ipnet.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/ipnet.go
1,98d0
< package pflag
< 
< import (
< 	"fmt"
< 	"net"
< 	"strings"
< )
< 
< // IPNet adapts net.IPNet for use as a flag.
< type ipNetValue net.IPNet
< 
< func (ipnet ipNetValue) String() string {
< 	n := net.IPNet(ipnet)
< 	return n.String()
< }
< 
< func (ipnet *ipNetValue) Set(value string) error {
< 	_, n, err := net.ParseCIDR(strings.TrimSpace(value))
< 	if err != nil {
< 		return err
< 	}
< 	*ipnet = ipNetValue(*n)
< 	return nil
< }
< 
< func (*ipNetValue) Type() string {
< 	return "ipNet"
< }
< 
< func newIPNetValue(val net.IPNet, p *net.IPNet) *ipNetValue {
< 	*p = val
< 	return (*ipNetValue)(p)
< }
< 
< func ipNetConv(sval string) (interface{}, error) {
< 	_, n, err := net.ParseCIDR(strings.TrimSpace(sval))
< 	if err == nil {
< 		return *n, nil
< 	}
< 	return nil, fmt.Errorf("invalid string being converted to IPNet: %s", sval)
< }
< 
< // GetIPNet return the net.IPNet value of a flag with the given name
< func (f *FlagSet) GetIPNet(name string) (net.IPNet, error) {
< 	val, err := f.getFlagType(name, "ipNet", ipNetConv)
< 	if err != nil {
< 		return net.IPNet{}, err
< 	}
< 	return val.(net.IPNet), nil
< }
< 
< // IPNetVar defines an net.IPNet flag with specified name, default value, and usage string.
< // The argument p points to an net.IPNet variable in which to store the value of the flag.
< func (f *FlagSet) IPNetVar(p *net.IPNet, name string, value net.IPNet, usage string) {
< 	f.VarP(newIPNetValue(value, p), name, "", usage)
< }
< 
< // IPNetVarP is like IPNetVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IPNetVarP(p *net.IPNet, name, shorthand string, value net.IPNet, usage string) {
< 	f.VarP(newIPNetValue(value, p), name, shorthand, usage)
< }
< 
< // IPNetVar defines an net.IPNet flag with specified name, default value, and usage string.
< // The argument p points to an net.IPNet variable in which to store the value of the flag.
< func IPNetVar(p *net.IPNet, name string, value net.IPNet, usage string) {
< 	CommandLine.VarP(newIPNetValue(value, p), name, "", usage)
< }
< 
< // IPNetVarP is like IPNetVar, but accepts a shorthand letter that can be used after a single dash.
< func IPNetVarP(p *net.IPNet, name, shorthand string, value net.IPNet, usage string) {
< 	CommandLine.VarP(newIPNetValue(value, p), name, shorthand, usage)
< }
< 
< // IPNet defines an net.IPNet flag with specified name, default value, and usage string.
< // The return value is the address of an net.IPNet variable that stores the value of the flag.
< func (f *FlagSet) IPNet(name string, value net.IPNet, usage string) *net.IPNet {
< 	p := new(net.IPNet)
< 	f.IPNetVarP(p, name, "", value, usage)
< 	return p
< }
< 
< // IPNetP is like IPNet, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) IPNetP(name, shorthand string, value net.IPNet, usage string) *net.IPNet {
< 	p := new(net.IPNet)
< 	f.IPNetVarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // IPNet defines an net.IPNet flag with specified name, default value, and usage string.
< // The return value is the address of an net.IPNet variable that stores the value of the flag.
< func IPNet(name string, value net.IPNet, usage string) *net.IPNet {
< 	return CommandLine.IPNetP(name, "", value, usage)
< }
< 
< // IPNetP is like IPNet, but accepts a shorthand letter that can be used after a single dash.
< func IPNetP(name, shorthand string, value net.IPNet, usage string) *net.IPNet {
< 	return CommandLine.IPNetP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string.go
1,80d0
< package pflag
< 
< // -- string Value
< type stringValue string
< 
< func newStringValue(val string, p *string) *stringValue {
< 	*p = val
< 	return (*stringValue)(p)
< }
< 
< func (s *stringValue) Set(val string) error {
< 	*s = stringValue(val)
< 	return nil
< }
< func (s *stringValue) Type() string {
< 	return "string"
< }
< 
< func (s *stringValue) String() string { return string(*s) }
< 
< func stringConv(sval string) (interface{}, error) {
< 	return sval, nil
< }
< 
< // GetString return the string value of a flag with the given name
< func (f *FlagSet) GetString(name string) (string, error) {
< 	val, err := f.getFlagType(name, "string", stringConv)
< 	if err != nil {
< 		return "", err
< 	}
< 	return val.(string), nil
< }
< 
< // StringVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a string variable in which to store the value of the flag.
< func (f *FlagSet) StringVar(p *string, name string, value string, usage string) {
< 	f.VarP(newStringValue(value, p), name, "", usage)
< }
< 
< // StringVarP is like StringVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringVarP(p *string, name, shorthand string, value string, usage string) {
< 	f.VarP(newStringValue(value, p), name, shorthand, usage)
< }
< 
< // StringVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a string variable in which to store the value of the flag.
< func StringVar(p *string, name string, value string, usage string) {
< 	CommandLine.VarP(newStringValue(value, p), name, "", usage)
< }
< 
< // StringVarP is like StringVar, but accepts a shorthand letter that can be used after a single dash.
< func StringVarP(p *string, name, shorthand string, value string, usage string) {
< 	CommandLine.VarP(newStringValue(value, p), name, shorthand, usage)
< }
< 
< // String defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a string variable that stores the value of the flag.
< func (f *FlagSet) String(name string, value string, usage string) *string {
< 	p := new(string)
< 	f.StringVarP(p, name, "", value, usage)
< 	return p
< }
< 
< // StringP is like String, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringP(name, shorthand string, value string, usage string) *string {
< 	p := new(string)
< 	f.StringVarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // String defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a string variable that stores the value of the flag.
< func String(name string, value string, usage string) *string {
< 	return CommandLine.StringP(name, "", value, usage)
< }
< 
< // StringP is like String, but accepts a shorthand letter that can be used after a single dash.
< func StringP(name, shorthand string, value string, usage string) *string {
< 	return CommandLine.StringP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_array.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_array.go
1,129d0
< package pflag
< 
< // -- stringArray Value
< type stringArrayValue struct {
< 	value   *[]string
< 	changed bool
< }
< 
< func newStringArrayValue(val []string, p *[]string) *stringArrayValue {
< 	ssv := new(stringArrayValue)
< 	ssv.value = p
< 	*ssv.value = val
< 	return ssv
< }
< 
< func (s *stringArrayValue) Set(val string) error {
< 	if !s.changed {
< 		*s.value = []string{val}
< 		s.changed = true
< 	} else {
< 		*s.value = append(*s.value, val)
< 	}
< 	return nil
< }
< 
< func (s *stringArrayValue) Append(val string) error {
< 	*s.value = append(*s.value, val)
< 	return nil
< }
< 
< func (s *stringArrayValue) Replace(val []string) error {
< 	out := make([]string, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i] = d
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *stringArrayValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = d
< 	}
< 	return out
< }
< 
< func (s *stringArrayValue) Type() string {
< 	return "stringArray"
< }
< 
< func (s *stringArrayValue) String() string {
< 	str, _ := writeAsCSV(*s.value)
< 	return "[" + str + "]"
< }
< 
< func stringArrayConv(sval string) (interface{}, error) {
< 	sval = sval[1 : len(sval)-1]
< 	// An empty string would cause a array with one (empty) string
< 	if len(sval) == 0 {
< 		return []string{}, nil
< 	}
< 	return readAsCSV(sval)
< }
< 
< // GetStringArray return the []string value of a flag with the given name
< func (f *FlagSet) GetStringArray(name string) ([]string, error) {
< 	val, err := f.getFlagType(name, "stringArray", stringArrayConv)
< 	if err != nil {
< 		return []string{}, err
< 	}
< 	return val.([]string), nil
< }
< 
< // StringArrayVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a []string variable in which to store the values of the multiple flags.
< // The value of each argument will not try to be separated by comma. Use a StringSlice for that.
< func (f *FlagSet) StringArrayVar(p *[]string, name string, value []string, usage string) {
< 	f.VarP(newStringArrayValue(value, p), name, "", usage)
< }
< 
< // StringArrayVarP is like StringArrayVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringArrayVarP(p *[]string, name, shorthand string, value []string, usage string) {
< 	f.VarP(newStringArrayValue(value, p), name, shorthand, usage)
< }
< 
< // StringArrayVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a []string variable in which to store the value of the flag.
< // The value of each argument will not try to be separated by comma. Use a StringSlice for that.
< func StringArrayVar(p *[]string, name string, value []string, usage string) {
< 	CommandLine.VarP(newStringArrayValue(value, p), name, "", usage)
< }
< 
< // StringArrayVarP is like StringArrayVar, but accepts a shorthand letter that can be used after a single dash.
< func StringArrayVarP(p *[]string, name, shorthand string, value []string, usage string) {
< 	CommandLine.VarP(newStringArrayValue(value, p), name, shorthand, usage)
< }
< 
< // StringArray defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a []string variable that stores the value of the flag.
< // The value of each argument will not try to be separated by comma. Use a StringSlice for that.
< func (f *FlagSet) StringArray(name string, value []string, usage string) *[]string {
< 	p := []string{}
< 	f.StringArrayVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // StringArrayP is like StringArray, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringArrayP(name, shorthand string, value []string, usage string) *[]string {
< 	p := []string{}
< 	f.StringArrayVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // StringArray defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a []string variable that stores the value of the flag.
< // The value of each argument will not try to be separated by comma. Use a StringSlice for that.
< func StringArray(name string, value []string, usage string) *[]string {
< 	return CommandLine.StringArrayP(name, "", value, usage)
< }
< 
< // StringArrayP is like StringArray, but accepts a shorthand letter that can be used after a single dash.
< func StringArrayP(name, shorthand string, value []string, usage string) *[]string {
< 	return CommandLine.StringArrayP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_slice.go
1,163d0
< package pflag
< 
< import (
< 	"bytes"
< 	"encoding/csv"
< 	"strings"
< )
< 
< // -- stringSlice Value
< type stringSliceValue struct {
< 	value   *[]string
< 	changed bool
< }
< 
< func newStringSliceValue(val []string, p *[]string) *stringSliceValue {
< 	ssv := new(stringSliceValue)
< 	ssv.value = p
< 	*ssv.value = val
< 	return ssv
< }
< 
< func readAsCSV(val string) ([]string, error) {
< 	if val == "" {
< 		return []string{}, nil
< 	}
< 	stringReader := strings.NewReader(val)
< 	csvReader := csv.NewReader(stringReader)
< 	return csvReader.Read()
< }
< 
< func writeAsCSV(vals []string) (string, error) {
< 	b := &bytes.Buffer{}
< 	w := csv.NewWriter(b)
< 	err := w.Write(vals)
< 	if err != nil {
< 		return "", err
< 	}
< 	w.Flush()
< 	return strings.TrimSuffix(b.String(), "\n"), nil
< }
< 
< func (s *stringSliceValue) Set(val string) error {
< 	v, err := readAsCSV(val)
< 	if err != nil {
< 		return err
< 	}
< 	if !s.changed {
< 		*s.value = v
< 	} else {
< 		*s.value = append(*s.value, v...)
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *stringSliceValue) Type() string {
< 	return "stringSlice"
< }
< 
< func (s *stringSliceValue) String() string {
< 	str, _ := writeAsCSV(*s.value)
< 	return "[" + str + "]"
< }
< 
< func (s *stringSliceValue) Append(val string) error {
< 	*s.value = append(*s.value, val)
< 	return nil
< }
< 
< func (s *stringSliceValue) Replace(val []string) error {
< 	*s.value = val
< 	return nil
< }
< 
< func (s *stringSliceValue) GetSlice() []string {
< 	return *s.value
< }
< 
< func stringSliceConv(sval string) (interface{}, error) {
< 	sval = sval[1 : len(sval)-1]
< 	// An empty string would cause a slice with one (empty) string
< 	if len(sval) == 0 {
< 		return []string{}, nil
< 	}
< 	return readAsCSV(sval)
< }
< 
< // GetStringSlice return the []string value of a flag with the given name
< func (f *FlagSet) GetStringSlice(name string) ([]string, error) {
< 	val, err := f.getFlagType(name, "stringSlice", stringSliceConv)
< 	if err != nil {
< 		return []string{}, err
< 	}
< 	return val.([]string), nil
< }
< 
< // StringSliceVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a []string variable in which to store the value of the flag.
< // Compared to StringArray flags, StringSlice flags take comma-separated value as arguments and split them accordingly.
< // For example:
< //   --ss="v1,v2" --ss="v3"
< // will result in
< //   []string{"v1", "v2", "v3"}
< func (f *FlagSet) StringSliceVar(p *[]string, name string, value []string, usage string) {
< 	f.VarP(newStringSliceValue(value, p), name, "", usage)
< }
< 
< // StringSliceVarP is like StringSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringSliceVarP(p *[]string, name, shorthand string, value []string, usage string) {
< 	f.VarP(newStringSliceValue(value, p), name, shorthand, usage)
< }
< 
< // StringSliceVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a []string variable in which to store the value of the flag.
< // Compared to StringArray flags, StringSlice flags take comma-separated value as arguments and split them accordingly.
< // For example:
< //   --ss="v1,v2" --ss="v3"
< // will result in
< //   []string{"v1", "v2", "v3"}
< func StringSliceVar(p *[]string, name string, value []string, usage string) {
< 	CommandLine.VarP(newStringSliceValue(value, p), name, "", usage)
< }
< 
< // StringSliceVarP is like StringSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func StringSliceVarP(p *[]string, name, shorthand string, value []string, usage string) {
< 	CommandLine.VarP(newStringSliceValue(value, p), name, shorthand, usage)
< }
< 
< // StringSlice defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a []string variable that stores the value of the flag.
< // Compared to StringArray flags, StringSlice flags take comma-separated value as arguments and split them accordingly.
< // For example:
< //   --ss="v1,v2" --ss="v3"
< // will result in
< //   []string{"v1", "v2", "v3"}
< func (f *FlagSet) StringSlice(name string, value []string, usage string) *[]string {
< 	p := []string{}
< 	f.StringSliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // StringSliceP is like StringSlice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringSliceP(name, shorthand string, value []string, usage string) *[]string {
< 	p := []string{}
< 	f.StringSliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // StringSlice defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a []string variable that stores the value of the flag.
< // Compared to StringArray flags, StringSlice flags take comma-separated value as arguments and split them accordingly.
< // For example:
< //   --ss="v1,v2" --ss="v3"
< // will result in
< //   []string{"v1", "v2", "v3"}
< func StringSlice(name string, value []string, usage string) *[]string {
< 	return CommandLine.StringSliceP(name, "", value, usage)
< }
< 
< // StringSliceP is like StringSlice, but accepts a shorthand letter that can be used after a single dash.
< func StringSliceP(name, shorthand string, value []string, usage string) *[]string {
< 	return CommandLine.StringSliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_to_int.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_to_int.go
1,149d0
< package pflag
< 
< import (
< 	"bytes"
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< // -- stringToInt Value
< type stringToIntValue struct {
< 	value   *map[string]int
< 	changed bool
< }
< 
< func newStringToIntValue(val map[string]int, p *map[string]int) *stringToIntValue {
< 	ssv := new(stringToIntValue)
< 	ssv.value = p
< 	*ssv.value = val
< 	return ssv
< }
< 
< // Format: a=1,b=2
< func (s *stringToIntValue) Set(val string) error {
< 	ss := strings.Split(val, ",")
< 	out := make(map[string]int, len(ss))
< 	for _, pair := range ss {
< 		kv := strings.SplitN(pair, "=", 2)
< 		if len(kv) != 2 {
< 			return fmt.Errorf("%s must be formatted as key=value", pair)
< 		}
< 		var err error
< 		out[kv[0]], err = strconv.Atoi(kv[1])
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		for k, v := range out {
< 			(*s.value)[k] = v
< 		}
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *stringToIntValue) Type() string {
< 	return "stringToInt"
< }
< 
< func (s *stringToIntValue) String() string {
< 	var buf bytes.Buffer
< 	i := 0
< 	for k, v := range *s.value {
< 		if i > 0 {
< 			buf.WriteRune(',')
< 		}
< 		buf.WriteString(k)
< 		buf.WriteRune('=')
< 		buf.WriteString(strconv.Itoa(v))
< 		i++
< 	}
< 	return "[" + buf.String() + "]"
< }
< 
< func stringToIntConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// An empty string would cause an empty map
< 	if len(val) == 0 {
< 		return map[string]int{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make(map[string]int, len(ss))
< 	for _, pair := range ss {
< 		kv := strings.SplitN(pair, "=", 2)
< 		if len(kv) != 2 {
< 			return nil, fmt.Errorf("%s must be formatted as key=value", pair)
< 		}
< 		var err error
< 		out[kv[0]], err = strconv.Atoi(kv[1])
< 		if err != nil {
< 			return nil, err
< 		}
< 	}
< 	return out, nil
< }
< 
< // GetStringToInt return the map[string]int value of a flag with the given name
< func (f *FlagSet) GetStringToInt(name string) (map[string]int, error) {
< 	val, err := f.getFlagType(name, "stringToInt", stringToIntConv)
< 	if err != nil {
< 		return map[string]int{}, err
< 	}
< 	return val.(map[string]int), nil
< }
< 
< // StringToIntVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a map[string]int variable in which to store the values of the multiple flags.
< // The value of each argument will not try to be separated by comma
< func (f *FlagSet) StringToIntVar(p *map[string]int, name string, value map[string]int, usage string) {
< 	f.VarP(newStringToIntValue(value, p), name, "", usage)
< }
< 
< // StringToIntVarP is like StringToIntVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringToIntVarP(p *map[string]int, name, shorthand string, value map[string]int, usage string) {
< 	f.VarP(newStringToIntValue(value, p), name, shorthand, usage)
< }
< 
< // StringToIntVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a map[string]int variable in which to store the value of the flag.
< // The value of each argument will not try to be separated by comma
< func StringToIntVar(p *map[string]int, name string, value map[string]int, usage string) {
< 	CommandLine.VarP(newStringToIntValue(value, p), name, "", usage)
< }
< 
< // StringToIntVarP is like StringToIntVar, but accepts a shorthand letter that can be used after a single dash.
< func StringToIntVarP(p *map[string]int, name, shorthand string, value map[string]int, usage string) {
< 	CommandLine.VarP(newStringToIntValue(value, p), name, shorthand, usage)
< }
< 
< // StringToInt defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a map[string]int variable that stores the value of the flag.
< // The value of each argument will not try to be separated by comma
< func (f *FlagSet) StringToInt(name string, value map[string]int, usage string) *map[string]int {
< 	p := map[string]int{}
< 	f.StringToIntVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // StringToIntP is like StringToInt, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringToIntP(name, shorthand string, value map[string]int, usage string) *map[string]int {
< 	p := map[string]int{}
< 	f.StringToIntVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // StringToInt defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a map[string]int variable that stores the value of the flag.
< // The value of each argument will not try to be separated by comma
< func StringToInt(name string, value map[string]int, usage string) *map[string]int {
< 	return CommandLine.StringToIntP(name, "", value, usage)
< }
< 
< // StringToIntP is like StringToInt, but accepts a shorthand letter that can be used after a single dash.
< func StringToIntP(name, shorthand string, value map[string]int, usage string) *map[string]int {
< 	return CommandLine.StringToIntP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_to_int64.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_to_int64.go
1,149d0
< package pflag
< 
< import (
< 	"bytes"
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< // -- stringToInt64 Value
< type stringToInt64Value struct {
< 	value   *map[string]int64
< 	changed bool
< }
< 
< func newStringToInt64Value(val map[string]int64, p *map[string]int64) *stringToInt64Value {
< 	ssv := new(stringToInt64Value)
< 	ssv.value = p
< 	*ssv.value = val
< 	return ssv
< }
< 
< // Format: a=1,b=2
< func (s *stringToInt64Value) Set(val string) error {
< 	ss := strings.Split(val, ",")
< 	out := make(map[string]int64, len(ss))
< 	for _, pair := range ss {
< 		kv := strings.SplitN(pair, "=", 2)
< 		if len(kv) != 2 {
< 			return fmt.Errorf("%s must be formatted as key=value", pair)
< 		}
< 		var err error
< 		out[kv[0]], err = strconv.ParseInt(kv[1], 10, 64)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		for k, v := range out {
< 			(*s.value)[k] = v
< 		}
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *stringToInt64Value) Type() string {
< 	return "stringToInt64"
< }
< 
< func (s *stringToInt64Value) String() string {
< 	var buf bytes.Buffer
< 	i := 0
< 	for k, v := range *s.value {
< 		if i > 0 {
< 			buf.WriteRune(',')
< 		}
< 		buf.WriteString(k)
< 		buf.WriteRune('=')
< 		buf.WriteString(strconv.FormatInt(v, 10))
< 		i++
< 	}
< 	return "[" + buf.String() + "]"
< }
< 
< func stringToInt64Conv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// An empty string would cause an empty map
< 	if len(val) == 0 {
< 		return map[string]int64{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make(map[string]int64, len(ss))
< 	for _, pair := range ss {
< 		kv := strings.SplitN(pair, "=", 2)
< 		if len(kv) != 2 {
< 			return nil, fmt.Errorf("%s must be formatted as key=value", pair)
< 		}
< 		var err error
< 		out[kv[0]], err = strconv.ParseInt(kv[1], 10, 64)
< 		if err != nil {
< 			return nil, err
< 		}
< 	}
< 	return out, nil
< }
< 
< // GetStringToInt64 return the map[string]int64 value of a flag with the given name
< func (f *FlagSet) GetStringToInt64(name string) (map[string]int64, error) {
< 	val, err := f.getFlagType(name, "stringToInt64", stringToInt64Conv)
< 	if err != nil {
< 		return map[string]int64{}, err
< 	}
< 	return val.(map[string]int64), nil
< }
< 
< // StringToInt64Var defines a string flag with specified name, default value, and usage string.
< // The argument p point64s to a map[string]int64 variable in which to store the values of the multiple flags.
< // The value of each argument will not try to be separated by comma
< func (f *FlagSet) StringToInt64Var(p *map[string]int64, name string, value map[string]int64, usage string) {
< 	f.VarP(newStringToInt64Value(value, p), name, "", usage)
< }
< 
< // StringToInt64VarP is like StringToInt64Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringToInt64VarP(p *map[string]int64, name, shorthand string, value map[string]int64, usage string) {
< 	f.VarP(newStringToInt64Value(value, p), name, shorthand, usage)
< }
< 
< // StringToInt64Var defines a string flag with specified name, default value, and usage string.
< // The argument p point64s to a map[string]int64 variable in which to store the value of the flag.
< // The value of each argument will not try to be separated by comma
< func StringToInt64Var(p *map[string]int64, name string, value map[string]int64, usage string) {
< 	CommandLine.VarP(newStringToInt64Value(value, p), name, "", usage)
< }
< 
< // StringToInt64VarP is like StringToInt64Var, but accepts a shorthand letter that can be used after a single dash.
< func StringToInt64VarP(p *map[string]int64, name, shorthand string, value map[string]int64, usage string) {
< 	CommandLine.VarP(newStringToInt64Value(value, p), name, shorthand, usage)
< }
< 
< // StringToInt64 defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a map[string]int64 variable that stores the value of the flag.
< // The value of each argument will not try to be separated by comma
< func (f *FlagSet) StringToInt64(name string, value map[string]int64, usage string) *map[string]int64 {
< 	p := map[string]int64{}
< 	f.StringToInt64VarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // StringToInt64P is like StringToInt64, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringToInt64P(name, shorthand string, value map[string]int64, usage string) *map[string]int64 {
< 	p := map[string]int64{}
< 	f.StringToInt64VarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // StringToInt64 defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a map[string]int64 variable that stores the value of the flag.
< // The value of each argument will not try to be separated by comma
< func StringToInt64(name string, value map[string]int64, usage string) *map[string]int64 {
< 	return CommandLine.StringToInt64P(name, "", value, usage)
< }
< 
< // StringToInt64P is like StringToInt64, but accepts a shorthand letter that can be used after a single dash.
< func StringToInt64P(name, shorthand string, value map[string]int64, usage string) *map[string]int64 {
< 	return CommandLine.StringToInt64P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_to_string.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/string_to_string.go
1,160d0
< package pflag
< 
< import (
< 	"bytes"
< 	"encoding/csv"
< 	"fmt"
< 	"strings"
< )
< 
< // -- stringToString Value
< type stringToStringValue struct {
< 	value   *map[string]string
< 	changed bool
< }
< 
< func newStringToStringValue(val map[string]string, p *map[string]string) *stringToStringValue {
< 	ssv := new(stringToStringValue)
< 	ssv.value = p
< 	*ssv.value = val
< 	return ssv
< }
< 
< // Format: a=1,b=2
< func (s *stringToStringValue) Set(val string) error {
< 	var ss []string
< 	n := strings.Count(val, "=")
< 	switch n {
< 	case 0:
< 		return fmt.Errorf("%s must be formatted as key=value", val)
< 	case 1:
< 		ss = append(ss, strings.Trim(val, `"`))
< 	default:
< 		r := csv.NewReader(strings.NewReader(val))
< 		var err error
< 		ss, err = r.Read()
< 		if err != nil {
< 			return err
< 		}
< 	}
< 
< 	out := make(map[string]string, len(ss))
< 	for _, pair := range ss {
< 		kv := strings.SplitN(pair, "=", 2)
< 		if len(kv) != 2 {
< 			return fmt.Errorf("%s must be formatted as key=value", pair)
< 		}
< 		out[kv[0]] = kv[1]
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		for k, v := range out {
< 			(*s.value)[k] = v
< 		}
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *stringToStringValue) Type() string {
< 	return "stringToString"
< }
< 
< func (s *stringToStringValue) String() string {
< 	records := make([]string, 0, len(*s.value)>>1)
< 	for k, v := range *s.value {
< 		records = append(records, k+"="+v)
< 	}
< 
< 	var buf bytes.Buffer
< 	w := csv.NewWriter(&buf)
< 	if err := w.Write(records); err != nil {
< 		panic(err)
< 	}
< 	w.Flush()
< 	return "[" + strings.TrimSpace(buf.String()) + "]"
< }
< 
< func stringToStringConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// An empty string would cause an empty map
< 	if len(val) == 0 {
< 		return map[string]string{}, nil
< 	}
< 	r := csv.NewReader(strings.NewReader(val))
< 	ss, err := r.Read()
< 	if err != nil {
< 		return nil, err
< 	}
< 	out := make(map[string]string, len(ss))
< 	for _, pair := range ss {
< 		kv := strings.SplitN(pair, "=", 2)
< 		if len(kv) != 2 {
< 			return nil, fmt.Errorf("%s must be formatted as key=value", pair)
< 		}
< 		out[kv[0]] = kv[1]
< 	}
< 	return out, nil
< }
< 
< // GetStringToString return the map[string]string value of a flag with the given name
< func (f *FlagSet) GetStringToString(name string) (map[string]string, error) {
< 	val, err := f.getFlagType(name, "stringToString", stringToStringConv)
< 	if err != nil {
< 		return map[string]string{}, err
< 	}
< 	return val.(map[string]string), nil
< }
< 
< // StringToStringVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a map[string]string variable in which to store the values of the multiple flags.
< // The value of each argument will not try to be separated by comma
< func (f *FlagSet) StringToStringVar(p *map[string]string, name string, value map[string]string, usage string) {
< 	f.VarP(newStringToStringValue(value, p), name, "", usage)
< }
< 
< // StringToStringVarP is like StringToStringVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringToStringVarP(p *map[string]string, name, shorthand string, value map[string]string, usage string) {
< 	f.VarP(newStringToStringValue(value, p), name, shorthand, usage)
< }
< 
< // StringToStringVar defines a string flag with specified name, default value, and usage string.
< // The argument p points to a map[string]string variable in which to store the value of the flag.
< // The value of each argument will not try to be separated by comma
< func StringToStringVar(p *map[string]string, name string, value map[string]string, usage string) {
< 	CommandLine.VarP(newStringToStringValue(value, p), name, "", usage)
< }
< 
< // StringToStringVarP is like StringToStringVar, but accepts a shorthand letter that can be used after a single dash.
< func StringToStringVarP(p *map[string]string, name, shorthand string, value map[string]string, usage string) {
< 	CommandLine.VarP(newStringToStringValue(value, p), name, shorthand, usage)
< }
< 
< // StringToString defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a map[string]string variable that stores the value of the flag.
< // The value of each argument will not try to be separated by comma
< func (f *FlagSet) StringToString(name string, value map[string]string, usage string) *map[string]string {
< 	p := map[string]string{}
< 	f.StringToStringVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // StringToStringP is like StringToString, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) StringToStringP(name, shorthand string, value map[string]string, usage string) *map[string]string {
< 	p := map[string]string{}
< 	f.StringToStringVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // StringToString defines a string flag with specified name, default value, and usage string.
< // The return value is the address of a map[string]string variable that stores the value of the flag.
< // The value of each argument will not try to be separated by comma
< func StringToString(name string, value map[string]string, usage string) *map[string]string {
< 	return CommandLine.StringToStringP(name, "", value, usage)
< }
< 
< // StringToStringP is like StringToString, but accepts a shorthand letter that can be used after a single dash.
< func StringToStringP(name, shorthand string, value map[string]string, usage string) *map[string]string {
< 	return CommandLine.StringToStringP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint.go
1,88d0
< package pflag
< 
< import "strconv"
< 
< // -- uint Value
< type uintValue uint
< 
< func newUintValue(val uint, p *uint) *uintValue {
< 	*p = val
< 	return (*uintValue)(p)
< }
< 
< func (i *uintValue) Set(s string) error {
< 	v, err := strconv.ParseUint(s, 0, 64)
< 	*i = uintValue(v)
< 	return err
< }
< 
< func (i *uintValue) Type() string {
< 	return "uint"
< }
< 
< func (i *uintValue) String() string { return strconv.FormatUint(uint64(*i), 10) }
< 
< func uintConv(sval string) (interface{}, error) {
< 	v, err := strconv.ParseUint(sval, 0, 0)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return uint(v), nil
< }
< 
< // GetUint return the uint value of a flag with the given name
< func (f *FlagSet) GetUint(name string) (uint, error) {
< 	val, err := f.getFlagType(name, "uint", uintConv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(uint), nil
< }
< 
< // UintVar defines a uint flag with specified name, default value, and usage string.
< // The argument p points to a uint variable in which to store the value of the flag.
< func (f *FlagSet) UintVar(p *uint, name string, value uint, usage string) {
< 	f.VarP(newUintValue(value, p), name, "", usage)
< }
< 
< // UintVarP is like UintVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) UintVarP(p *uint, name, shorthand string, value uint, usage string) {
< 	f.VarP(newUintValue(value, p), name, shorthand, usage)
< }
< 
< // UintVar defines a uint flag with specified name, default value, and usage string.
< // The argument p points to a uint  variable in which to store the value of the flag.
< func UintVar(p *uint, name string, value uint, usage string) {
< 	CommandLine.VarP(newUintValue(value, p), name, "", usage)
< }
< 
< // UintVarP is like UintVar, but accepts a shorthand letter that can be used after a single dash.
< func UintVarP(p *uint, name, shorthand string, value uint, usage string) {
< 	CommandLine.VarP(newUintValue(value, p), name, shorthand, usage)
< }
< 
< // Uint defines a uint flag with specified name, default value, and usage string.
< // The return value is the address of a uint  variable that stores the value of the flag.
< func (f *FlagSet) Uint(name string, value uint, usage string) *uint {
< 	p := new(uint)
< 	f.UintVarP(p, name, "", value, usage)
< 	return p
< }
< 
< // UintP is like Uint, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) UintP(name, shorthand string, value uint, usage string) *uint {
< 	p := new(uint)
< 	f.UintVarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Uint defines a uint flag with specified name, default value, and usage string.
< // The return value is the address of a uint  variable that stores the value of the flag.
< func Uint(name string, value uint, usage string) *uint {
< 	return CommandLine.UintP(name, "", value, usage)
< }
< 
< // UintP is like Uint, but accepts a shorthand letter that can be used after a single dash.
< func UintP(name, shorthand string, value uint, usage string) *uint {
< 	return CommandLine.UintP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint16.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint16.go
1,88d0
< package pflag
< 
< import "strconv"
< 
< // -- uint16 value
< type uint16Value uint16
< 
< func newUint16Value(val uint16, p *uint16) *uint16Value {
< 	*p = val
< 	return (*uint16Value)(p)
< }
< 
< func (i *uint16Value) Set(s string) error {
< 	v, err := strconv.ParseUint(s, 0, 16)
< 	*i = uint16Value(v)
< 	return err
< }
< 
< func (i *uint16Value) Type() string {
< 	return "uint16"
< }
< 
< func (i *uint16Value) String() string { return strconv.FormatUint(uint64(*i), 10) }
< 
< func uint16Conv(sval string) (interface{}, error) {
< 	v, err := strconv.ParseUint(sval, 0, 16)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return uint16(v), nil
< }
< 
< // GetUint16 return the uint16 value of a flag with the given name
< func (f *FlagSet) GetUint16(name string) (uint16, error) {
< 	val, err := f.getFlagType(name, "uint16", uint16Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(uint16), nil
< }
< 
< // Uint16Var defines a uint flag with specified name, default value, and usage string.
< // The argument p points to a uint variable in which to store the value of the flag.
< func (f *FlagSet) Uint16Var(p *uint16, name string, value uint16, usage string) {
< 	f.VarP(newUint16Value(value, p), name, "", usage)
< }
< 
< // Uint16VarP is like Uint16Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Uint16VarP(p *uint16, name, shorthand string, value uint16, usage string) {
< 	f.VarP(newUint16Value(value, p), name, shorthand, usage)
< }
< 
< // Uint16Var defines a uint flag with specified name, default value, and usage string.
< // The argument p points to a uint  variable in which to store the value of the flag.
< func Uint16Var(p *uint16, name string, value uint16, usage string) {
< 	CommandLine.VarP(newUint16Value(value, p), name, "", usage)
< }
< 
< // Uint16VarP is like Uint16Var, but accepts a shorthand letter that can be used after a single dash.
< func Uint16VarP(p *uint16, name, shorthand string, value uint16, usage string) {
< 	CommandLine.VarP(newUint16Value(value, p), name, shorthand, usage)
< }
< 
< // Uint16 defines a uint flag with specified name, default value, and usage string.
< // The return value is the address of a uint  variable that stores the value of the flag.
< func (f *FlagSet) Uint16(name string, value uint16, usage string) *uint16 {
< 	p := new(uint16)
< 	f.Uint16VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Uint16P is like Uint16, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Uint16P(name, shorthand string, value uint16, usage string) *uint16 {
< 	p := new(uint16)
< 	f.Uint16VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Uint16 defines a uint flag with specified name, default value, and usage string.
< // The return value is the address of a uint  variable that stores the value of the flag.
< func Uint16(name string, value uint16, usage string) *uint16 {
< 	return CommandLine.Uint16P(name, "", value, usage)
< }
< 
< // Uint16P is like Uint16, but accepts a shorthand letter that can be used after a single dash.
< func Uint16P(name, shorthand string, value uint16, usage string) *uint16 {
< 	return CommandLine.Uint16P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint32.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint32.go
1,88d0
< package pflag
< 
< import "strconv"
< 
< // -- uint32 value
< type uint32Value uint32
< 
< func newUint32Value(val uint32, p *uint32) *uint32Value {
< 	*p = val
< 	return (*uint32Value)(p)
< }
< 
< func (i *uint32Value) Set(s string) error {
< 	v, err := strconv.ParseUint(s, 0, 32)
< 	*i = uint32Value(v)
< 	return err
< }
< 
< func (i *uint32Value) Type() string {
< 	return "uint32"
< }
< 
< func (i *uint32Value) String() string { return strconv.FormatUint(uint64(*i), 10) }
< 
< func uint32Conv(sval string) (interface{}, error) {
< 	v, err := strconv.ParseUint(sval, 0, 32)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return uint32(v), nil
< }
< 
< // GetUint32 return the uint32 value of a flag with the given name
< func (f *FlagSet) GetUint32(name string) (uint32, error) {
< 	val, err := f.getFlagType(name, "uint32", uint32Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(uint32), nil
< }
< 
< // Uint32Var defines a uint32 flag with specified name, default value, and usage string.
< // The argument p points to a uint32 variable in which to store the value of the flag.
< func (f *FlagSet) Uint32Var(p *uint32, name string, value uint32, usage string) {
< 	f.VarP(newUint32Value(value, p), name, "", usage)
< }
< 
< // Uint32VarP is like Uint32Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Uint32VarP(p *uint32, name, shorthand string, value uint32, usage string) {
< 	f.VarP(newUint32Value(value, p), name, shorthand, usage)
< }
< 
< // Uint32Var defines a uint32 flag with specified name, default value, and usage string.
< // The argument p points to a uint32  variable in which to store the value of the flag.
< func Uint32Var(p *uint32, name string, value uint32, usage string) {
< 	CommandLine.VarP(newUint32Value(value, p), name, "", usage)
< }
< 
< // Uint32VarP is like Uint32Var, but accepts a shorthand letter that can be used after a single dash.
< func Uint32VarP(p *uint32, name, shorthand string, value uint32, usage string) {
< 	CommandLine.VarP(newUint32Value(value, p), name, shorthand, usage)
< }
< 
< // Uint32 defines a uint32 flag with specified name, default value, and usage string.
< // The return value is the address of a uint32  variable that stores the value of the flag.
< func (f *FlagSet) Uint32(name string, value uint32, usage string) *uint32 {
< 	p := new(uint32)
< 	f.Uint32VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Uint32P is like Uint32, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Uint32P(name, shorthand string, value uint32, usage string) *uint32 {
< 	p := new(uint32)
< 	f.Uint32VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Uint32 defines a uint32 flag with specified name, default value, and usage string.
< // The return value is the address of a uint32  variable that stores the value of the flag.
< func Uint32(name string, value uint32, usage string) *uint32 {
< 	return CommandLine.Uint32P(name, "", value, usage)
< }
< 
< // Uint32P is like Uint32, but accepts a shorthand letter that can be used after a single dash.
< func Uint32P(name, shorthand string, value uint32, usage string) *uint32 {
< 	return CommandLine.Uint32P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint64.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint64.go
1,88d0
< package pflag
< 
< import "strconv"
< 
< // -- uint64 Value
< type uint64Value uint64
< 
< func newUint64Value(val uint64, p *uint64) *uint64Value {
< 	*p = val
< 	return (*uint64Value)(p)
< }
< 
< func (i *uint64Value) Set(s string) error {
< 	v, err := strconv.ParseUint(s, 0, 64)
< 	*i = uint64Value(v)
< 	return err
< }
< 
< func (i *uint64Value) Type() string {
< 	return "uint64"
< }
< 
< func (i *uint64Value) String() string { return strconv.FormatUint(uint64(*i), 10) }
< 
< func uint64Conv(sval string) (interface{}, error) {
< 	v, err := strconv.ParseUint(sval, 0, 64)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return uint64(v), nil
< }
< 
< // GetUint64 return the uint64 value of a flag with the given name
< func (f *FlagSet) GetUint64(name string) (uint64, error) {
< 	val, err := f.getFlagType(name, "uint64", uint64Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(uint64), nil
< }
< 
< // Uint64Var defines a uint64 flag with specified name, default value, and usage string.
< // The argument p points to a uint64 variable in which to store the value of the flag.
< func (f *FlagSet) Uint64Var(p *uint64, name string, value uint64, usage string) {
< 	f.VarP(newUint64Value(value, p), name, "", usage)
< }
< 
< // Uint64VarP is like Uint64Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Uint64VarP(p *uint64, name, shorthand string, value uint64, usage string) {
< 	f.VarP(newUint64Value(value, p), name, shorthand, usage)
< }
< 
< // Uint64Var defines a uint64 flag with specified name, default value, and usage string.
< // The argument p points to a uint64 variable in which to store the value of the flag.
< func Uint64Var(p *uint64, name string, value uint64, usage string) {
< 	CommandLine.VarP(newUint64Value(value, p), name, "", usage)
< }
< 
< // Uint64VarP is like Uint64Var, but accepts a shorthand letter that can be used after a single dash.
< func Uint64VarP(p *uint64, name, shorthand string, value uint64, usage string) {
< 	CommandLine.VarP(newUint64Value(value, p), name, shorthand, usage)
< }
< 
< // Uint64 defines a uint64 flag with specified name, default value, and usage string.
< // The return value is the address of a uint64 variable that stores the value of the flag.
< func (f *FlagSet) Uint64(name string, value uint64, usage string) *uint64 {
< 	p := new(uint64)
< 	f.Uint64VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Uint64P is like Uint64, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Uint64P(name, shorthand string, value uint64, usage string) *uint64 {
< 	p := new(uint64)
< 	f.Uint64VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Uint64 defines a uint64 flag with specified name, default value, and usage string.
< // The return value is the address of a uint64 variable that stores the value of the flag.
< func Uint64(name string, value uint64, usage string) *uint64 {
< 	return CommandLine.Uint64P(name, "", value, usage)
< }
< 
< // Uint64P is like Uint64, but accepts a shorthand letter that can be used after a single dash.
< func Uint64P(name, shorthand string, value uint64, usage string) *uint64 {
< 	return CommandLine.Uint64P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint8.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint8.go
1,88d0
< package pflag
< 
< import "strconv"
< 
< // -- uint8 Value
< type uint8Value uint8
< 
< func newUint8Value(val uint8, p *uint8) *uint8Value {
< 	*p = val
< 	return (*uint8Value)(p)
< }
< 
< func (i *uint8Value) Set(s string) error {
< 	v, err := strconv.ParseUint(s, 0, 8)
< 	*i = uint8Value(v)
< 	return err
< }
< 
< func (i *uint8Value) Type() string {
< 	return "uint8"
< }
< 
< func (i *uint8Value) String() string { return strconv.FormatUint(uint64(*i), 10) }
< 
< func uint8Conv(sval string) (interface{}, error) {
< 	v, err := strconv.ParseUint(sval, 0, 8)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return uint8(v), nil
< }
< 
< // GetUint8 return the uint8 value of a flag with the given name
< func (f *FlagSet) GetUint8(name string) (uint8, error) {
< 	val, err := f.getFlagType(name, "uint8", uint8Conv)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return val.(uint8), nil
< }
< 
< // Uint8Var defines a uint8 flag with specified name, default value, and usage string.
< // The argument p points to a uint8 variable in which to store the value of the flag.
< func (f *FlagSet) Uint8Var(p *uint8, name string, value uint8, usage string) {
< 	f.VarP(newUint8Value(value, p), name, "", usage)
< }
< 
< // Uint8VarP is like Uint8Var, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Uint8VarP(p *uint8, name, shorthand string, value uint8, usage string) {
< 	f.VarP(newUint8Value(value, p), name, shorthand, usage)
< }
< 
< // Uint8Var defines a uint8 flag with specified name, default value, and usage string.
< // The argument p points to a uint8 variable in which to store the value of the flag.
< func Uint8Var(p *uint8, name string, value uint8, usage string) {
< 	CommandLine.VarP(newUint8Value(value, p), name, "", usage)
< }
< 
< // Uint8VarP is like Uint8Var, but accepts a shorthand letter that can be used after a single dash.
< func Uint8VarP(p *uint8, name, shorthand string, value uint8, usage string) {
< 	CommandLine.VarP(newUint8Value(value, p), name, shorthand, usage)
< }
< 
< // Uint8 defines a uint8 flag with specified name, default value, and usage string.
< // The return value is the address of a uint8 variable that stores the value of the flag.
< func (f *FlagSet) Uint8(name string, value uint8, usage string) *uint8 {
< 	p := new(uint8)
< 	f.Uint8VarP(p, name, "", value, usage)
< 	return p
< }
< 
< // Uint8P is like Uint8, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) Uint8P(name, shorthand string, value uint8, usage string) *uint8 {
< 	p := new(uint8)
< 	f.Uint8VarP(p, name, shorthand, value, usage)
< 	return p
< }
< 
< // Uint8 defines a uint8 flag with specified name, default value, and usage string.
< // The return value is the address of a uint8 variable that stores the value of the flag.
< func Uint8(name string, value uint8, usage string) *uint8 {
< 	return CommandLine.Uint8P(name, "", value, usage)
< }
< 
< // Uint8P is like Uint8, but accepts a shorthand letter that can be used after a single dash.
< func Uint8P(name, shorthand string, value uint8, usage string) *uint8 {
< 	return CommandLine.Uint8P(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint_slice.go updated/vendor/github.com/coreos/fcct/vendor/github.com/spf13/pflag/uint_slice.go
1,168d0
< package pflag
< 
< import (
< 	"fmt"
< 	"strconv"
< 	"strings"
< )
< 
< // -- uintSlice Value
< type uintSliceValue struct {
< 	value   *[]uint
< 	changed bool
< }
< 
< func newUintSliceValue(val []uint, p *[]uint) *uintSliceValue {
< 	uisv := new(uintSliceValue)
< 	uisv.value = p
< 	*uisv.value = val
< 	return uisv
< }
< 
< func (s *uintSliceValue) Set(val string) error {
< 	ss := strings.Split(val, ",")
< 	out := make([]uint, len(ss))
< 	for i, d := range ss {
< 		u, err := strconv.ParseUint(d, 10, 0)
< 		if err != nil {
< 			return err
< 		}
< 		out[i] = uint(u)
< 	}
< 	if !s.changed {
< 		*s.value = out
< 	} else {
< 		*s.value = append(*s.value, out...)
< 	}
< 	s.changed = true
< 	return nil
< }
< 
< func (s *uintSliceValue) Type() string {
< 	return "uintSlice"
< }
< 
< func (s *uintSliceValue) String() string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = fmt.Sprintf("%d", d)
< 	}
< 	return "[" + strings.Join(out, ",") + "]"
< }
< 
< func (s *uintSliceValue) fromString(val string) (uint, error) {
< 	t, err := strconv.ParseUint(val, 10, 0)
< 	if err != nil {
< 		return 0, err
< 	}
< 	return uint(t), nil
< }
< 
< func (s *uintSliceValue) toString(val uint) string {
< 	return fmt.Sprintf("%d", val)
< }
< 
< func (s *uintSliceValue) Append(val string) error {
< 	i, err := s.fromString(val)
< 	if err != nil {
< 		return err
< 	}
< 	*s.value = append(*s.value, i)
< 	return nil
< }
< 
< func (s *uintSliceValue) Replace(val []string) error {
< 	out := make([]uint, len(val))
< 	for i, d := range val {
< 		var err error
< 		out[i], err = s.fromString(d)
< 		if err != nil {
< 			return err
< 		}
< 	}
< 	*s.value = out
< 	return nil
< }
< 
< func (s *uintSliceValue) GetSlice() []string {
< 	out := make([]string, len(*s.value))
< 	for i, d := range *s.value {
< 		out[i] = s.toString(d)
< 	}
< 	return out
< }
< 
< func uintSliceConv(val string) (interface{}, error) {
< 	val = strings.Trim(val, "[]")
< 	// Empty string would cause a slice with one (empty) entry
< 	if len(val) == 0 {
< 		return []uint{}, nil
< 	}
< 	ss := strings.Split(val, ",")
< 	out := make([]uint, len(ss))
< 	for i, d := range ss {
< 		u, err := strconv.ParseUint(d, 10, 0)
< 		if err != nil {
< 			return nil, err
< 		}
< 		out[i] = uint(u)
< 	}
< 	return out, nil
< }
< 
< // GetUintSlice returns the []uint value of a flag with the given name.
< func (f *FlagSet) GetUintSlice(name string) ([]uint, error) {
< 	val, err := f.getFlagType(name, "uintSlice", uintSliceConv)
< 	if err != nil {
< 		return []uint{}, err
< 	}
< 	return val.([]uint), nil
< }
< 
< // UintSliceVar defines a uintSlice flag with specified name, default value, and usage string.
< // The argument p points to a []uint variable in which to store the value of the flag.
< func (f *FlagSet) UintSliceVar(p *[]uint, name string, value []uint, usage string) {
< 	f.VarP(newUintSliceValue(value, p), name, "", usage)
< }
< 
< // UintSliceVarP is like UintSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) UintSliceVarP(p *[]uint, name, shorthand string, value []uint, usage string) {
< 	f.VarP(newUintSliceValue(value, p), name, shorthand, usage)
< }
< 
< // UintSliceVar defines a uint[] flag with specified name, default value, and usage string.
< // The argument p points to a uint[] variable in which to store the value of the flag.
< func UintSliceVar(p *[]uint, name string, value []uint, usage string) {
< 	CommandLine.VarP(newUintSliceValue(value, p), name, "", usage)
< }
< 
< // UintSliceVarP is like the UintSliceVar, but accepts a shorthand letter that can be used after a single dash.
< func UintSliceVarP(p *[]uint, name, shorthand string, value []uint, usage string) {
< 	CommandLine.VarP(newUintSliceValue(value, p), name, shorthand, usage)
< }
< 
< // UintSlice defines a []uint flag with specified name, default value, and usage string.
< // The return value is the address of a []uint variable that stores the value of the flag.
< func (f *FlagSet) UintSlice(name string, value []uint, usage string) *[]uint {
< 	p := []uint{}
< 	f.UintSliceVarP(&p, name, "", value, usage)
< 	return &p
< }
< 
< // UintSliceP is like UintSlice, but accepts a shorthand letter that can be used after a single dash.
< func (f *FlagSet) UintSliceP(name, shorthand string, value []uint, usage string) *[]uint {
< 	p := []uint{}
< 	f.UintSliceVarP(&p, name, shorthand, value, usage)
< 	return &p
< }
< 
< // UintSlice defines a []uint flag with specified name, default value, and usage string.
< // The return value is the address of a []uint variable that stores the value of the flag.
< func UintSlice(name string, value []uint, usage string) *[]uint {
< 	return CommandLine.UintSliceP(name, "", value, usage)
< }
< 
< // UintSliceP is like UintSlice, but accepts a shorthand letter that can be used after a single dash.
< func UintSliceP(name, shorthand string, value []uint, usage string) *[]uint {
< 	return CommandLine.UintSliceP(name, shorthand, value, usage)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/LICENSE
1,21d0
< MIT License
< 
< Copyright (c) 2012-2018 Mat Ryer and Tyler Bunnell
< 
< Permission is hereby granted, free of charge, to any person obtaining a copy
< of this software and associated documentation files (the "Software"), to deal
< in the Software without restriction, including without limitation the rights
< to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
< copies of the Software, and to permit persons to whom the Software is
< furnished to do so, subject to the following conditions:
< 
< The above copyright notice and this permission notice shall be included in all
< copies or substantial portions of the Software.
< 
< THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< SOFTWARE.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_format.go updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_format.go
1,622d0
< /*
< * CODE GENERATED AUTOMATICALLY WITH github.com/stretchr/testify/_codegen
< * THIS FILE MUST NOT BE EDITED BY HAND
<  */
< 
< package assert
< 
< import (
< 	http "net/http"
< 	url "net/url"
< 	time "time"
< )
< 
< // Conditionf uses a Comparison to assert a complex condition.
< func Conditionf(t TestingT, comp Comparison, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Condition(t, comp, append([]interface{}{msg}, args...)...)
< }
< 
< // Containsf asserts that the specified string, list(array, slice...) or map contains the
< // specified substring or element.
< //
< //    assert.Containsf(t, "Hello World", "World", "error message %s", "formatted")
< //    assert.Containsf(t, ["Hello", "World"], "World", "error message %s", "formatted")
< //    assert.Containsf(t, {"Hello": "World"}, "Hello", "error message %s", "formatted")
< func Containsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Contains(t, s, contains, append([]interface{}{msg}, args...)...)
< }
< 
< // DirExistsf checks whether a directory exists in the given path. It also fails
< // if the path is a file rather a directory or there is an error checking whether it exists.
< func DirExistsf(t TestingT, path string, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return DirExists(t, path, append([]interface{}{msg}, args...)...)
< }
< 
< // ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
< // listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
< // the number of appearances of each of them in both lists should match.
< //
< // assert.ElementsMatchf(t, [1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted")
< func ElementsMatchf(t TestingT, listA interface{}, listB interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return ElementsMatch(t, listA, listB, append([]interface{}{msg}, args...)...)
< }
< 
< // Emptyf asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
< // a slice or a channel with len == 0.
< //
< //  assert.Emptyf(t, obj, "error message %s", "formatted")
< func Emptyf(t TestingT, object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Empty(t, object, append([]interface{}{msg}, args...)...)
< }
< 
< // Equalf asserts that two objects are equal.
< //
< //    assert.Equalf(t, 123, 123, "error message %s", "formatted")
< //
< // Pointer variable equality is determined based on the equality of the
< // referenced values (as opposed to the memory addresses). Function equality
< // cannot be determined and will always fail.
< func Equalf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Equal(t, expected, actual, append([]interface{}{msg}, args...)...)
< }
< 
< // EqualErrorf asserts that a function returned an error (i.e. not `nil`)
< // and that it is equal to the provided error.
< //
< //   actualObj, err := SomeFunction()
< //   assert.EqualErrorf(t, err,  expectedErrorString, "error message %s", "formatted")
< func EqualErrorf(t TestingT, theError error, errString string, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return EqualError(t, theError, errString, append([]interface{}{msg}, args...)...)
< }
< 
< // EqualValuesf asserts that two objects are equal or convertable to the same types
< // and equal.
< //
< //    assert.EqualValuesf(t, uint32(123, "error message %s", "formatted"), int32(123))
< func EqualValuesf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return EqualValues(t, expected, actual, append([]interface{}{msg}, args...)...)
< }
< 
< // Errorf asserts that a function returned an error (i.e. not `nil`).
< //
< //   actualObj, err := SomeFunction()
< //   if assert.Errorf(t, err, "error message %s", "formatted") {
< // 	   assert.Equal(t, expectedErrorf, err)
< //   }
< func Errorf(t TestingT, err error, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Error(t, err, append([]interface{}{msg}, args...)...)
< }
< 
< // Eventuallyf asserts that given condition will be met in waitFor time,
< // periodically checking target function each tick.
< //
< //    assert.Eventuallyf(t, func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
< func Eventuallyf(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Eventually(t, condition, waitFor, tick, append([]interface{}{msg}, args...)...)
< }
< 
< // Exactlyf asserts that two objects are equal in value and type.
< //
< //    assert.Exactlyf(t, int32(123, "error message %s", "formatted"), int64(123))
< func Exactlyf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Exactly(t, expected, actual, append([]interface{}{msg}, args...)...)
< }
< 
< // Failf reports a failure through
< func Failf(t TestingT, failureMessage string, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Fail(t, failureMessage, append([]interface{}{msg}, args...)...)
< }
< 
< // FailNowf fails test
< func FailNowf(t TestingT, failureMessage string, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return FailNow(t, failureMessage, append([]interface{}{msg}, args...)...)
< }
< 
< // Falsef asserts that the specified value is false.
< //
< //    assert.Falsef(t, myBool, "error message %s", "formatted")
< func Falsef(t TestingT, value bool, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return False(t, value, append([]interface{}{msg}, args...)...)
< }
< 
< // FileExistsf checks whether a file exists in the given path. It also fails if
< // the path points to a directory or there is an error when trying to check the file.
< func FileExistsf(t TestingT, path string, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return FileExists(t, path, append([]interface{}{msg}, args...)...)
< }
< 
< // Greaterf asserts that the first element is greater than the second
< //
< //    assert.Greaterf(t, 2, 1, "error message %s", "formatted")
< //    assert.Greaterf(t, float64(2, "error message %s", "formatted"), float64(1))
< //    assert.Greaterf(t, "b", "a", "error message %s", "formatted")
< func Greaterf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Greater(t, e1, e2, append([]interface{}{msg}, args...)...)
< }
< 
< // GreaterOrEqualf asserts that the first element is greater than or equal to the second
< //
< //    assert.GreaterOrEqualf(t, 2, 1, "error message %s", "formatted")
< //    assert.GreaterOrEqualf(t, 2, 2, "error message %s", "formatted")
< //    assert.GreaterOrEqualf(t, "b", "a", "error message %s", "formatted")
< //    assert.GreaterOrEqualf(t, "b", "b", "error message %s", "formatted")
< func GreaterOrEqualf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return GreaterOrEqual(t, e1, e2, append([]interface{}{msg}, args...)...)
< }
< 
< // HTTPBodyContainsf asserts that a specified handler returns a
< // body that contains a string.
< //
< //  assert.HTTPBodyContainsf(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func HTTPBodyContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPBodyContains(t, handler, method, url, values, str, append([]interface{}{msg}, args...)...)
< }
< 
< // HTTPBodyNotContainsf asserts that a specified handler returns a
< // body that does not contain a string.
< //
< //  assert.HTTPBodyNotContainsf(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func HTTPBodyNotContainsf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPBodyNotContains(t, handler, method, url, values, str, append([]interface{}{msg}, args...)...)
< }
< 
< // HTTPErrorf asserts that a specified handler returns an error status code.
< //
< //  assert.HTTPErrorf(t, myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
< //
< // Returns whether the assertion was successful (true, "error message %s", "formatted") or not (false).
< func HTTPErrorf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPError(t, handler, method, url, values, append([]interface{}{msg}, args...)...)
< }
< 
< // HTTPRedirectf asserts that a specified handler returns a redirect status code.
< //
< //  assert.HTTPRedirectf(t, myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
< //
< // Returns whether the assertion was successful (true, "error message %s", "formatted") or not (false).
< func HTTPRedirectf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPRedirect(t, handler, method, url, values, append([]interface{}{msg}, args...)...)
< }
< 
< // HTTPSuccessf asserts that a specified handler returns a success status code.
< //
< //  assert.HTTPSuccessf(t, myHandler, "POST", "http://www.google.com", nil, "error message %s", "formatted")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func HTTPSuccessf(t TestingT, handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPSuccess(t, handler, method, url, values, append([]interface{}{msg}, args...)...)
< }
< 
< // Implementsf asserts that an object is implemented by the specified interface.
< //
< //    assert.Implementsf(t, (*MyInterface, "error message %s", "formatted")(nil), new(MyObject))
< func Implementsf(t TestingT, interfaceObject interface{}, object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Implements(t, interfaceObject, object, append([]interface{}{msg}, args...)...)
< }
< 
< // InDeltaf asserts that the two numerals are within delta of each other.
< //
< // 	 assert.InDeltaf(t, math.Pi, 22/7.0, 0.01, "error message %s", "formatted")
< func InDeltaf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InDelta(t, expected, actual, delta, append([]interface{}{msg}, args...)...)
< }
< 
< // InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
< func InDeltaMapValuesf(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InDeltaMapValues(t, expected, actual, delta, append([]interface{}{msg}, args...)...)
< }
< 
< // InDeltaSlicef is the same as InDelta, except it compares two slices.
< func InDeltaSlicef(t TestingT, expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InDeltaSlice(t, expected, actual, delta, append([]interface{}{msg}, args...)...)
< }
< 
< // InEpsilonf asserts that expected and actual have a relative error less than epsilon
< func InEpsilonf(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InEpsilon(t, expected, actual, epsilon, append([]interface{}{msg}, args...)...)
< }
< 
< // InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.
< func InEpsilonSlicef(t TestingT, expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InEpsilonSlice(t, expected, actual, epsilon, append([]interface{}{msg}, args...)...)
< }
< 
< // IsTypef asserts that the specified objects are of the same type.
< func IsTypef(t TestingT, expectedType interface{}, object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return IsType(t, expectedType, object, append([]interface{}{msg}, args...)...)
< }
< 
< // JSONEqf asserts that two JSON strings are equivalent.
< //
< //  assert.JSONEqf(t, `{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`, "error message %s", "formatted")
< func JSONEqf(t TestingT, expected string, actual string, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return JSONEq(t, expected, actual, append([]interface{}{msg}, args...)...)
< }
< 
< // Lenf asserts that the specified object has specific length.
< // Lenf also fails if the object has a type that len() not accept.
< //
< //    assert.Lenf(t, mySlice, 3, "error message %s", "formatted")
< func Lenf(t TestingT, object interface{}, length int, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Len(t, object, length, append([]interface{}{msg}, args...)...)
< }
< 
< // Lessf asserts that the first element is less than the second
< //
< //    assert.Lessf(t, 1, 2, "error message %s", "formatted")
< //    assert.Lessf(t, float64(1, "error message %s", "formatted"), float64(2))
< //    assert.Lessf(t, "a", "b", "error message %s", "formatted")
< func Lessf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Less(t, e1, e2, append([]interface{}{msg}, args...)...)
< }
< 
< // LessOrEqualf asserts that the first element is less than or equal to the second
< //
< //    assert.LessOrEqualf(t, 1, 2, "error message %s", "formatted")
< //    assert.LessOrEqualf(t, 2, 2, "error message %s", "formatted")
< //    assert.LessOrEqualf(t, "a", "b", "error message %s", "formatted")
< //    assert.LessOrEqualf(t, "b", "b", "error message %s", "formatted")
< func LessOrEqualf(t TestingT, e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return LessOrEqual(t, e1, e2, append([]interface{}{msg}, args...)...)
< }
< 
< // Neverf asserts that the given condition doesn't satisfy in waitFor time,
< // periodically checking the target function each tick.
< //
< //    assert.Neverf(t, func() bool { return false; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
< func Neverf(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Never(t, condition, waitFor, tick, append([]interface{}{msg}, args...)...)
< }
< 
< // Nilf asserts that the specified object is nil.
< //
< //    assert.Nilf(t, err, "error message %s", "formatted")
< func Nilf(t TestingT, object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Nil(t, object, append([]interface{}{msg}, args...)...)
< }
< 
< // NoDirExistsf checks whether a directory does not exist in the given path.
< // It fails if the path points to an existing _directory_ only.
< func NoDirExistsf(t TestingT, path string, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NoDirExists(t, path, append([]interface{}{msg}, args...)...)
< }
< 
< // NoErrorf asserts that a function returned no error (i.e. `nil`).
< //
< //   actualObj, err := SomeFunction()
< //   if assert.NoErrorf(t, err, "error message %s", "formatted") {
< // 	   assert.Equal(t, expectedObj, actualObj)
< //   }
< func NoErrorf(t TestingT, err error, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NoError(t, err, append([]interface{}{msg}, args...)...)
< }
< 
< // NoFileExistsf checks whether a file does not exist in a given path. It fails
< // if the path points to an existing _file_ only.
< func NoFileExistsf(t TestingT, path string, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NoFileExists(t, path, append([]interface{}{msg}, args...)...)
< }
< 
< // NotContainsf asserts that the specified string, list(array, slice...) or map does NOT contain the
< // specified substring or element.
< //
< //    assert.NotContainsf(t, "Hello World", "Earth", "error message %s", "formatted")
< //    assert.NotContainsf(t, ["Hello", "World"], "Earth", "error message %s", "formatted")
< //    assert.NotContainsf(t, {"Hello": "World"}, "Earth", "error message %s", "formatted")
< func NotContainsf(t TestingT, s interface{}, contains interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotContains(t, s, contains, append([]interface{}{msg}, args...)...)
< }
< 
< // NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
< // a slice or a channel with len == 0.
< //
< //  if assert.NotEmptyf(t, obj, "error message %s", "formatted") {
< //    assert.Equal(t, "two", obj[1])
< //  }
< func NotEmptyf(t TestingT, object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotEmpty(t, object, append([]interface{}{msg}, args...)...)
< }
< 
< // NotEqualf asserts that the specified values are NOT equal.
< //
< //    assert.NotEqualf(t, obj1, obj2, "error message %s", "formatted")
< //
< // Pointer variable equality is determined based on the equality of the
< // referenced values (as opposed to the memory addresses).
< func NotEqualf(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotEqual(t, expected, actual, append([]interface{}{msg}, args...)...)
< }
< 
< // NotNilf asserts that the specified object is not nil.
< //
< //    assert.NotNilf(t, err, "error message %s", "formatted")
< func NotNilf(t TestingT, object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotNil(t, object, append([]interface{}{msg}, args...)...)
< }
< 
< // NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
< //
< //   assert.NotPanicsf(t, func(){ RemainCalm() }, "error message %s", "formatted")
< func NotPanicsf(t TestingT, f PanicTestFunc, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotPanics(t, f, append([]interface{}{msg}, args...)...)
< }
< 
< // NotRegexpf asserts that a specified regexp does not match a string.
< //
< //  assert.NotRegexpf(t, regexp.MustCompile("starts", "error message %s", "formatted"), "it's starting")
< //  assert.NotRegexpf(t, "^start", "it's not starting", "error message %s", "formatted")
< func NotRegexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotRegexp(t, rx, str, append([]interface{}{msg}, args...)...)
< }
< 
< // NotSamef asserts that two pointers do not reference the same object.
< //
< //    assert.NotSamef(t, ptr1, ptr2, "error message %s", "formatted")
< //
< // Both arguments must be pointer variables. Pointer variable sameness is
< // determined based on the equality of both type and value.
< func NotSamef(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotSame(t, expected, actual, append([]interface{}{msg}, args...)...)
< }
< 
< // NotSubsetf asserts that the specified list(array, slice...) contains not all
< // elements given in the specified subset(array, slice...).
< //
< //    assert.NotSubsetf(t, [1, 3, 4], [1, 2], "But [1, 3, 4] does not contain [1, 2]", "error message %s", "formatted")
< func NotSubsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotSubset(t, list, subset, append([]interface{}{msg}, args...)...)
< }
< 
< // NotZerof asserts that i is not the zero value for its type.
< func NotZerof(t TestingT, i interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotZero(t, i, append([]interface{}{msg}, args...)...)
< }
< 
< // Panicsf asserts that the code inside the specified PanicTestFunc panics.
< //
< //   assert.Panicsf(t, func(){ GoCrazy() }, "error message %s", "formatted")
< func Panicsf(t TestingT, f PanicTestFunc, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Panics(t, f, append([]interface{}{msg}, args...)...)
< }
< 
< // PanicsWithErrorf asserts that the code inside the specified PanicTestFunc
< // panics, and that the recovered panic value is an error that satisfies the
< // EqualError comparison.
< //
< //   assert.PanicsWithErrorf(t, "crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
< func PanicsWithErrorf(t TestingT, errString string, f PanicTestFunc, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return PanicsWithError(t, errString, f, append([]interface{}{msg}, args...)...)
< }
< 
< // PanicsWithValuef asserts that the code inside the specified PanicTestFunc panics, and that
< // the recovered panic value equals the expected panic value.
< //
< //   assert.PanicsWithValuef(t, "crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
< func PanicsWithValuef(t TestingT, expected interface{}, f PanicTestFunc, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return PanicsWithValue(t, expected, f, append([]interface{}{msg}, args...)...)
< }
< 
< // Regexpf asserts that a specified regexp matches a string.
< //
< //  assert.Regexpf(t, regexp.MustCompile("start", "error message %s", "formatted"), "it's starting")
< //  assert.Regexpf(t, "start...$", "it's not starting", "error message %s", "formatted")
< func Regexpf(t TestingT, rx interface{}, str interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Regexp(t, rx, str, append([]interface{}{msg}, args...)...)
< }
< 
< // Samef asserts that two pointers reference the same object.
< //
< //    assert.Samef(t, ptr1, ptr2, "error message %s", "formatted")
< //
< // Both arguments must be pointer variables. Pointer variable sameness is
< // determined based on the equality of both type and value.
< func Samef(t TestingT, expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Same(t, expected, actual, append([]interface{}{msg}, args...)...)
< }
< 
< // Subsetf asserts that the specified list(array, slice...) contains all
< // elements given in the specified subset(array, slice...).
< //
< //    assert.Subsetf(t, [1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]", "error message %s", "formatted")
< func Subsetf(t TestingT, list interface{}, subset interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Subset(t, list, subset, append([]interface{}{msg}, args...)...)
< }
< 
< // Truef asserts that the specified value is true.
< //
< //    assert.Truef(t, myBool, "error message %s", "formatted")
< func Truef(t TestingT, value bool, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return True(t, value, append([]interface{}{msg}, args...)...)
< }
< 
< // WithinDurationf asserts that the two times are within duration delta of each other.
< //
< //   assert.WithinDurationf(t, time.Now(), time.Now(), 10*time.Second, "error message %s", "formatted")
< func WithinDurationf(t TestingT, expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return WithinDuration(t, expected, actual, delta, append([]interface{}{msg}, args...)...)
< }
< 
< // YAMLEqf asserts that two YAML strings are equivalent.
< func YAMLEqf(t TestingT, expected string, actual string, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return YAMLEq(t, expected, actual, append([]interface{}{msg}, args...)...)
< }
< 
< // Zerof asserts that i is the zero value for its type.
< func Zerof(t TestingT, i interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Zero(t, i, append([]interface{}{msg}, args...)...)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_format.go.tmpl updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_format.go.tmpl
1,5d0
< {{.CommentFormat}}
< func {{.DocInfo.Name}}f(t TestingT, {{.ParamsFormat}}) bool {
< 	if h, ok := t.(tHelper); ok { h.Helper() }
< 	return {{.DocInfo.Name}}(t, {{.ForwardedParamsFormat}})
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_forward.go updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_forward.go
1,1232d0
< /*
< * CODE GENERATED AUTOMATICALLY WITH github.com/stretchr/testify/_codegen
< * THIS FILE MUST NOT BE EDITED BY HAND
<  */
< 
< package assert
< 
< import (
< 	http "net/http"
< 	url "net/url"
< 	time "time"
< )
< 
< // Condition uses a Comparison to assert a complex condition.
< func (a *Assertions) Condition(comp Comparison, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Condition(a.t, comp, msgAndArgs...)
< }
< 
< // Conditionf uses a Comparison to assert a complex condition.
< func (a *Assertions) Conditionf(comp Comparison, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Conditionf(a.t, comp, msg, args...)
< }
< 
< // Contains asserts that the specified string, list(array, slice...) or map contains the
< // specified substring or element.
< //
< //    a.Contains("Hello World", "World")
< //    a.Contains(["Hello", "World"], "World")
< //    a.Contains({"Hello": "World"}, "Hello")
< func (a *Assertions) Contains(s interface{}, contains interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Contains(a.t, s, contains, msgAndArgs...)
< }
< 
< // Containsf asserts that the specified string, list(array, slice...) or map contains the
< // specified substring or element.
< //
< //    a.Containsf("Hello World", "World", "error message %s", "formatted")
< //    a.Containsf(["Hello", "World"], "World", "error message %s", "formatted")
< //    a.Containsf({"Hello": "World"}, "Hello", "error message %s", "formatted")
< func (a *Assertions) Containsf(s interface{}, contains interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Containsf(a.t, s, contains, msg, args...)
< }
< 
< // DirExists checks whether a directory exists in the given path. It also fails
< // if the path is a file rather a directory or there is an error checking whether it exists.
< func (a *Assertions) DirExists(path string, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return DirExists(a.t, path, msgAndArgs...)
< }
< 
< // DirExistsf checks whether a directory exists in the given path. It also fails
< // if the path is a file rather a directory or there is an error checking whether it exists.
< func (a *Assertions) DirExistsf(path string, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return DirExistsf(a.t, path, msg, args...)
< }
< 
< // ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
< // listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
< // the number of appearances of each of them in both lists should match.
< //
< // a.ElementsMatch([1, 3, 2, 3], [1, 3, 3, 2])
< func (a *Assertions) ElementsMatch(listA interface{}, listB interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return ElementsMatch(a.t, listA, listB, msgAndArgs...)
< }
< 
< // ElementsMatchf asserts that the specified listA(array, slice...) is equal to specified
< // listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
< // the number of appearances of each of them in both lists should match.
< //
< // a.ElementsMatchf([1, 3, 2, 3], [1, 3, 3, 2], "error message %s", "formatted")
< func (a *Assertions) ElementsMatchf(listA interface{}, listB interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return ElementsMatchf(a.t, listA, listB, msg, args...)
< }
< 
< // Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
< // a slice or a channel with len == 0.
< //
< //  a.Empty(obj)
< func (a *Assertions) Empty(object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Empty(a.t, object, msgAndArgs...)
< }
< 
< // Emptyf asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
< // a slice or a channel with len == 0.
< //
< //  a.Emptyf(obj, "error message %s", "formatted")
< func (a *Assertions) Emptyf(object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Emptyf(a.t, object, msg, args...)
< }
< 
< // Equal asserts that two objects are equal.
< //
< //    a.Equal(123, 123)
< //
< // Pointer variable equality is determined based on the equality of the
< // referenced values (as opposed to the memory addresses). Function equality
< // cannot be determined and will always fail.
< func (a *Assertions) Equal(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Equal(a.t, expected, actual, msgAndArgs...)
< }
< 
< // EqualError asserts that a function returned an error (i.e. not `nil`)
< // and that it is equal to the provided error.
< //
< //   actualObj, err := SomeFunction()
< //   a.EqualError(err,  expectedErrorString)
< func (a *Assertions) EqualError(theError error, errString string, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return EqualError(a.t, theError, errString, msgAndArgs...)
< }
< 
< // EqualErrorf asserts that a function returned an error (i.e. not `nil`)
< // and that it is equal to the provided error.
< //
< //   actualObj, err := SomeFunction()
< //   a.EqualErrorf(err,  expectedErrorString, "error message %s", "formatted")
< func (a *Assertions) EqualErrorf(theError error, errString string, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return EqualErrorf(a.t, theError, errString, msg, args...)
< }
< 
< // EqualValues asserts that two objects are equal or convertable to the same types
< // and equal.
< //
< //    a.EqualValues(uint32(123), int32(123))
< func (a *Assertions) EqualValues(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return EqualValues(a.t, expected, actual, msgAndArgs...)
< }
< 
< // EqualValuesf asserts that two objects are equal or convertable to the same types
< // and equal.
< //
< //    a.EqualValuesf(uint32(123, "error message %s", "formatted"), int32(123))
< func (a *Assertions) EqualValuesf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return EqualValuesf(a.t, expected, actual, msg, args...)
< }
< 
< // Equalf asserts that two objects are equal.
< //
< //    a.Equalf(123, 123, "error message %s", "formatted")
< //
< // Pointer variable equality is determined based on the equality of the
< // referenced values (as opposed to the memory addresses). Function equality
< // cannot be determined and will always fail.
< func (a *Assertions) Equalf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Equalf(a.t, expected, actual, msg, args...)
< }
< 
< // Error asserts that a function returned an error (i.e. not `nil`).
< //
< //   actualObj, err := SomeFunction()
< //   if a.Error(err) {
< // 	   assert.Equal(t, expectedError, err)
< //   }
< func (a *Assertions) Error(err error, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Error(a.t, err, msgAndArgs...)
< }
< 
< // Errorf asserts that a function returned an error (i.e. not `nil`).
< //
< //   actualObj, err := SomeFunction()
< //   if a.Errorf(err, "error message %s", "formatted") {
< // 	   assert.Equal(t, expectedErrorf, err)
< //   }
< func (a *Assertions) Errorf(err error, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Errorf(a.t, err, msg, args...)
< }
< 
< // Eventually asserts that given condition will be met in waitFor time,
< // periodically checking target function each tick.
< //
< //    a.Eventually(func() bool { return true; }, time.Second, 10*time.Millisecond)
< func (a *Assertions) Eventually(condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Eventually(a.t, condition, waitFor, tick, msgAndArgs...)
< }
< 
< // Eventuallyf asserts that given condition will be met in waitFor time,
< // periodically checking target function each tick.
< //
< //    a.Eventuallyf(func() bool { return true; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
< func (a *Assertions) Eventuallyf(condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Eventuallyf(a.t, condition, waitFor, tick, msg, args...)
< }
< 
< // Exactly asserts that two objects are equal in value and type.
< //
< //    a.Exactly(int32(123), int64(123))
< func (a *Assertions) Exactly(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Exactly(a.t, expected, actual, msgAndArgs...)
< }
< 
< // Exactlyf asserts that two objects are equal in value and type.
< //
< //    a.Exactlyf(int32(123, "error message %s", "formatted"), int64(123))
< func (a *Assertions) Exactlyf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Exactlyf(a.t, expected, actual, msg, args...)
< }
< 
< // Fail reports a failure through
< func (a *Assertions) Fail(failureMessage string, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Fail(a.t, failureMessage, msgAndArgs...)
< }
< 
< // FailNow fails test
< func (a *Assertions) FailNow(failureMessage string, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return FailNow(a.t, failureMessage, msgAndArgs...)
< }
< 
< // FailNowf fails test
< func (a *Assertions) FailNowf(failureMessage string, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return FailNowf(a.t, failureMessage, msg, args...)
< }
< 
< // Failf reports a failure through
< func (a *Assertions) Failf(failureMessage string, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Failf(a.t, failureMessage, msg, args...)
< }
< 
< // False asserts that the specified value is false.
< //
< //    a.False(myBool)
< func (a *Assertions) False(value bool, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return False(a.t, value, msgAndArgs...)
< }
< 
< // Falsef asserts that the specified value is false.
< //
< //    a.Falsef(myBool, "error message %s", "formatted")
< func (a *Assertions) Falsef(value bool, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Falsef(a.t, value, msg, args...)
< }
< 
< // FileExists checks whether a file exists in the given path. It also fails if
< // the path points to a directory or there is an error when trying to check the file.
< func (a *Assertions) FileExists(path string, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return FileExists(a.t, path, msgAndArgs...)
< }
< 
< // FileExistsf checks whether a file exists in the given path. It also fails if
< // the path points to a directory or there is an error when trying to check the file.
< func (a *Assertions) FileExistsf(path string, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return FileExistsf(a.t, path, msg, args...)
< }
< 
< // Greater asserts that the first element is greater than the second
< //
< //    a.Greater(2, 1)
< //    a.Greater(float64(2), float64(1))
< //    a.Greater("b", "a")
< func (a *Assertions) Greater(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Greater(a.t, e1, e2, msgAndArgs...)
< }
< 
< // GreaterOrEqual asserts that the first element is greater than or equal to the second
< //
< //    a.GreaterOrEqual(2, 1)
< //    a.GreaterOrEqual(2, 2)
< //    a.GreaterOrEqual("b", "a")
< //    a.GreaterOrEqual("b", "b")
< func (a *Assertions) GreaterOrEqual(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return GreaterOrEqual(a.t, e1, e2, msgAndArgs...)
< }
< 
< // GreaterOrEqualf asserts that the first element is greater than or equal to the second
< //
< //    a.GreaterOrEqualf(2, 1, "error message %s", "formatted")
< //    a.GreaterOrEqualf(2, 2, "error message %s", "formatted")
< //    a.GreaterOrEqualf("b", "a", "error message %s", "formatted")
< //    a.GreaterOrEqualf("b", "b", "error message %s", "formatted")
< func (a *Assertions) GreaterOrEqualf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return GreaterOrEqualf(a.t, e1, e2, msg, args...)
< }
< 
< // Greaterf asserts that the first element is greater than the second
< //
< //    a.Greaterf(2, 1, "error message %s", "formatted")
< //    a.Greaterf(float64(2, "error message %s", "formatted"), float64(1))
< //    a.Greaterf("b", "a", "error message %s", "formatted")
< func (a *Assertions) Greaterf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Greaterf(a.t, e1, e2, msg, args...)
< }
< 
< // HTTPBodyContains asserts that a specified handler returns a
< // body that contains a string.
< //
< //  a.HTTPBodyContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func (a *Assertions) HTTPBodyContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPBodyContains(a.t, handler, method, url, values, str, msgAndArgs...)
< }
< 
< // HTTPBodyContainsf asserts that a specified handler returns a
< // body that contains a string.
< //
< //  a.HTTPBodyContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func (a *Assertions) HTTPBodyContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPBodyContainsf(a.t, handler, method, url, values, str, msg, args...)
< }
< 
< // HTTPBodyNotContains asserts that a specified handler returns a
< // body that does not contain a string.
< //
< //  a.HTTPBodyNotContains(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func (a *Assertions) HTTPBodyNotContains(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPBodyNotContains(a.t, handler, method, url, values, str, msgAndArgs...)
< }
< 
< // HTTPBodyNotContainsf asserts that a specified handler returns a
< // body that does not contain a string.
< //
< //  a.HTTPBodyNotContainsf(myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky", "error message %s", "formatted")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func (a *Assertions) HTTPBodyNotContainsf(handler http.HandlerFunc, method string, url string, values url.Values, str interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPBodyNotContainsf(a.t, handler, method, url, values, str, msg, args...)
< }
< 
< // HTTPError asserts that a specified handler returns an error status code.
< //
< //  a.HTTPError(myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
< //
< // Returns whether the assertion was successful (true) or not (false).
< func (a *Assertions) HTTPError(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPError(a.t, handler, method, url, values, msgAndArgs...)
< }
< 
< // HTTPErrorf asserts that a specified handler returns an error status code.
< //
< //  a.HTTPErrorf(myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
< //
< // Returns whether the assertion was successful (true, "error message %s", "formatted") or not (false).
< func (a *Assertions) HTTPErrorf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPErrorf(a.t, handler, method, url, values, msg, args...)
< }
< 
< // HTTPRedirect asserts that a specified handler returns a redirect status code.
< //
< //  a.HTTPRedirect(myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
< //
< // Returns whether the assertion was successful (true) or not (false).
< func (a *Assertions) HTTPRedirect(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPRedirect(a.t, handler, method, url, values, msgAndArgs...)
< }
< 
< // HTTPRedirectf asserts that a specified handler returns a redirect status code.
< //
< //  a.HTTPRedirectf(myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
< //
< // Returns whether the assertion was successful (true, "error message %s", "formatted") or not (false).
< func (a *Assertions) HTTPRedirectf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPRedirectf(a.t, handler, method, url, values, msg, args...)
< }
< 
< // HTTPSuccess asserts that a specified handler returns a success status code.
< //
< //  a.HTTPSuccess(myHandler, "POST", "http://www.google.com", nil)
< //
< // Returns whether the assertion was successful (true) or not (false).
< func (a *Assertions) HTTPSuccess(handler http.HandlerFunc, method string, url string, values url.Values, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPSuccess(a.t, handler, method, url, values, msgAndArgs...)
< }
< 
< // HTTPSuccessf asserts that a specified handler returns a success status code.
< //
< //  a.HTTPSuccessf(myHandler, "POST", "http://www.google.com", nil, "error message %s", "formatted")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func (a *Assertions) HTTPSuccessf(handler http.HandlerFunc, method string, url string, values url.Values, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return HTTPSuccessf(a.t, handler, method, url, values, msg, args...)
< }
< 
< // Implements asserts that an object is implemented by the specified interface.
< //
< //    a.Implements((*MyInterface)(nil), new(MyObject))
< func (a *Assertions) Implements(interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Implements(a.t, interfaceObject, object, msgAndArgs...)
< }
< 
< // Implementsf asserts that an object is implemented by the specified interface.
< //
< //    a.Implementsf((*MyInterface, "error message %s", "formatted")(nil), new(MyObject))
< func (a *Assertions) Implementsf(interfaceObject interface{}, object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Implementsf(a.t, interfaceObject, object, msg, args...)
< }
< 
< // InDelta asserts that the two numerals are within delta of each other.
< //
< // 	 a.InDelta(math.Pi, 22/7.0, 0.01)
< func (a *Assertions) InDelta(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InDelta(a.t, expected, actual, delta, msgAndArgs...)
< }
< 
< // InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
< func (a *Assertions) InDeltaMapValues(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InDeltaMapValues(a.t, expected, actual, delta, msgAndArgs...)
< }
< 
< // InDeltaMapValuesf is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
< func (a *Assertions) InDeltaMapValuesf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InDeltaMapValuesf(a.t, expected, actual, delta, msg, args...)
< }
< 
< // InDeltaSlice is the same as InDelta, except it compares two slices.
< func (a *Assertions) InDeltaSlice(expected interface{}, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InDeltaSlice(a.t, expected, actual, delta, msgAndArgs...)
< }
< 
< // InDeltaSlicef is the same as InDelta, except it compares two slices.
< func (a *Assertions) InDeltaSlicef(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InDeltaSlicef(a.t, expected, actual, delta, msg, args...)
< }
< 
< // InDeltaf asserts that the two numerals are within delta of each other.
< //
< // 	 a.InDeltaf(math.Pi, 22/7.0, 0.01, "error message %s", "formatted")
< func (a *Assertions) InDeltaf(expected interface{}, actual interface{}, delta float64, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InDeltaf(a.t, expected, actual, delta, msg, args...)
< }
< 
< // InEpsilon asserts that expected and actual have a relative error less than epsilon
< func (a *Assertions) InEpsilon(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InEpsilon(a.t, expected, actual, epsilon, msgAndArgs...)
< }
< 
< // InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.
< func (a *Assertions) InEpsilonSlice(expected interface{}, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InEpsilonSlice(a.t, expected, actual, epsilon, msgAndArgs...)
< }
< 
< // InEpsilonSlicef is the same as InEpsilon, except it compares each value from two slices.
< func (a *Assertions) InEpsilonSlicef(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InEpsilonSlicef(a.t, expected, actual, epsilon, msg, args...)
< }
< 
< // InEpsilonf asserts that expected and actual have a relative error less than epsilon
< func (a *Assertions) InEpsilonf(expected interface{}, actual interface{}, epsilon float64, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return InEpsilonf(a.t, expected, actual, epsilon, msg, args...)
< }
< 
< // IsType asserts that the specified objects are of the same type.
< func (a *Assertions) IsType(expectedType interface{}, object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return IsType(a.t, expectedType, object, msgAndArgs...)
< }
< 
< // IsTypef asserts that the specified objects are of the same type.
< func (a *Assertions) IsTypef(expectedType interface{}, object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return IsTypef(a.t, expectedType, object, msg, args...)
< }
< 
< // JSONEq asserts that two JSON strings are equivalent.
< //
< //  a.JSONEq(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
< func (a *Assertions) JSONEq(expected string, actual string, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return JSONEq(a.t, expected, actual, msgAndArgs...)
< }
< 
< // JSONEqf asserts that two JSON strings are equivalent.
< //
< //  a.JSONEqf(`{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`, "error message %s", "formatted")
< func (a *Assertions) JSONEqf(expected string, actual string, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return JSONEqf(a.t, expected, actual, msg, args...)
< }
< 
< // Len asserts that the specified object has specific length.
< // Len also fails if the object has a type that len() not accept.
< //
< //    a.Len(mySlice, 3)
< func (a *Assertions) Len(object interface{}, length int, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Len(a.t, object, length, msgAndArgs...)
< }
< 
< // Lenf asserts that the specified object has specific length.
< // Lenf also fails if the object has a type that len() not accept.
< //
< //    a.Lenf(mySlice, 3, "error message %s", "formatted")
< func (a *Assertions) Lenf(object interface{}, length int, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Lenf(a.t, object, length, msg, args...)
< }
< 
< // Less asserts that the first element is less than the second
< //
< //    a.Less(1, 2)
< //    a.Less(float64(1), float64(2))
< //    a.Less("a", "b")
< func (a *Assertions) Less(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Less(a.t, e1, e2, msgAndArgs...)
< }
< 
< // LessOrEqual asserts that the first element is less than or equal to the second
< //
< //    a.LessOrEqual(1, 2)
< //    a.LessOrEqual(2, 2)
< //    a.LessOrEqual("a", "b")
< //    a.LessOrEqual("b", "b")
< func (a *Assertions) LessOrEqual(e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return LessOrEqual(a.t, e1, e2, msgAndArgs...)
< }
< 
< // LessOrEqualf asserts that the first element is less than or equal to the second
< //
< //    a.LessOrEqualf(1, 2, "error message %s", "formatted")
< //    a.LessOrEqualf(2, 2, "error message %s", "formatted")
< //    a.LessOrEqualf("a", "b", "error message %s", "formatted")
< //    a.LessOrEqualf("b", "b", "error message %s", "formatted")
< func (a *Assertions) LessOrEqualf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return LessOrEqualf(a.t, e1, e2, msg, args...)
< }
< 
< // Lessf asserts that the first element is less than the second
< //
< //    a.Lessf(1, 2, "error message %s", "formatted")
< //    a.Lessf(float64(1, "error message %s", "formatted"), float64(2))
< //    a.Lessf("a", "b", "error message %s", "formatted")
< func (a *Assertions) Lessf(e1 interface{}, e2 interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Lessf(a.t, e1, e2, msg, args...)
< }
< 
< // Never asserts that the given condition doesn't satisfy in waitFor time,
< // periodically checking the target function each tick.
< //
< //    a.Never(func() bool { return false; }, time.Second, 10*time.Millisecond)
< func (a *Assertions) Never(condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Never(a.t, condition, waitFor, tick, msgAndArgs...)
< }
< 
< // Neverf asserts that the given condition doesn't satisfy in waitFor time,
< // periodically checking the target function each tick.
< //
< //    a.Neverf(func() bool { return false; }, time.Second, 10*time.Millisecond, "error message %s", "formatted")
< func (a *Assertions) Neverf(condition func() bool, waitFor time.Duration, tick time.Duration, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Neverf(a.t, condition, waitFor, tick, msg, args...)
< }
< 
< // Nil asserts that the specified object is nil.
< //
< //    a.Nil(err)
< func (a *Assertions) Nil(object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Nil(a.t, object, msgAndArgs...)
< }
< 
< // Nilf asserts that the specified object is nil.
< //
< //    a.Nilf(err, "error message %s", "formatted")
< func (a *Assertions) Nilf(object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Nilf(a.t, object, msg, args...)
< }
< 
< // NoDirExists checks whether a directory does not exist in the given path.
< // It fails if the path points to an existing _directory_ only.
< func (a *Assertions) NoDirExists(path string, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NoDirExists(a.t, path, msgAndArgs...)
< }
< 
< // NoDirExistsf checks whether a directory does not exist in the given path.
< // It fails if the path points to an existing _directory_ only.
< func (a *Assertions) NoDirExistsf(path string, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NoDirExistsf(a.t, path, msg, args...)
< }
< 
< // NoError asserts that a function returned no error (i.e. `nil`).
< //
< //   actualObj, err := SomeFunction()
< //   if a.NoError(err) {
< // 	   assert.Equal(t, expectedObj, actualObj)
< //   }
< func (a *Assertions) NoError(err error, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NoError(a.t, err, msgAndArgs...)
< }
< 
< // NoErrorf asserts that a function returned no error (i.e. `nil`).
< //
< //   actualObj, err := SomeFunction()
< //   if a.NoErrorf(err, "error message %s", "formatted") {
< // 	   assert.Equal(t, expectedObj, actualObj)
< //   }
< func (a *Assertions) NoErrorf(err error, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NoErrorf(a.t, err, msg, args...)
< }
< 
< // NoFileExists checks whether a file does not exist in a given path. It fails
< // if the path points to an existing _file_ only.
< func (a *Assertions) NoFileExists(path string, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NoFileExists(a.t, path, msgAndArgs...)
< }
< 
< // NoFileExistsf checks whether a file does not exist in a given path. It fails
< // if the path points to an existing _file_ only.
< func (a *Assertions) NoFileExistsf(path string, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NoFileExistsf(a.t, path, msg, args...)
< }
< 
< // NotContains asserts that the specified string, list(array, slice...) or map does NOT contain the
< // specified substring or element.
< //
< //    a.NotContains("Hello World", "Earth")
< //    a.NotContains(["Hello", "World"], "Earth")
< //    a.NotContains({"Hello": "World"}, "Earth")
< func (a *Assertions) NotContains(s interface{}, contains interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotContains(a.t, s, contains, msgAndArgs...)
< }
< 
< // NotContainsf asserts that the specified string, list(array, slice...) or map does NOT contain the
< // specified substring or element.
< //
< //    a.NotContainsf("Hello World", "Earth", "error message %s", "formatted")
< //    a.NotContainsf(["Hello", "World"], "Earth", "error message %s", "formatted")
< //    a.NotContainsf({"Hello": "World"}, "Earth", "error message %s", "formatted")
< func (a *Assertions) NotContainsf(s interface{}, contains interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotContainsf(a.t, s, contains, msg, args...)
< }
< 
< // NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
< // a slice or a channel with len == 0.
< //
< //  if a.NotEmpty(obj) {
< //    assert.Equal(t, "two", obj[1])
< //  }
< func (a *Assertions) NotEmpty(object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotEmpty(a.t, object, msgAndArgs...)
< }
< 
< // NotEmptyf asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
< // a slice or a channel with len == 0.
< //
< //  if a.NotEmptyf(obj, "error message %s", "formatted") {
< //    assert.Equal(t, "two", obj[1])
< //  }
< func (a *Assertions) NotEmptyf(object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotEmptyf(a.t, object, msg, args...)
< }
< 
< // NotEqual asserts that the specified values are NOT equal.
< //
< //    a.NotEqual(obj1, obj2)
< //
< // Pointer variable equality is determined based on the equality of the
< // referenced values (as opposed to the memory addresses).
< func (a *Assertions) NotEqual(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotEqual(a.t, expected, actual, msgAndArgs...)
< }
< 
< // NotEqualf asserts that the specified values are NOT equal.
< //
< //    a.NotEqualf(obj1, obj2, "error message %s", "formatted")
< //
< // Pointer variable equality is determined based on the equality of the
< // referenced values (as opposed to the memory addresses).
< func (a *Assertions) NotEqualf(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotEqualf(a.t, expected, actual, msg, args...)
< }
< 
< // NotNil asserts that the specified object is not nil.
< //
< //    a.NotNil(err)
< func (a *Assertions) NotNil(object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotNil(a.t, object, msgAndArgs...)
< }
< 
< // NotNilf asserts that the specified object is not nil.
< //
< //    a.NotNilf(err, "error message %s", "formatted")
< func (a *Assertions) NotNilf(object interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotNilf(a.t, object, msg, args...)
< }
< 
< // NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.
< //
< //   a.NotPanics(func(){ RemainCalm() })
< func (a *Assertions) NotPanics(f PanicTestFunc, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotPanics(a.t, f, msgAndArgs...)
< }
< 
< // NotPanicsf asserts that the code inside the specified PanicTestFunc does NOT panic.
< //
< //   a.NotPanicsf(func(){ RemainCalm() }, "error message %s", "formatted")
< func (a *Assertions) NotPanicsf(f PanicTestFunc, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotPanicsf(a.t, f, msg, args...)
< }
< 
< // NotRegexp asserts that a specified regexp does not match a string.
< //
< //  a.NotRegexp(regexp.MustCompile("starts"), "it's starting")
< //  a.NotRegexp("^start", "it's not starting")
< func (a *Assertions) NotRegexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotRegexp(a.t, rx, str, msgAndArgs...)
< }
< 
< // NotRegexpf asserts that a specified regexp does not match a string.
< //
< //  a.NotRegexpf(regexp.MustCompile("starts", "error message %s", "formatted"), "it's starting")
< //  a.NotRegexpf("^start", "it's not starting", "error message %s", "formatted")
< func (a *Assertions) NotRegexpf(rx interface{}, str interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotRegexpf(a.t, rx, str, msg, args...)
< }
< 
< // NotSame asserts that two pointers do not reference the same object.
< //
< //    a.NotSame(ptr1, ptr2)
< //
< // Both arguments must be pointer variables. Pointer variable sameness is
< // determined based on the equality of both type and value.
< func (a *Assertions) NotSame(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotSame(a.t, expected, actual, msgAndArgs...)
< }
< 
< // NotSamef asserts that two pointers do not reference the same object.
< //
< //    a.NotSamef(ptr1, ptr2, "error message %s", "formatted")
< //
< // Both arguments must be pointer variables. Pointer variable sameness is
< // determined based on the equality of both type and value.
< func (a *Assertions) NotSamef(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotSamef(a.t, expected, actual, msg, args...)
< }
< 
< // NotSubset asserts that the specified list(array, slice...) contains not all
< // elements given in the specified subset(array, slice...).
< //
< //    a.NotSubset([1, 3, 4], [1, 2], "But [1, 3, 4] does not contain [1, 2]")
< func (a *Assertions) NotSubset(list interface{}, subset interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotSubset(a.t, list, subset, msgAndArgs...)
< }
< 
< // NotSubsetf asserts that the specified list(array, slice...) contains not all
< // elements given in the specified subset(array, slice...).
< //
< //    a.NotSubsetf([1, 3, 4], [1, 2], "But [1, 3, 4] does not contain [1, 2]", "error message %s", "formatted")
< func (a *Assertions) NotSubsetf(list interface{}, subset interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotSubsetf(a.t, list, subset, msg, args...)
< }
< 
< // NotZero asserts that i is not the zero value for its type.
< func (a *Assertions) NotZero(i interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotZero(a.t, i, msgAndArgs...)
< }
< 
< // NotZerof asserts that i is not the zero value for its type.
< func (a *Assertions) NotZerof(i interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return NotZerof(a.t, i, msg, args...)
< }
< 
< // Panics asserts that the code inside the specified PanicTestFunc panics.
< //
< //   a.Panics(func(){ GoCrazy() })
< func (a *Assertions) Panics(f PanicTestFunc, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Panics(a.t, f, msgAndArgs...)
< }
< 
< // PanicsWithError asserts that the code inside the specified PanicTestFunc
< // panics, and that the recovered panic value is an error that satisfies the
< // EqualError comparison.
< //
< //   a.PanicsWithError("crazy error", func(){ GoCrazy() })
< func (a *Assertions) PanicsWithError(errString string, f PanicTestFunc, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return PanicsWithError(a.t, errString, f, msgAndArgs...)
< }
< 
< // PanicsWithErrorf asserts that the code inside the specified PanicTestFunc
< // panics, and that the recovered panic value is an error that satisfies the
< // EqualError comparison.
< //
< //   a.PanicsWithErrorf("crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
< func (a *Assertions) PanicsWithErrorf(errString string, f PanicTestFunc, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return PanicsWithErrorf(a.t, errString, f, msg, args...)
< }
< 
< // PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that
< // the recovered panic value equals the expected panic value.
< //
< //   a.PanicsWithValue("crazy error", func(){ GoCrazy() })
< func (a *Assertions) PanicsWithValue(expected interface{}, f PanicTestFunc, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return PanicsWithValue(a.t, expected, f, msgAndArgs...)
< }
< 
< // PanicsWithValuef asserts that the code inside the specified PanicTestFunc panics, and that
< // the recovered panic value equals the expected panic value.
< //
< //   a.PanicsWithValuef("crazy error", func(){ GoCrazy() }, "error message %s", "formatted")
< func (a *Assertions) PanicsWithValuef(expected interface{}, f PanicTestFunc, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return PanicsWithValuef(a.t, expected, f, msg, args...)
< }
< 
< // Panicsf asserts that the code inside the specified PanicTestFunc panics.
< //
< //   a.Panicsf(func(){ GoCrazy() }, "error message %s", "formatted")
< func (a *Assertions) Panicsf(f PanicTestFunc, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Panicsf(a.t, f, msg, args...)
< }
< 
< // Regexp asserts that a specified regexp matches a string.
< //
< //  a.Regexp(regexp.MustCompile("start"), "it's starting")
< //  a.Regexp("start...$", "it's not starting")
< func (a *Assertions) Regexp(rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Regexp(a.t, rx, str, msgAndArgs...)
< }
< 
< // Regexpf asserts that a specified regexp matches a string.
< //
< //  a.Regexpf(regexp.MustCompile("start", "error message %s", "formatted"), "it's starting")
< //  a.Regexpf("start...$", "it's not starting", "error message %s", "formatted")
< func (a *Assertions) Regexpf(rx interface{}, str interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Regexpf(a.t, rx, str, msg, args...)
< }
< 
< // Same asserts that two pointers reference the same object.
< //
< //    a.Same(ptr1, ptr2)
< //
< // Both arguments must be pointer variables. Pointer variable sameness is
< // determined based on the equality of both type and value.
< func (a *Assertions) Same(expected interface{}, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Same(a.t, expected, actual, msgAndArgs...)
< }
< 
< // Samef asserts that two pointers reference the same object.
< //
< //    a.Samef(ptr1, ptr2, "error message %s", "formatted")
< //
< // Both arguments must be pointer variables. Pointer variable sameness is
< // determined based on the equality of both type and value.
< func (a *Assertions) Samef(expected interface{}, actual interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Samef(a.t, expected, actual, msg, args...)
< }
< 
< // Subset asserts that the specified list(array, slice...) contains all
< // elements given in the specified subset(array, slice...).
< //
< //    a.Subset([1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]")
< func (a *Assertions) Subset(list interface{}, subset interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Subset(a.t, list, subset, msgAndArgs...)
< }
< 
< // Subsetf asserts that the specified list(array, slice...) contains all
< // elements given in the specified subset(array, slice...).
< //
< //    a.Subsetf([1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]", "error message %s", "formatted")
< func (a *Assertions) Subsetf(list interface{}, subset interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Subsetf(a.t, list, subset, msg, args...)
< }
< 
< // True asserts that the specified value is true.
< //
< //    a.True(myBool)
< func (a *Assertions) True(value bool, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return True(a.t, value, msgAndArgs...)
< }
< 
< // Truef asserts that the specified value is true.
< //
< //    a.Truef(myBool, "error message %s", "formatted")
< func (a *Assertions) Truef(value bool, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Truef(a.t, value, msg, args...)
< }
< 
< // WithinDuration asserts that the two times are within duration delta of each other.
< //
< //   a.WithinDuration(time.Now(), time.Now(), 10*time.Second)
< func (a *Assertions) WithinDuration(expected time.Time, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return WithinDuration(a.t, expected, actual, delta, msgAndArgs...)
< }
< 
< // WithinDurationf asserts that the two times are within duration delta of each other.
< //
< //   a.WithinDurationf(time.Now(), time.Now(), 10*time.Second, "error message %s", "formatted")
< func (a *Assertions) WithinDurationf(expected time.Time, actual time.Time, delta time.Duration, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return WithinDurationf(a.t, expected, actual, delta, msg, args...)
< }
< 
< // YAMLEq asserts that two YAML strings are equivalent.
< func (a *Assertions) YAMLEq(expected string, actual string, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return YAMLEq(a.t, expected, actual, msgAndArgs...)
< }
< 
< // YAMLEqf asserts that two YAML strings are equivalent.
< func (a *Assertions) YAMLEqf(expected string, actual string, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return YAMLEqf(a.t, expected, actual, msg, args...)
< }
< 
< // Zero asserts that i is the zero value for its type.
< func (a *Assertions) Zero(i interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Zero(a.t, i, msgAndArgs...)
< }
< 
< // Zerof asserts that i is the zero value for its type.
< func (a *Assertions) Zerof(i interface{}, msg string, args ...interface{}) bool {
< 	if h, ok := a.t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	return Zerof(a.t, i, msg, args...)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_forward.go.tmpl updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_forward.go.tmpl
1,5d0
< {{.CommentWithoutT "a"}}
< func (a *Assertions) {{.DocInfo.Name}}({{.Params}}) bool {
< 	if h, ok := a.t.(tHelper); ok { h.Helper() }
< 	return {{.DocInfo.Name}}(a.t, {{.ForwardedParams}})
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_order.go updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertion_order.go
1,309d0
< package assert
< 
< import (
< 	"fmt"
< 	"reflect"
< )
< 
< func compare(obj1, obj2 interface{}, kind reflect.Kind) (int, bool) {
< 	switch kind {
< 	case reflect.Int:
< 		{
< 			intobj1 := obj1.(int)
< 			intobj2 := obj2.(int)
< 			if intobj1 > intobj2 {
< 				return -1, true
< 			}
< 			if intobj1 == intobj2 {
< 				return 0, true
< 			}
< 			if intobj1 < intobj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Int8:
< 		{
< 			int8obj1 := obj1.(int8)
< 			int8obj2 := obj2.(int8)
< 			if int8obj1 > int8obj2 {
< 				return -1, true
< 			}
< 			if int8obj1 == int8obj2 {
< 				return 0, true
< 			}
< 			if int8obj1 < int8obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Int16:
< 		{
< 			int16obj1 := obj1.(int16)
< 			int16obj2 := obj2.(int16)
< 			if int16obj1 > int16obj2 {
< 				return -1, true
< 			}
< 			if int16obj1 == int16obj2 {
< 				return 0, true
< 			}
< 			if int16obj1 < int16obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Int32:
< 		{
< 			int32obj1 := obj1.(int32)
< 			int32obj2 := obj2.(int32)
< 			if int32obj1 > int32obj2 {
< 				return -1, true
< 			}
< 			if int32obj1 == int32obj2 {
< 				return 0, true
< 			}
< 			if int32obj1 < int32obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Int64:
< 		{
< 			int64obj1 := obj1.(int64)
< 			int64obj2 := obj2.(int64)
< 			if int64obj1 > int64obj2 {
< 				return -1, true
< 			}
< 			if int64obj1 == int64obj2 {
< 				return 0, true
< 			}
< 			if int64obj1 < int64obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Uint:
< 		{
< 			uintobj1 := obj1.(uint)
< 			uintobj2 := obj2.(uint)
< 			if uintobj1 > uintobj2 {
< 				return -1, true
< 			}
< 			if uintobj1 == uintobj2 {
< 				return 0, true
< 			}
< 			if uintobj1 < uintobj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Uint8:
< 		{
< 			uint8obj1 := obj1.(uint8)
< 			uint8obj2 := obj2.(uint8)
< 			if uint8obj1 > uint8obj2 {
< 				return -1, true
< 			}
< 			if uint8obj1 == uint8obj2 {
< 				return 0, true
< 			}
< 			if uint8obj1 < uint8obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Uint16:
< 		{
< 			uint16obj1 := obj1.(uint16)
< 			uint16obj2 := obj2.(uint16)
< 			if uint16obj1 > uint16obj2 {
< 				return -1, true
< 			}
< 			if uint16obj1 == uint16obj2 {
< 				return 0, true
< 			}
< 			if uint16obj1 < uint16obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Uint32:
< 		{
< 			uint32obj1 := obj1.(uint32)
< 			uint32obj2 := obj2.(uint32)
< 			if uint32obj1 > uint32obj2 {
< 				return -1, true
< 			}
< 			if uint32obj1 == uint32obj2 {
< 				return 0, true
< 			}
< 			if uint32obj1 < uint32obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Uint64:
< 		{
< 			uint64obj1 := obj1.(uint64)
< 			uint64obj2 := obj2.(uint64)
< 			if uint64obj1 > uint64obj2 {
< 				return -1, true
< 			}
< 			if uint64obj1 == uint64obj2 {
< 				return 0, true
< 			}
< 			if uint64obj1 < uint64obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Float32:
< 		{
< 			float32obj1 := obj1.(float32)
< 			float32obj2 := obj2.(float32)
< 			if float32obj1 > float32obj2 {
< 				return -1, true
< 			}
< 			if float32obj1 == float32obj2 {
< 				return 0, true
< 			}
< 			if float32obj1 < float32obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.Float64:
< 		{
< 			float64obj1 := obj1.(float64)
< 			float64obj2 := obj2.(float64)
< 			if float64obj1 > float64obj2 {
< 				return -1, true
< 			}
< 			if float64obj1 == float64obj2 {
< 				return 0, true
< 			}
< 			if float64obj1 < float64obj2 {
< 				return 1, true
< 			}
< 		}
< 	case reflect.String:
< 		{
< 			stringobj1 := obj1.(string)
< 			stringobj2 := obj2.(string)
< 			if stringobj1 > stringobj2 {
< 				return -1, true
< 			}
< 			if stringobj1 == stringobj2 {
< 				return 0, true
< 			}
< 			if stringobj1 < stringobj2 {
< 				return 1, true
< 			}
< 		}
< 	}
< 
< 	return 0, false
< }
< 
< // Greater asserts that the first element is greater than the second
< //
< //    assert.Greater(t, 2, 1)
< //    assert.Greater(t, float64(2), float64(1))
< //    assert.Greater(t, "b", "a")
< func Greater(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	e1Kind := reflect.ValueOf(e1).Kind()
< 	e2Kind := reflect.ValueOf(e2).Kind()
< 	if e1Kind != e2Kind {
< 		return Fail(t, "Elements should be the same type", msgAndArgs...)
< 	}
< 
< 	res, isComparable := compare(e1, e2, e1Kind)
< 	if !isComparable {
< 		return Fail(t, fmt.Sprintf("Can not compare type \"%s\"", reflect.TypeOf(e1)), msgAndArgs...)
< 	}
< 
< 	if res != -1 {
< 		return Fail(t, fmt.Sprintf("\"%v\" is not greater than \"%v\"", e1, e2), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // GreaterOrEqual asserts that the first element is greater than or equal to the second
< //
< //    assert.GreaterOrEqual(t, 2, 1)
< //    assert.GreaterOrEqual(t, 2, 2)
< //    assert.GreaterOrEqual(t, "b", "a")
< //    assert.GreaterOrEqual(t, "b", "b")
< func GreaterOrEqual(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	e1Kind := reflect.ValueOf(e1).Kind()
< 	e2Kind := reflect.ValueOf(e2).Kind()
< 	if e1Kind != e2Kind {
< 		return Fail(t, "Elements should be the same type", msgAndArgs...)
< 	}
< 
< 	res, isComparable := compare(e1, e2, e1Kind)
< 	if !isComparable {
< 		return Fail(t, fmt.Sprintf("Can not compare type \"%s\"", reflect.TypeOf(e1)), msgAndArgs...)
< 	}
< 
< 	if res != -1 && res != 0 {
< 		return Fail(t, fmt.Sprintf("\"%v\" is not greater than or equal to \"%v\"", e1, e2), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // Less asserts that the first element is less than the second
< //
< //    assert.Less(t, 1, 2)
< //    assert.Less(t, float64(1), float64(2))
< //    assert.Less(t, "a", "b")
< func Less(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	e1Kind := reflect.ValueOf(e1).Kind()
< 	e2Kind := reflect.ValueOf(e2).Kind()
< 	if e1Kind != e2Kind {
< 		return Fail(t, "Elements should be the same type", msgAndArgs...)
< 	}
< 
< 	res, isComparable := compare(e1, e2, e1Kind)
< 	if !isComparable {
< 		return Fail(t, fmt.Sprintf("Can not compare type \"%s\"", reflect.TypeOf(e1)), msgAndArgs...)
< 	}
< 
< 	if res != 1 {
< 		return Fail(t, fmt.Sprintf("\"%v\" is not less than \"%v\"", e1, e2), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // LessOrEqual asserts that the first element is less than or equal to the second
< //
< //    assert.LessOrEqual(t, 1, 2)
< //    assert.LessOrEqual(t, 2, 2)
< //    assert.LessOrEqual(t, "a", "b")
< //    assert.LessOrEqual(t, "b", "b")
< func LessOrEqual(t TestingT, e1 interface{}, e2 interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	e1Kind := reflect.ValueOf(e1).Kind()
< 	e2Kind := reflect.ValueOf(e2).Kind()
< 	if e1Kind != e2Kind {
< 		return Fail(t, "Elements should be the same type", msgAndArgs...)
< 	}
< 
< 	res, isComparable := compare(e1, e2, e1Kind)
< 	if !isComparable {
< 		return Fail(t, fmt.Sprintf("Can not compare type \"%s\"", reflect.TypeOf(e1)), msgAndArgs...)
< 	}
< 
< 	if res != 1 && res != 0 {
< 		return Fail(t, fmt.Sprintf("\"%v\" is not less than or equal to \"%v\"", e1, e2), msgAndArgs...)
< 	}
< 
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertions.go updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/assertions.go
1,1626d0
< package assert
< 
< import (
< 	"bufio"
< 	"bytes"
< 	"encoding/json"
< 	"errors"
< 	"fmt"
< 	"math"
< 	"os"
< 	"reflect"
< 	"regexp"
< 	"runtime"
< 	"runtime/debug"
< 	"strings"
< 	"time"
< 	"unicode"
< 	"unicode/utf8"
< 
< 	"github.com/davecgh/go-spew/spew"
< 	"github.com/pmezard/go-difflib/difflib"
< 	yaml "gopkg.in/yaml.v2"
< )
< 
< //go:generate sh -c "cd ../_codegen && go build && cd - && ../_codegen/_codegen -output-package=assert -template=assertion_format.go.tmpl"
< 
< // TestingT is an interface wrapper around *testing.T
< type TestingT interface {
< 	Errorf(format string, args ...interface{})
< }
< 
< // ComparisonAssertionFunc is a common function prototype when comparing two values.  Can be useful
< // for table driven tests.
< type ComparisonAssertionFunc func(TestingT, interface{}, interface{}, ...interface{}) bool
< 
< // ValueAssertionFunc is a common function prototype when validating a single value.  Can be useful
< // for table driven tests.
< type ValueAssertionFunc func(TestingT, interface{}, ...interface{}) bool
< 
< // BoolAssertionFunc is a common function prototype when validating a bool value.  Can be useful
< // for table driven tests.
< type BoolAssertionFunc func(TestingT, bool, ...interface{}) bool
< 
< // ErrorAssertionFunc is a common function prototype when validating an error value.  Can be useful
< // for table driven tests.
< type ErrorAssertionFunc func(TestingT, error, ...interface{}) bool
< 
< // Comparison a custom function that returns true on success and false on failure
< type Comparison func() (success bool)
< 
< /*
< 	Helper functions
< */
< 
< // ObjectsAreEqual determines if two objects are considered equal.
< //
< // This function does no assertion of any kind.
< func ObjectsAreEqual(expected, actual interface{}) bool {
< 	if expected == nil || actual == nil {
< 		return expected == actual
< 	}
< 
< 	exp, ok := expected.([]byte)
< 	if !ok {
< 		return reflect.DeepEqual(expected, actual)
< 	}
< 
< 	act, ok := actual.([]byte)
< 	if !ok {
< 		return false
< 	}
< 	if exp == nil || act == nil {
< 		return exp == nil && act == nil
< 	}
< 	return bytes.Equal(exp, act)
< }
< 
< // ObjectsAreEqualValues gets whether two objects are equal, or if their
< // values are equal.
< func ObjectsAreEqualValues(expected, actual interface{}) bool {
< 	if ObjectsAreEqual(expected, actual) {
< 		return true
< 	}
< 
< 	actualType := reflect.TypeOf(actual)
< 	if actualType == nil {
< 		return false
< 	}
< 	expectedValue := reflect.ValueOf(expected)
< 	if expectedValue.IsValid() && expectedValue.Type().ConvertibleTo(actualType) {
< 		// Attempt comparison after type conversion
< 		return reflect.DeepEqual(expectedValue.Convert(actualType).Interface(), actual)
< 	}
< 
< 	return false
< }
< 
< /* CallerInfo is necessary because the assert functions use the testing object
< internally, causing it to print the file:line of the assert method, rather than where
< the problem actually occurred in calling code.*/
< 
< // CallerInfo returns an array of strings containing the file and line number
< // of each stack frame leading from the current test to the assert call that
< // failed.
< func CallerInfo() []string {
< 
< 	pc := uintptr(0)
< 	file := ""
< 	line := 0
< 	ok := false
< 	name := ""
< 
< 	callers := []string{}
< 	for i := 0; ; i++ {
< 		pc, file, line, ok = runtime.Caller(i)
< 		if !ok {
< 			// The breaks below failed to terminate the loop, and we ran off the
< 			// end of the call stack.
< 			break
< 		}
< 
< 		// This is a huge edge case, but it will panic if this is the case, see #180
< 		if file == "<autogenerated>" {
< 			break
< 		}
< 
< 		f := runtime.FuncForPC(pc)
< 		if f == nil {
< 			break
< 		}
< 		name = f.Name()
< 
< 		// testing.tRunner is the standard library function that calls
< 		// tests. Subtests are called directly by tRunner, without going through
< 		// the Test/Benchmark/Example function that contains the t.Run calls, so
< 		// with subtests we should break when we hit tRunner, without adding it
< 		// to the list of callers.
< 		if name == "testing.tRunner" {
< 			break
< 		}
< 
< 		parts := strings.Split(file, "/")
< 		file = parts[len(parts)-1]
< 		if len(parts) > 1 {
< 			dir := parts[len(parts)-2]
< 			if (dir != "assert" && dir != "mock" && dir != "require") || file == "mock_test.go" {
< 				callers = append(callers, fmt.Sprintf("%s:%d", file, line))
< 			}
< 		}
< 
< 		// Drop the package
< 		segments := strings.Split(name, ".")
< 		name = segments[len(segments)-1]
< 		if isTest(name, "Test") ||
< 			isTest(name, "Benchmark") ||
< 			isTest(name, "Example") {
< 			break
< 		}
< 	}
< 
< 	return callers
< }
< 
< // Stolen from the `go test` tool.
< // isTest tells whether name looks like a test (or benchmark, according to prefix).
< // It is a Test (say) if there is a character after Test that is not a lower-case letter.
< // We don't want TesticularCancer.
< func isTest(name, prefix string) bool {
< 	if !strings.HasPrefix(name, prefix) {
< 		return false
< 	}
< 	if len(name) == len(prefix) { // "Test" is ok
< 		return true
< 	}
< 	rune, _ := utf8.DecodeRuneInString(name[len(prefix):])
< 	return !unicode.IsLower(rune)
< }
< 
< func messageFromMsgAndArgs(msgAndArgs ...interface{}) string {
< 	if len(msgAndArgs) == 0 || msgAndArgs == nil {
< 		return ""
< 	}
< 	if len(msgAndArgs) == 1 {
< 		msg := msgAndArgs[0]
< 		if msgAsStr, ok := msg.(string); ok {
< 			return msgAsStr
< 		}
< 		return fmt.Sprintf("%+v", msg)
< 	}
< 	if len(msgAndArgs) > 1 {
< 		return fmt.Sprintf(msgAndArgs[0].(string), msgAndArgs[1:]...)
< 	}
< 	return ""
< }
< 
< // Aligns the provided message so that all lines after the first line start at the same location as the first line.
< // Assumes that the first line starts at the correct location (after carriage return, tab, label, spacer and tab).
< // The longestLabelLen parameter specifies the length of the longest label in the output (required becaues this is the
< // basis on which the alignment occurs).
< func indentMessageLines(message string, longestLabelLen int) string {
< 	outBuf := new(bytes.Buffer)
< 
< 	for i, scanner := 0, bufio.NewScanner(strings.NewReader(message)); scanner.Scan(); i++ {
< 		// no need to align first line because it starts at the correct location (after the label)
< 		if i != 0 {
< 			// append alignLen+1 spaces to align with "{{longestLabel}}:" before adding tab
< 			outBuf.WriteString("\n\t" + strings.Repeat(" ", longestLabelLen+1) + "\t")
< 		}
< 		outBuf.WriteString(scanner.Text())
< 	}
< 
< 	return outBuf.String()
< }
< 
< type failNower interface {
< 	FailNow()
< }
< 
< // FailNow fails test
< func FailNow(t TestingT, failureMessage string, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	Fail(t, failureMessage, msgAndArgs...)
< 
< 	// We cannot extend TestingT with FailNow() and
< 	// maintain backwards compatibility, so we fallback
< 	// to panicking when FailNow is not available in
< 	// TestingT.
< 	// See issue #263
< 
< 	if t, ok := t.(failNower); ok {
< 		t.FailNow()
< 	} else {
< 		panic("test failed and t is missing `FailNow()`")
< 	}
< 	return false
< }
< 
< // Fail reports a failure through
< func Fail(t TestingT, failureMessage string, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	content := []labeledContent{
< 		{"Error Trace", strings.Join(CallerInfo(), "\n\t\t\t")},
< 		{"Error", failureMessage},
< 	}
< 
< 	// Add test name if the Go version supports it
< 	if n, ok := t.(interface {
< 		Name() string
< 	}); ok {
< 		content = append(content, labeledContent{"Test", n.Name()})
< 	}
< 
< 	message := messageFromMsgAndArgs(msgAndArgs...)
< 	if len(message) > 0 {
< 		content = append(content, labeledContent{"Messages", message})
< 	}
< 
< 	t.Errorf("\n%s", ""+labeledOutput(content...))
< 
< 	return false
< }
< 
< type labeledContent struct {
< 	label   string
< 	content string
< }
< 
< // labeledOutput returns a string consisting of the provided labeledContent. Each labeled output is appended in the following manner:
< //
< //   \t{{label}}:{{align_spaces}}\t{{content}}\n
< //
< // The initial carriage return is required to undo/erase any padding added by testing.T.Errorf. The "\t{{label}}:" is for the label.
< // If a label is shorter than the longest label provided, padding spaces are added to make all the labels match in length. Once this
< // alignment is achieved, "\t{{content}}\n" is added for the output.
< //
< // If the content of the labeledOutput contains line breaks, the subsequent lines are aligned so that they start at the same location as the first line.
< func labeledOutput(content ...labeledContent) string {
< 	longestLabel := 0
< 	for _, v := range content {
< 		if len(v.label) > longestLabel {
< 			longestLabel = len(v.label)
< 		}
< 	}
< 	var output string
< 	for _, v := range content {
< 		output += "\t" + v.label + ":" + strings.Repeat(" ", longestLabel-len(v.label)) + "\t" + indentMessageLines(v.content, longestLabel) + "\n"
< 	}
< 	return output
< }
< 
< // Implements asserts that an object is implemented by the specified interface.
< //
< //    assert.Implements(t, (*MyInterface)(nil), new(MyObject))
< func Implements(t TestingT, interfaceObject interface{}, object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	interfaceType := reflect.TypeOf(interfaceObject).Elem()
< 
< 	if object == nil {
< 		return Fail(t, fmt.Sprintf("Cannot check if nil implements %v", interfaceType), msgAndArgs...)
< 	}
< 	if !reflect.TypeOf(object).Implements(interfaceType) {
< 		return Fail(t, fmt.Sprintf("%T must implement %v", object, interfaceType), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // IsType asserts that the specified objects are of the same type.
< func IsType(t TestingT, expectedType interface{}, object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	if !ObjectsAreEqual(reflect.TypeOf(object), reflect.TypeOf(expectedType)) {
< 		return Fail(t, fmt.Sprintf("Object expected to be of type %v, but was %v", reflect.TypeOf(expectedType), reflect.TypeOf(object)), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // Equal asserts that two objects are equal.
< //
< //    assert.Equal(t, 123, 123)
< //
< // Pointer variable equality is determined based on the equality of the
< // referenced values (as opposed to the memory addresses). Function equality
< // cannot be determined and will always fail.
< func Equal(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if err := validateEqualArgs(expected, actual); err != nil {
< 		return Fail(t, fmt.Sprintf("Invalid operation: %#v == %#v (%s)",
< 			expected, actual, err), msgAndArgs...)
< 	}
< 
< 	if !ObjectsAreEqual(expected, actual) {
< 		diff := diff(expected, actual)
< 		expected, actual = formatUnequalValues(expected, actual)
< 		return Fail(t, fmt.Sprintf("Not equal: \n"+
< 			"expected: %s\n"+
< 			"actual  : %s%s", expected, actual, diff), msgAndArgs...)
< 	}
< 
< 	return true
< 
< }
< 
< // validateEqualArgs checks whether provided arguments can be safely used in the
< // Equal/NotEqual functions.
< func validateEqualArgs(expected, actual interface{}) error {
< 	if expected == nil && actual == nil {
< 		return nil
< 	}
< 
< 	if isFunction(expected) || isFunction(actual) {
< 		return errors.New("cannot take func type as argument")
< 	}
< 	return nil
< }
< 
< // Same asserts that two pointers reference the same object.
< //
< //    assert.Same(t, ptr1, ptr2)
< //
< // Both arguments must be pointer variables. Pointer variable sameness is
< // determined based on the equality of both type and value.
< func Same(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	if !samePointers(expected, actual) {
< 		return Fail(t, fmt.Sprintf("Not same: \n"+
< 			"expected: %p %#v\n"+
< 			"actual  : %p %#v", expected, expected, actual, actual), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // NotSame asserts that two pointers do not reference the same object.
< //
< //    assert.NotSame(t, ptr1, ptr2)
< //
< // Both arguments must be pointer variables. Pointer variable sameness is
< // determined based on the equality of both type and value.
< func NotSame(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	if samePointers(expected, actual) {
< 		return Fail(t, fmt.Sprintf(
< 			"Expected and actual point to the same object: %p %#v",
< 			expected, expected), msgAndArgs...)
< 	}
< 	return true
< }
< 
< // samePointers compares two generic interface objects and returns whether
< // they point to the same object
< func samePointers(first, second interface{}) bool {
< 	firstPtr, secondPtr := reflect.ValueOf(first), reflect.ValueOf(second)
< 	if firstPtr.Kind() != reflect.Ptr || secondPtr.Kind() != reflect.Ptr {
< 		return false
< 	}
< 
< 	firstType, secondType := reflect.TypeOf(first), reflect.TypeOf(second)
< 	if firstType != secondType {
< 		return false
< 	}
< 
< 	// compare pointer addresses
< 	return first == second
< }
< 
< // formatUnequalValues takes two values of arbitrary types and returns string
< // representations appropriate to be presented to the user.
< //
< // If the values are not of like type, the returned strings will be prefixed
< // with the type name, and the value will be enclosed in parenthesis similar
< // to a type conversion in the Go grammar.
< func formatUnequalValues(expected, actual interface{}) (e string, a string) {
< 	if reflect.TypeOf(expected) != reflect.TypeOf(actual) {
< 		return fmt.Sprintf("%T(%#v)", expected, expected),
< 			fmt.Sprintf("%T(%#v)", actual, actual)
< 	}
< 	switch expected.(type) {
< 	case time.Duration:
< 		return fmt.Sprintf("%v", expected), fmt.Sprintf("%v", actual)
< 	}
< 	return fmt.Sprintf("%#v", expected), fmt.Sprintf("%#v", actual)
< }
< 
< // EqualValues asserts that two objects are equal or convertable to the same types
< // and equal.
< //
< //    assert.EqualValues(t, uint32(123), int32(123))
< func EqualValues(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	if !ObjectsAreEqualValues(expected, actual) {
< 		diff := diff(expected, actual)
< 		expected, actual = formatUnequalValues(expected, actual)
< 		return Fail(t, fmt.Sprintf("Not equal: \n"+
< 			"expected: %s\n"+
< 			"actual  : %s%s", expected, actual, diff), msgAndArgs...)
< 	}
< 
< 	return true
< 
< }
< 
< // Exactly asserts that two objects are equal in value and type.
< //
< //    assert.Exactly(t, int32(123), int64(123))
< func Exactly(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	aType := reflect.TypeOf(expected)
< 	bType := reflect.TypeOf(actual)
< 
< 	if aType != bType {
< 		return Fail(t, fmt.Sprintf("Types expected to match exactly\n\t%v != %v", aType, bType), msgAndArgs...)
< 	}
< 
< 	return Equal(t, expected, actual, msgAndArgs...)
< 
< }
< 
< // NotNil asserts that the specified object is not nil.
< //
< //    assert.NotNil(t, err)
< func NotNil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if !isNil(object) {
< 		return true
< 	}
< 	return Fail(t, "Expected value not to be nil.", msgAndArgs...)
< }
< 
< // containsKind checks if a specified kind in the slice of kinds.
< func containsKind(kinds []reflect.Kind, kind reflect.Kind) bool {
< 	for i := 0; i < len(kinds); i++ {
< 		if kind == kinds[i] {
< 			return true
< 		}
< 	}
< 
< 	return false
< }
< 
< // isNil checks if a specified object is nil or not, without Failing.
< func isNil(object interface{}) bool {
< 	if object == nil {
< 		return true
< 	}
< 
< 	value := reflect.ValueOf(object)
< 	kind := value.Kind()
< 	isNilableKind := containsKind(
< 		[]reflect.Kind{
< 			reflect.Chan, reflect.Func,
< 			reflect.Interface, reflect.Map,
< 			reflect.Ptr, reflect.Slice},
< 		kind)
< 
< 	if isNilableKind && value.IsNil() {
< 		return true
< 	}
< 
< 	return false
< }
< 
< // Nil asserts that the specified object is nil.
< //
< //    assert.Nil(t, err)
< func Nil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if isNil(object) {
< 		return true
< 	}
< 	return Fail(t, fmt.Sprintf("Expected nil, but got: %#v", object), msgAndArgs...)
< }
< 
< // isEmpty gets whether the specified object is considered empty or not.
< func isEmpty(object interface{}) bool {
< 
< 	// get nil case out of the way
< 	if object == nil {
< 		return true
< 	}
< 
< 	objValue := reflect.ValueOf(object)
< 
< 	switch objValue.Kind() {
< 	// collection types are empty when they have no element
< 	case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:
< 		return objValue.Len() == 0
< 		// pointers are empty if nil or if the value they point to is empty
< 	case reflect.Ptr:
< 		if objValue.IsNil() {
< 			return true
< 		}
< 		deref := objValue.Elem().Interface()
< 		return isEmpty(deref)
< 		// for all other types, compare against the zero value
< 	default:
< 		zero := reflect.Zero(objValue.Type())
< 		return reflect.DeepEqual(object, zero.Interface())
< 	}
< }
< 
< // Empty asserts that the specified object is empty.  I.e. nil, "", false, 0 or either
< // a slice or a channel with len == 0.
< //
< //  assert.Empty(t, obj)
< func Empty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	pass := isEmpty(object)
< 	if !pass {
< 		Fail(t, fmt.Sprintf("Should be empty, but was %v", object), msgAndArgs...)
< 	}
< 
< 	return pass
< 
< }
< 
< // NotEmpty asserts that the specified object is NOT empty.  I.e. not nil, "", false, 0 or either
< // a slice or a channel with len == 0.
< //
< //  if assert.NotEmpty(t, obj) {
< //    assert.Equal(t, "two", obj[1])
< //  }
< func NotEmpty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	pass := !isEmpty(object)
< 	if !pass {
< 		Fail(t, fmt.Sprintf("Should NOT be empty, but was %v", object), msgAndArgs...)
< 	}
< 
< 	return pass
< 
< }
< 
< // getLen try to get length of object.
< // return (false, 0) if impossible.
< func getLen(x interface{}) (ok bool, length int) {
< 	v := reflect.ValueOf(x)
< 	defer func() {
< 		if e := recover(); e != nil {
< 			ok = false
< 		}
< 	}()
< 	return true, v.Len()
< }
< 
< // Len asserts that the specified object has specific length.
< // Len also fails if the object has a type that len() not accept.
< //
< //    assert.Len(t, mySlice, 3)
< func Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	ok, l := getLen(object)
< 	if !ok {
< 		return Fail(t, fmt.Sprintf("\"%s\" could not be applied builtin len()", object), msgAndArgs...)
< 	}
< 
< 	if l != length {
< 		return Fail(t, fmt.Sprintf("\"%s\" should have %d item(s), but has %d", object, length, l), msgAndArgs...)
< 	}
< 	return true
< }
< 
< // True asserts that the specified value is true.
< //
< //    assert.True(t, myBool)
< func True(t TestingT, value bool, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if h, ok := t.(interface {
< 		Helper()
< 	}); ok {
< 		h.Helper()
< 	}
< 
< 	if value != true {
< 		return Fail(t, "Should be true", msgAndArgs...)
< 	}
< 
< 	return true
< 
< }
< 
< // False asserts that the specified value is false.
< //
< //    assert.False(t, myBool)
< func False(t TestingT, value bool, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	if value != false {
< 		return Fail(t, "Should be false", msgAndArgs...)
< 	}
< 
< 	return true
< 
< }
< 
< // NotEqual asserts that the specified values are NOT equal.
< //
< //    assert.NotEqual(t, obj1, obj2)
< //
< // Pointer variable equality is determined based on the equality of the
< // referenced values (as opposed to the memory addresses).
< func NotEqual(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if err := validateEqualArgs(expected, actual); err != nil {
< 		return Fail(t, fmt.Sprintf("Invalid operation: %#v != %#v (%s)",
< 			expected, actual, err), msgAndArgs...)
< 	}
< 
< 	if ObjectsAreEqual(expected, actual) {
< 		return Fail(t, fmt.Sprintf("Should not be: %#v\n", actual), msgAndArgs...)
< 	}
< 
< 	return true
< 
< }
< 
< // containsElement try loop over the list check if the list includes the element.
< // return (false, false) if impossible.
< // return (true, false) if element was not found.
< // return (true, true) if element was found.
< func includeElement(list interface{}, element interface{}) (ok, found bool) {
< 
< 	listValue := reflect.ValueOf(list)
< 	listKind := reflect.TypeOf(list).Kind()
< 	defer func() {
< 		if e := recover(); e != nil {
< 			ok = false
< 			found = false
< 		}
< 	}()
< 
< 	if listKind == reflect.String {
< 		elementValue := reflect.ValueOf(element)
< 		return true, strings.Contains(listValue.String(), elementValue.String())
< 	}
< 
< 	if listKind == reflect.Map {
< 		mapKeys := listValue.MapKeys()
< 		for i := 0; i < len(mapKeys); i++ {
< 			if ObjectsAreEqual(mapKeys[i].Interface(), element) {
< 				return true, true
< 			}
< 		}
< 		return true, false
< 	}
< 
< 	for i := 0; i < listValue.Len(); i++ {
< 		if ObjectsAreEqual(listValue.Index(i).Interface(), element) {
< 			return true, true
< 		}
< 	}
< 	return true, false
< 
< }
< 
< // Contains asserts that the specified string, list(array, slice...) or map contains the
< // specified substring or element.
< //
< //    assert.Contains(t, "Hello World", "World")
< //    assert.Contains(t, ["Hello", "World"], "World")
< //    assert.Contains(t, {"Hello": "World"}, "Hello")
< func Contains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	ok, found := includeElement(s, contains)
< 	if !ok {
< 		return Fail(t, fmt.Sprintf("\"%s\" could not be applied builtin len()", s), msgAndArgs...)
< 	}
< 	if !found {
< 		return Fail(t, fmt.Sprintf("\"%s\" does not contain \"%s\"", s, contains), msgAndArgs...)
< 	}
< 
< 	return true
< 
< }
< 
< // NotContains asserts that the specified string, list(array, slice...) or map does NOT contain the
< // specified substring or element.
< //
< //    assert.NotContains(t, "Hello World", "Earth")
< //    assert.NotContains(t, ["Hello", "World"], "Earth")
< //    assert.NotContains(t, {"Hello": "World"}, "Earth")
< func NotContains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	ok, found := includeElement(s, contains)
< 	if !ok {
< 		return Fail(t, fmt.Sprintf("\"%s\" could not be applied builtin len()", s), msgAndArgs...)
< 	}
< 	if found {
< 		return Fail(t, fmt.Sprintf("\"%s\" should not contain \"%s\"", s, contains), msgAndArgs...)
< 	}
< 
< 	return true
< 
< }
< 
< // Subset asserts that the specified list(array, slice...) contains all
< // elements given in the specified subset(array, slice...).
< //
< //    assert.Subset(t, [1, 2, 3], [1, 2], "But [1, 2, 3] does contain [1, 2]")
< func Subset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool) {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if subset == nil {
< 		return true // we consider nil to be equal to the nil set
< 	}
< 
< 	subsetValue := reflect.ValueOf(subset)
< 	defer func() {
< 		if e := recover(); e != nil {
< 			ok = false
< 		}
< 	}()
< 
< 	listKind := reflect.TypeOf(list).Kind()
< 	subsetKind := reflect.TypeOf(subset).Kind()
< 
< 	if listKind != reflect.Array && listKind != reflect.Slice {
< 		return Fail(t, fmt.Sprintf("%q has an unsupported type %s", list, listKind), msgAndArgs...)
< 	}
< 
< 	if subsetKind != reflect.Array && subsetKind != reflect.Slice {
< 		return Fail(t, fmt.Sprintf("%q has an unsupported type %s", subset, subsetKind), msgAndArgs...)
< 	}
< 
< 	for i := 0; i < subsetValue.Len(); i++ {
< 		element := subsetValue.Index(i).Interface()
< 		ok, found := includeElement(list, element)
< 		if !ok {
< 			return Fail(t, fmt.Sprintf("\"%s\" could not be applied builtin len()", list), msgAndArgs...)
< 		}
< 		if !found {
< 			return Fail(t, fmt.Sprintf("\"%s\" does not contain \"%s\"", list, element), msgAndArgs...)
< 		}
< 	}
< 
< 	return true
< }
< 
< // NotSubset asserts that the specified list(array, slice...) contains not all
< // elements given in the specified subset(array, slice...).
< //
< //    assert.NotSubset(t, [1, 3, 4], [1, 2], "But [1, 3, 4] does not contain [1, 2]")
< func NotSubset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool) {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if subset == nil {
< 		return Fail(t, fmt.Sprintf("nil is the empty set which is a subset of every set"), msgAndArgs...)
< 	}
< 
< 	subsetValue := reflect.ValueOf(subset)
< 	defer func() {
< 		if e := recover(); e != nil {
< 			ok = false
< 		}
< 	}()
< 
< 	listKind := reflect.TypeOf(list).Kind()
< 	subsetKind := reflect.TypeOf(subset).Kind()
< 
< 	if listKind != reflect.Array && listKind != reflect.Slice {
< 		return Fail(t, fmt.Sprintf("%q has an unsupported type %s", list, listKind), msgAndArgs...)
< 	}
< 
< 	if subsetKind != reflect.Array && subsetKind != reflect.Slice {
< 		return Fail(t, fmt.Sprintf("%q has an unsupported type %s", subset, subsetKind), msgAndArgs...)
< 	}
< 
< 	for i := 0; i < subsetValue.Len(); i++ {
< 		element := subsetValue.Index(i).Interface()
< 		ok, found := includeElement(list, element)
< 		if !ok {
< 			return Fail(t, fmt.Sprintf("\"%s\" could not be applied builtin len()", list), msgAndArgs...)
< 		}
< 		if !found {
< 			return true
< 		}
< 	}
< 
< 	return Fail(t, fmt.Sprintf("%q is a subset of %q", subset, list), msgAndArgs...)
< }
< 
< // ElementsMatch asserts that the specified listA(array, slice...) is equal to specified
< // listB(array, slice...) ignoring the order of the elements. If there are duplicate elements,
< // the number of appearances of each of them in both lists should match.
< //
< // assert.ElementsMatch(t, [1, 3, 2, 3], [1, 3, 3, 2])
< func ElementsMatch(t TestingT, listA, listB interface{}, msgAndArgs ...interface{}) (ok bool) {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if isEmpty(listA) && isEmpty(listB) {
< 		return true
< 	}
< 
< 	aKind := reflect.TypeOf(listA).Kind()
< 	bKind := reflect.TypeOf(listB).Kind()
< 
< 	if aKind != reflect.Array && aKind != reflect.Slice {
< 		return Fail(t, fmt.Sprintf("%q has an unsupported type %s", listA, aKind), msgAndArgs...)
< 	}
< 
< 	if bKind != reflect.Array && bKind != reflect.Slice {
< 		return Fail(t, fmt.Sprintf("%q has an unsupported type %s", listB, bKind), msgAndArgs...)
< 	}
< 
< 	aValue := reflect.ValueOf(listA)
< 	bValue := reflect.ValueOf(listB)
< 
< 	aLen := aValue.Len()
< 	bLen := bValue.Len()
< 
< 	if aLen != bLen {
< 		return Fail(t, fmt.Sprintf("lengths don't match: %d != %d", aLen, bLen), msgAndArgs...)
< 	}
< 
< 	// Mark indexes in bValue that we already used
< 	visited := make([]bool, bLen)
< 	for i := 0; i < aLen; i++ {
< 		element := aValue.Index(i).Interface()
< 		found := false
< 		for j := 0; j < bLen; j++ {
< 			if visited[j] {
< 				continue
< 			}
< 			if ObjectsAreEqual(bValue.Index(j).Interface(), element) {
< 				visited[j] = true
< 				found = true
< 				break
< 			}
< 		}
< 		if !found {
< 			return Fail(t, fmt.Sprintf("element %s appears more times in %s than in %s", element, aValue, bValue), msgAndArgs...)
< 		}
< 	}
< 
< 	return true
< }
< 
< // Condition uses a Comparison to assert a complex condition.
< func Condition(t TestingT, comp Comparison, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	result := comp()
< 	if !result {
< 		Fail(t, "Condition failed!", msgAndArgs...)
< 	}
< 	return result
< }
< 
< // PanicTestFunc defines a func that should be passed to the assert.Panics and assert.NotPanics
< // methods, and represents a simple func that takes no arguments, and returns nothing.
< type PanicTestFunc func()
< 
< // didPanic returns true if the function passed to it panics. Otherwise, it returns false.
< func didPanic(f PanicTestFunc) (bool, interface{}, string) {
< 
< 	didPanic := false
< 	var message interface{}
< 	var stack string
< 	func() {
< 
< 		defer func() {
< 			if message = recover(); message != nil {
< 				didPanic = true
< 				stack = string(debug.Stack())
< 			}
< 		}()
< 
< 		// call the target function
< 		f()
< 
< 	}()
< 
< 	return didPanic, message, stack
< 
< }
< 
< // Panics asserts that the code inside the specified PanicTestFunc panics.
< //
< //   assert.Panics(t, func(){ GoCrazy() })
< func Panics(t TestingT, f PanicTestFunc, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	if funcDidPanic, panicValue, _ := didPanic(f); !funcDidPanic {
< 		return Fail(t, fmt.Sprintf("func %#v should panic\n\tPanic value:\t%#v", f, panicValue), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // PanicsWithValue asserts that the code inside the specified PanicTestFunc panics, and that
< // the recovered panic value equals the expected panic value.
< //
< //   assert.PanicsWithValue(t, "crazy error", func(){ GoCrazy() })
< func PanicsWithValue(t TestingT, expected interface{}, f PanicTestFunc, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	funcDidPanic, panicValue, panickedStack := didPanic(f)
< 	if !funcDidPanic {
< 		return Fail(t, fmt.Sprintf("func %#v should panic\n\tPanic value:\t%#v", f, panicValue), msgAndArgs...)
< 	}
< 	if panicValue != expected {
< 		return Fail(t, fmt.Sprintf("func %#v should panic with value:\t%#v\n\tPanic value:\t%#v\n\tPanic stack:\t%s", f, expected, panicValue, panickedStack), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // PanicsWithError asserts that the code inside the specified PanicTestFunc
< // panics, and that the recovered panic value is an error that satisfies the
< // EqualError comparison.
< //
< //   assert.PanicsWithError(t, "crazy error", func(){ GoCrazy() })
< func PanicsWithError(t TestingT, errString string, f PanicTestFunc, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	funcDidPanic, panicValue, panickedStack := didPanic(f)
< 	if !funcDidPanic {
< 		return Fail(t, fmt.Sprintf("func %#v should panic\n\tPanic value:\t%#v", f, panicValue), msgAndArgs...)
< 	}
< 	panicErr, ok := panicValue.(error)
< 	if !ok || panicErr.Error() != errString {
< 		return Fail(t, fmt.Sprintf("func %#v should panic with error message:\t%#v\n\tPanic value:\t%#v\n\tPanic stack:\t%s", f, errString, panicValue, panickedStack), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // NotPanics asserts that the code inside the specified PanicTestFunc does NOT panic.
< //
< //   assert.NotPanics(t, func(){ RemainCalm() })
< func NotPanics(t TestingT, f PanicTestFunc, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	if funcDidPanic, panicValue, panickedStack := didPanic(f); funcDidPanic {
< 		return Fail(t, fmt.Sprintf("func %#v should not panic\n\tPanic value:\t%v\n\tPanic stack:\t%s", f, panicValue, panickedStack), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // WithinDuration asserts that the two times are within duration delta of each other.
< //
< //   assert.WithinDuration(t, time.Now(), time.Now(), 10*time.Second)
< func WithinDuration(t TestingT, expected, actual time.Time, delta time.Duration, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	dt := expected.Sub(actual)
< 	if dt < -delta || dt > delta {
< 		return Fail(t, fmt.Sprintf("Max difference between %v and %v allowed is %v, but difference was %v", expected, actual, delta, dt), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< func toFloat(x interface{}) (float64, bool) {
< 	var xf float64
< 	xok := true
< 
< 	switch xn := x.(type) {
< 	case uint8:
< 		xf = float64(xn)
< 	case uint16:
< 		xf = float64(xn)
< 	case uint32:
< 		xf = float64(xn)
< 	case uint64:
< 		xf = float64(xn)
< 	case int:
< 		xf = float64(xn)
< 	case int8:
< 		xf = float64(xn)
< 	case int16:
< 		xf = float64(xn)
< 	case int32:
< 		xf = float64(xn)
< 	case int64:
< 		xf = float64(xn)
< 	case float32:
< 		xf = float64(xn)
< 	case float64:
< 		xf = float64(xn)
< 	case time.Duration:
< 		xf = float64(xn)
< 	default:
< 		xok = false
< 	}
< 
< 	return xf, xok
< }
< 
< // InDelta asserts that the two numerals are within delta of each other.
< //
< // 	 assert.InDelta(t, math.Pi, 22/7.0, 0.01)
< func InDelta(t TestingT, expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	af, aok := toFloat(expected)
< 	bf, bok := toFloat(actual)
< 
< 	if !aok || !bok {
< 		return Fail(t, fmt.Sprintf("Parameters must be numerical"), msgAndArgs...)
< 	}
< 
< 	if math.IsNaN(af) {
< 		return Fail(t, fmt.Sprintf("Expected must not be NaN"), msgAndArgs...)
< 	}
< 
< 	if math.IsNaN(bf) {
< 		return Fail(t, fmt.Sprintf("Expected %v with delta %v, but was NaN", expected, delta), msgAndArgs...)
< 	}
< 
< 	dt := af - bf
< 	if dt < -delta || dt > delta {
< 		return Fail(t, fmt.Sprintf("Max difference between %v and %v allowed is %v, but difference was %v", expected, actual, delta, dt), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // InDeltaSlice is the same as InDelta, except it compares two slices.
< func InDeltaSlice(t TestingT, expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if expected == nil || actual == nil ||
< 		reflect.TypeOf(actual).Kind() != reflect.Slice ||
< 		reflect.TypeOf(expected).Kind() != reflect.Slice {
< 		return Fail(t, fmt.Sprintf("Parameters must be slice"), msgAndArgs...)
< 	}
< 
< 	actualSlice := reflect.ValueOf(actual)
< 	expectedSlice := reflect.ValueOf(expected)
< 
< 	for i := 0; i < actualSlice.Len(); i++ {
< 		result := InDelta(t, actualSlice.Index(i).Interface(), expectedSlice.Index(i).Interface(), delta, msgAndArgs...)
< 		if !result {
< 			return result
< 		}
< 	}
< 
< 	return true
< }
< 
< // InDeltaMapValues is the same as InDelta, but it compares all values between two maps. Both maps must have exactly the same keys.
< func InDeltaMapValues(t TestingT, expected, actual interface{}, delta float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if expected == nil || actual == nil ||
< 		reflect.TypeOf(actual).Kind() != reflect.Map ||
< 		reflect.TypeOf(expected).Kind() != reflect.Map {
< 		return Fail(t, "Arguments must be maps", msgAndArgs...)
< 	}
< 
< 	expectedMap := reflect.ValueOf(expected)
< 	actualMap := reflect.ValueOf(actual)
< 
< 	if expectedMap.Len() != actualMap.Len() {
< 		return Fail(t, "Arguments must have the same number of keys", msgAndArgs...)
< 	}
< 
< 	for _, k := range expectedMap.MapKeys() {
< 		ev := expectedMap.MapIndex(k)
< 		av := actualMap.MapIndex(k)
< 
< 		if !ev.IsValid() {
< 			return Fail(t, fmt.Sprintf("missing key %q in expected map", k), msgAndArgs...)
< 		}
< 
< 		if !av.IsValid() {
< 			return Fail(t, fmt.Sprintf("missing key %q in actual map", k), msgAndArgs...)
< 		}
< 
< 		if !InDelta(
< 			t,
< 			ev.Interface(),
< 			av.Interface(),
< 			delta,
< 			msgAndArgs...,
< 		) {
< 			return false
< 		}
< 	}
< 
< 	return true
< }
< 
< func calcRelativeError(expected, actual interface{}) (float64, error) {
< 	af, aok := toFloat(expected)
< 	if !aok {
< 		return 0, fmt.Errorf("expected value %q cannot be converted to float", expected)
< 	}
< 	if af == 0 {
< 		return 0, fmt.Errorf("expected value must have a value other than zero to calculate the relative error")
< 	}
< 	bf, bok := toFloat(actual)
< 	if !bok {
< 		return 0, fmt.Errorf("actual value %q cannot be converted to float", actual)
< 	}
< 
< 	return math.Abs(af-bf) / math.Abs(af), nil
< }
< 
< // InEpsilon asserts that expected and actual have a relative error less than epsilon
< func InEpsilon(t TestingT, expected, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	actualEpsilon, err := calcRelativeError(expected, actual)
< 	if err != nil {
< 		return Fail(t, err.Error(), msgAndArgs...)
< 	}
< 	if actualEpsilon > epsilon {
< 		return Fail(t, fmt.Sprintf("Relative error is too high: %#v (expected)\n"+
< 			"        < %#v (actual)", epsilon, actualEpsilon), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // InEpsilonSlice is the same as InEpsilon, except it compares each value from two slices.
< func InEpsilonSlice(t TestingT, expected, actual interface{}, epsilon float64, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if expected == nil || actual == nil ||
< 		reflect.TypeOf(actual).Kind() != reflect.Slice ||
< 		reflect.TypeOf(expected).Kind() != reflect.Slice {
< 		return Fail(t, fmt.Sprintf("Parameters must be slice"), msgAndArgs...)
< 	}
< 
< 	actualSlice := reflect.ValueOf(actual)
< 	expectedSlice := reflect.ValueOf(expected)
< 
< 	for i := 0; i < actualSlice.Len(); i++ {
< 		result := InEpsilon(t, actualSlice.Index(i).Interface(), expectedSlice.Index(i).Interface(), epsilon)
< 		if !result {
< 			return result
< 		}
< 	}
< 
< 	return true
< }
< 
< /*
< 	Errors
< */
< 
< // NoError asserts that a function returned no error (i.e. `nil`).
< //
< //   actualObj, err := SomeFunction()
< //   if assert.NoError(t, err) {
< //	   assert.Equal(t, expectedObj, actualObj)
< //   }
< func NoError(t TestingT, err error, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if err != nil {
< 		return Fail(t, fmt.Sprintf("Received unexpected error:\n%+v", err), msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // Error asserts that a function returned an error (i.e. not `nil`).
< //
< //   actualObj, err := SomeFunction()
< //   if assert.Error(t, err) {
< //	   assert.Equal(t, expectedError, err)
< //   }
< func Error(t TestingT, err error, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	if err == nil {
< 		return Fail(t, "An error is expected but got nil.", msgAndArgs...)
< 	}
< 
< 	return true
< }
< 
< // EqualError asserts that a function returned an error (i.e. not `nil`)
< // and that it is equal to the provided error.
< //
< //   actualObj, err := SomeFunction()
< //   assert.EqualError(t, err,  expectedErrorString)
< func EqualError(t TestingT, theError error, errString string, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if !Error(t, theError, msgAndArgs...) {
< 		return false
< 	}
< 	expected := errString
< 	actual := theError.Error()
< 	// don't need to use deep equals here, we know they are both strings
< 	if expected != actual {
< 		return Fail(t, fmt.Sprintf("Error message not equal:\n"+
< 			"expected: %q\n"+
< 			"actual  : %q", expected, actual), msgAndArgs...)
< 	}
< 	return true
< }
< 
< // matchRegexp return true if a specified regexp matches a string.
< func matchRegexp(rx interface{}, str interface{}) bool {
< 
< 	var r *regexp.Regexp
< 	if rr, ok := rx.(*regexp.Regexp); ok {
< 		r = rr
< 	} else {
< 		r = regexp.MustCompile(fmt.Sprint(rx))
< 	}
< 
< 	return (r.FindStringIndex(fmt.Sprint(str)) != nil)
< 
< }
< 
< // Regexp asserts that a specified regexp matches a string.
< //
< //  assert.Regexp(t, regexp.MustCompile("start"), "it's starting")
< //  assert.Regexp(t, "start...$", "it's not starting")
< func Regexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	match := matchRegexp(rx, str)
< 
< 	if !match {
< 		Fail(t, fmt.Sprintf("Expect \"%v\" to match \"%v\"", str, rx), msgAndArgs...)
< 	}
< 
< 	return match
< }
< 
< // NotRegexp asserts that a specified regexp does not match a string.
< //
< //  assert.NotRegexp(t, regexp.MustCompile("starts"), "it's starting")
< //  assert.NotRegexp(t, "^start", "it's not starting")
< func NotRegexp(t TestingT, rx interface{}, str interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	match := matchRegexp(rx, str)
< 
< 	if match {
< 		Fail(t, fmt.Sprintf("Expect \"%v\" to NOT match \"%v\"", str, rx), msgAndArgs...)
< 	}
< 
< 	return !match
< 
< }
< 
< // Zero asserts that i is the zero value for its type.
< func Zero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if i != nil && !reflect.DeepEqual(i, reflect.Zero(reflect.TypeOf(i)).Interface()) {
< 		return Fail(t, fmt.Sprintf("Should be zero, but was %v", i), msgAndArgs...)
< 	}
< 	return true
< }
< 
< // NotZero asserts that i is not the zero value for its type.
< func NotZero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	if i == nil || reflect.DeepEqual(i, reflect.Zero(reflect.TypeOf(i)).Interface()) {
< 		return Fail(t, fmt.Sprintf("Should not be zero, but was %v", i), msgAndArgs...)
< 	}
< 	return true
< }
< 
< // FileExists checks whether a file exists in the given path. It also fails if
< // the path points to a directory or there is an error when trying to check the file.
< func FileExists(t TestingT, path string, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	info, err := os.Lstat(path)
< 	if err != nil {
< 		if os.IsNotExist(err) {
< 			return Fail(t, fmt.Sprintf("unable to find file %q", path), msgAndArgs...)
< 		}
< 		return Fail(t, fmt.Sprintf("error when running os.Lstat(%q): %s", path, err), msgAndArgs...)
< 	}
< 	if info.IsDir() {
< 		return Fail(t, fmt.Sprintf("%q is a directory", path), msgAndArgs...)
< 	}
< 	return true
< }
< 
< // NoFileExists checks whether a file does not exist in a given path. It fails
< // if the path points to an existing _file_ only.
< func NoFileExists(t TestingT, path string, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	info, err := os.Lstat(path)
< 	if err != nil {
< 		return true
< 	}
< 	if info.IsDir() {
< 		return true
< 	}
< 	return Fail(t, fmt.Sprintf("file %q exists", path), msgAndArgs...)
< }
< 
< // DirExists checks whether a directory exists in the given path. It also fails
< // if the path is a file rather a directory or there is an error checking whether it exists.
< func DirExists(t TestingT, path string, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	info, err := os.Lstat(path)
< 	if err != nil {
< 		if os.IsNotExist(err) {
< 			return Fail(t, fmt.Sprintf("unable to find file %q", path), msgAndArgs...)
< 		}
< 		return Fail(t, fmt.Sprintf("error when running os.Lstat(%q): %s", path, err), msgAndArgs...)
< 	}
< 	if !info.IsDir() {
< 		return Fail(t, fmt.Sprintf("%q is a file", path), msgAndArgs...)
< 	}
< 	return true
< }
< 
< // NoDirExists checks whether a directory does not exist in the given path.
< // It fails if the path points to an existing _directory_ only.
< func NoDirExists(t TestingT, path string, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	info, err := os.Lstat(path)
< 	if err != nil {
< 		if os.IsNotExist(err) {
< 			return true
< 		}
< 		return true
< 	}
< 	if !info.IsDir() {
< 		return true
< 	}
< 	return Fail(t, fmt.Sprintf("directory %q exists", path), msgAndArgs...)
< }
< 
< // JSONEq asserts that two JSON strings are equivalent.
< //
< //  assert.JSONEq(t, `{"hello": "world", "foo": "bar"}`, `{"foo": "bar", "hello": "world"}`)
< func JSONEq(t TestingT, expected string, actual string, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	var expectedJSONAsInterface, actualJSONAsInterface interface{}
< 
< 	if err := json.Unmarshal([]byte(expected), &expectedJSONAsInterface); err != nil {
< 		return Fail(t, fmt.Sprintf("Expected value ('%s') is not valid json.\nJSON parsing error: '%s'", expected, err.Error()), msgAndArgs...)
< 	}
< 
< 	if err := json.Unmarshal([]byte(actual), &actualJSONAsInterface); err != nil {
< 		return Fail(t, fmt.Sprintf("Input ('%s') needs to be valid json.\nJSON parsing error: '%s'", actual, err.Error()), msgAndArgs...)
< 	}
< 
< 	return Equal(t, expectedJSONAsInterface, actualJSONAsInterface, msgAndArgs...)
< }
< 
< // YAMLEq asserts that two YAML strings are equivalent.
< func YAMLEq(t TestingT, expected string, actual string, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	var expectedYAMLAsInterface, actualYAMLAsInterface interface{}
< 
< 	if err := yaml.Unmarshal([]byte(expected), &expectedYAMLAsInterface); err != nil {
< 		return Fail(t, fmt.Sprintf("Expected value ('%s') is not valid yaml.\nYAML parsing error: '%s'", expected, err.Error()), msgAndArgs...)
< 	}
< 
< 	if err := yaml.Unmarshal([]byte(actual), &actualYAMLAsInterface); err != nil {
< 		return Fail(t, fmt.Sprintf("Input ('%s') needs to be valid yaml.\nYAML error: '%s'", actual, err.Error()), msgAndArgs...)
< 	}
< 
< 	return Equal(t, expectedYAMLAsInterface, actualYAMLAsInterface, msgAndArgs...)
< }
< 
< func typeAndKind(v interface{}) (reflect.Type, reflect.Kind) {
< 	t := reflect.TypeOf(v)
< 	k := t.Kind()
< 
< 	if k == reflect.Ptr {
< 		t = t.Elem()
< 		k = t.Kind()
< 	}
< 	return t, k
< }
< 
< // diff returns a diff of both values as long as both are of the same type and
< // are a struct, map, slice, array or string. Otherwise it returns an empty string.
< func diff(expected interface{}, actual interface{}) string {
< 	if expected == nil || actual == nil {
< 		return ""
< 	}
< 
< 	et, ek := typeAndKind(expected)
< 	at, _ := typeAndKind(actual)
< 
< 	if et != at {
< 		return ""
< 	}
< 
< 	if ek != reflect.Struct && ek != reflect.Map && ek != reflect.Slice && ek != reflect.Array && ek != reflect.String {
< 		return ""
< 	}
< 
< 	var e, a string
< 	if et != reflect.TypeOf("") {
< 		e = spewConfig.Sdump(expected)
< 		a = spewConfig.Sdump(actual)
< 	} else {
< 		e = reflect.ValueOf(expected).String()
< 		a = reflect.ValueOf(actual).String()
< 	}
< 
< 	diff, _ := difflib.GetUnifiedDiffString(difflib.UnifiedDiff{
< 		A:        difflib.SplitLines(e),
< 		B:        difflib.SplitLines(a),
< 		FromFile: "Expected",
< 		FromDate: "",
< 		ToFile:   "Actual",
< 		ToDate:   "",
< 		Context:  1,
< 	})
< 
< 	return "\n\nDiff:\n" + diff
< }
< 
< func isFunction(arg interface{}) bool {
< 	if arg == nil {
< 		return false
< 	}
< 	return reflect.TypeOf(arg).Kind() == reflect.Func
< }
< 
< var spewConfig = spew.ConfigState{
< 	Indent:                  " ",
< 	DisablePointerAddresses: true,
< 	DisableCapacities:       true,
< 	SortKeys:                true,
< }
< 
< type tHelper interface {
< 	Helper()
< }
< 
< // Eventually asserts that given condition will be met in waitFor time,
< // periodically checking target function each tick.
< //
< //    assert.Eventually(t, func() bool { return true; }, time.Second, 10*time.Millisecond)
< func Eventually(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	ch := make(chan bool, 1)
< 
< 	timer := time.NewTimer(waitFor)
< 	defer timer.Stop()
< 
< 	ticker := time.NewTicker(tick)
< 	defer ticker.Stop()
< 
< 	for tick := ticker.C; ; {
< 		select {
< 		case <-timer.C:
< 			return Fail(t, "Condition never satisfied", msgAndArgs...)
< 		case <-tick:
< 			tick = nil
< 			go func() { ch <- condition() }()
< 		case v := <-ch:
< 			if v {
< 				return true
< 			}
< 			tick = ticker.C
< 		}
< 	}
< }
< 
< // Never asserts that the given condition doesn't satisfy in waitFor time,
< // periodically checking the target function each tick.
< //
< //    assert.Never(t, func() bool { return false; }, time.Second, 10*time.Millisecond)
< func Never(t TestingT, condition func() bool, waitFor time.Duration, tick time.Duration, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 
< 	ch := make(chan bool, 1)
< 
< 	timer := time.NewTimer(waitFor)
< 	defer timer.Stop()
< 
< 	ticker := time.NewTicker(tick)
< 	defer ticker.Stop()
< 
< 	for tick := ticker.C; ; {
< 		select {
< 		case <-timer.C:
< 			return true
< 		case <-tick:
< 			tick = nil
< 			go func() { ch <- condition() }()
< 		case v := <-ch:
< 			if v {
< 				return Fail(t, "Condition satisfied", msgAndArgs...)
< 			}
< 			tick = ticker.C
< 		}
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/doc.go updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/doc.go
1,45d0
< // Package assert provides a set of comprehensive testing tools for use with the normal Go testing system.
< //
< // Example Usage
< //
< // The following is a complete example using assert in a standard test function:
< //    import (
< //      "testing"
< //      "github.com/stretchr/testify/assert"
< //    )
< //
< //    func TestSomething(t *testing.T) {
< //
< //      var a string = "Hello"
< //      var b string = "Hello"
< //
< //      assert.Equal(t, a, b, "The two words should be the same.")
< //
< //    }
< //
< // if you assert many times, use the format below:
< //
< //    import (
< //      "testing"
< //      "github.com/stretchr/testify/assert"
< //    )
< //
< //    func TestSomething(t *testing.T) {
< //      assert := assert.New(t)
< //
< //      var a string = "Hello"
< //      var b string = "Hello"
< //
< //      assert.Equal(a, b, "The two words should be the same.")
< //    }
< //
< // Assertions
< //
< // Assertions allow you to easily write test code, and are global funcs in the `assert` package.
< // All assertion functions take, as the first argument, the `*testing.T` object provided by the
< // testing framework. This allows the assertion funcs to write the failings and other details to
< // the correct place.
< //
< // Every assertion function also takes an optional string message as the final argument,
< // allowing custom error messages to be appended to the message the assertion method outputs.
< package assert
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/errors.go updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/errors.go
1,10d0
< package assert
< 
< import (
< 	"errors"
< )
< 
< // AnError is an error instance useful for testing.  If the code does not care
< // about error specifics, and only needs to return the error for example, this
< // error should be used to make the test code more readable.
< var AnError = errors.New("assert.AnError general error for testing")
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/forward_assertions.go updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/forward_assertions.go
1,16d0
< package assert
< 
< // Assertions provides assertion methods around the
< // TestingT interface.
< type Assertions struct {
< 	t TestingT
< }
< 
< // New makes a new Assertions object for the specified TestingT.
< func New(t TestingT) *Assertions {
< 	return &Assertions{
< 		t: t,
< 	}
< }
< 
< //go:generate sh -c "cd ../_codegen && go build && cd - && ../_codegen/_codegen -output-package=assert -template=assertion_forward.go.tmpl -include-format-funcs"
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/http_assertions.go updated/vendor/github.com/coreos/fcct/vendor/github.com/stretchr/testify/assert/http_assertions.go
1,143d0
< package assert
< 
< import (
< 	"fmt"
< 	"net/http"
< 	"net/http/httptest"
< 	"net/url"
< 	"strings"
< )
< 
< // httpCode is a helper that returns HTTP code of the response. It returns -1 and
< // an error if building a new request fails.
< func httpCode(handler http.HandlerFunc, method, url string, values url.Values) (int, error) {
< 	w := httptest.NewRecorder()
< 	req, err := http.NewRequest(method, url, nil)
< 	if err != nil {
< 		return -1, err
< 	}
< 	req.URL.RawQuery = values.Encode()
< 	handler(w, req)
< 	return w.Code, nil
< }
< 
< // HTTPSuccess asserts that a specified handler returns a success status code.
< //
< //  assert.HTTPSuccess(t, myHandler, "POST", "http://www.google.com", nil)
< //
< // Returns whether the assertion was successful (true) or not (false).
< func HTTPSuccess(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	code, err := httpCode(handler, method, url, values)
< 	if err != nil {
< 		Fail(t, fmt.Sprintf("Failed to build test request, got error: %s", err))
< 		return false
< 	}
< 
< 	isSuccessCode := code >= http.StatusOK && code <= http.StatusPartialContent
< 	if !isSuccessCode {
< 		Fail(t, fmt.Sprintf("Expected HTTP success status code for %q but received %d", url+"?"+values.Encode(), code))
< 	}
< 
< 	return isSuccessCode
< }
< 
< // HTTPRedirect asserts that a specified handler returns a redirect status code.
< //
< //  assert.HTTPRedirect(t, myHandler, "GET", "/a/b/c", url.Values{"a": []string{"b", "c"}}
< //
< // Returns whether the assertion was successful (true) or not (false).
< func HTTPRedirect(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	code, err := httpCode(handler, method, url, values)
< 	if err != nil {
< 		Fail(t, fmt.Sprintf("Failed to build test request, got error: %s", err))
< 		return false
< 	}
< 
< 	isRedirectCode := code >= http.StatusMultipleChoices && code <= http.StatusTemporaryRedirect
< 	if !isRedirectCode {
< 		Fail(t, fmt.Sprintf("Expected HTTP redirect status code for %q but received %d", url+"?"+values.Encode(), code))
< 	}
< 
< 	return isRedirectCode
< }
< 
< // HTTPError asserts that a specified handler returns an error status code.
< //
< //  assert.HTTPError(t, myHandler, "POST", "/a/b/c", url.Values{"a": []string{"b", "c"}}
< //
< // Returns whether the assertion was successful (true) or not (false).
< func HTTPError(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	code, err := httpCode(handler, method, url, values)
< 	if err != nil {
< 		Fail(t, fmt.Sprintf("Failed to build test request, got error: %s", err))
< 		return false
< 	}
< 
< 	isErrorCode := code >= http.StatusBadRequest
< 	if !isErrorCode {
< 		Fail(t, fmt.Sprintf("Expected HTTP error status code for %q but received %d", url+"?"+values.Encode(), code))
< 	}
< 
< 	return isErrorCode
< }
< 
< // HTTPBody is a helper that returns HTTP body of the response. It returns
< // empty string if building a new request fails.
< func HTTPBody(handler http.HandlerFunc, method, url string, values url.Values) string {
< 	w := httptest.NewRecorder()
< 	req, err := http.NewRequest(method, url+"?"+values.Encode(), nil)
< 	if err != nil {
< 		return ""
< 	}
< 	handler(w, req)
< 	return w.Body.String()
< }
< 
< // HTTPBodyContains asserts that a specified handler returns a
< // body that contains a string.
< //
< //  assert.HTTPBodyContains(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func HTTPBodyContains(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	body := HTTPBody(handler, method, url, values)
< 
< 	contains := strings.Contains(body, fmt.Sprint(str))
< 	if !contains {
< 		Fail(t, fmt.Sprintf("Expected response body for \"%s\" to contain \"%s\" but found \"%s\"", url+"?"+values.Encode(), str, body))
< 	}
< 
< 	return contains
< }
< 
< // HTTPBodyNotContains asserts that a specified handler returns a
< // body that does not contain a string.
< //
< //  assert.HTTPBodyNotContains(t, myHandler, "GET", "www.google.com", nil, "I'm Feeling Lucky")
< //
< // Returns whether the assertion was successful (true) or not (false).
< func HTTPBodyNotContains(t TestingT, handler http.HandlerFunc, method, url string, values url.Values, str interface{}, msgAndArgs ...interface{}) bool {
< 	if h, ok := t.(tHelper); ok {
< 		h.Helper()
< 	}
< 	body := HTTPBody(handler, method, url, values)
< 
< 	contains := strings.Contains(body, fmt.Sprint(str))
< 	if contains {
< 		Fail(t, fmt.Sprintf("Expected response body for \"%s\" to NOT contain \"%s\" but found \"%s\"", url+"?"+values.Encode(), str, body))
< 	}
< 
< 	return !contains
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/LICENSE updated/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/LICENSE
1,20d0
< The MIT License (MIT)
< 
< Copyright (c) 2014 Vincent Petithory
< 
< Permission is hereby granted, free of charge, to any person obtaining a copy of
< this software and associated documentation files (the "Software"), to deal in
< the Software without restriction, including without limitation the rights to
< use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
< the Software, and to permit persons to whom the Software is furnished to do so,
< subject to the following conditions:
< 
< The above copyright notice and this permission notice shall be included in all
< copies or substantial portions of the Software.
< 
< THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
< FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
< COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
< IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
< CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/README.md updated/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/README.md
1,81d0
< # Data URL Schemes for Go [![wercker status](https://app.wercker.com/status/6f9a2e144dfcc59e862c52459b452928/s "wercker status")](https://app.wercker.com/project/bykey/6f9a2e144dfcc59e862c52459b452928) [![GoDoc](https://godoc.org/github.com/vincent-petithory/dataurl?status.png)](https://godoc.org/github.com/vincent-petithory/dataurl)
< 
< This package parses and generates Data URL Schemes for the Go language, according to [RFC 2397](http://tools.ietf.org/html/rfc2397).
< 
< Data URLs are small chunks of data commonly used in browsers to display inline data,
< typically like small images, or when you use the FileReader API of the browser.
< 
< Common use-cases:
< 
<  * generate a data URL out of a `string`, `[]byte`, `io.Reader` for inclusion in HTML templates,
<  * parse a data URL sent by a browser in a http.Handler, and do something with the data (save to disk, etc.)
<  * ...
< 
< Install the package with:
< ~~~
< go get github.com/vincent-petithory/dataurl
< ~~~
< 
< ## Usage
< 
< ~~~ go
< package main
< 
< import (
< 	"github.com/vincent-petithory/dataurl"
< 	"fmt"
< )
< 
< func main() {
< 	dataURL, err := dataurl.DecodeString(`data:text/plain;charset=utf-8;base64,aGV5YQ==`)
< 	if err != nil {
< 		fmt.Println(err)
< 		return
< 	}
< 	fmt.Printf("content type: %s, data: %s\n", dataURL.MediaType.ContentType(), string(dataURL.Data))
< 	// Output: content type: text/plain, data: heya
< }
< ~~~
< 
< From a `http.Handler`:
< 
< ~~~ go
< func handleDataURLUpload(w http.ResponseWriter, r *http.Request) {
< 	dataURL, err := dataurl.Decode(r.Body)
< 	defer r.Body.Close()
< 	if err != nil {
< 		http.Error(w, err.Error(), http.StatusBadRequest)
< 		return
< 	}
< 	if dataURL.ContentType() == "image/png" {
< 		ioutil.WriteFile("image.png", dataURL.Data, 0644)
< 	} else {
< 		http.Error(w, "not a png", http.StatusBadRequest)
< 	}
< }
< ~~~
< 
< ## Command
< 
< For convenience, a `dataurl` command is provided to encode/decode dataurl streams.
< 
< ~~~
< dataurl - Encode or decode dataurl data and print to standard output
< 
< Usage: dataurl [OPTION]... [FILE]
< 
<   dataurl encodes or decodes FILE or standard input if FILE is - or omitted, and prints to standard output.
<   Unless -mimetype is used, when FILE is specified, dataurl will attempt to detect its mimetype using Go's mime.TypeByExtension (http://golang.org/pkg/mime/#TypeByExtension). If this fails or data is read from STDIN, the mimetype will default to application/octet-stream.
< 
< Options:
<   -a=false: encode data using ascii instead of base64
<   -ascii=false: encode data using ascii instead of base64
<   -d=false: decode data instead of encoding
<   -decode=false: decode data instead of encoding
<   -m="": force the mimetype of the data to encode to this value
<   -mimetype="": force the mimetype of the data to encode to this value
< ~~~
< 
< ## Contributing
< 
< Feel free to file an issue/make a pull request if you find any bug, or want to suggest enhancements.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/dataurl.go updated/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/dataurl.go
1,280d0
< package dataurl
< 
< import (
< 	"bytes"
< 	"encoding/base64"
< 	"errors"
< 	"fmt"
< 	"io"
< 	"io/ioutil"
< 	"net/http"
< 	"strconv"
< 	"strings"
< )
< 
< const (
< 	// EncodingBase64 is base64 encoding for the data url
< 	EncodingBase64 = "base64"
< 	// EncodingASCII is ascii encoding for the data url
< 	EncodingASCII = "ascii"
< )
< 
< func defaultMediaType() MediaType {
< 	return MediaType{
< 		"text",
< 		"plain",
< 		map[string]string{"charset": "US-ASCII"},
< 	}
< }
< 
< // MediaType is the combination of a media type, a media subtype
< // and optional parameters.
< type MediaType struct {
< 	Type    string
< 	Subtype string
< 	Params  map[string]string
< }
< 
< // ContentType returns the content type of the dataurl's data, in the form type/subtype.
< func (mt *MediaType) ContentType() string {
< 	return fmt.Sprintf("%s/%s", mt.Type, mt.Subtype)
< }
< 
< // String implements the Stringer interface.
< //
< // Params values are escaped with the Escape function, rather than in a quoted string.
< func (mt *MediaType) String() string {
< 	var buf bytes.Buffer
< 	for k, v := range mt.Params {
< 		fmt.Fprintf(&buf, ";%s=%s", k, EscapeString(v))
< 	}
< 	return mt.ContentType() + (&buf).String()
< }
< 
< // DataURL is the combination of a MediaType describing the type of its Data.
< type DataURL struct {
< 	MediaType
< 	Encoding string
< 	Data     []byte
< }
< 
< // New returns a new DataURL initialized with data and
< // a MediaType parsed from mediatype and paramPairs.
< // mediatype must be of the form "type/subtype" or it will panic.
< // paramPairs must have an even number of elements or it will panic.
< // For more complex DataURL, initialize a DataURL struct.
< // The DataURL is initialized with base64 encoding.
< func New(data []byte, mediatype string, paramPairs ...string) *DataURL {
< 	parts := strings.Split(mediatype, "/")
< 	if len(parts) != 2 {
< 		panic("dataurl: invalid mediatype")
< 	}
< 
< 	nParams := len(paramPairs)
< 	if nParams%2 != 0 {
< 		panic("dataurl: requires an even number of param pairs")
< 	}
< 	params := make(map[string]string)
< 	for i := 0; i < nParams; i += 2 {
< 		params[paramPairs[i]] = paramPairs[i+1]
< 	}
< 
< 	mt := MediaType{
< 		parts[0],
< 		parts[1],
< 		params,
< 	}
< 	return &DataURL{
< 		MediaType: mt,
< 		Encoding:  EncodingBase64,
< 		Data:      data,
< 	}
< }
< 
< // String implements the Stringer interface.
< //
< // Note: it doesn't guarantee the returned string is equal to
< // the initial source string that was used to create this DataURL.
< // The reasons for that are:
< //  * Insertion of default values for MediaType that were maybe not in the initial string,
< //  * Various ways to encode the MediaType parameters (quoted string or url encoded string, the latter is used),
< func (du *DataURL) String() string {
< 	var buf bytes.Buffer
< 	du.WriteTo(&buf)
< 	return (&buf).String()
< }
< 
< // WriteTo implements the WriterTo interface.
< // See the note about String().
< func (du *DataURL) WriteTo(w io.Writer) (n int64, err error) {
< 	var ni int
< 	ni, _ = fmt.Fprint(w, "data:")
< 	n += int64(ni)
< 
< 	ni, _ = fmt.Fprint(w, du.MediaType.String())
< 	n += int64(ni)
< 
< 	if du.Encoding == EncodingBase64 {
< 		ni, _ = fmt.Fprint(w, ";base64")
< 		n += int64(ni)
< 	}
< 
< 	ni, _ = fmt.Fprint(w, ",")
< 	n += int64(ni)
< 
< 	if du.Encoding == EncodingBase64 {
< 		encoder := base64.NewEncoder(base64.StdEncoding, w)
< 		ni, err = encoder.Write(du.Data)
< 		if err != nil {
< 			return
< 		}
< 		encoder.Close()
< 	} else if du.Encoding == EncodingASCII {
< 		ni, _ = fmt.Fprint(w, Escape(du.Data))
< 		n += int64(ni)
< 	} else {
< 		err = fmt.Errorf("dataurl: invalid encoding %s", du.Encoding)
< 		return
< 	}
< 
< 	return
< }
< 
< // UnmarshalText decodes a Data URL string and sets it to *du
< func (du *DataURL) UnmarshalText(text []byte) error {
< 	decoded, err := DecodeString(string(text))
< 	if err != nil {
< 		return err
< 	}
< 	*du = *decoded
< 	return nil
< }
< 
< // MarshalText writes du as a Data URL
< func (du *DataURL) MarshalText() ([]byte, error) {
< 	buf := bytes.NewBuffer(nil)
< 	if _, err := du.WriteTo(buf); err != nil {
< 		return nil, err
< 	}
< 	return buf.Bytes(), nil
< }
< 
< type encodedDataReader func(string) ([]byte, error)
< 
< var asciiDataReader encodedDataReader = func(s string) ([]byte, error) {
< 	us, err := Unescape(s)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return []byte(us), nil
< }
< 
< var base64DataReader encodedDataReader = func(s string) ([]byte, error) {
< 	data, err := base64.StdEncoding.DecodeString(s)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return []byte(data), nil
< }
< 
< type parser struct {
< 	du                  *DataURL
< 	l                   *lexer
< 	currentAttr         string
< 	unquoteParamVal     bool
< 	encodedDataReaderFn encodedDataReader
< }
< 
< func (p *parser) parse() error {
< 	for item := range p.l.items {
< 		switch item.t {
< 		case itemError:
< 			return errors.New(item.String())
< 		case itemMediaType:
< 			p.du.MediaType.Type = item.val
< 			// Should we clear the default
< 			// "charset" parameter at this point?
< 			delete(p.du.MediaType.Params, "charset")
< 		case itemMediaSubType:
< 			p.du.MediaType.Subtype = item.val
< 		case itemParamAttr:
< 			p.currentAttr = item.val
< 		case itemLeftStringQuote:
< 			p.unquoteParamVal = true
< 		case itemParamVal:
< 			val := item.val
< 			if p.unquoteParamVal {
< 				p.unquoteParamVal = false
< 				us, err := strconv.Unquote("\"" + val + "\"")
< 				if err != nil {
< 					return err
< 				}
< 				val = us
< 			} else {
< 				us, err := UnescapeToString(val)
< 				if err != nil {
< 					return err
< 				}
< 				val = us
< 			}
< 			p.du.MediaType.Params[p.currentAttr] = val
< 		case itemBase64Enc:
< 			p.du.Encoding = EncodingBase64
< 			p.encodedDataReaderFn = base64DataReader
< 		case itemDataComma:
< 			if p.encodedDataReaderFn == nil {
< 				p.encodedDataReaderFn = asciiDataReader
< 			}
< 		case itemData:
< 			reader, err := p.encodedDataReaderFn(item.val)
< 			if err != nil {
< 				return err
< 			}
< 			p.du.Data = reader
< 		case itemEOF:
< 			if p.du.Data == nil {
< 				p.du.Data = []byte("")
< 			}
< 			return nil
< 		}
< 	}
< 	panic("EOF not found")
< }
< 
< // DecodeString decodes a Data URL scheme string.
< func DecodeString(s string) (*DataURL, error) {
< 	du := &DataURL{
< 		MediaType: defaultMediaType(),
< 		Encoding:  EncodingASCII,
< 	}
< 
< 	parser := &parser{
< 		du: du,
< 		l:  lex(s),
< 	}
< 	if err := parser.parse(); err != nil {
< 		return nil, err
< 	}
< 	return du, nil
< }
< 
< // Decode decodes a Data URL scheme from a io.Reader.
< func Decode(r io.Reader) (*DataURL, error) {
< 	data, err := ioutil.ReadAll(r)
< 	if err != nil {
< 		return nil, err
< 	}
< 	return DecodeString(string(data))
< }
< 
< // EncodeBytes encodes the data bytes into a Data URL string, using base 64 encoding.
< //
< // The media type of data is detected using http.DetectContentType.
< func EncodeBytes(data []byte) string {
< 	mt := http.DetectContentType(data)
< 	// http.DetectContentType may add spurious spaces between ; and a parameter.
< 	// The canonical way is to not have them.
< 	cleanedMt := strings.Replace(mt, "; ", ";", -1)
< 
< 	return New(data, cleanedMt).String()
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/doc.go updated/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/doc.go
1,28d0
< /*
< Package dataurl parses Data URL Schemes
< according to RFC 2397
< (http://tools.ietf.org/html/rfc2397).
< 
< Data URLs are small chunks of data commonly used in browsers to display inline data,
< typically like small images, or when you use the FileReader API of the browser.
< 
< A dataurl looks like:
< 
< 	data:text/plain;charset=utf-8,A%20brief%20note
< 
< Or, with base64 encoding:
< 
< 	data:image/vnd.microsoft.icon;name=golang%20favicon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAA
< 	AAAAAAD///8AVE44//7hdv/+4Xb//uF2//7hdv/+4Xb//uF2//7hdv/+4Xb//uF2//7hdv/+4Xb/
< 	/uF2/1ROOP////8A////AFROOP/+4Xb//uF2//7hdv/+4Xb//uF2//7hdv/+4Xb//uF2//7hdv/+
< 	...
< 	/6CcjP97c07/e3NO/1dOMf9BOiX/TkUn/2VXLf97c07/e3NO/6CcjP/h4uX/////AP///wD///8A
< 	////AP///wD///8A////AP///wDq6/H/3N/j/9fZ3f/q6/H/////AP///wD///8A////AP///wD/
< 	//8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
< 	AAAAAAAAAAAAAA==
< 
< Common functions are Decode and DecodeString to obtain a DataURL,
< and DataURL.String() and DataURL.WriteTo to generate a Data URL string.
< 
< */
< package dataurl
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/lex.go updated/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/lex.go
1,521d0
< package dataurl
< 
< import (
< 	"fmt"
< 	"strings"
< 	"unicode"
< 	"unicode/utf8"
< )
< 
< type item struct {
< 	t   itemType
< 	val string
< }
< 
< func (i item) String() string {
< 	switch i.t {
< 	case itemEOF:
< 		return "EOF"
< 	case itemError:
< 		return i.val
< 	}
< 	if len(i.val) > 10 {
< 		return fmt.Sprintf("%.10q...", i.val)
< 	}
< 	return fmt.Sprintf("%q", i.val)
< }
< 
< type itemType int
< 
< const (
< 	itemError itemType = iota
< 	itemEOF
< 
< 	itemDataPrefix
< 
< 	itemMediaType
< 	itemMediaSep
< 	itemMediaSubType
< 	itemParamSemicolon
< 	itemParamAttr
< 	itemParamEqual
< 	itemLeftStringQuote
< 	itemRightStringQuote
< 	itemParamVal
< 
< 	itemBase64Enc
< 
< 	itemDataComma
< 	itemData
< )
< 
< const eof rune = -1
< 
< func isTokenRune(r rune) bool {
< 	return r <= unicode.MaxASCII &&
< 		!unicode.IsControl(r) &&
< 		!unicode.IsSpace(r) &&
< 		!isTSpecialRune(r)
< }
< 
< func isTSpecialRune(r rune) bool {
< 	return r == '(' ||
< 		r == ')' ||
< 		r == '<' ||
< 		r == '>' ||
< 		r == '@' ||
< 		r == ',' ||
< 		r == ';' ||
< 		r == ':' ||
< 		r == '\\' ||
< 		r == '"' ||
< 		r == '/' ||
< 		r == '[' ||
< 		r == ']' ||
< 		r == '?' ||
< 		r == '='
< }
< 
< // See http://tools.ietf.org/html/rfc2045
< // This doesn't include extension-token case
< // as it's handled separatly
< func isDiscreteType(s string) bool {
< 	if strings.HasPrefix(s, "text") ||
< 		strings.HasPrefix(s, "image") ||
< 		strings.HasPrefix(s, "audio") ||
< 		strings.HasPrefix(s, "video") ||
< 		strings.HasPrefix(s, "application") {
< 		return true
< 	}
< 	return false
< }
< 
< // See http://tools.ietf.org/html/rfc2045
< // This doesn't include extension-token case
< // as it's handled separatly
< func isCompositeType(s string) bool {
< 	if strings.HasPrefix(s, "message") ||
< 		strings.HasPrefix(s, "multipart") {
< 		return true
< 	}
< 	return false
< }
< 
< func isURLCharRune(r rune) bool {
< 	// We're a bit permissive here,
< 	// by not including '%' in delims
< 	// This is okay, since url unescaping will validate
< 	// that later in the parser.
< 	return r <= unicode.MaxASCII &&
< 		!(r >= 0x00 && r <= 0x1F) && r != 0x7F && /* control */
< 		// delims
< 		r != ' ' &&
< 		r != '<' &&
< 		r != '>' &&
< 		r != '#' &&
< 		r != '"' &&
< 		// unwise
< 		r != '{' &&
< 		r != '}' &&
< 		r != '|' &&
< 		r != '\\' &&
< 		r != '^' &&
< 		r != '[' &&
< 		r != ']' &&
< 		r != '`'
< }
< 
< func isBase64Rune(r rune) bool {
< 	return (r >= 'a' && r <= 'z') ||
< 		(r >= 'A' && r <= 'Z') ||
< 		(r >= '0' && r <= '9') ||
< 		r == '+' ||
< 		r == '/' ||
< 		r == '=' ||
< 		r == '\n'
< }
< 
< type stateFn func(*lexer) stateFn
< 
< // lexer lexes the data URL scheme input string.
< // The implementation is from the text/template/parser package.
< type lexer struct {
< 	input          string
< 	start          int
< 	pos            int
< 	width          int
< 	seenBase64Item bool
< 	items          chan item
< }
< 
< func (l *lexer) run() {
< 	for state := lexBeforeDataPrefix; state != nil; {
< 		state = state(l)
< 	}
< 	close(l.items)
< }
< 
< func (l *lexer) emit(t itemType) {
< 	l.items <- item{t, l.input[l.start:l.pos]}
< 	l.start = l.pos
< }
< 
< func (l *lexer) next() (r rune) {
< 	if l.pos >= len(l.input) {
< 		l.width = 0
< 		return eof
< 	}
< 	r, l.width = utf8.DecodeRuneInString(l.input[l.pos:])
< 	l.pos += l.width
< 	return r
< }
< 
< func (l *lexer) backup() {
< 	l.pos -= l.width
< }
< 
< func (l *lexer) ignore() {
< 	l.start = l.pos
< }
< 
< func (l *lexer) errorf(format string, args ...interface{}) stateFn {
< 	l.items <- item{itemError, fmt.Sprintf(format, args...)}
< 	return nil
< }
< 
< func lex(input string) *lexer {
< 	l := &lexer{
< 		input: input,
< 		items: make(chan item),
< 	}
< 	go l.run() // Concurrently run state machine.
< 	return l
< }
< 
< const (
< 	dataPrefix     = "data:"
< 	mediaSep       = '/'
< 	paramSemicolon = ';'
< 	paramEqual     = '='
< 	dataComma      = ','
< )
< 
< // start lexing by detecting data prefix
< func lexBeforeDataPrefix(l *lexer) stateFn {
< 	if strings.HasPrefix(l.input[l.pos:], dataPrefix) {
< 		return lexDataPrefix
< 	}
< 	return l.errorf("missing data prefix")
< }
< 
< // lex data prefix
< func lexDataPrefix(l *lexer) stateFn {
< 	l.pos += len(dataPrefix)
< 	l.emit(itemDataPrefix)
< 	return lexAfterDataPrefix
< }
< 
< // lex what's after data prefix.
< // it can be the media type/subtype separator,
< // the base64 encoding, or the comma preceding the data
< func lexAfterDataPrefix(l *lexer) stateFn {
< 	switch r := l.next(); {
< 	case r == paramSemicolon:
< 		l.backup()
< 		return lexParamSemicolon
< 	case r == dataComma:
< 		l.backup()
< 		return lexDataComma
< 	case r == eof:
< 		return l.errorf("missing comma before data")
< 	case r == 'x' || r == 'X':
< 		if l.next() == '-' {
< 			return lexXTokenMediaType
< 		}
< 		return lexInDiscreteMediaType
< 	case isTokenRune(r):
< 		return lexInDiscreteMediaType
< 	default:
< 		return l.errorf("invalid character after data prefix")
< 	}
< }
< 
< func lexXTokenMediaType(l *lexer) stateFn {
< 	for {
< 		switch r := l.next(); {
< 		case r == mediaSep:
< 			l.backup()
< 			return lexMediaType
< 		case r == eof:
< 			return l.errorf("missing media type slash")
< 		case isTokenRune(r):
< 		default:
< 			return l.errorf("invalid character for media type")
< 		}
< 	}
< }
< 
< func lexInDiscreteMediaType(l *lexer) stateFn {
< 	for {
< 		switch r := l.next(); {
< 		case r == mediaSep:
< 			l.backup()
< 			// check it's valid discrete type
< 			if !isDiscreteType(l.input[l.start:l.pos]) &&
< 				!isCompositeType(l.input[l.start:l.pos]) {
< 				return l.errorf("invalid media type")
< 			}
< 			return lexMediaType
< 		case r == eof:
< 			return l.errorf("missing media type slash")
< 		case isTokenRune(r):
< 		default:
< 			return l.errorf("invalid character for media type")
< 		}
< 	}
< }
< 
< func lexMediaType(l *lexer) stateFn {
< 	if l.pos > l.start {
< 		l.emit(itemMediaType)
< 	}
< 	return lexMediaSep
< }
< 
< func lexMediaSep(l *lexer) stateFn {
< 	l.next()
< 	l.emit(itemMediaSep)
< 	return lexAfterMediaSep
< }
< 
< func lexAfterMediaSep(l *lexer) stateFn {
< 	for {
< 		switch r := l.next(); {
< 		case r == paramSemicolon || r == dataComma:
< 			l.backup()
< 			return lexMediaSubType
< 		case r == eof:
< 			return l.errorf("incomplete media type")
< 		case isTokenRune(r):
< 		default:
< 			return l.errorf("invalid character for media subtype")
< 		}
< 	}
< }
< 
< func lexMediaSubType(l *lexer) stateFn {
< 	if l.pos > l.start {
< 		l.emit(itemMediaSubType)
< 	}
< 	return lexAfterMediaSubType
< }
< 
< func lexAfterMediaSubType(l *lexer) stateFn {
< 	switch r := l.next(); {
< 	case r == paramSemicolon:
< 		l.backup()
< 		return lexParamSemicolon
< 	case r == dataComma:
< 		l.backup()
< 		return lexDataComma
< 	case r == eof:
< 		return l.errorf("missing comma before data")
< 	default:
< 		return l.errorf("expected semicolon or comma")
< 	}
< }
< 
< func lexParamSemicolon(l *lexer) stateFn {
< 	l.next()
< 	l.emit(itemParamSemicolon)
< 	return lexAfterParamSemicolon
< }
< 
< func lexAfterParamSemicolon(l *lexer) stateFn {
< 	switch r := l.next(); {
< 	case r == eof:
< 		return l.errorf("unterminated parameter sequence")
< 	case r == paramEqual || r == dataComma:
< 		return l.errorf("unterminated parameter sequence")
< 	case isTokenRune(r):
< 		l.backup()
< 		return lexInParamAttr
< 	default:
< 		return l.errorf("invalid character for parameter attribute")
< 	}
< }
< 
< func lexBase64Enc(l *lexer) stateFn {
< 	if l.pos > l.start {
< 		if v := l.input[l.start:l.pos]; v != "base64" {
< 			return l.errorf("expected base64, got %s", v)
< 		}
< 		l.seenBase64Item = true
< 		l.emit(itemBase64Enc)
< 	}
< 	return lexDataComma
< }
< 
< func lexInParamAttr(l *lexer) stateFn {
< 	for {
< 		switch r := l.next(); {
< 		case r == paramEqual:
< 			l.backup()
< 			return lexParamAttr
< 		case r == dataComma:
< 			l.backup()
< 			return lexBase64Enc
< 		case r == eof:
< 			return l.errorf("unterminated parameter sequence")
< 		case isTokenRune(r):
< 		default:
< 			return l.errorf("invalid character for parameter attribute")
< 		}
< 	}
< }
< 
< func lexParamAttr(l *lexer) stateFn {
< 	if l.pos > l.start {
< 		l.emit(itemParamAttr)
< 	}
< 	return lexParamEqual
< }
< 
< func lexParamEqual(l *lexer) stateFn {
< 	l.next()
< 	l.emit(itemParamEqual)
< 	return lexAfterParamEqual
< }
< 
< func lexAfterParamEqual(l *lexer) stateFn {
< 	switch r := l.next(); {
< 	case r == '"':
< 		l.emit(itemLeftStringQuote)
< 		return lexInQuotedStringParamVal
< 	case r == eof:
< 		return l.errorf("missing comma before data")
< 	case isTokenRune(r):
< 		return lexInParamVal
< 	default:
< 		return l.errorf("invalid character for parameter value")
< 	}
< }
< 
< func lexInQuotedStringParamVal(l *lexer) stateFn {
< 	for {
< 		switch r := l.next(); {
< 		case r == eof:
< 			return l.errorf("unclosed quoted string")
< 		case r == '\\':
< 			return lexEscapedChar
< 		case r == '"':
< 			l.backup()
< 			return lexQuotedStringParamVal
< 		case r <= unicode.MaxASCII:
< 		default:
< 			return l.errorf("invalid character for parameter value")
< 		}
< 	}
< }
< 
< func lexEscapedChar(l *lexer) stateFn {
< 	switch r := l.next(); {
< 	case r <= unicode.MaxASCII:
< 		return lexInQuotedStringParamVal
< 	case r == eof:
< 		return l.errorf("unexpected eof")
< 	default:
< 		return l.errorf("invalid escaped character")
< 	}
< }
< 
< func lexInParamVal(l *lexer) stateFn {
< 	for {
< 		switch r := l.next(); {
< 		case r == paramSemicolon || r == dataComma:
< 			l.backup()
< 			return lexParamVal
< 		case r == eof:
< 			return l.errorf("missing comma before data")
< 		case isTokenRune(r):
< 		default:
< 			return l.errorf("invalid character for parameter value")
< 		}
< 	}
< }
< 
< func lexQuotedStringParamVal(l *lexer) stateFn {
< 	if l.pos > l.start {
< 		l.emit(itemParamVal)
< 	}
< 	l.next()
< 	l.emit(itemRightStringQuote)
< 	return lexAfterParamVal
< }
< 
< func lexParamVal(l *lexer) stateFn {
< 	if l.pos > l.start {
< 		l.emit(itemParamVal)
< 	}
< 	return lexAfterParamVal
< }
< 
< func lexAfterParamVal(l *lexer) stateFn {
< 	switch r := l.next(); {
< 	case r == paramSemicolon:
< 		l.backup()
< 		return lexParamSemicolon
< 	case r == dataComma:
< 		l.backup()
< 		return lexDataComma
< 	case r == eof:
< 		return l.errorf("missing comma before data")
< 	default:
< 		return l.errorf("expected semicolon or comma")
< 	}
< }
< 
< func lexDataComma(l *lexer) stateFn {
< 	l.next()
< 	l.emit(itemDataComma)
< 	if l.seenBase64Item {
< 		return lexBase64Data
< 	}
< 	return lexData
< }
< 
< func lexData(l *lexer) stateFn {
< Loop:
< 	for {
< 		switch r := l.next(); {
< 		case r == eof:
< 			break Loop
< 		case isURLCharRune(r):
< 		default:
< 			return l.errorf("invalid data character")
< 		}
< 	}
< 	if l.pos > l.start {
< 		l.emit(itemData)
< 	}
< 	l.emit(itemEOF)
< 	return nil
< }
< 
< func lexBase64Data(l *lexer) stateFn {
< Loop:
< 	for {
< 		switch r := l.next(); {
< 		case r == eof:
< 			break Loop
< 		case isBase64Rune(r):
< 		default:
< 			return l.errorf("invalid data character")
< 		}
< 	}
< 	if l.pos > l.start {
< 		l.emit(itemData)
< 	}
< 	l.emit(itemEOF)
< 	return nil
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/rfc2396.go updated/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/rfc2396.go
1,130d0
< package dataurl
< 
< import (
< 	"bytes"
< 	"fmt"
< 	"io"
< 	"strings"
< )
< 
< // Escape implements URL escaping, as defined in RFC 2397 (http://tools.ietf.org/html/rfc2397).
< // It differs a bit from net/url's QueryEscape and QueryUnescape, e.g how spaces are treated (+ instead of %20):
< //
< // Only ASCII chars are allowed. Reserved chars are escaped to their %xx form.
< // Unreserved chars are [a-z], [A-Z], [0-9], and -_.!~*\().
< func Escape(data []byte) string {
< 	var buf = new(bytes.Buffer)
< 	for _, b := range data {
< 		switch {
< 		case isUnreserved(b):
< 			buf.WriteByte(b)
< 		default:
< 			fmt.Fprintf(buf, "%%%02X", b)
< 		}
< 	}
< 	return buf.String()
< }
< 
< // EscapeString is like Escape, but taking
< // a string as argument.
< func EscapeString(s string) string {
< 	return Escape([]byte(s))
< }
< 
< // isUnreserved return true
< // if the byte c is an unreserved char,
< // as defined in RFC 2396.
< func isUnreserved(c byte) bool {
< 	return (c >= 'a' && c <= 'z') ||
< 		(c >= 'A' && c <= 'Z') ||
< 		(c >= '0' && c <= '9') ||
< 		c == '-' ||
< 		c == '_' ||
< 		c == '.' ||
< 		c == '!' ||
< 		c == '~' ||
< 		c == '*' ||
< 		c == '\'' ||
< 		c == '(' ||
< 		c == ')'
< }
< 
< func isHex(c byte) bool {
< 	switch {
< 	case c >= 'a' && c <= 'f':
< 		return true
< 	case c >= 'A' && c <= 'F':
< 		return true
< 	case c >= '0' && c <= '9':
< 		return true
< 	}
< 	return false
< }
< 
< // borrowed from net/url/url.go
< func unhex(c byte) byte {
< 	switch {
< 	case '0' <= c && c <= '9':
< 		return c - '0'
< 	case 'a' <= c && c <= 'f':
< 		return c - 'a' + 10
< 	case 'A' <= c && c <= 'F':
< 		return c - 'A' + 10
< 	}
< 	return 0
< }
< 
< // Unescape unescapes a character sequence
< // escaped with Escape(String?).
< func Unescape(s string) ([]byte, error) {
< 	var buf = new(bytes.Buffer)
< 	reader := strings.NewReader(s)
< 
< 	for {
< 		r, size, err := reader.ReadRune()
< 		if err == io.EOF {
< 			break
< 		}
< 		if err != nil {
< 			return nil, err
< 		}
< 		if size > 1 {
< 			return nil, fmt.Errorf("rfc2396: non-ASCII char detected")
< 		}
< 
< 		switch r {
< 		case '%':
< 			eb1, err := reader.ReadByte()
< 			if err == io.EOF {
< 				return nil, fmt.Errorf("rfc2396: unexpected end of unescape sequence")
< 			}
< 			if err != nil {
< 				return nil, err
< 			}
< 			if !isHex(eb1) {
< 				return nil, fmt.Errorf("rfc2396: invalid char 0x%x in unescape sequence", r)
< 			}
< 			eb0, err := reader.ReadByte()
< 			if err == io.EOF {
< 				return nil, fmt.Errorf("rfc2396: unexpected end of unescape sequence")
< 			}
< 			if err != nil {
< 				return nil, err
< 			}
< 			if !isHex(eb0) {
< 				return nil, fmt.Errorf("rfc2396: invalid char 0x%x in unescape sequence", r)
< 			}
< 			buf.WriteByte(unhex(eb0) + unhex(eb1)*16)
< 		default:
< 			buf.WriteByte(byte(r))
< 		}
< 	}
< 	return buf.Bytes(), nil
< }
< 
< // UnescapeToString is like Unescape, but returning
< // a string.
< func UnescapeToString(s string) (string, error) {
< 	b, err := Unescape(s)
< 	return string(b), err
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/wercker.yml updated/vendor/github.com/coreos/fcct/vendor/github.com/vincent-petithory/dataurl/wercker.yml
1d0
< box: wercker/default
\ No newline at end of file
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/.travis.yml updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/.travis.yml
1,12d0
< language: go
< 
< go:
<     - 1.4
<     - 1.5
<     - 1.6
<     - 1.7
<     - 1.8
<     - 1.9
<     - tip
< 
< go_import_path: gopkg.in/yaml.v2
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/LICENSE updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/LICENSE
1,201d0
<                                  Apache License
<                            Version 2.0, January 2004
<                         http://www.apache.org/licenses/
< 
<    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
< 
<    1. Definitions.
< 
<       "License" shall mean the terms and conditions for use, reproduction,
<       and distribution as defined by Sections 1 through 9 of this document.
< 
<       "Licensor" shall mean the copyright owner or entity authorized by
<       the copyright owner that is granting the License.
< 
<       "Legal Entity" shall mean the union of the acting entity and all
<       other entities that control, are controlled by, or are under common
<       control with that entity. For the purposes of this definition,
<       "control" means (i) the power, direct or indirect, to cause the
<       direction or management of such entity, whether by contract or
<       otherwise, or (ii) ownership of fifty percent (50%) or more of the
<       outstanding shares, or (iii) beneficial ownership of such entity.
< 
<       "You" (or "Your") shall mean an individual or Legal Entity
<       exercising permissions granted by this License.
< 
<       "Source" form shall mean the preferred form for making modifications,
<       including but not limited to software source code, documentation
<       source, and configuration files.
< 
<       "Object" form shall mean any form resulting from mechanical
<       transformation or translation of a Source form, including but
<       not limited to compiled object code, generated documentation,
<       and conversions to other media types.
< 
<       "Work" shall mean the work of authorship, whether in Source or
<       Object form, made available under the License, as indicated by a
<       copyright notice that is included in or attached to the work
<       (an example is provided in the Appendix below).
< 
<       "Derivative Works" shall mean any work, whether in Source or Object
<       form, that is based on (or derived from) the Work and for which the
<       editorial revisions, annotations, elaborations, or other modifications
<       represent, as a whole, an original work of authorship. For the purposes
<       of this License, Derivative Works shall not include works that remain
<       separable from, or merely link (or bind by name) to the interfaces of,
<       the Work and Derivative Works thereof.
< 
<       "Contribution" shall mean any work of authorship, including
<       the original version of the Work and any modifications or additions
<       to that Work or Derivative Works thereof, that is intentionally
<       submitted to Licensor for inclusion in the Work by the copyright owner
<       or by an individual or Legal Entity authorized to submit on behalf of
<       the copyright owner. For the purposes of this definition, "submitted"
<       means any form of electronic, verbal, or written communication sent
<       to the Licensor or its representatives, including but not limited to
<       communication on electronic mailing lists, source code control systems,
<       and issue tracking systems that are managed by, or on behalf of, the
<       Licensor for the purpose of discussing and improving the Work, but
<       excluding communication that is conspicuously marked or otherwise
<       designated in writing by the copyright owner as "Not a Contribution."
< 
<       "Contributor" shall mean Licensor and any individual or Legal Entity
<       on behalf of whom a Contribution has been received by Licensor and
<       subsequently incorporated within the Work.
< 
<    2. Grant of Copyright License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       copyright license to reproduce, prepare Derivative Works of,
<       publicly display, publicly perform, sublicense, and distribute the
<       Work and such Derivative Works in Source or Object form.
< 
<    3. Grant of Patent License. Subject to the terms and conditions of
<       this License, each Contributor hereby grants to You a perpetual,
<       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
<       (except as stated in this section) patent license to make, have made,
<       use, offer to sell, sell, import, and otherwise transfer the Work,
<       where such license applies only to those patent claims licensable
<       by such Contributor that are necessarily infringed by their
<       Contribution(s) alone or by combination of their Contribution(s)
<       with the Work to which such Contribution(s) was submitted. If You
<       institute patent litigation against any entity (including a
<       cross-claim or counterclaim in a lawsuit) alleging that the Work
<       or a Contribution incorporated within the Work constitutes direct
<       or contributory patent infringement, then any patent licenses
<       granted to You under this License for that Work shall terminate
<       as of the date such litigation is filed.
< 
<    4. Redistribution. You may reproduce and distribute copies of the
<       Work or Derivative Works thereof in any medium, with or without
<       modifications, and in Source or Object form, provided that You
<       meet the following conditions:
< 
<       (a) You must give any other recipients of the Work or
<           Derivative Works a copy of this License; and
< 
<       (b) You must cause any modified files to carry prominent notices
<           stating that You changed the files; and
< 
<       (c) You must retain, in the Source form of any Derivative Works
<           that You distribute, all copyright, patent, trademark, and
<           attribution notices from the Source form of the Work,
<           excluding those notices that do not pertain to any part of
<           the Derivative Works; and
< 
<       (d) If the Work includes a "NOTICE" text file as part of its
<           distribution, then any Derivative Works that You distribute must
<           include a readable copy of the attribution notices contained
<           within such NOTICE file, excluding those notices that do not
<           pertain to any part of the Derivative Works, in at least one
<           of the following places: within a NOTICE text file distributed
<           as part of the Derivative Works; within the Source form or
<           documentation, if provided along with the Derivative Works; or,
<           within a display generated by the Derivative Works, if and
<           wherever such third-party notices normally appear. The contents
<           of the NOTICE file are for informational purposes only and
<           do not modify the License. You may add Your own attribution
<           notices within Derivative Works that You distribute, alongside
<           or as an addendum to the NOTICE text from the Work, provided
<           that such additional attribution notices cannot be construed
<           as modifying the License.
< 
<       You may add Your own copyright statement to Your modifications and
<       may provide additional or different license terms and conditions
<       for use, reproduction, or distribution of Your modifications, or
<       for any such Derivative Works as a whole, provided Your use,
<       reproduction, and distribution of the Work otherwise complies with
<       the conditions stated in this License.
< 
<    5. Submission of Contributions. Unless You explicitly state otherwise,
<       any Contribution intentionally submitted for inclusion in the Work
<       by You to the Licensor shall be under the terms and conditions of
<       this License, without any additional terms or conditions.
<       Notwithstanding the above, nothing herein shall supersede or modify
<       the terms of any separate license agreement you may have executed
<       with Licensor regarding such Contributions.
< 
<    6. Trademarks. This License does not grant permission to use the trade
<       names, trademarks, service marks, or product names of the Licensor,
<       except as required for reasonable and customary use in describing the
<       origin of the Work and reproducing the content of the NOTICE file.
< 
<    7. Disclaimer of Warranty. Unless required by applicable law or
<       agreed to in writing, Licensor provides the Work (and each
<       Contributor provides its Contributions) on an "AS IS" BASIS,
<       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
<       implied, including, without limitation, any warranties or conditions
<       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
<       PARTICULAR PURPOSE. You are solely responsible for determining the
<       appropriateness of using or redistributing the Work and assume any
<       risks associated with Your exercise of permissions under this License.
< 
<    8. Limitation of Liability. In no event and under no legal theory,
<       whether in tort (including negligence), contract, or otherwise,
<       unless required by applicable law (such as deliberate and grossly
<       negligent acts) or agreed to in writing, shall any Contributor be
<       liable to You for damages, including any direct, indirect, special,
<       incidental, or consequential damages of any character arising as a
<       result of this License or out of the use or inability to use the
<       Work (including but not limited to damages for loss of goodwill,
<       work stoppage, computer failure or malfunction, or any and all
<       other commercial damages or losses), even if such Contributor
<       has been advised of the possibility of such damages.
< 
<    9. Accepting Warranty or Additional Liability. While redistributing
<       the Work or Derivative Works thereof, You may choose to offer,
<       and charge a fee for, acceptance of support, warranty, indemnity,
<       or other liability obligations and/or rights consistent with this
<       License. However, in accepting such obligations, You may act only
<       on Your own behalf and on Your sole responsibility, not on behalf
<       of any other Contributor, and only if You agree to indemnify,
<       defend, and hold each Contributor harmless for any liability
<       incurred by, or claims asserted against, such Contributor by reason
<       of your accepting any such warranty or additional liability.
< 
<    END OF TERMS AND CONDITIONS
< 
<    APPENDIX: How to apply the Apache License to your work.
< 
<       To apply the Apache License to your work, attach the following
<       boilerplate notice, with the fields enclosed by brackets "{}"
<       replaced with your own identifying information. (Don't include
<       the brackets!)  The text should be enclosed in the appropriate
<       comment syntax for the file format. We also recommend that a
<       file or class name and description of purpose be included on the
<       same "printed page" as the copyright notice for easier
<       identification within third-party archives.
< 
<    Copyright {yyyy} {name of copyright owner}
< 
<    Licensed under the Apache License, Version 2.0 (the "License");
<    you may not use this file except in compliance with the License.
<    You may obtain a copy of the License at
< 
<        http://www.apache.org/licenses/LICENSE-2.0
< 
<    Unless required by applicable law or agreed to in writing, software
<    distributed under the License is distributed on an "AS IS" BASIS,
<    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<    See the License for the specific language governing permissions and
<    limitations under the License.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/LICENSE.libyaml updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/LICENSE.libyaml
1,31d0
< The following files were ported to Go from C files of libyaml, and thus
< are still covered by their original copyright and license:
< 
<     apic.go
<     emitterc.go
<     parserc.go
<     readerc.go
<     scannerc.go
<     writerc.go
<     yamlh.go
<     yamlprivateh.go
< 
< Copyright (c) 2006 Kirill Simonov
< 
< Permission is hereby granted, free of charge, to any person obtaining a copy of
< this software and associated documentation files (the "Software"), to deal in
< the Software without restriction, including without limitation the rights to
< use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< of the Software, and to permit persons to whom the Software is furnished to do
< so, subject to the following conditions:
< 
< The above copyright notice and this permission notice shall be included in all
< copies or substantial portions of the Software.
< 
< THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< SOFTWARE.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/NOTICE updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/NOTICE
1,13d0
< Copyright 2011-2016 Canonical Ltd.
< 
< Licensed under the Apache License, Version 2.0 (the "License");
< you may not use this file except in compliance with the License.
< You may obtain a copy of the License at
< 
<     http://www.apache.org/licenses/LICENSE-2.0
< 
< Unless required by applicable law or agreed to in writing, software
< distributed under the License is distributed on an "AS IS" BASIS,
< WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< See the License for the specific language governing permissions and
< limitations under the License.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/README.md updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/README.md
1,133d0
< # YAML support for the Go language
< 
< Introduction
< ------------
< 
< The yaml package enables Go programs to comfortably encode and decode YAML
< values. It was developed within [Canonical](https://www.canonical.com) as
< part of the [juju](https://juju.ubuntu.com) project, and is based on a
< pure Go port of the well-known [libyaml](http://pyyaml.org/wiki/LibYAML)
< C library to parse and generate YAML data quickly and reliably.
< 
< Compatibility
< -------------
< 
< The yaml package supports most of YAML 1.1 and 1.2, including support for
< anchors, tags, map merging, etc. Multi-document unmarshalling is not yet
< implemented, and base-60 floats from YAML 1.1 are purposefully not
< supported since they're a poor design and are gone in YAML 1.2.
< 
< Installation and usage
< ----------------------
< 
< The import path for the package is *gopkg.in/yaml.v2*.
< 
< To install it, run:
< 
<     go get gopkg.in/yaml.v2
< 
< API documentation
< -----------------
< 
< If opened in a browser, the import path itself leads to the API documentation:
< 
<   * [https://gopkg.in/yaml.v2](https://gopkg.in/yaml.v2)
< 
< API stability
< -------------
< 
< The package API for yaml v2 will remain stable as described in [gopkg.in](https://gopkg.in).
< 
< 
< License
< -------
< 
< The yaml package is licensed under the Apache License 2.0. Please see the LICENSE file for details.
< 
< 
< Example
< -------
< 
< ```Go
< package main
< 
< import (
<         "fmt"
<         "log"
< 
<         "gopkg.in/yaml.v2"
< )
< 
< var data = `
< a: Easy!
< b:
<   c: 2
<   d: [3, 4]
< `
< 
< // Note: struct fields must be public in order for unmarshal to
< // correctly populate the data.
< type T struct {
<         A string
<         B struct {
<                 RenamedC int   `yaml:"c"`
<                 D        []int `yaml:",flow"`
<         }
< }
< 
< func main() {
<         t := T{}
<     
<         err := yaml.Unmarshal([]byte(data), &t)
<         if err != nil {
<                 log.Fatalf("error: %v", err)
<         }
<         fmt.Printf("--- t:\n%v\n\n", t)
<     
<         d, err := yaml.Marshal(&t)
<         if err != nil {
<                 log.Fatalf("error: %v", err)
<         }
<         fmt.Printf("--- t dump:\n%s\n\n", string(d))
<     
<         m := make(map[interface{}]interface{})
<     
<         err = yaml.Unmarshal([]byte(data), &m)
<         if err != nil {
<                 log.Fatalf("error: %v", err)
<         }
<         fmt.Printf("--- m:\n%v\n\n", m)
<     
<         d, err = yaml.Marshal(&m)
<         if err != nil {
<                 log.Fatalf("error: %v", err)
<         }
<         fmt.Printf("--- m dump:\n%s\n\n", string(d))
< }
< ```
< 
< This example will generate the following output:
< 
< ```
< --- t:
< {Easy! {2 [3 4]}}
< 
< --- t dump:
< a: Easy!
< b:
<   c: 2
<   d: [3, 4]
< 
< 
< --- m:
< map[a:Easy! b:map[c:2 d:[3 4]]]
< 
< --- m dump:
< a: Easy!
< b:
<   c: 2
<   d:
<   - 3
<   - 4
< ```
< 
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/apic.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/apic.go
1,739d0
< package yaml
< 
< import (
< 	"io"
< )
< 
< func yaml_insert_token(parser *yaml_parser_t, pos int, token *yaml_token_t) {
< 	//fmt.Println("yaml_insert_token", "pos:", pos, "typ:", token.typ, "head:", parser.tokens_head, "len:", len(parser.tokens))
< 
< 	// Check if we can move the queue at the beginning of the buffer.
< 	if parser.tokens_head > 0 && len(parser.tokens) == cap(parser.tokens) {
< 		if parser.tokens_head != len(parser.tokens) {
< 			copy(parser.tokens, parser.tokens[parser.tokens_head:])
< 		}
< 		parser.tokens = parser.tokens[:len(parser.tokens)-parser.tokens_head]
< 		parser.tokens_head = 0
< 	}
< 	parser.tokens = append(parser.tokens, *token)
< 	if pos < 0 {
< 		return
< 	}
< 	copy(parser.tokens[parser.tokens_head+pos+1:], parser.tokens[parser.tokens_head+pos:])
< 	parser.tokens[parser.tokens_head+pos] = *token
< }
< 
< // Create a new parser object.
< func yaml_parser_initialize(parser *yaml_parser_t) bool {
< 	*parser = yaml_parser_t{
< 		raw_buffer: make([]byte, 0, input_raw_buffer_size),
< 		buffer:     make([]byte, 0, input_buffer_size),
< 	}
< 	return true
< }
< 
< // Destroy a parser object.
< func yaml_parser_delete(parser *yaml_parser_t) {
< 	*parser = yaml_parser_t{}
< }
< 
< // String read handler.
< func yaml_string_read_handler(parser *yaml_parser_t, buffer []byte) (n int, err error) {
< 	if parser.input_pos == len(parser.input) {
< 		return 0, io.EOF
< 	}
< 	n = copy(buffer, parser.input[parser.input_pos:])
< 	parser.input_pos += n
< 	return n, nil
< }
< 
< // Reader read handler.
< func yaml_reader_read_handler(parser *yaml_parser_t, buffer []byte) (n int, err error) {
< 	return parser.input_reader.Read(buffer)
< }
< 
< // Set a string input.
< func yaml_parser_set_input_string(parser *yaml_parser_t, input []byte) {
< 	if parser.read_handler != nil {
< 		panic("must set the input source only once")
< 	}
< 	parser.read_handler = yaml_string_read_handler
< 	parser.input = input
< 	parser.input_pos = 0
< }
< 
< // Set a file input.
< func yaml_parser_set_input_reader(parser *yaml_parser_t, r io.Reader) {
< 	if parser.read_handler != nil {
< 		panic("must set the input source only once")
< 	}
< 	parser.read_handler = yaml_reader_read_handler
< 	parser.input_reader = r
< }
< 
< // Set the source encoding.
< func yaml_parser_set_encoding(parser *yaml_parser_t, encoding yaml_encoding_t) {
< 	if parser.encoding != yaml_ANY_ENCODING {
< 		panic("must set the encoding only once")
< 	}
< 	parser.encoding = encoding
< }
< 
< // Create a new emitter object.
< func yaml_emitter_initialize(emitter *yaml_emitter_t) {
< 	*emitter = yaml_emitter_t{
< 		buffer:     make([]byte, output_buffer_size),
< 		raw_buffer: make([]byte, 0, output_raw_buffer_size),
< 		states:     make([]yaml_emitter_state_t, 0, initial_stack_size),
< 		events:     make([]yaml_event_t, 0, initial_queue_size),
< 	}
< }
< 
< // Destroy an emitter object.
< func yaml_emitter_delete(emitter *yaml_emitter_t) {
< 	*emitter = yaml_emitter_t{}
< }
< 
< // String write handler.
< func yaml_string_write_handler(emitter *yaml_emitter_t, buffer []byte) error {
< 	*emitter.output_buffer = append(*emitter.output_buffer, buffer...)
< 	return nil
< }
< 
< // yaml_writer_write_handler uses emitter.output_writer to write the
< // emitted text.
< func yaml_writer_write_handler(emitter *yaml_emitter_t, buffer []byte) error {
< 	_, err := emitter.output_writer.Write(buffer)
< 	return err
< }
< 
< // Set a string output.
< func yaml_emitter_set_output_string(emitter *yaml_emitter_t, output_buffer *[]byte) {
< 	if emitter.write_handler != nil {
< 		panic("must set the output target only once")
< 	}
< 	emitter.write_handler = yaml_string_write_handler
< 	emitter.output_buffer = output_buffer
< }
< 
< // Set a file output.
< func yaml_emitter_set_output_writer(emitter *yaml_emitter_t, w io.Writer) {
< 	if emitter.write_handler != nil {
< 		panic("must set the output target only once")
< 	}
< 	emitter.write_handler = yaml_writer_write_handler
< 	emitter.output_writer = w
< }
< 
< // Set the output encoding.
< func yaml_emitter_set_encoding(emitter *yaml_emitter_t, encoding yaml_encoding_t) {
< 	if emitter.encoding != yaml_ANY_ENCODING {
< 		panic("must set the output encoding only once")
< 	}
< 	emitter.encoding = encoding
< }
< 
< // Set the canonical output style.
< func yaml_emitter_set_canonical(emitter *yaml_emitter_t, canonical bool) {
< 	emitter.canonical = canonical
< }
< 
< //// Set the indentation increment.
< func yaml_emitter_set_indent(emitter *yaml_emitter_t, indent int) {
< 	if indent < 2 || indent > 9 {
< 		indent = 2
< 	}
< 	emitter.best_indent = indent
< }
< 
< // Set the preferred line width.
< func yaml_emitter_set_width(emitter *yaml_emitter_t, width int) {
< 	if width < 0 {
< 		width = -1
< 	}
< 	emitter.best_width = width
< }
< 
< // Set if unescaped non-ASCII characters are allowed.
< func yaml_emitter_set_unicode(emitter *yaml_emitter_t, unicode bool) {
< 	emitter.unicode = unicode
< }
< 
< // Set the preferred line break character.
< func yaml_emitter_set_break(emitter *yaml_emitter_t, line_break yaml_break_t) {
< 	emitter.line_break = line_break
< }
< 
< ///*
< // * Destroy a token object.
< // */
< //
< //YAML_DECLARE(void)
< //yaml_token_delete(yaml_token_t *token)
< //{
< //    assert(token);  // Non-NULL token object expected.
< //
< //    switch (token.type)
< //    {
< //        case YAML_TAG_DIRECTIVE_TOKEN:
< //            yaml_free(token.data.tag_directive.handle);
< //            yaml_free(token.data.tag_directive.prefix);
< //            break;
< //
< //        case YAML_ALIAS_TOKEN:
< //            yaml_free(token.data.alias.value);
< //            break;
< //
< //        case YAML_ANCHOR_TOKEN:
< //            yaml_free(token.data.anchor.value);
< //            break;
< //
< //        case YAML_TAG_TOKEN:
< //            yaml_free(token.data.tag.handle);
< //            yaml_free(token.data.tag.suffix);
< //            break;
< //
< //        case YAML_SCALAR_TOKEN:
< //            yaml_free(token.data.scalar.value);
< //            break;
< //
< //        default:
< //            break;
< //    }
< //
< //    memset(token, 0, sizeof(yaml_token_t));
< //}
< //
< ///*
< // * Check if a string is a valid UTF-8 sequence.
< // *
< // * Check 'reader.c' for more details on UTF-8 encoding.
< // */
< //
< //static int
< //yaml_check_utf8(yaml_char_t *start, size_t length)
< //{
< //    yaml_char_t *end = start+length;
< //    yaml_char_t *pointer = start;
< //
< //    while (pointer < end) {
< //        unsigned char octet;
< //        unsigned int width;
< //        unsigned int value;
< //        size_t k;
< //
< //        octet = pointer[0];
< //        width = (octet & 0x80) == 0x00 ? 1 :
< //                (octet & 0xE0) == 0xC0 ? 2 :
< //                (octet & 0xF0) == 0xE0 ? 3 :
< //                (octet & 0xF8) == 0xF0 ? 4 : 0;
< //        value = (octet & 0x80) == 0x00 ? octet & 0x7F :
< //                (octet & 0xE0) == 0xC0 ? octet & 0x1F :
< //                (octet & 0xF0) == 0xE0 ? octet & 0x0F :
< //                (octet & 0xF8) == 0xF0 ? octet & 0x07 : 0;
< //        if (!width) return 0;
< //        if (pointer+width > end) return 0;
< //        for (k = 1; k < width; k ++) {
< //            octet = pointer[k];
< //            if ((octet & 0xC0) != 0x80) return 0;
< //            value = (value << 6) + (octet & 0x3F);
< //        }
< //        if (!((width == 1) ||
< //            (width == 2 && value >= 0x80) ||
< //            (width == 3 && value >= 0x800) ||
< //            (width == 4 && value >= 0x10000))) return 0;
< //
< //        pointer += width;
< //    }
< //
< //    return 1;
< //}
< //
< 
< // Create STREAM-START.
< func yaml_stream_start_event_initialize(event *yaml_event_t, encoding yaml_encoding_t) {
< 	*event = yaml_event_t{
< 		typ:      yaml_STREAM_START_EVENT,
< 		encoding: encoding,
< 	}
< }
< 
< // Create STREAM-END.
< func yaml_stream_end_event_initialize(event *yaml_event_t) {
< 	*event = yaml_event_t{
< 		typ: yaml_STREAM_END_EVENT,
< 	}
< }
< 
< // Create DOCUMENT-START.
< func yaml_document_start_event_initialize(
< 	event *yaml_event_t,
< 	version_directive *yaml_version_directive_t,
< 	tag_directives []yaml_tag_directive_t,
< 	implicit bool,
< ) {
< 	*event = yaml_event_t{
< 		typ:               yaml_DOCUMENT_START_EVENT,
< 		version_directive: version_directive,
< 		tag_directives:    tag_directives,
< 		implicit:          implicit,
< 	}
< }
< 
< // Create DOCUMENT-END.
< func yaml_document_end_event_initialize(event *yaml_event_t, implicit bool) {
< 	*event = yaml_event_t{
< 		typ:      yaml_DOCUMENT_END_EVENT,
< 		implicit: implicit,
< 	}
< }
< 
< ///*
< // * Create ALIAS.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_alias_event_initialize(event *yaml_event_t, anchor *yaml_char_t)
< //{
< //    mark yaml_mark_t = { 0, 0, 0 }
< //    anchor_copy *yaml_char_t = NULL
< //
< //    assert(event) // Non-NULL event object is expected.
< //    assert(anchor) // Non-NULL anchor is expected.
< //
< //    if (!yaml_check_utf8(anchor, strlen((char *)anchor))) return 0
< //
< //    anchor_copy = yaml_strdup(anchor)
< //    if (!anchor_copy)
< //        return 0
< //
< //    ALIAS_EVENT_INIT(*event, anchor_copy, mark, mark)
< //
< //    return 1
< //}
< 
< // Create SCALAR.
< func yaml_scalar_event_initialize(event *yaml_event_t, anchor, tag, value []byte, plain_implicit, quoted_implicit bool, style yaml_scalar_style_t) bool {
< 	*event = yaml_event_t{
< 		typ:             yaml_SCALAR_EVENT,
< 		anchor:          anchor,
< 		tag:             tag,
< 		value:           value,
< 		implicit:        plain_implicit,
< 		quoted_implicit: quoted_implicit,
< 		style:           yaml_style_t(style),
< 	}
< 	return true
< }
< 
< // Create SEQUENCE-START.
< func yaml_sequence_start_event_initialize(event *yaml_event_t, anchor, tag []byte, implicit bool, style yaml_sequence_style_t) bool {
< 	*event = yaml_event_t{
< 		typ:      yaml_SEQUENCE_START_EVENT,
< 		anchor:   anchor,
< 		tag:      tag,
< 		implicit: implicit,
< 		style:    yaml_style_t(style),
< 	}
< 	return true
< }
< 
< // Create SEQUENCE-END.
< func yaml_sequence_end_event_initialize(event *yaml_event_t) bool {
< 	*event = yaml_event_t{
< 		typ: yaml_SEQUENCE_END_EVENT,
< 	}
< 	return true
< }
< 
< // Create MAPPING-START.
< func yaml_mapping_start_event_initialize(event *yaml_event_t, anchor, tag []byte, implicit bool, style yaml_mapping_style_t) {
< 	*event = yaml_event_t{
< 		typ:      yaml_MAPPING_START_EVENT,
< 		anchor:   anchor,
< 		tag:      tag,
< 		implicit: implicit,
< 		style:    yaml_style_t(style),
< 	}
< }
< 
< // Create MAPPING-END.
< func yaml_mapping_end_event_initialize(event *yaml_event_t) {
< 	*event = yaml_event_t{
< 		typ: yaml_MAPPING_END_EVENT,
< 	}
< }
< 
< // Destroy an event object.
< func yaml_event_delete(event *yaml_event_t) {
< 	*event = yaml_event_t{}
< }
< 
< ///*
< // * Create a document object.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_initialize(document *yaml_document_t,
< //        version_directive *yaml_version_directive_t,
< //        tag_directives_start *yaml_tag_directive_t,
< //        tag_directives_end *yaml_tag_directive_t,
< //        start_implicit int, end_implicit int)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    struct {
< //        start *yaml_node_t
< //        end *yaml_node_t
< //        top *yaml_node_t
< //    } nodes = { NULL, NULL, NULL }
< //    version_directive_copy *yaml_version_directive_t = NULL
< //    struct {
< //        start *yaml_tag_directive_t
< //        end *yaml_tag_directive_t
< //        top *yaml_tag_directive_t
< //    } tag_directives_copy = { NULL, NULL, NULL }
< //    value yaml_tag_directive_t = { NULL, NULL }
< //    mark yaml_mark_t = { 0, 0, 0 }
< //
< //    assert(document) // Non-NULL document object is expected.
< //    assert((tag_directives_start && tag_directives_end) ||
< //            (tag_directives_start == tag_directives_end))
< //                            // Valid tag directives are expected.
< //
< //    if (!STACK_INIT(&context, nodes, INITIAL_STACK_SIZE)) goto error
< //
< //    if (version_directive) {
< //        version_directive_copy = yaml_malloc(sizeof(yaml_version_directive_t))
< //        if (!version_directive_copy) goto error
< //        version_directive_copy.major = version_directive.major
< //        version_directive_copy.minor = version_directive.minor
< //    }
< //
< //    if (tag_directives_start != tag_directives_end) {
< //        tag_directive *yaml_tag_directive_t
< //        if (!STACK_INIT(&context, tag_directives_copy, INITIAL_STACK_SIZE))
< //            goto error
< //        for (tag_directive = tag_directives_start
< //                tag_directive != tag_directives_end; tag_directive ++) {
< //            assert(tag_directive.handle)
< //            assert(tag_directive.prefix)
< //            if (!yaml_check_utf8(tag_directive.handle,
< //                        strlen((char *)tag_directive.handle)))
< //                goto error
< //            if (!yaml_check_utf8(tag_directive.prefix,
< //                        strlen((char *)tag_directive.prefix)))
< //                goto error
< //            value.handle = yaml_strdup(tag_directive.handle)
< //            value.prefix = yaml_strdup(tag_directive.prefix)
< //            if (!value.handle || !value.prefix) goto error
< //            if (!PUSH(&context, tag_directives_copy, value))
< //                goto error
< //            value.handle = NULL
< //            value.prefix = NULL
< //        }
< //    }
< //
< //    DOCUMENT_INIT(*document, nodes.start, nodes.end, version_directive_copy,
< //            tag_directives_copy.start, tag_directives_copy.top,
< //            start_implicit, end_implicit, mark, mark)
< //
< //    return 1
< //
< //error:
< //    STACK_DEL(&context, nodes)
< //    yaml_free(version_directive_copy)
< //    while (!STACK_EMPTY(&context, tag_directives_copy)) {
< //        value yaml_tag_directive_t = POP(&context, tag_directives_copy)
< //        yaml_free(value.handle)
< //        yaml_free(value.prefix)
< //    }
< //    STACK_DEL(&context, tag_directives_copy)
< //    yaml_free(value.handle)
< //    yaml_free(value.prefix)
< //
< //    return 0
< //}
< //
< ///*
< // * Destroy a document object.
< // */
< //
< //YAML_DECLARE(void)
< //yaml_document_delete(document *yaml_document_t)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    tag_directive *yaml_tag_directive_t
< //
< //    context.error = YAML_NO_ERROR // Eliminate a compiler warning.
< //
< //    assert(document) // Non-NULL document object is expected.
< //
< //    while (!STACK_EMPTY(&context, document.nodes)) {
< //        node yaml_node_t = POP(&context, document.nodes)
< //        yaml_free(node.tag)
< //        switch (node.type) {
< //            case YAML_SCALAR_NODE:
< //                yaml_free(node.data.scalar.value)
< //                break
< //            case YAML_SEQUENCE_NODE:
< //                STACK_DEL(&context, node.data.sequence.items)
< //                break
< //            case YAML_MAPPING_NODE:
< //                STACK_DEL(&context, node.data.mapping.pairs)
< //                break
< //            default:
< //                assert(0) // Should not happen.
< //        }
< //    }
< //    STACK_DEL(&context, document.nodes)
< //
< //    yaml_free(document.version_directive)
< //    for (tag_directive = document.tag_directives.start
< //            tag_directive != document.tag_directives.end
< //            tag_directive++) {
< //        yaml_free(tag_directive.handle)
< //        yaml_free(tag_directive.prefix)
< //    }
< //    yaml_free(document.tag_directives.start)
< //
< //    memset(document, 0, sizeof(yaml_document_t))
< //}
< //
< ///**
< // * Get a document node.
< // */
< //
< //YAML_DECLARE(yaml_node_t *)
< //yaml_document_get_node(document *yaml_document_t, index int)
< //{
< //    assert(document) // Non-NULL document object is expected.
< //
< //    if (index > 0 && document.nodes.start + index <= document.nodes.top) {
< //        return document.nodes.start + index - 1
< //    }
< //    return NULL
< //}
< //
< ///**
< // * Get the root object.
< // */
< //
< //YAML_DECLARE(yaml_node_t *)
< //yaml_document_get_root_node(document *yaml_document_t)
< //{
< //    assert(document) // Non-NULL document object is expected.
< //
< //    if (document.nodes.top != document.nodes.start) {
< //        return document.nodes.start
< //    }
< //    return NULL
< //}
< //
< ///*
< // * Add a scalar node to a document.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_add_scalar(document *yaml_document_t,
< //        tag *yaml_char_t, value *yaml_char_t, length int,
< //        style yaml_scalar_style_t)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    mark yaml_mark_t = { 0, 0, 0 }
< //    tag_copy *yaml_char_t = NULL
< //    value_copy *yaml_char_t = NULL
< //    node yaml_node_t
< //
< //    assert(document) // Non-NULL document object is expected.
< //    assert(value) // Non-NULL value is expected.
< //
< //    if (!tag) {
< //        tag = (yaml_char_t *)YAML_DEFAULT_SCALAR_TAG
< //    }
< //
< //    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
< //    tag_copy = yaml_strdup(tag)
< //    if (!tag_copy) goto error
< //
< //    if (length < 0) {
< //        length = strlen((char *)value)
< //    }
< //
< //    if (!yaml_check_utf8(value, length)) goto error
< //    value_copy = yaml_malloc(length+1)
< //    if (!value_copy) goto error
< //    memcpy(value_copy, value, length)
< //    value_copy[length] = '\0'
< //
< //    SCALAR_NODE_INIT(node, tag_copy, value_copy, length, style, mark, mark)
< //    if (!PUSH(&context, document.nodes, node)) goto error
< //
< //    return document.nodes.top - document.nodes.start
< //
< //error:
< //    yaml_free(tag_copy)
< //    yaml_free(value_copy)
< //
< //    return 0
< //}
< //
< ///*
< // * Add a sequence node to a document.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_add_sequence(document *yaml_document_t,
< //        tag *yaml_char_t, style yaml_sequence_style_t)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    mark yaml_mark_t = { 0, 0, 0 }
< //    tag_copy *yaml_char_t = NULL
< //    struct {
< //        start *yaml_node_item_t
< //        end *yaml_node_item_t
< //        top *yaml_node_item_t
< //    } items = { NULL, NULL, NULL }
< //    node yaml_node_t
< //
< //    assert(document) // Non-NULL document object is expected.
< //
< //    if (!tag) {
< //        tag = (yaml_char_t *)YAML_DEFAULT_SEQUENCE_TAG
< //    }
< //
< //    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
< //    tag_copy = yaml_strdup(tag)
< //    if (!tag_copy) goto error
< //
< //    if (!STACK_INIT(&context, items, INITIAL_STACK_SIZE)) goto error
< //
< //    SEQUENCE_NODE_INIT(node, tag_copy, items.start, items.end,
< //            style, mark, mark)
< //    if (!PUSH(&context, document.nodes, node)) goto error
< //
< //    return document.nodes.top - document.nodes.start
< //
< //error:
< //    STACK_DEL(&context, items)
< //    yaml_free(tag_copy)
< //
< //    return 0
< //}
< //
< ///*
< // * Add a mapping node to a document.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_add_mapping(document *yaml_document_t,
< //        tag *yaml_char_t, style yaml_mapping_style_t)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    mark yaml_mark_t = { 0, 0, 0 }
< //    tag_copy *yaml_char_t = NULL
< //    struct {
< //        start *yaml_node_pair_t
< //        end *yaml_node_pair_t
< //        top *yaml_node_pair_t
< //    } pairs = { NULL, NULL, NULL }
< //    node yaml_node_t
< //
< //    assert(document) // Non-NULL document object is expected.
< //
< //    if (!tag) {
< //        tag = (yaml_char_t *)YAML_DEFAULT_MAPPING_TAG
< //    }
< //
< //    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
< //    tag_copy = yaml_strdup(tag)
< //    if (!tag_copy) goto error
< //
< //    if (!STACK_INIT(&context, pairs, INITIAL_STACK_SIZE)) goto error
< //
< //    MAPPING_NODE_INIT(node, tag_copy, pairs.start, pairs.end,
< //            style, mark, mark)
< //    if (!PUSH(&context, document.nodes, node)) goto error
< //
< //    return document.nodes.top - document.nodes.start
< //
< //error:
< //    STACK_DEL(&context, pairs)
< //    yaml_free(tag_copy)
< //
< //    return 0
< //}
< //
< ///*
< // * Append an item to a sequence node.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_append_sequence_item(document *yaml_document_t,
< //        sequence int, item int)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //
< //    assert(document) // Non-NULL document is required.
< //    assert(sequence > 0
< //            && document.nodes.start + sequence <= document.nodes.top)
< //                            // Valid sequence id is required.
< //    assert(document.nodes.start[sequence-1].type == YAML_SEQUENCE_NODE)
< //                            // A sequence node is required.
< //    assert(item > 0 && document.nodes.start + item <= document.nodes.top)
< //                            // Valid item id is required.
< //
< //    if (!PUSH(&context,
< //                document.nodes.start[sequence-1].data.sequence.items, item))
< //        return 0
< //
< //    return 1
< //}
< //
< ///*
< // * Append a pair of a key and a value to a mapping node.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_append_mapping_pair(document *yaml_document_t,
< //        mapping int, key int, value int)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //
< //    pair yaml_node_pair_t
< //
< //    assert(document) // Non-NULL document is required.
< //    assert(mapping > 0
< //            && document.nodes.start + mapping <= document.nodes.top)
< //                            // Valid mapping id is required.
< //    assert(document.nodes.start[mapping-1].type == YAML_MAPPING_NODE)
< //                            // A mapping node is required.
< //    assert(key > 0 && document.nodes.start + key <= document.nodes.top)
< //                            // Valid key id is required.
< //    assert(value > 0 && document.nodes.start + value <= document.nodes.top)
< //                            // Valid value id is required.
< //
< //    pair.key = key
< //    pair.value = value
< //
< //    if (!PUSH(&context,
< //                document.nodes.start[mapping-1].data.mapping.pairs, pair))
< //        return 0
< //
< //    return 1
< //}
< //
< //
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/decode.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/decode.go
1,775d0
< package yaml
< 
< import (
< 	"encoding"
< 	"encoding/base64"
< 	"fmt"
< 	"io"
< 	"math"
< 	"reflect"
< 	"strconv"
< 	"time"
< )
< 
< const (
< 	documentNode = 1 << iota
< 	mappingNode
< 	sequenceNode
< 	scalarNode
< 	aliasNode
< )
< 
< type node struct {
< 	kind         int
< 	line, column int
< 	tag          string
< 	// For an alias node, alias holds the resolved alias.
< 	alias    *node
< 	value    string
< 	implicit bool
< 	children []*node
< 	anchors  map[string]*node
< }
< 
< // ----------------------------------------------------------------------------
< // Parser, produces a node tree out of a libyaml event stream.
< 
< type parser struct {
< 	parser   yaml_parser_t
< 	event    yaml_event_t
< 	doc      *node
< 	doneInit bool
< }
< 
< func newParser(b []byte) *parser {
< 	p := parser{}
< 	if !yaml_parser_initialize(&p.parser) {
< 		panic("failed to initialize YAML emitter")
< 	}
< 	if len(b) == 0 {
< 		b = []byte{'\n'}
< 	}
< 	yaml_parser_set_input_string(&p.parser, b)
< 	return &p
< }
< 
< func newParserFromReader(r io.Reader) *parser {
< 	p := parser{}
< 	if !yaml_parser_initialize(&p.parser) {
< 		panic("failed to initialize YAML emitter")
< 	}
< 	yaml_parser_set_input_reader(&p.parser, r)
< 	return &p
< }
< 
< func (p *parser) init() {
< 	if p.doneInit {
< 		return
< 	}
< 	p.expect(yaml_STREAM_START_EVENT)
< 	p.doneInit = true
< }
< 
< func (p *parser) destroy() {
< 	if p.event.typ != yaml_NO_EVENT {
< 		yaml_event_delete(&p.event)
< 	}
< 	yaml_parser_delete(&p.parser)
< }
< 
< // expect consumes an event from the event stream and
< // checks that it's of the expected type.
< func (p *parser) expect(e yaml_event_type_t) {
< 	if p.event.typ == yaml_NO_EVENT {
< 		if !yaml_parser_parse(&p.parser, &p.event) {
< 			p.fail()
< 		}
< 	}
< 	if p.event.typ == yaml_STREAM_END_EVENT {
< 		failf("attempted to go past the end of stream; corrupted value?")
< 	}
< 	if p.event.typ != e {
< 		p.parser.problem = fmt.Sprintf("expected %s event but got %s", e, p.event.typ)
< 		p.fail()
< 	}
< 	yaml_event_delete(&p.event)
< 	p.event.typ = yaml_NO_EVENT
< }
< 
< // peek peeks at the next event in the event stream,
< // puts the results into p.event and returns the event type.
< func (p *parser) peek() yaml_event_type_t {
< 	if p.event.typ != yaml_NO_EVENT {
< 		return p.event.typ
< 	}
< 	if !yaml_parser_parse(&p.parser, &p.event) {
< 		p.fail()
< 	}
< 	return p.event.typ
< }
< 
< func (p *parser) fail() {
< 	var where string
< 	var line int
< 	if p.parser.problem_mark.line != 0 {
< 		line = p.parser.problem_mark.line
< 		// Scanner errors don't iterate line before returning error
< 		if p.parser.error == yaml_SCANNER_ERROR {
< 			line++
< 		}
< 	} else if p.parser.context_mark.line != 0 {
< 		line = p.parser.context_mark.line
< 	}
< 	if line != 0 {
< 		where = "line " + strconv.Itoa(line) + ": "
< 	}
< 	var msg string
< 	if len(p.parser.problem) > 0 {
< 		msg = p.parser.problem
< 	} else {
< 		msg = "unknown problem parsing YAML content"
< 	}
< 	failf("%s%s", where, msg)
< }
< 
< func (p *parser) anchor(n *node, anchor []byte) {
< 	if anchor != nil {
< 		p.doc.anchors[string(anchor)] = n
< 	}
< }
< 
< func (p *parser) parse() *node {
< 	p.init()
< 	switch p.peek() {
< 	case yaml_SCALAR_EVENT:
< 		return p.scalar()
< 	case yaml_ALIAS_EVENT:
< 		return p.alias()
< 	case yaml_MAPPING_START_EVENT:
< 		return p.mapping()
< 	case yaml_SEQUENCE_START_EVENT:
< 		return p.sequence()
< 	case yaml_DOCUMENT_START_EVENT:
< 		return p.document()
< 	case yaml_STREAM_END_EVENT:
< 		// Happens when attempting to decode an empty buffer.
< 		return nil
< 	default:
< 		panic("attempted to parse unknown event: " + p.event.typ.String())
< 	}
< }
< 
< func (p *parser) node(kind int) *node {
< 	return &node{
< 		kind:   kind,
< 		line:   p.event.start_mark.line,
< 		column: p.event.start_mark.column,
< 	}
< }
< 
< func (p *parser) document() *node {
< 	n := p.node(documentNode)
< 	n.anchors = make(map[string]*node)
< 	p.doc = n
< 	p.expect(yaml_DOCUMENT_START_EVENT)
< 	n.children = append(n.children, p.parse())
< 	p.expect(yaml_DOCUMENT_END_EVENT)
< 	return n
< }
< 
< func (p *parser) alias() *node {
< 	n := p.node(aliasNode)
< 	n.value = string(p.event.anchor)
< 	n.alias = p.doc.anchors[n.value]
< 	if n.alias == nil {
< 		failf("unknown anchor '%s' referenced", n.value)
< 	}
< 	p.expect(yaml_ALIAS_EVENT)
< 	return n
< }
< 
< func (p *parser) scalar() *node {
< 	n := p.node(scalarNode)
< 	n.value = string(p.event.value)
< 	n.tag = string(p.event.tag)
< 	n.implicit = p.event.implicit
< 	p.anchor(n, p.event.anchor)
< 	p.expect(yaml_SCALAR_EVENT)
< 	return n
< }
< 
< func (p *parser) sequence() *node {
< 	n := p.node(sequenceNode)
< 	p.anchor(n, p.event.anchor)
< 	p.expect(yaml_SEQUENCE_START_EVENT)
< 	for p.peek() != yaml_SEQUENCE_END_EVENT {
< 		n.children = append(n.children, p.parse())
< 	}
< 	p.expect(yaml_SEQUENCE_END_EVENT)
< 	return n
< }
< 
< func (p *parser) mapping() *node {
< 	n := p.node(mappingNode)
< 	p.anchor(n, p.event.anchor)
< 	p.expect(yaml_MAPPING_START_EVENT)
< 	for p.peek() != yaml_MAPPING_END_EVENT {
< 		n.children = append(n.children, p.parse(), p.parse())
< 	}
< 	p.expect(yaml_MAPPING_END_EVENT)
< 	return n
< }
< 
< // ----------------------------------------------------------------------------
< // Decoder, unmarshals a node into a provided value.
< 
< type decoder struct {
< 	doc     *node
< 	aliases map[*node]bool
< 	mapType reflect.Type
< 	terrors []string
< 	strict  bool
< }
< 
< var (
< 	mapItemType    = reflect.TypeOf(MapItem{})
< 	durationType   = reflect.TypeOf(time.Duration(0))
< 	defaultMapType = reflect.TypeOf(map[interface{}]interface{}{})
< 	ifaceType      = defaultMapType.Elem()
< 	timeType       = reflect.TypeOf(time.Time{})
< 	ptrTimeType    = reflect.TypeOf(&time.Time{})
< )
< 
< func newDecoder(strict bool) *decoder {
< 	d := &decoder{mapType: defaultMapType, strict: strict}
< 	d.aliases = make(map[*node]bool)
< 	return d
< }
< 
< func (d *decoder) terror(n *node, tag string, out reflect.Value) {
< 	if n.tag != "" {
< 		tag = n.tag
< 	}
< 	value := n.value
< 	if tag != yaml_SEQ_TAG && tag != yaml_MAP_TAG {
< 		if len(value) > 10 {
< 			value = " `" + value[:7] + "...`"
< 		} else {
< 			value = " `" + value + "`"
< 		}
< 	}
< 	d.terrors = append(d.terrors, fmt.Sprintf("line %d: cannot unmarshal %s%s into %s", n.line+1, shortTag(tag), value, out.Type()))
< }
< 
< func (d *decoder) callUnmarshaler(n *node, u Unmarshaler) (good bool) {
< 	terrlen := len(d.terrors)
< 	err := u.UnmarshalYAML(func(v interface{}) (err error) {
< 		defer handleErr(&err)
< 		d.unmarshal(n, reflect.ValueOf(v))
< 		if len(d.terrors) > terrlen {
< 			issues := d.terrors[terrlen:]
< 			d.terrors = d.terrors[:terrlen]
< 			return &TypeError{issues}
< 		}
< 		return nil
< 	})
< 	if e, ok := err.(*TypeError); ok {
< 		d.terrors = append(d.terrors, e.Errors...)
< 		return false
< 	}
< 	if err != nil {
< 		fail(err)
< 	}
< 	return true
< }
< 
< // d.prepare initializes and dereferences pointers and calls UnmarshalYAML
< // if a value is found to implement it.
< // It returns the initialized and dereferenced out value, whether
< // unmarshalling was already done by UnmarshalYAML, and if so whether
< // its types unmarshalled appropriately.
< //
< // If n holds a null value, prepare returns before doing anything.
< func (d *decoder) prepare(n *node, out reflect.Value) (newout reflect.Value, unmarshaled, good bool) {
< 	if n.tag == yaml_NULL_TAG || n.kind == scalarNode && n.tag == "" && (n.value == "null" || n.value == "~" || n.value == "" && n.implicit) {
< 		return out, false, false
< 	}
< 	again := true
< 	for again {
< 		again = false
< 		if out.Kind() == reflect.Ptr {
< 			if out.IsNil() {
< 				out.Set(reflect.New(out.Type().Elem()))
< 			}
< 			out = out.Elem()
< 			again = true
< 		}
< 		if out.CanAddr() {
< 			if u, ok := out.Addr().Interface().(Unmarshaler); ok {
< 				good = d.callUnmarshaler(n, u)
< 				return out, true, good
< 			}
< 		}
< 	}
< 	return out, false, false
< }
< 
< func (d *decoder) unmarshal(n *node, out reflect.Value) (good bool) {
< 	switch n.kind {
< 	case documentNode:
< 		return d.document(n, out)
< 	case aliasNode:
< 		return d.alias(n, out)
< 	}
< 	out, unmarshaled, good := d.prepare(n, out)
< 	if unmarshaled {
< 		return good
< 	}
< 	switch n.kind {
< 	case scalarNode:
< 		good = d.scalar(n, out)
< 	case mappingNode:
< 		good = d.mapping(n, out)
< 	case sequenceNode:
< 		good = d.sequence(n, out)
< 	default:
< 		panic("internal error: unknown node kind: " + strconv.Itoa(n.kind))
< 	}
< 	return good
< }
< 
< func (d *decoder) document(n *node, out reflect.Value) (good bool) {
< 	if len(n.children) == 1 {
< 		d.doc = n
< 		d.unmarshal(n.children[0], out)
< 		return true
< 	}
< 	return false
< }
< 
< func (d *decoder) alias(n *node, out reflect.Value) (good bool) {
< 	if d.aliases[n] {
< 		// TODO this could actually be allowed in some circumstances.
< 		failf("anchor '%s' value contains itself", n.value)
< 	}
< 	d.aliases[n] = true
< 	good = d.unmarshal(n.alias, out)
< 	delete(d.aliases, n)
< 	return good
< }
< 
< var zeroValue reflect.Value
< 
< func resetMap(out reflect.Value) {
< 	for _, k := range out.MapKeys() {
< 		out.SetMapIndex(k, zeroValue)
< 	}
< }
< 
< func (d *decoder) scalar(n *node, out reflect.Value) bool {
< 	var tag string
< 	var resolved interface{}
< 	if n.tag == "" && !n.implicit {
< 		tag = yaml_STR_TAG
< 		resolved = n.value
< 	} else {
< 		tag, resolved = resolve(n.tag, n.value)
< 		if tag == yaml_BINARY_TAG {
< 			data, err := base64.StdEncoding.DecodeString(resolved.(string))
< 			if err != nil {
< 				failf("!!binary value contains invalid base64 data")
< 			}
< 			resolved = string(data)
< 		}
< 	}
< 	if resolved == nil {
< 		if out.Kind() == reflect.Map && !out.CanAddr() {
< 			resetMap(out)
< 		} else {
< 			out.Set(reflect.Zero(out.Type()))
< 		}
< 		return true
< 	}
< 	if resolvedv := reflect.ValueOf(resolved); out.Type() == resolvedv.Type() {
< 		// We've resolved to exactly the type we want, so use that.
< 		out.Set(resolvedv)
< 		return true
< 	}
< 	// Perhaps we can use the value as a TextUnmarshaler to
< 	// set its value.
< 	if out.CanAddr() {
< 		u, ok := out.Addr().Interface().(encoding.TextUnmarshaler)
< 		if ok {
< 			var text []byte
< 			if tag == yaml_BINARY_TAG {
< 				text = []byte(resolved.(string))
< 			} else {
< 				// We let any value be unmarshaled into TextUnmarshaler.
< 				// That might be more lax than we'd like, but the
< 				// TextUnmarshaler itself should bowl out any dubious values.
< 				text = []byte(n.value)
< 			}
< 			err := u.UnmarshalText(text)
< 			if err != nil {
< 				fail(err)
< 			}
< 			return true
< 		}
< 	}
< 	switch out.Kind() {
< 	case reflect.String:
< 		if tag == yaml_BINARY_TAG {
< 			out.SetString(resolved.(string))
< 			return true
< 		}
< 		if resolved != nil {
< 			out.SetString(n.value)
< 			return true
< 		}
< 	case reflect.Interface:
< 		if resolved == nil {
< 			out.Set(reflect.Zero(out.Type()))
< 		} else if tag == yaml_TIMESTAMP_TAG {
< 			// It looks like a timestamp but for backward compatibility
< 			// reasons we set it as a string, so that code that unmarshals
< 			// timestamp-like values into interface{} will continue to
< 			// see a string and not a time.Time.
< 			// TODO(v3) Drop this.
< 			out.Set(reflect.ValueOf(n.value))
< 		} else {
< 			out.Set(reflect.ValueOf(resolved))
< 		}
< 		return true
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		switch resolved := resolved.(type) {
< 		case int:
< 			if !out.OverflowInt(int64(resolved)) {
< 				out.SetInt(int64(resolved))
< 				return true
< 			}
< 		case int64:
< 			if !out.OverflowInt(resolved) {
< 				out.SetInt(resolved)
< 				return true
< 			}
< 		case uint64:
< 			if resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {
< 				out.SetInt(int64(resolved))
< 				return true
< 			}
< 		case float64:
< 			if resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {
< 				out.SetInt(int64(resolved))
< 				return true
< 			}
< 		case string:
< 			if out.Type() == durationType {
< 				d, err := time.ParseDuration(resolved)
< 				if err == nil {
< 					out.SetInt(int64(d))
< 					return true
< 				}
< 			}
< 		}
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		switch resolved := resolved.(type) {
< 		case int:
< 			if resolved >= 0 && !out.OverflowUint(uint64(resolved)) {
< 				out.SetUint(uint64(resolved))
< 				return true
< 			}
< 		case int64:
< 			if resolved >= 0 && !out.OverflowUint(uint64(resolved)) {
< 				out.SetUint(uint64(resolved))
< 				return true
< 			}
< 		case uint64:
< 			if !out.OverflowUint(uint64(resolved)) {
< 				out.SetUint(uint64(resolved))
< 				return true
< 			}
< 		case float64:
< 			if resolved <= math.MaxUint64 && !out.OverflowUint(uint64(resolved)) {
< 				out.SetUint(uint64(resolved))
< 				return true
< 			}
< 		}
< 	case reflect.Bool:
< 		switch resolved := resolved.(type) {
< 		case bool:
< 			out.SetBool(resolved)
< 			return true
< 		}
< 	case reflect.Float32, reflect.Float64:
< 		switch resolved := resolved.(type) {
< 		case int:
< 			out.SetFloat(float64(resolved))
< 			return true
< 		case int64:
< 			out.SetFloat(float64(resolved))
< 			return true
< 		case uint64:
< 			out.SetFloat(float64(resolved))
< 			return true
< 		case float64:
< 			out.SetFloat(resolved)
< 			return true
< 		}
< 	case reflect.Struct:
< 		if resolvedv := reflect.ValueOf(resolved); out.Type() == resolvedv.Type() {
< 			out.Set(resolvedv)
< 			return true
< 		}
< 	case reflect.Ptr:
< 		if out.Type().Elem() == reflect.TypeOf(resolved) {
< 			// TODO DOes this make sense? When is out a Ptr except when decoding a nil value?
< 			elem := reflect.New(out.Type().Elem())
< 			elem.Elem().Set(reflect.ValueOf(resolved))
< 			out.Set(elem)
< 			return true
< 		}
< 	}
< 	d.terror(n, tag, out)
< 	return false
< }
< 
< func settableValueOf(i interface{}) reflect.Value {
< 	v := reflect.ValueOf(i)
< 	sv := reflect.New(v.Type()).Elem()
< 	sv.Set(v)
< 	return sv
< }
< 
< func (d *decoder) sequence(n *node, out reflect.Value) (good bool) {
< 	l := len(n.children)
< 
< 	var iface reflect.Value
< 	switch out.Kind() {
< 	case reflect.Slice:
< 		out.Set(reflect.MakeSlice(out.Type(), l, l))
< 	case reflect.Array:
< 		if l != out.Len() {
< 			failf("invalid array: want %d elements but got %d", out.Len(), l)
< 		}
< 	case reflect.Interface:
< 		// No type hints. Will have to use a generic sequence.
< 		iface = out
< 		out = settableValueOf(make([]interface{}, l))
< 	default:
< 		d.terror(n, yaml_SEQ_TAG, out)
< 		return false
< 	}
< 	et := out.Type().Elem()
< 
< 	j := 0
< 	for i := 0; i < l; i++ {
< 		e := reflect.New(et).Elem()
< 		if ok := d.unmarshal(n.children[i], e); ok {
< 			out.Index(j).Set(e)
< 			j++
< 		}
< 	}
< 	if out.Kind() != reflect.Array {
< 		out.Set(out.Slice(0, j))
< 	}
< 	if iface.IsValid() {
< 		iface.Set(out)
< 	}
< 	return true
< }
< 
< func (d *decoder) mapping(n *node, out reflect.Value) (good bool) {
< 	switch out.Kind() {
< 	case reflect.Struct:
< 		return d.mappingStruct(n, out)
< 	case reflect.Slice:
< 		return d.mappingSlice(n, out)
< 	case reflect.Map:
< 		// okay
< 	case reflect.Interface:
< 		if d.mapType.Kind() == reflect.Map {
< 			iface := out
< 			out = reflect.MakeMap(d.mapType)
< 			iface.Set(out)
< 		} else {
< 			slicev := reflect.New(d.mapType).Elem()
< 			if !d.mappingSlice(n, slicev) {
< 				return false
< 			}
< 			out.Set(slicev)
< 			return true
< 		}
< 	default:
< 		d.terror(n, yaml_MAP_TAG, out)
< 		return false
< 	}
< 	outt := out.Type()
< 	kt := outt.Key()
< 	et := outt.Elem()
< 
< 	mapType := d.mapType
< 	if outt.Key() == ifaceType && outt.Elem() == ifaceType {
< 		d.mapType = outt
< 	}
< 
< 	if out.IsNil() {
< 		out.Set(reflect.MakeMap(outt))
< 	}
< 	l := len(n.children)
< 	for i := 0; i < l; i += 2 {
< 		if isMerge(n.children[i]) {
< 			d.merge(n.children[i+1], out)
< 			continue
< 		}
< 		k := reflect.New(kt).Elem()
< 		if d.unmarshal(n.children[i], k) {
< 			kkind := k.Kind()
< 			if kkind == reflect.Interface {
< 				kkind = k.Elem().Kind()
< 			}
< 			if kkind == reflect.Map || kkind == reflect.Slice {
< 				failf("invalid map key: %#v", k.Interface())
< 			}
< 			e := reflect.New(et).Elem()
< 			if d.unmarshal(n.children[i+1], e) {
< 				d.setMapIndex(n.children[i+1], out, k, e)
< 			}
< 		}
< 	}
< 	d.mapType = mapType
< 	return true
< }
< 
< func (d *decoder) setMapIndex(n *node, out, k, v reflect.Value) {
< 	if d.strict && out.MapIndex(k) != zeroValue {
< 		d.terrors = append(d.terrors, fmt.Sprintf("line %d: key %#v already set in map", n.line+1, k.Interface()))
< 		return
< 	}
< 	out.SetMapIndex(k, v)
< }
< 
< func (d *decoder) mappingSlice(n *node, out reflect.Value) (good bool) {
< 	outt := out.Type()
< 	if outt.Elem() != mapItemType {
< 		d.terror(n, yaml_MAP_TAG, out)
< 		return false
< 	}
< 
< 	mapType := d.mapType
< 	d.mapType = outt
< 
< 	var slice []MapItem
< 	var l = len(n.children)
< 	for i := 0; i < l; i += 2 {
< 		if isMerge(n.children[i]) {
< 			d.merge(n.children[i+1], out)
< 			continue
< 		}
< 		item := MapItem{}
< 		k := reflect.ValueOf(&item.Key).Elem()
< 		if d.unmarshal(n.children[i], k) {
< 			v := reflect.ValueOf(&item.Value).Elem()
< 			if d.unmarshal(n.children[i+1], v) {
< 				slice = append(slice, item)
< 			}
< 		}
< 	}
< 	out.Set(reflect.ValueOf(slice))
< 	d.mapType = mapType
< 	return true
< }
< 
< func (d *decoder) mappingStruct(n *node, out reflect.Value) (good bool) {
< 	sinfo, err := getStructInfo(out.Type())
< 	if err != nil {
< 		panic(err)
< 	}
< 	name := settableValueOf("")
< 	l := len(n.children)
< 
< 	var inlineMap reflect.Value
< 	var elemType reflect.Type
< 	if sinfo.InlineMap != -1 {
< 		inlineMap = out.Field(sinfo.InlineMap)
< 		inlineMap.Set(reflect.New(inlineMap.Type()).Elem())
< 		elemType = inlineMap.Type().Elem()
< 	}
< 
< 	var doneFields []bool
< 	if d.strict {
< 		doneFields = make([]bool, len(sinfo.FieldsList))
< 	}
< 	for i := 0; i < l; i += 2 {
< 		ni := n.children[i]
< 		if isMerge(ni) {
< 			d.merge(n.children[i+1], out)
< 			continue
< 		}
< 		if !d.unmarshal(ni, name) {
< 			continue
< 		}
< 		if info, ok := sinfo.FieldsMap[name.String()]; ok {
< 			if d.strict {
< 				if doneFields[info.Id] {
< 					d.terrors = append(d.terrors, fmt.Sprintf("line %d: field %s already set in type %s", ni.line+1, name.String(), out.Type()))
< 					continue
< 				}
< 				doneFields[info.Id] = true
< 			}
< 			var field reflect.Value
< 			if info.Inline == nil {
< 				field = out.Field(info.Num)
< 			} else {
< 				field = out.FieldByIndex(info.Inline)
< 			}
< 			d.unmarshal(n.children[i+1], field)
< 		} else if sinfo.InlineMap != -1 {
< 			if inlineMap.IsNil() {
< 				inlineMap.Set(reflect.MakeMap(inlineMap.Type()))
< 			}
< 			value := reflect.New(elemType).Elem()
< 			d.unmarshal(n.children[i+1], value)
< 			d.setMapIndex(n.children[i+1], inlineMap, name, value)
< 		} else if d.strict {
< 			d.terrors = append(d.terrors, fmt.Sprintf("line %d: field %s not found in type %s", ni.line+1, name.String(), out.Type()))
< 		}
< 	}
< 	return true
< }
< 
< func failWantMap() {
< 	failf("map merge requires map or sequence of maps as the value")
< }
< 
< func (d *decoder) merge(n *node, out reflect.Value) {
< 	switch n.kind {
< 	case mappingNode:
< 		d.unmarshal(n, out)
< 	case aliasNode:
< 		an, ok := d.doc.anchors[n.value]
< 		if ok && an.kind != mappingNode {
< 			failWantMap()
< 		}
< 		d.unmarshal(n, out)
< 	case sequenceNode:
< 		// Step backwards as earlier nodes take precedence.
< 		for i := len(n.children) - 1; i >= 0; i-- {
< 			ni := n.children[i]
< 			if ni.kind == aliasNode {
< 				an, ok := d.doc.anchors[ni.value]
< 				if ok && an.kind != mappingNode {
< 					failWantMap()
< 				}
< 			} else if ni.kind != mappingNode {
< 				failWantMap()
< 			}
< 			d.unmarshal(ni, out)
< 		}
< 	default:
< 		failWantMap()
< 	}
< }
< 
< func isMerge(n *node) bool {
< 	return n.kind == scalarNode && n.value == "<<" && (n.implicit == true || n.tag == yaml_MERGE_TAG)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/emitterc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/emitterc.go
1,1685d0
< package yaml
< 
< import (
< 	"bytes"
< 	"fmt"
< )
< 
< // Flush the buffer if needed.
< func flush(emitter *yaml_emitter_t) bool {
< 	if emitter.buffer_pos+5 >= len(emitter.buffer) {
< 		return yaml_emitter_flush(emitter)
< 	}
< 	return true
< }
< 
< // Put a character to the output buffer.
< func put(emitter *yaml_emitter_t, value byte) bool {
< 	if emitter.buffer_pos+5 >= len(emitter.buffer) && !yaml_emitter_flush(emitter) {
< 		return false
< 	}
< 	emitter.buffer[emitter.buffer_pos] = value
< 	emitter.buffer_pos++
< 	emitter.column++
< 	return true
< }
< 
< // Put a line break to the output buffer.
< func put_break(emitter *yaml_emitter_t) bool {
< 	if emitter.buffer_pos+5 >= len(emitter.buffer) && !yaml_emitter_flush(emitter) {
< 		return false
< 	}
< 	switch emitter.line_break {
< 	case yaml_CR_BREAK:
< 		emitter.buffer[emitter.buffer_pos] = '\r'
< 		emitter.buffer_pos += 1
< 	case yaml_LN_BREAK:
< 		emitter.buffer[emitter.buffer_pos] = '\n'
< 		emitter.buffer_pos += 1
< 	case yaml_CRLN_BREAK:
< 		emitter.buffer[emitter.buffer_pos+0] = '\r'
< 		emitter.buffer[emitter.buffer_pos+1] = '\n'
< 		emitter.buffer_pos += 2
< 	default:
< 		panic("unknown line break setting")
< 	}
< 	emitter.column = 0
< 	emitter.line++
< 	return true
< }
< 
< // Copy a character from a string into buffer.
< func write(emitter *yaml_emitter_t, s []byte, i *int) bool {
< 	if emitter.buffer_pos+5 >= len(emitter.buffer) && !yaml_emitter_flush(emitter) {
< 		return false
< 	}
< 	p := emitter.buffer_pos
< 	w := width(s[*i])
< 	switch w {
< 	case 4:
< 		emitter.buffer[p+3] = s[*i+3]
< 		fallthrough
< 	case 3:
< 		emitter.buffer[p+2] = s[*i+2]
< 		fallthrough
< 	case 2:
< 		emitter.buffer[p+1] = s[*i+1]
< 		fallthrough
< 	case 1:
< 		emitter.buffer[p+0] = s[*i+0]
< 	default:
< 		panic("unknown character width")
< 	}
< 	emitter.column++
< 	emitter.buffer_pos += w
< 	*i += w
< 	return true
< }
< 
< // Write a whole string into buffer.
< func write_all(emitter *yaml_emitter_t, s []byte) bool {
< 	for i := 0; i < len(s); {
< 		if !write(emitter, s, &i) {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< // Copy a line break character from a string into buffer.
< func write_break(emitter *yaml_emitter_t, s []byte, i *int) bool {
< 	if s[*i] == '\n' {
< 		if !put_break(emitter) {
< 			return false
< 		}
< 		*i++
< 	} else {
< 		if !write(emitter, s, i) {
< 			return false
< 		}
< 		emitter.column = 0
< 		emitter.line++
< 	}
< 	return true
< }
< 
< // Set an emitter error and return false.
< func yaml_emitter_set_emitter_error(emitter *yaml_emitter_t, problem string) bool {
< 	emitter.error = yaml_EMITTER_ERROR
< 	emitter.problem = problem
< 	return false
< }
< 
< // Emit an event.
< func yaml_emitter_emit(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	emitter.events = append(emitter.events, *event)
< 	for !yaml_emitter_need_more_events(emitter) {
< 		event := &emitter.events[emitter.events_head]
< 		if !yaml_emitter_analyze_event(emitter, event) {
< 			return false
< 		}
< 		if !yaml_emitter_state_machine(emitter, event) {
< 			return false
< 		}
< 		yaml_event_delete(event)
< 		emitter.events_head++
< 	}
< 	return true
< }
< 
< // Check if we need to accumulate more events before emitting.
< //
< // We accumulate extra
< //  - 1 event for DOCUMENT-START
< //  - 2 events for SEQUENCE-START
< //  - 3 events for MAPPING-START
< //
< func yaml_emitter_need_more_events(emitter *yaml_emitter_t) bool {
< 	if emitter.events_head == len(emitter.events) {
< 		return true
< 	}
< 	var accumulate int
< 	switch emitter.events[emitter.events_head].typ {
< 	case yaml_DOCUMENT_START_EVENT:
< 		accumulate = 1
< 		break
< 	case yaml_SEQUENCE_START_EVENT:
< 		accumulate = 2
< 		break
< 	case yaml_MAPPING_START_EVENT:
< 		accumulate = 3
< 		break
< 	default:
< 		return false
< 	}
< 	if len(emitter.events)-emitter.events_head > accumulate {
< 		return false
< 	}
< 	var level int
< 	for i := emitter.events_head; i < len(emitter.events); i++ {
< 		switch emitter.events[i].typ {
< 		case yaml_STREAM_START_EVENT, yaml_DOCUMENT_START_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT:
< 			level++
< 		case yaml_STREAM_END_EVENT, yaml_DOCUMENT_END_EVENT, yaml_SEQUENCE_END_EVENT, yaml_MAPPING_END_EVENT:
< 			level--
< 		}
< 		if level == 0 {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< // Append a directive to the directives stack.
< func yaml_emitter_append_tag_directive(emitter *yaml_emitter_t, value *yaml_tag_directive_t, allow_duplicates bool) bool {
< 	for i := 0; i < len(emitter.tag_directives); i++ {
< 		if bytes.Equal(value.handle, emitter.tag_directives[i].handle) {
< 			if allow_duplicates {
< 				return true
< 			}
< 			return yaml_emitter_set_emitter_error(emitter, "duplicate %TAG directive")
< 		}
< 	}
< 
< 	// [Go] Do we actually need to copy this given garbage collection
< 	// and the lack of deallocating destructors?
< 	tag_copy := yaml_tag_directive_t{
< 		handle: make([]byte, len(value.handle)),
< 		prefix: make([]byte, len(value.prefix)),
< 	}
< 	copy(tag_copy.handle, value.handle)
< 	copy(tag_copy.prefix, value.prefix)
< 	emitter.tag_directives = append(emitter.tag_directives, tag_copy)
< 	return true
< }
< 
< // Increase the indentation level.
< func yaml_emitter_increase_indent(emitter *yaml_emitter_t, flow, indentless bool) bool {
< 	emitter.indents = append(emitter.indents, emitter.indent)
< 	if emitter.indent < 0 {
< 		if flow {
< 			emitter.indent = emitter.best_indent
< 		} else {
< 			emitter.indent = 0
< 		}
< 	} else if !indentless {
< 		emitter.indent += emitter.best_indent
< 	}
< 	return true
< }
< 
< // State dispatcher.
< func yaml_emitter_state_machine(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	switch emitter.state {
< 	default:
< 	case yaml_EMIT_STREAM_START_STATE:
< 		return yaml_emitter_emit_stream_start(emitter, event)
< 
< 	case yaml_EMIT_FIRST_DOCUMENT_START_STATE:
< 		return yaml_emitter_emit_document_start(emitter, event, true)
< 
< 	case yaml_EMIT_DOCUMENT_START_STATE:
< 		return yaml_emitter_emit_document_start(emitter, event, false)
< 
< 	case yaml_EMIT_DOCUMENT_CONTENT_STATE:
< 		return yaml_emitter_emit_document_content(emitter, event)
< 
< 	case yaml_EMIT_DOCUMENT_END_STATE:
< 		return yaml_emitter_emit_document_end(emitter, event)
< 
< 	case yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE:
< 		return yaml_emitter_emit_flow_sequence_item(emitter, event, true)
< 
< 	case yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE:
< 		return yaml_emitter_emit_flow_sequence_item(emitter, event, false)
< 
< 	case yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE:
< 		return yaml_emitter_emit_flow_mapping_key(emitter, event, true)
< 
< 	case yaml_EMIT_FLOW_MAPPING_KEY_STATE:
< 		return yaml_emitter_emit_flow_mapping_key(emitter, event, false)
< 
< 	case yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE:
< 		return yaml_emitter_emit_flow_mapping_value(emitter, event, true)
< 
< 	case yaml_EMIT_FLOW_MAPPING_VALUE_STATE:
< 		return yaml_emitter_emit_flow_mapping_value(emitter, event, false)
< 
< 	case yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE:
< 		return yaml_emitter_emit_block_sequence_item(emitter, event, true)
< 
< 	case yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE:
< 		return yaml_emitter_emit_block_sequence_item(emitter, event, false)
< 
< 	case yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE:
< 		return yaml_emitter_emit_block_mapping_key(emitter, event, true)
< 
< 	case yaml_EMIT_BLOCK_MAPPING_KEY_STATE:
< 		return yaml_emitter_emit_block_mapping_key(emitter, event, false)
< 
< 	case yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE:
< 		return yaml_emitter_emit_block_mapping_value(emitter, event, true)
< 
< 	case yaml_EMIT_BLOCK_MAPPING_VALUE_STATE:
< 		return yaml_emitter_emit_block_mapping_value(emitter, event, false)
< 
< 	case yaml_EMIT_END_STATE:
< 		return yaml_emitter_set_emitter_error(emitter, "expected nothing after STREAM-END")
< 	}
< 	panic("invalid emitter state")
< }
< 
< // Expect STREAM-START.
< func yaml_emitter_emit_stream_start(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if event.typ != yaml_STREAM_START_EVENT {
< 		return yaml_emitter_set_emitter_error(emitter, "expected STREAM-START")
< 	}
< 	if emitter.encoding == yaml_ANY_ENCODING {
< 		emitter.encoding = event.encoding
< 		if emitter.encoding == yaml_ANY_ENCODING {
< 			emitter.encoding = yaml_UTF8_ENCODING
< 		}
< 	}
< 	if emitter.best_indent < 2 || emitter.best_indent > 9 {
< 		emitter.best_indent = 2
< 	}
< 	if emitter.best_width >= 0 && emitter.best_width <= emitter.best_indent*2 {
< 		emitter.best_width = 80
< 	}
< 	if emitter.best_width < 0 {
< 		emitter.best_width = 1<<31 - 1
< 	}
< 	if emitter.line_break == yaml_ANY_BREAK {
< 		emitter.line_break = yaml_LN_BREAK
< 	}
< 
< 	emitter.indent = -1
< 	emitter.line = 0
< 	emitter.column = 0
< 	emitter.whitespace = true
< 	emitter.indention = true
< 
< 	if emitter.encoding != yaml_UTF8_ENCODING {
< 		if !yaml_emitter_write_bom(emitter) {
< 			return false
< 		}
< 	}
< 	emitter.state = yaml_EMIT_FIRST_DOCUMENT_START_STATE
< 	return true
< }
< 
< // Expect DOCUMENT-START or STREAM-END.
< func yaml_emitter_emit_document_start(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
< 
< 	if event.typ == yaml_DOCUMENT_START_EVENT {
< 
< 		if event.version_directive != nil {
< 			if !yaml_emitter_analyze_version_directive(emitter, event.version_directive) {
< 				return false
< 			}
< 		}
< 
< 		for i := 0; i < len(event.tag_directives); i++ {
< 			tag_directive := &event.tag_directives[i]
< 			if !yaml_emitter_analyze_tag_directive(emitter, tag_directive) {
< 				return false
< 			}
< 			if !yaml_emitter_append_tag_directive(emitter, tag_directive, false) {
< 				return false
< 			}
< 		}
< 
< 		for i := 0; i < len(default_tag_directives); i++ {
< 			tag_directive := &default_tag_directives[i]
< 			if !yaml_emitter_append_tag_directive(emitter, tag_directive, true) {
< 				return false
< 			}
< 		}
< 
< 		implicit := event.implicit
< 		if !first || emitter.canonical {
< 			implicit = false
< 		}
< 
< 		if emitter.open_ended && (event.version_directive != nil || len(event.tag_directives) > 0) {
< 			if !yaml_emitter_write_indicator(emitter, []byte("..."), true, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 
< 		if event.version_directive != nil {
< 			implicit = false
< 			if !yaml_emitter_write_indicator(emitter, []byte("%YAML"), true, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indicator(emitter, []byte("1.1"), true, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 
< 		if len(event.tag_directives) > 0 {
< 			implicit = false
< 			for i := 0; i < len(event.tag_directives); i++ {
< 				tag_directive := &event.tag_directives[i]
< 				if !yaml_emitter_write_indicator(emitter, []byte("%TAG"), true, false, false) {
< 					return false
< 				}
< 				if !yaml_emitter_write_tag_handle(emitter, tag_directive.handle) {
< 					return false
< 				}
< 				if !yaml_emitter_write_tag_content(emitter, tag_directive.prefix, true) {
< 					return false
< 				}
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 		}
< 
< 		if yaml_emitter_check_empty_document(emitter) {
< 			implicit = false
< 		}
< 		if !implicit {
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indicator(emitter, []byte("---"), true, false, false) {
< 				return false
< 			}
< 			if emitter.canonical {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 		}
< 
< 		emitter.state = yaml_EMIT_DOCUMENT_CONTENT_STATE
< 		return true
< 	}
< 
< 	if event.typ == yaml_STREAM_END_EVENT {
< 		if emitter.open_ended {
< 			if !yaml_emitter_write_indicator(emitter, []byte("..."), true, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_flush(emitter) {
< 			return false
< 		}
< 		emitter.state = yaml_EMIT_END_STATE
< 		return true
< 	}
< 
< 	return yaml_emitter_set_emitter_error(emitter, "expected DOCUMENT-START or STREAM-END")
< }
< 
< // Expect the root node.
< func yaml_emitter_emit_document_content(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	emitter.states = append(emitter.states, yaml_EMIT_DOCUMENT_END_STATE)
< 	return yaml_emitter_emit_node(emitter, event, true, false, false, false)
< }
< 
< // Expect DOCUMENT-END.
< func yaml_emitter_emit_document_end(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if event.typ != yaml_DOCUMENT_END_EVENT {
< 		return yaml_emitter_set_emitter_error(emitter, "expected DOCUMENT-END")
< 	}
< 	if !yaml_emitter_write_indent(emitter) {
< 		return false
< 	}
< 	if !event.implicit {
< 		// [Go] Allocate the slice elsewhere.
< 		if !yaml_emitter_write_indicator(emitter, []byte("..."), true, false, false) {
< 			return false
< 		}
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 	}
< 	if !yaml_emitter_flush(emitter) {
< 		return false
< 	}
< 	emitter.state = yaml_EMIT_DOCUMENT_START_STATE
< 	emitter.tag_directives = emitter.tag_directives[:0]
< 	return true
< }
< 
< // Expect a flow item node.
< func yaml_emitter_emit_flow_sequence_item(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		if !yaml_emitter_write_indicator(emitter, []byte{'['}, true, true, false) {
< 			return false
< 		}
< 		if !yaml_emitter_increase_indent(emitter, true, false) {
< 			return false
< 		}
< 		emitter.flow_level++
< 	}
< 
< 	if event.typ == yaml_SEQUENCE_END_EVENT {
< 		emitter.flow_level--
< 		emitter.indent = emitter.indents[len(emitter.indents)-1]
< 		emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 		if emitter.canonical && !first {
< 			if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{']'}, false, false, false) {
< 			return false
< 		}
< 		emitter.state = emitter.states[len(emitter.states)-1]
< 		emitter.states = emitter.states[:len(emitter.states)-1]
< 
< 		return true
< 	}
< 
< 	if !first {
< 		if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 			return false
< 		}
< 	}
< 
< 	if emitter.canonical || emitter.column > emitter.best_width {
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE)
< 	return yaml_emitter_emit_node(emitter, event, false, true, false, false)
< }
< 
< // Expect a flow key node.
< func yaml_emitter_emit_flow_mapping_key(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		if !yaml_emitter_write_indicator(emitter, []byte{'{'}, true, true, false) {
< 			return false
< 		}
< 		if !yaml_emitter_increase_indent(emitter, true, false) {
< 			return false
< 		}
< 		emitter.flow_level++
< 	}
< 
< 	if event.typ == yaml_MAPPING_END_EVENT {
< 		emitter.flow_level--
< 		emitter.indent = emitter.indents[len(emitter.indents)-1]
< 		emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 		if emitter.canonical && !first {
< 			if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{'}'}, false, false, false) {
< 			return false
< 		}
< 		emitter.state = emitter.states[len(emitter.states)-1]
< 		emitter.states = emitter.states[:len(emitter.states)-1]
< 		return true
< 	}
< 
< 	if !first {
< 		if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 			return false
< 		}
< 	}
< 	if emitter.canonical || emitter.column > emitter.best_width {
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 	}
< 
< 	if !emitter.canonical && yaml_emitter_check_simple_key(emitter) {
< 		emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE)
< 		return yaml_emitter_emit_node(emitter, event, false, false, true, true)
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'?'}, true, false, false) {
< 		return false
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_VALUE_STATE)
< 	return yaml_emitter_emit_node(emitter, event, false, false, true, false)
< }
< 
< // Expect a flow value node.
< func yaml_emitter_emit_flow_mapping_value(emitter *yaml_emitter_t, event *yaml_event_t, simple bool) bool {
< 	if simple {
< 		if !yaml_emitter_write_indicator(emitter, []byte{':'}, false, false, false) {
< 			return false
< 		}
< 	} else {
< 		if emitter.canonical || emitter.column > emitter.best_width {
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{':'}, true, false, false) {
< 			return false
< 		}
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_KEY_STATE)
< 	return yaml_emitter_emit_node(emitter, event, false, false, true, false)
< }
< 
< // Expect a block item node.
< func yaml_emitter_emit_block_sequence_item(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		if !yaml_emitter_increase_indent(emitter, false, emitter.mapping_context && !emitter.indention) {
< 			return false
< 		}
< 	}
< 	if event.typ == yaml_SEQUENCE_END_EVENT {
< 		emitter.indent = emitter.indents[len(emitter.indents)-1]
< 		emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 		emitter.state = emitter.states[len(emitter.states)-1]
< 		emitter.states = emitter.states[:len(emitter.states)-1]
< 		return true
< 	}
< 	if !yaml_emitter_write_indent(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'-'}, true, false, true) {
< 		return false
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE)
< 	return yaml_emitter_emit_node(emitter, event, false, true, false, false)
< }
< 
< // Expect a block key node.
< func yaml_emitter_emit_block_mapping_key(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		if !yaml_emitter_increase_indent(emitter, false, false) {
< 			return false
< 		}
< 	}
< 	if event.typ == yaml_MAPPING_END_EVENT {
< 		emitter.indent = emitter.indents[len(emitter.indents)-1]
< 		emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 		emitter.state = emitter.states[len(emitter.states)-1]
< 		emitter.states = emitter.states[:len(emitter.states)-1]
< 		return true
< 	}
< 	if !yaml_emitter_write_indent(emitter) {
< 		return false
< 	}
< 	if yaml_emitter_check_simple_key(emitter) {
< 		emitter.states = append(emitter.states, yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE)
< 		return yaml_emitter_emit_node(emitter, event, false, false, true, true)
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'?'}, true, false, true) {
< 		return false
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_BLOCK_MAPPING_VALUE_STATE)
< 	return yaml_emitter_emit_node(emitter, event, false, false, true, false)
< }
< 
< // Expect a block value node.
< func yaml_emitter_emit_block_mapping_value(emitter *yaml_emitter_t, event *yaml_event_t, simple bool) bool {
< 	if simple {
< 		if !yaml_emitter_write_indicator(emitter, []byte{':'}, false, false, false) {
< 			return false
< 		}
< 	} else {
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{':'}, true, false, true) {
< 			return false
< 		}
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_BLOCK_MAPPING_KEY_STATE)
< 	return yaml_emitter_emit_node(emitter, event, false, false, true, false)
< }
< 
< // Expect a node.
< func yaml_emitter_emit_node(emitter *yaml_emitter_t, event *yaml_event_t,
< 	root bool, sequence bool, mapping bool, simple_key bool) bool {
< 
< 	emitter.root_context = root
< 	emitter.sequence_context = sequence
< 	emitter.mapping_context = mapping
< 	emitter.simple_key_context = simple_key
< 
< 	switch event.typ {
< 	case yaml_ALIAS_EVENT:
< 		return yaml_emitter_emit_alias(emitter, event)
< 	case yaml_SCALAR_EVENT:
< 		return yaml_emitter_emit_scalar(emitter, event)
< 	case yaml_SEQUENCE_START_EVENT:
< 		return yaml_emitter_emit_sequence_start(emitter, event)
< 	case yaml_MAPPING_START_EVENT:
< 		return yaml_emitter_emit_mapping_start(emitter, event)
< 	default:
< 		return yaml_emitter_set_emitter_error(emitter,
< 			fmt.Sprintf("expected SCALAR, SEQUENCE-START, MAPPING-START, or ALIAS, but got %v", event.typ))
< 	}
< }
< 
< // Expect ALIAS.
< func yaml_emitter_emit_alias(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if !yaml_emitter_process_anchor(emitter) {
< 		return false
< 	}
< 	emitter.state = emitter.states[len(emitter.states)-1]
< 	emitter.states = emitter.states[:len(emitter.states)-1]
< 	return true
< }
< 
< // Expect SCALAR.
< func yaml_emitter_emit_scalar(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if !yaml_emitter_select_scalar_style(emitter, event) {
< 		return false
< 	}
< 	if !yaml_emitter_process_anchor(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_tag(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_increase_indent(emitter, true, false) {
< 		return false
< 	}
< 	if !yaml_emitter_process_scalar(emitter) {
< 		return false
< 	}
< 	emitter.indent = emitter.indents[len(emitter.indents)-1]
< 	emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 	emitter.state = emitter.states[len(emitter.states)-1]
< 	emitter.states = emitter.states[:len(emitter.states)-1]
< 	return true
< }
< 
< // Expect SEQUENCE-START.
< func yaml_emitter_emit_sequence_start(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if !yaml_emitter_process_anchor(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_tag(emitter) {
< 		return false
< 	}
< 	if emitter.flow_level > 0 || emitter.canonical || event.sequence_style() == yaml_FLOW_SEQUENCE_STYLE ||
< 		yaml_emitter_check_empty_sequence(emitter) {
< 		emitter.state = yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE
< 	} else {
< 		emitter.state = yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE
< 	}
< 	return true
< }
< 
< // Expect MAPPING-START.
< func yaml_emitter_emit_mapping_start(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if !yaml_emitter_process_anchor(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_tag(emitter) {
< 		return false
< 	}
< 	if emitter.flow_level > 0 || emitter.canonical || event.mapping_style() == yaml_FLOW_MAPPING_STYLE ||
< 		yaml_emitter_check_empty_mapping(emitter) {
< 		emitter.state = yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE
< 	} else {
< 		emitter.state = yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE
< 	}
< 	return true
< }
< 
< // Check if the document content is an empty scalar.
< func yaml_emitter_check_empty_document(emitter *yaml_emitter_t) bool {
< 	return false // [Go] Huh?
< }
< 
< // Check if the next events represent an empty sequence.
< func yaml_emitter_check_empty_sequence(emitter *yaml_emitter_t) bool {
< 	if len(emitter.events)-emitter.events_head < 2 {
< 		return false
< 	}
< 	return emitter.events[emitter.events_head].typ == yaml_SEQUENCE_START_EVENT &&
< 		emitter.events[emitter.events_head+1].typ == yaml_SEQUENCE_END_EVENT
< }
< 
< // Check if the next events represent an empty mapping.
< func yaml_emitter_check_empty_mapping(emitter *yaml_emitter_t) bool {
< 	if len(emitter.events)-emitter.events_head < 2 {
< 		return false
< 	}
< 	return emitter.events[emitter.events_head].typ == yaml_MAPPING_START_EVENT &&
< 		emitter.events[emitter.events_head+1].typ == yaml_MAPPING_END_EVENT
< }
< 
< // Check if the next node can be expressed as a simple key.
< func yaml_emitter_check_simple_key(emitter *yaml_emitter_t) bool {
< 	length := 0
< 	switch emitter.events[emitter.events_head].typ {
< 	case yaml_ALIAS_EVENT:
< 		length += len(emitter.anchor_data.anchor)
< 	case yaml_SCALAR_EVENT:
< 		if emitter.scalar_data.multiline {
< 			return false
< 		}
< 		length += len(emitter.anchor_data.anchor) +
< 			len(emitter.tag_data.handle) +
< 			len(emitter.tag_data.suffix) +
< 			len(emitter.scalar_data.value)
< 	case yaml_SEQUENCE_START_EVENT:
< 		if !yaml_emitter_check_empty_sequence(emitter) {
< 			return false
< 		}
< 		length += len(emitter.anchor_data.anchor) +
< 			len(emitter.tag_data.handle) +
< 			len(emitter.tag_data.suffix)
< 	case yaml_MAPPING_START_EVENT:
< 		if !yaml_emitter_check_empty_mapping(emitter) {
< 			return false
< 		}
< 		length += len(emitter.anchor_data.anchor) +
< 			len(emitter.tag_data.handle) +
< 			len(emitter.tag_data.suffix)
< 	default:
< 		return false
< 	}
< 	return length <= 128
< }
< 
< // Determine an acceptable scalar style.
< func yaml_emitter_select_scalar_style(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 
< 	no_tag := len(emitter.tag_data.handle) == 0 && len(emitter.tag_data.suffix) == 0
< 	if no_tag && !event.implicit && !event.quoted_implicit {
< 		return yaml_emitter_set_emitter_error(emitter, "neither tag nor implicit flags are specified")
< 	}
< 
< 	style := event.scalar_style()
< 	if style == yaml_ANY_SCALAR_STYLE {
< 		style = yaml_PLAIN_SCALAR_STYLE
< 	}
< 	if emitter.canonical {
< 		style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 	}
< 	if emitter.simple_key_context && emitter.scalar_data.multiline {
< 		style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 	}
< 
< 	if style == yaml_PLAIN_SCALAR_STYLE {
< 		if emitter.flow_level > 0 && !emitter.scalar_data.flow_plain_allowed ||
< 			emitter.flow_level == 0 && !emitter.scalar_data.block_plain_allowed {
< 			style = yaml_SINGLE_QUOTED_SCALAR_STYLE
< 		}
< 		if len(emitter.scalar_data.value) == 0 && (emitter.flow_level > 0 || emitter.simple_key_context) {
< 			style = yaml_SINGLE_QUOTED_SCALAR_STYLE
< 		}
< 		if no_tag && !event.implicit {
< 			style = yaml_SINGLE_QUOTED_SCALAR_STYLE
< 		}
< 	}
< 	if style == yaml_SINGLE_QUOTED_SCALAR_STYLE {
< 		if !emitter.scalar_data.single_quoted_allowed {
< 			style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 		}
< 	}
< 	if style == yaml_LITERAL_SCALAR_STYLE || style == yaml_FOLDED_SCALAR_STYLE {
< 		if !emitter.scalar_data.block_allowed || emitter.flow_level > 0 || emitter.simple_key_context {
< 			style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 		}
< 	}
< 
< 	if no_tag && !event.quoted_implicit && style != yaml_PLAIN_SCALAR_STYLE {
< 		emitter.tag_data.handle = []byte{'!'}
< 	}
< 	emitter.scalar_data.style = style
< 	return true
< }
< 
< // Write an anchor.
< func yaml_emitter_process_anchor(emitter *yaml_emitter_t) bool {
< 	if emitter.anchor_data.anchor == nil {
< 		return true
< 	}
< 	c := []byte{'&'}
< 	if emitter.anchor_data.alias {
< 		c[0] = '*'
< 	}
< 	if !yaml_emitter_write_indicator(emitter, c, true, false, false) {
< 		return false
< 	}
< 	return yaml_emitter_write_anchor(emitter, emitter.anchor_data.anchor)
< }
< 
< // Write a tag.
< func yaml_emitter_process_tag(emitter *yaml_emitter_t) bool {
< 	if len(emitter.tag_data.handle) == 0 && len(emitter.tag_data.suffix) == 0 {
< 		return true
< 	}
< 	if len(emitter.tag_data.handle) > 0 {
< 		if !yaml_emitter_write_tag_handle(emitter, emitter.tag_data.handle) {
< 			return false
< 		}
< 		if len(emitter.tag_data.suffix) > 0 {
< 			if !yaml_emitter_write_tag_content(emitter, emitter.tag_data.suffix, false) {
< 				return false
< 			}
< 		}
< 	} else {
< 		// [Go] Allocate these slices elsewhere.
< 		if !yaml_emitter_write_indicator(emitter, []byte("!<"), true, false, false) {
< 			return false
< 		}
< 		if !yaml_emitter_write_tag_content(emitter, emitter.tag_data.suffix, false) {
< 			return false
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{'>'}, false, false, false) {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< // Write a scalar.
< func yaml_emitter_process_scalar(emitter *yaml_emitter_t) bool {
< 	switch emitter.scalar_data.style {
< 	case yaml_PLAIN_SCALAR_STYLE:
< 		return yaml_emitter_write_plain_scalar(emitter, emitter.scalar_data.value, !emitter.simple_key_context)
< 
< 	case yaml_SINGLE_QUOTED_SCALAR_STYLE:
< 		return yaml_emitter_write_single_quoted_scalar(emitter, emitter.scalar_data.value, !emitter.simple_key_context)
< 
< 	case yaml_DOUBLE_QUOTED_SCALAR_STYLE:
< 		return yaml_emitter_write_double_quoted_scalar(emitter, emitter.scalar_data.value, !emitter.simple_key_context)
< 
< 	case yaml_LITERAL_SCALAR_STYLE:
< 		return yaml_emitter_write_literal_scalar(emitter, emitter.scalar_data.value)
< 
< 	case yaml_FOLDED_SCALAR_STYLE:
< 		return yaml_emitter_write_folded_scalar(emitter, emitter.scalar_data.value)
< 	}
< 	panic("unknown scalar style")
< }
< 
< // Check if a %YAML directive is valid.
< func yaml_emitter_analyze_version_directive(emitter *yaml_emitter_t, version_directive *yaml_version_directive_t) bool {
< 	if version_directive.major != 1 || version_directive.minor != 1 {
< 		return yaml_emitter_set_emitter_error(emitter, "incompatible %YAML directive")
< 	}
< 	return true
< }
< 
< // Check if a %TAG directive is valid.
< func yaml_emitter_analyze_tag_directive(emitter *yaml_emitter_t, tag_directive *yaml_tag_directive_t) bool {
< 	handle := tag_directive.handle
< 	prefix := tag_directive.prefix
< 	if len(handle) == 0 {
< 		return yaml_emitter_set_emitter_error(emitter, "tag handle must not be empty")
< 	}
< 	if handle[0] != '!' {
< 		return yaml_emitter_set_emitter_error(emitter, "tag handle must start with '!'")
< 	}
< 	if handle[len(handle)-1] != '!' {
< 		return yaml_emitter_set_emitter_error(emitter, "tag handle must end with '!'")
< 	}
< 	for i := 1; i < len(handle)-1; i += width(handle[i]) {
< 		if !is_alpha(handle, i) {
< 			return yaml_emitter_set_emitter_error(emitter, "tag handle must contain alphanumerical characters only")
< 		}
< 	}
< 	if len(prefix) == 0 {
< 		return yaml_emitter_set_emitter_error(emitter, "tag prefix must not be empty")
< 	}
< 	return true
< }
< 
< // Check if an anchor is valid.
< func yaml_emitter_analyze_anchor(emitter *yaml_emitter_t, anchor []byte, alias bool) bool {
< 	if len(anchor) == 0 {
< 		problem := "anchor value must not be empty"
< 		if alias {
< 			problem = "alias value must not be empty"
< 		}
< 		return yaml_emitter_set_emitter_error(emitter, problem)
< 	}
< 	for i := 0; i < len(anchor); i += width(anchor[i]) {
< 		if !is_alpha(anchor, i) {
< 			problem := "anchor value must contain alphanumerical characters only"
< 			if alias {
< 				problem = "alias value must contain alphanumerical characters only"
< 			}
< 			return yaml_emitter_set_emitter_error(emitter, problem)
< 		}
< 	}
< 	emitter.anchor_data.anchor = anchor
< 	emitter.anchor_data.alias = alias
< 	return true
< }
< 
< // Check if a tag is valid.
< func yaml_emitter_analyze_tag(emitter *yaml_emitter_t, tag []byte) bool {
< 	if len(tag) == 0 {
< 		return yaml_emitter_set_emitter_error(emitter, "tag value must not be empty")
< 	}
< 	for i := 0; i < len(emitter.tag_directives); i++ {
< 		tag_directive := &emitter.tag_directives[i]
< 		if bytes.HasPrefix(tag, tag_directive.prefix) {
< 			emitter.tag_data.handle = tag_directive.handle
< 			emitter.tag_data.suffix = tag[len(tag_directive.prefix):]
< 			return true
< 		}
< 	}
< 	emitter.tag_data.suffix = tag
< 	return true
< }
< 
< // Check if a scalar is valid.
< func yaml_emitter_analyze_scalar(emitter *yaml_emitter_t, value []byte) bool {
< 	var (
< 		block_indicators   = false
< 		flow_indicators    = false
< 		line_breaks        = false
< 		special_characters = false
< 
< 		leading_space  = false
< 		leading_break  = false
< 		trailing_space = false
< 		trailing_break = false
< 		break_space    = false
< 		space_break    = false
< 
< 		preceded_by_whitespace = false
< 		followed_by_whitespace = false
< 		previous_space         = false
< 		previous_break         = false
< 	)
< 
< 	emitter.scalar_data.value = value
< 
< 	if len(value) == 0 {
< 		emitter.scalar_data.multiline = false
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = true
< 		emitter.scalar_data.single_quoted_allowed = true
< 		emitter.scalar_data.block_allowed = false
< 		return true
< 	}
< 
< 	if len(value) >= 3 && ((value[0] == '-' && value[1] == '-' && value[2] == '-') || (value[0] == '.' && value[1] == '.' && value[2] == '.')) {
< 		block_indicators = true
< 		flow_indicators = true
< 	}
< 
< 	preceded_by_whitespace = true
< 	for i, w := 0, 0; i < len(value); i += w {
< 		w = width(value[i])
< 		followed_by_whitespace = i+w >= len(value) || is_blank(value, i+w)
< 
< 		if i == 0 {
< 			switch value[i] {
< 			case '#', ',', '[', ']', '{', '}', '&', '*', '!', '|', '>', '\'', '"', '%', '@', '`':
< 				flow_indicators = true
< 				block_indicators = true
< 			case '?', ':':
< 				flow_indicators = true
< 				if followed_by_whitespace {
< 					block_indicators = true
< 				}
< 			case '-':
< 				if followed_by_whitespace {
< 					flow_indicators = true
< 					block_indicators = true
< 				}
< 			}
< 		} else {
< 			switch value[i] {
< 			case ',', '?', '[', ']', '{', '}':
< 				flow_indicators = true
< 			case ':':
< 				flow_indicators = true
< 				if followed_by_whitespace {
< 					block_indicators = true
< 				}
< 			case '#':
< 				if preceded_by_whitespace {
< 					flow_indicators = true
< 					block_indicators = true
< 				}
< 			}
< 		}
< 
< 		if !is_printable(value, i) || !is_ascii(value, i) && !emitter.unicode {
< 			special_characters = true
< 		}
< 		if is_space(value, i) {
< 			if i == 0 {
< 				leading_space = true
< 			}
< 			if i+width(value[i]) == len(value) {
< 				trailing_space = true
< 			}
< 			if previous_break {
< 				break_space = true
< 			}
< 			previous_space = true
< 			previous_break = false
< 		} else if is_break(value, i) {
< 			line_breaks = true
< 			if i == 0 {
< 				leading_break = true
< 			}
< 			if i+width(value[i]) == len(value) {
< 				trailing_break = true
< 			}
< 			if previous_space {
< 				space_break = true
< 			}
< 			previous_space = false
< 			previous_break = true
< 		} else {
< 			previous_space = false
< 			previous_break = false
< 		}
< 
< 		// [Go]: Why 'z'? Couldn't be the end of the string as that's the loop condition.
< 		preceded_by_whitespace = is_blankz(value, i)
< 	}
< 
< 	emitter.scalar_data.multiline = line_breaks
< 	emitter.scalar_data.flow_plain_allowed = true
< 	emitter.scalar_data.block_plain_allowed = true
< 	emitter.scalar_data.single_quoted_allowed = true
< 	emitter.scalar_data.block_allowed = true
< 
< 	if leading_space || leading_break || trailing_space || trailing_break {
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = false
< 	}
< 	if trailing_space {
< 		emitter.scalar_data.block_allowed = false
< 	}
< 	if break_space {
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = false
< 		emitter.scalar_data.single_quoted_allowed = false
< 	}
< 	if space_break || special_characters {
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = false
< 		emitter.scalar_data.single_quoted_allowed = false
< 		emitter.scalar_data.block_allowed = false
< 	}
< 	if line_breaks {
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = false
< 	}
< 	if flow_indicators {
< 		emitter.scalar_data.flow_plain_allowed = false
< 	}
< 	if block_indicators {
< 		emitter.scalar_data.block_plain_allowed = false
< 	}
< 	return true
< }
< 
< // Check if the event data is valid.
< func yaml_emitter_analyze_event(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 
< 	emitter.anchor_data.anchor = nil
< 	emitter.tag_data.handle = nil
< 	emitter.tag_data.suffix = nil
< 	emitter.scalar_data.value = nil
< 
< 	switch event.typ {
< 	case yaml_ALIAS_EVENT:
< 		if !yaml_emitter_analyze_anchor(emitter, event.anchor, true) {
< 			return false
< 		}
< 
< 	case yaml_SCALAR_EVENT:
< 		if len(event.anchor) > 0 {
< 			if !yaml_emitter_analyze_anchor(emitter, event.anchor, false) {
< 				return false
< 			}
< 		}
< 		if len(event.tag) > 0 && (emitter.canonical || (!event.implicit && !event.quoted_implicit)) {
< 			if !yaml_emitter_analyze_tag(emitter, event.tag) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_analyze_scalar(emitter, event.value) {
< 			return false
< 		}
< 
< 	case yaml_SEQUENCE_START_EVENT:
< 		if len(event.anchor) > 0 {
< 			if !yaml_emitter_analyze_anchor(emitter, event.anchor, false) {
< 				return false
< 			}
< 		}
< 		if len(event.tag) > 0 && (emitter.canonical || !event.implicit) {
< 			if !yaml_emitter_analyze_tag(emitter, event.tag) {
< 				return false
< 			}
< 		}
< 
< 	case yaml_MAPPING_START_EVENT:
< 		if len(event.anchor) > 0 {
< 			if !yaml_emitter_analyze_anchor(emitter, event.anchor, false) {
< 				return false
< 			}
< 		}
< 		if len(event.tag) > 0 && (emitter.canonical || !event.implicit) {
< 			if !yaml_emitter_analyze_tag(emitter, event.tag) {
< 				return false
< 			}
< 		}
< 	}
< 	return true
< }
< 
< // Write the BOM character.
< func yaml_emitter_write_bom(emitter *yaml_emitter_t) bool {
< 	if !flush(emitter) {
< 		return false
< 	}
< 	pos := emitter.buffer_pos
< 	emitter.buffer[pos+0] = '\xEF'
< 	emitter.buffer[pos+1] = '\xBB'
< 	emitter.buffer[pos+2] = '\xBF'
< 	emitter.buffer_pos += 3
< 	return true
< }
< 
< func yaml_emitter_write_indent(emitter *yaml_emitter_t) bool {
< 	indent := emitter.indent
< 	if indent < 0 {
< 		indent = 0
< 	}
< 	if !emitter.indention || emitter.column > indent || (emitter.column == indent && !emitter.whitespace) {
< 		if !put_break(emitter) {
< 			return false
< 		}
< 	}
< 	for emitter.column < indent {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 	emitter.whitespace = true
< 	emitter.indention = true
< 	return true
< }
< 
< func yaml_emitter_write_indicator(emitter *yaml_emitter_t, indicator []byte, need_whitespace, is_whitespace, is_indention bool) bool {
< 	if need_whitespace && !emitter.whitespace {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 	if !write_all(emitter, indicator) {
< 		return false
< 	}
< 	emitter.whitespace = is_whitespace
< 	emitter.indention = (emitter.indention && is_indention)
< 	emitter.open_ended = false
< 	return true
< }
< 
< func yaml_emitter_write_anchor(emitter *yaml_emitter_t, value []byte) bool {
< 	if !write_all(emitter, value) {
< 		return false
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_tag_handle(emitter *yaml_emitter_t, value []byte) bool {
< 	if !emitter.whitespace {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 	if !write_all(emitter, value) {
< 		return false
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_tag_content(emitter *yaml_emitter_t, value []byte, need_whitespace bool) bool {
< 	if need_whitespace && !emitter.whitespace {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 	for i := 0; i < len(value); {
< 		var must_write bool
< 		switch value[i] {
< 		case ';', '/', '?', ':', '@', '&', '=', '+', '$', ',', '_', '.', '~', '*', '\'', '(', ')', '[', ']':
< 			must_write = true
< 		default:
< 			must_write = is_alpha(value, i)
< 		}
< 		if must_write {
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 		} else {
< 			w := width(value[i])
< 			for k := 0; k < w; k++ {
< 				octet := value[i]
< 				i++
< 				if !put(emitter, '%') {
< 					return false
< 				}
< 
< 				c := octet >> 4
< 				if c < 10 {
< 					c += '0'
< 				} else {
< 					c += 'A' - 10
< 				}
< 				if !put(emitter, c) {
< 					return false
< 				}
< 
< 				c = octet & 0x0f
< 				if c < 10 {
< 					c += '0'
< 				} else {
< 					c += 'A' - 10
< 				}
< 				if !put(emitter, c) {
< 					return false
< 				}
< 			}
< 		}
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_plain_scalar(emitter *yaml_emitter_t, value []byte, allow_breaks bool) bool {
< 	if !emitter.whitespace {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 
< 	spaces := false
< 	breaks := false
< 	for i := 0; i < len(value); {
< 		if is_space(value, i) {
< 			if allow_breaks && !spaces && emitter.column > emitter.best_width && !is_space(value, i+1) {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				i += width(value[i])
< 			} else {
< 				if !write(emitter, value, &i) {
< 					return false
< 				}
< 			}
< 			spaces = true
< 		} else if is_break(value, i) {
< 			if !breaks && value[i] == '\n' {
< 				if !put_break(emitter) {
< 					return false
< 				}
< 			}
< 			if !write_break(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = true
< 			breaks = true
< 		} else {
< 			if breaks {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = false
< 			spaces = false
< 			breaks = false
< 		}
< 	}
< 
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	if emitter.root_context {
< 		emitter.open_ended = true
< 	}
< 
< 	return true
< }
< 
< func yaml_emitter_write_single_quoted_scalar(emitter *yaml_emitter_t, value []byte, allow_breaks bool) bool {
< 
< 	if !yaml_emitter_write_indicator(emitter, []byte{'\''}, true, false, false) {
< 		return false
< 	}
< 
< 	spaces := false
< 	breaks := false
< 	for i := 0; i < len(value); {
< 		if is_space(value, i) {
< 			if allow_breaks && !spaces && emitter.column > emitter.best_width && i > 0 && i < len(value)-1 && !is_space(value, i+1) {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				i += width(value[i])
< 			} else {
< 				if !write(emitter, value, &i) {
< 					return false
< 				}
< 			}
< 			spaces = true
< 		} else if is_break(value, i) {
< 			if !breaks && value[i] == '\n' {
< 				if !put_break(emitter) {
< 					return false
< 				}
< 			}
< 			if !write_break(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = true
< 			breaks = true
< 		} else {
< 			if breaks {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 			if value[i] == '\'' {
< 				if !put(emitter, '\'') {
< 					return false
< 				}
< 			}
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = false
< 			spaces = false
< 			breaks = false
< 		}
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'\''}, false, false, false) {
< 		return false
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_double_quoted_scalar(emitter *yaml_emitter_t, value []byte, allow_breaks bool) bool {
< 	spaces := false
< 	if !yaml_emitter_write_indicator(emitter, []byte{'"'}, true, false, false) {
< 		return false
< 	}
< 
< 	for i := 0; i < len(value); {
< 		if !is_printable(value, i) || (!emitter.unicode && !is_ascii(value, i)) ||
< 			is_bom(value, i) || is_break(value, i) ||
< 			value[i] == '"' || value[i] == '\\' {
< 
< 			octet := value[i]
< 
< 			var w int
< 			var v rune
< 			switch {
< 			case octet&0x80 == 0x00:
< 				w, v = 1, rune(octet&0x7F)
< 			case octet&0xE0 == 0xC0:
< 				w, v = 2, rune(octet&0x1F)
< 			case octet&0xF0 == 0xE0:
< 				w, v = 3, rune(octet&0x0F)
< 			case octet&0xF8 == 0xF0:
< 				w, v = 4, rune(octet&0x07)
< 			}
< 			for k := 1; k < w; k++ {
< 				octet = value[i+k]
< 				v = (v << 6) + (rune(octet) & 0x3F)
< 			}
< 			i += w
< 
< 			if !put(emitter, '\\') {
< 				return false
< 			}
< 
< 			var ok bool
< 			switch v {
< 			case 0x00:
< 				ok = put(emitter, '0')
< 			case 0x07:
< 				ok = put(emitter, 'a')
< 			case 0x08:
< 				ok = put(emitter, 'b')
< 			case 0x09:
< 				ok = put(emitter, 't')
< 			case 0x0A:
< 				ok = put(emitter, 'n')
< 			case 0x0b:
< 				ok = put(emitter, 'v')
< 			case 0x0c:
< 				ok = put(emitter, 'f')
< 			case 0x0d:
< 				ok = put(emitter, 'r')
< 			case 0x1b:
< 				ok = put(emitter, 'e')
< 			case 0x22:
< 				ok = put(emitter, '"')
< 			case 0x5c:
< 				ok = put(emitter, '\\')
< 			case 0x85:
< 				ok = put(emitter, 'N')
< 			case 0xA0:
< 				ok = put(emitter, '_')
< 			case 0x2028:
< 				ok = put(emitter, 'L')
< 			case 0x2029:
< 				ok = put(emitter, 'P')
< 			default:
< 				if v <= 0xFF {
< 					ok = put(emitter, 'x')
< 					w = 2
< 				} else if v <= 0xFFFF {
< 					ok = put(emitter, 'u')
< 					w = 4
< 				} else {
< 					ok = put(emitter, 'U')
< 					w = 8
< 				}
< 				for k := (w - 1) * 4; ok && k >= 0; k -= 4 {
< 					digit := byte((v >> uint(k)) & 0x0F)
< 					if digit < 10 {
< 						ok = put(emitter, digit+'0')
< 					} else {
< 						ok = put(emitter, digit+'A'-10)
< 					}
< 				}
< 			}
< 			if !ok {
< 				return false
< 			}
< 			spaces = false
< 		} else if is_space(value, i) {
< 			if allow_breaks && !spaces && emitter.column > emitter.best_width && i > 0 && i < len(value)-1 {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				if is_space(value, i+1) {
< 					if !put(emitter, '\\') {
< 						return false
< 					}
< 				}
< 				i += width(value[i])
< 			} else if !write(emitter, value, &i) {
< 				return false
< 			}
< 			spaces = true
< 		} else {
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 			spaces = false
< 		}
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'"'}, false, false, false) {
< 		return false
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_block_scalar_hints(emitter *yaml_emitter_t, value []byte) bool {
< 	if is_space(value, 0) || is_break(value, 0) {
< 		indent_hint := []byte{'0' + byte(emitter.best_indent)}
< 		if !yaml_emitter_write_indicator(emitter, indent_hint, false, false, false) {
< 			return false
< 		}
< 	}
< 
< 	emitter.open_ended = false
< 
< 	var chomp_hint [1]byte
< 	if len(value) == 0 {
< 		chomp_hint[0] = '-'
< 	} else {
< 		i := len(value) - 1
< 		for value[i]&0xC0 == 0x80 {
< 			i--
< 		}
< 		if !is_break(value, i) {
< 			chomp_hint[0] = '-'
< 		} else if i == 0 {
< 			chomp_hint[0] = '+'
< 			emitter.open_ended = true
< 		} else {
< 			i--
< 			for value[i]&0xC0 == 0x80 {
< 				i--
< 			}
< 			if is_break(value, i) {
< 				chomp_hint[0] = '+'
< 				emitter.open_ended = true
< 			}
< 		}
< 	}
< 	if chomp_hint[0] != 0 {
< 		if !yaml_emitter_write_indicator(emitter, chomp_hint[:], false, false, false) {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< func yaml_emitter_write_literal_scalar(emitter *yaml_emitter_t, value []byte) bool {
< 	if !yaml_emitter_write_indicator(emitter, []byte{'|'}, true, false, false) {
< 		return false
< 	}
< 	if !yaml_emitter_write_block_scalar_hints(emitter, value) {
< 		return false
< 	}
< 	if !put_break(emitter) {
< 		return false
< 	}
< 	emitter.indention = true
< 	emitter.whitespace = true
< 	breaks := true
< 	for i := 0; i < len(value); {
< 		if is_break(value, i) {
< 			if !write_break(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = true
< 			breaks = true
< 		} else {
< 			if breaks {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = false
< 			breaks = false
< 		}
< 	}
< 
< 	return true
< }
< 
< func yaml_emitter_write_folded_scalar(emitter *yaml_emitter_t, value []byte) bool {
< 	if !yaml_emitter_write_indicator(emitter, []byte{'>'}, true, false, false) {
< 		return false
< 	}
< 	if !yaml_emitter_write_block_scalar_hints(emitter, value) {
< 		return false
< 	}
< 
< 	if !put_break(emitter) {
< 		return false
< 	}
< 	emitter.indention = true
< 	emitter.whitespace = true
< 
< 	breaks := true
< 	leading_spaces := true
< 	for i := 0; i < len(value); {
< 		if is_break(value, i) {
< 			if !breaks && !leading_spaces && value[i] == '\n' {
< 				k := 0
< 				for is_break(value, k) {
< 					k += width(value[k])
< 				}
< 				if !is_blankz(value, k) {
< 					if !put_break(emitter) {
< 						return false
< 					}
< 				}
< 			}
< 			if !write_break(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = true
< 			breaks = true
< 		} else {
< 			if breaks {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				leading_spaces = is_blank(value, i)
< 			}
< 			if !breaks && is_space(value, i) && !is_space(value, i+1) && emitter.column > emitter.best_width {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				i += width(value[i])
< 			} else {
< 				if !write(emitter, value, &i) {
< 					return false
< 				}
< 			}
< 			emitter.indention = false
< 			breaks = false
< 		}
< 	}
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/encode.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/encode.go
1,390d0
< package yaml
< 
< import (
< 	"encoding"
< 	"fmt"
< 	"io"
< 	"reflect"
< 	"regexp"
< 	"sort"
< 	"strconv"
< 	"strings"
< 	"time"
< 	"unicode/utf8"
< )
< 
< // jsonNumber is the interface of the encoding/json.Number datatype.
< // Repeating the interface here avoids a dependency on encoding/json, and also
< // supports other libraries like jsoniter, which use a similar datatype with
< // the same interface. Detecting this interface is useful when dealing with
< // structures containing json.Number, which is a string under the hood. The
< // encoder should prefer the use of Int64(), Float64() and string(), in that
< // order, when encoding this type.
< type jsonNumber interface {
< 	Float64() (float64, error)
< 	Int64() (int64, error)
< 	String() string
< }
< 
< type encoder struct {
< 	emitter yaml_emitter_t
< 	event   yaml_event_t
< 	out     []byte
< 	flow    bool
< 	// doneInit holds whether the initial stream_start_event has been
< 	// emitted.
< 	doneInit bool
< }
< 
< func newEncoder() *encoder {
< 	e := &encoder{}
< 	yaml_emitter_initialize(&e.emitter)
< 	yaml_emitter_set_output_string(&e.emitter, &e.out)
< 	yaml_emitter_set_unicode(&e.emitter, true)
< 	return e
< }
< 
< func newEncoderWithWriter(w io.Writer) *encoder {
< 	e := &encoder{}
< 	yaml_emitter_initialize(&e.emitter)
< 	yaml_emitter_set_output_writer(&e.emitter, w)
< 	yaml_emitter_set_unicode(&e.emitter, true)
< 	return e
< }
< 
< func (e *encoder) init() {
< 	if e.doneInit {
< 		return
< 	}
< 	yaml_stream_start_event_initialize(&e.event, yaml_UTF8_ENCODING)
< 	e.emit()
< 	e.doneInit = true
< }
< 
< func (e *encoder) finish() {
< 	e.emitter.open_ended = false
< 	yaml_stream_end_event_initialize(&e.event)
< 	e.emit()
< }
< 
< func (e *encoder) destroy() {
< 	yaml_emitter_delete(&e.emitter)
< }
< 
< func (e *encoder) emit() {
< 	// This will internally delete the e.event value.
< 	e.must(yaml_emitter_emit(&e.emitter, &e.event))
< }
< 
< func (e *encoder) must(ok bool) {
< 	if !ok {
< 		msg := e.emitter.problem
< 		if msg == "" {
< 			msg = "unknown problem generating YAML content"
< 		}
< 		failf("%s", msg)
< 	}
< }
< 
< func (e *encoder) marshalDoc(tag string, in reflect.Value) {
< 	e.init()
< 	yaml_document_start_event_initialize(&e.event, nil, nil, true)
< 	e.emit()
< 	e.marshal(tag, in)
< 	yaml_document_end_event_initialize(&e.event, true)
< 	e.emit()
< }
< 
< func (e *encoder) marshal(tag string, in reflect.Value) {
< 	if !in.IsValid() || in.Kind() == reflect.Ptr && in.IsNil() {
< 		e.nilv()
< 		return
< 	}
< 	iface := in.Interface()
< 	switch m := iface.(type) {
< 	case jsonNumber:
< 		integer, err := m.Int64()
< 		if err == nil {
< 			// In this case the json.Number is a valid int64
< 			in = reflect.ValueOf(integer)
< 			break
< 		}
< 		float, err := m.Float64()
< 		if err == nil {
< 			// In this case the json.Number is a valid float64
< 			in = reflect.ValueOf(float)
< 			break
< 		}
< 		// fallback case - no number could be obtained
< 		in = reflect.ValueOf(m.String())
< 	case time.Time, *time.Time:
< 		// Although time.Time implements TextMarshaler,
< 		// we don't want to treat it as a string for YAML
< 		// purposes because YAML has special support for
< 		// timestamps.
< 	case Marshaler:
< 		v, err := m.MarshalYAML()
< 		if err != nil {
< 			fail(err)
< 		}
< 		if v == nil {
< 			e.nilv()
< 			return
< 		}
< 		in = reflect.ValueOf(v)
< 	case encoding.TextMarshaler:
< 		text, err := m.MarshalText()
< 		if err != nil {
< 			fail(err)
< 		}
< 		in = reflect.ValueOf(string(text))
< 	case nil:
< 		e.nilv()
< 		return
< 	}
< 	switch in.Kind() {
< 	case reflect.Interface:
< 		e.marshal(tag, in.Elem())
< 	case reflect.Map:
< 		e.mapv(tag, in)
< 	case reflect.Ptr:
< 		if in.Type() == ptrTimeType {
< 			e.timev(tag, in.Elem())
< 		} else {
< 			e.marshal(tag, in.Elem())
< 		}
< 	case reflect.Struct:
< 		if in.Type() == timeType {
< 			e.timev(tag, in)
< 		} else {
< 			e.structv(tag, in)
< 		}
< 	case reflect.Slice, reflect.Array:
< 		if in.Type().Elem() == mapItemType {
< 			e.itemsv(tag, in)
< 		} else {
< 			e.slicev(tag, in)
< 		}
< 	case reflect.String:
< 		e.stringv(tag, in)
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		if in.Type() == durationType {
< 			e.stringv(tag, reflect.ValueOf(iface.(time.Duration).String()))
< 		} else {
< 			e.intv(tag, in)
< 		}
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		e.uintv(tag, in)
< 	case reflect.Float32, reflect.Float64:
< 		e.floatv(tag, in)
< 	case reflect.Bool:
< 		e.boolv(tag, in)
< 	default:
< 		panic("cannot marshal type: " + in.Type().String())
< 	}
< }
< 
< func (e *encoder) mapv(tag string, in reflect.Value) {
< 	e.mappingv(tag, func() {
< 		keys := keyList(in.MapKeys())
< 		sort.Sort(keys)
< 		for _, k := range keys {
< 			e.marshal("", k)
< 			e.marshal("", in.MapIndex(k))
< 		}
< 	})
< }
< 
< func (e *encoder) itemsv(tag string, in reflect.Value) {
< 	e.mappingv(tag, func() {
< 		slice := in.Convert(reflect.TypeOf([]MapItem{})).Interface().([]MapItem)
< 		for _, item := range slice {
< 			e.marshal("", reflect.ValueOf(item.Key))
< 			e.marshal("", reflect.ValueOf(item.Value))
< 		}
< 	})
< }
< 
< func (e *encoder) structv(tag string, in reflect.Value) {
< 	sinfo, err := getStructInfo(in.Type())
< 	if err != nil {
< 		panic(err)
< 	}
< 	e.mappingv(tag, func() {
< 		for _, info := range sinfo.FieldsList {
< 			var value reflect.Value
< 			if info.Inline == nil {
< 				value = in.Field(info.Num)
< 			} else {
< 				value = in.FieldByIndex(info.Inline)
< 			}
< 			if info.OmitEmpty && isZero(value) {
< 				continue
< 			}
< 			e.marshal("", reflect.ValueOf(info.Key))
< 			e.flow = info.Flow
< 			e.marshal("", value)
< 		}
< 		if sinfo.InlineMap >= 0 {
< 			m := in.Field(sinfo.InlineMap)
< 			if m.Len() > 0 {
< 				e.flow = false
< 				keys := keyList(m.MapKeys())
< 				sort.Sort(keys)
< 				for _, k := range keys {
< 					if _, found := sinfo.FieldsMap[k.String()]; found {
< 						panic(fmt.Sprintf("Can't have key %q in inlined map; conflicts with struct field", k.String()))
< 					}
< 					e.marshal("", k)
< 					e.flow = false
< 					e.marshal("", m.MapIndex(k))
< 				}
< 			}
< 		}
< 	})
< }
< 
< func (e *encoder) mappingv(tag string, f func()) {
< 	implicit := tag == ""
< 	style := yaml_BLOCK_MAPPING_STYLE
< 	if e.flow {
< 		e.flow = false
< 		style = yaml_FLOW_MAPPING_STYLE
< 	}
< 	yaml_mapping_start_event_initialize(&e.event, nil, []byte(tag), implicit, style)
< 	e.emit()
< 	f()
< 	yaml_mapping_end_event_initialize(&e.event)
< 	e.emit()
< }
< 
< func (e *encoder) slicev(tag string, in reflect.Value) {
< 	implicit := tag == ""
< 	style := yaml_BLOCK_SEQUENCE_STYLE
< 	if e.flow {
< 		e.flow = false
< 		style = yaml_FLOW_SEQUENCE_STYLE
< 	}
< 	e.must(yaml_sequence_start_event_initialize(&e.event, nil, []byte(tag), implicit, style))
< 	e.emit()
< 	n := in.Len()
< 	for i := 0; i < n; i++ {
< 		e.marshal("", in.Index(i))
< 	}
< 	e.must(yaml_sequence_end_event_initialize(&e.event))
< 	e.emit()
< }
< 
< // isBase60 returns whether s is in base 60 notation as defined in YAML 1.1.
< //
< // The base 60 float notation in YAML 1.1 is a terrible idea and is unsupported
< // in YAML 1.2 and by this package, but these should be marshalled quoted for
< // the time being for compatibility with other parsers.
< func isBase60Float(s string) (result bool) {
< 	// Fast path.
< 	if s == "" {
< 		return false
< 	}
< 	c := s[0]
< 	if !(c == '+' || c == '-' || c >= '0' && c <= '9') || strings.IndexByte(s, ':') < 0 {
< 		return false
< 	}
< 	// Do the full match.
< 	return base60float.MatchString(s)
< }
< 
< // From http://yaml.org/type/float.html, except the regular expression there
< // is bogus. In practice parsers do not enforce the "\.[0-9_]*" suffix.
< var base60float = regexp.MustCompile(`^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+(?:\.[0-9_]*)?$`)
< 
< func (e *encoder) stringv(tag string, in reflect.Value) {
< 	var style yaml_scalar_style_t
< 	s := in.String()
< 	canUsePlain := true
< 	switch {
< 	case !utf8.ValidString(s):
< 		if tag == yaml_BINARY_TAG {
< 			failf("explicitly tagged !!binary data must be base64-encoded")
< 		}
< 		if tag != "" {
< 			failf("cannot marshal invalid UTF-8 data as %s", shortTag(tag))
< 		}
< 		// It can't be encoded directly as YAML so use a binary tag
< 		// and encode it as base64.
< 		tag = yaml_BINARY_TAG
< 		s = encodeBase64(s)
< 	case tag == "":
< 		// Check to see if it would resolve to a specific
< 		// tag when encoded unquoted. If it doesn't,
< 		// there's no need to quote it.
< 		rtag, _ := resolve("", s)
< 		canUsePlain = rtag == yaml_STR_TAG && !isBase60Float(s)
< 	}
< 	// Note: it's possible for user code to emit invalid YAML
< 	// if they explicitly specify a tag and a string containing
< 	// text that's incompatible with that tag.
< 	switch {
< 	case strings.Contains(s, "\n"):
< 		style = yaml_LITERAL_SCALAR_STYLE
< 	case canUsePlain:
< 		style = yaml_PLAIN_SCALAR_STYLE
< 	default:
< 		style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 	}
< 	e.emitScalar(s, "", tag, style)
< }
< 
< func (e *encoder) boolv(tag string, in reflect.Value) {
< 	var s string
< 	if in.Bool() {
< 		s = "true"
< 	} else {
< 		s = "false"
< 	}
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
< }
< 
< func (e *encoder) intv(tag string, in reflect.Value) {
< 	s := strconv.FormatInt(in.Int(), 10)
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
< }
< 
< func (e *encoder) uintv(tag string, in reflect.Value) {
< 	s := strconv.FormatUint(in.Uint(), 10)
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
< }
< 
< func (e *encoder) timev(tag string, in reflect.Value) {
< 	t := in.Interface().(time.Time)
< 	s := t.Format(time.RFC3339Nano)
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
< }
< 
< func (e *encoder) floatv(tag string, in reflect.Value) {
< 	// Issue #352: When formatting, use the precision of the underlying value
< 	precision := 64
< 	if in.Kind() == reflect.Float32 {
< 		precision = 32
< 	}
< 
< 	s := strconv.FormatFloat(in.Float(), 'g', -1, precision)
< 	switch s {
< 	case "+Inf":
< 		s = ".inf"
< 	case "-Inf":
< 		s = "-.inf"
< 	case "NaN":
< 		s = ".nan"
< 	}
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE)
< }
< 
< func (e *encoder) nilv() {
< 	e.emitScalar("null", "", "", yaml_PLAIN_SCALAR_STYLE)
< }
< 
< func (e *encoder) emitScalar(value, anchor, tag string, style yaml_scalar_style_t) {
< 	implicit := tag == ""
< 	e.must(yaml_scalar_event_initialize(&e.event, []byte(anchor), []byte(tag), []byte(value), implicit, implicit, style))
< 	e.emit()
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/go.mod updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/go.mod
1,5d0
< module "gopkg.in/yaml.v2"
< 
< require (
< 	"gopkg.in/check.v1" v0.0.0-20161208181325-20d25e280405
< )
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/parserc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/parserc.go
1,1095d0
< package yaml
< 
< import (
< 	"bytes"
< )
< 
< // The parser implements the following grammar:
< //
< // stream               ::= STREAM-START implicit_document? explicit_document* STREAM-END
< // implicit_document    ::= block_node DOCUMENT-END*
< // explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
< // block_node_or_indentless_sequence    ::=
< //                          ALIAS
< //                          | properties (block_content | indentless_block_sequence)?
< //                          | block_content
< //                          | indentless_block_sequence
< // block_node           ::= ALIAS
< //                          | properties block_content?
< //                          | block_content
< // flow_node            ::= ALIAS
< //                          | properties flow_content?
< //                          | flow_content
< // properties           ::= TAG ANCHOR? | ANCHOR TAG?
< // block_content        ::= block_collection | flow_collection | SCALAR
< // flow_content         ::= flow_collection | SCALAR
< // block_collection     ::= block_sequence | block_mapping
< // flow_collection      ::= flow_sequence | flow_mapping
< // block_sequence       ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
< // indentless_sequence  ::= (BLOCK-ENTRY block_node?)+
< // block_mapping        ::= BLOCK-MAPPING_START
< //                          ((KEY block_node_or_indentless_sequence?)?
< //                          (VALUE block_node_or_indentless_sequence?)?)*
< //                          BLOCK-END
< // flow_sequence        ::= FLOW-SEQUENCE-START
< //                          (flow_sequence_entry FLOW-ENTRY)*
< //                          flow_sequence_entry?
< //                          FLOW-SEQUENCE-END
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< // flow_mapping         ::= FLOW-MAPPING-START
< //                          (flow_mapping_entry FLOW-ENTRY)*
< //                          flow_mapping_entry?
< //                          FLOW-MAPPING-END
< // flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< 
< // Peek the next token in the token queue.
< func peek_token(parser *yaml_parser_t) *yaml_token_t {
< 	if parser.token_available || yaml_parser_fetch_more_tokens(parser) {
< 		return &parser.tokens[parser.tokens_head]
< 	}
< 	return nil
< }
< 
< // Remove the next token from the queue (must be called after peek_token).
< func skip_token(parser *yaml_parser_t) {
< 	parser.token_available = false
< 	parser.tokens_parsed++
< 	parser.stream_end_produced = parser.tokens[parser.tokens_head].typ == yaml_STREAM_END_TOKEN
< 	parser.tokens_head++
< }
< 
< // Get the next event.
< func yaml_parser_parse(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	// Erase the event object.
< 	*event = yaml_event_t{}
< 
< 	// No events after the end of the stream or error.
< 	if parser.stream_end_produced || parser.error != yaml_NO_ERROR || parser.state == yaml_PARSE_END_STATE {
< 		return true
< 	}
< 
< 	// Generate the next event.
< 	return yaml_parser_state_machine(parser, event)
< }
< 
< // Set parser error.
< func yaml_parser_set_parser_error(parser *yaml_parser_t, problem string, problem_mark yaml_mark_t) bool {
< 	parser.error = yaml_PARSER_ERROR
< 	parser.problem = problem
< 	parser.problem_mark = problem_mark
< 	return false
< }
< 
< func yaml_parser_set_parser_error_context(parser *yaml_parser_t, context string, context_mark yaml_mark_t, problem string, problem_mark yaml_mark_t) bool {
< 	parser.error = yaml_PARSER_ERROR
< 	parser.context = context
< 	parser.context_mark = context_mark
< 	parser.problem = problem
< 	parser.problem_mark = problem_mark
< 	return false
< }
< 
< // State dispatcher.
< func yaml_parser_state_machine(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	//trace("yaml_parser_state_machine", "state:", parser.state.String())
< 
< 	switch parser.state {
< 	case yaml_PARSE_STREAM_START_STATE:
< 		return yaml_parser_parse_stream_start(parser, event)
< 
< 	case yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE:
< 		return yaml_parser_parse_document_start(parser, event, true)
< 
< 	case yaml_PARSE_DOCUMENT_START_STATE:
< 		return yaml_parser_parse_document_start(parser, event, false)
< 
< 	case yaml_PARSE_DOCUMENT_CONTENT_STATE:
< 		return yaml_parser_parse_document_content(parser, event)
< 
< 	case yaml_PARSE_DOCUMENT_END_STATE:
< 		return yaml_parser_parse_document_end(parser, event)
< 
< 	case yaml_PARSE_BLOCK_NODE_STATE:
< 		return yaml_parser_parse_node(parser, event, true, false)
< 
< 	case yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE:
< 		return yaml_parser_parse_node(parser, event, true, true)
< 
< 	case yaml_PARSE_FLOW_NODE_STATE:
< 		return yaml_parser_parse_node(parser, event, false, false)
< 
< 	case yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE:
< 		return yaml_parser_parse_block_sequence_entry(parser, event, true)
< 
< 	case yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE:
< 		return yaml_parser_parse_block_sequence_entry(parser, event, false)
< 
< 	case yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE:
< 		return yaml_parser_parse_indentless_sequence_entry(parser, event)
< 
< 	case yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE:
< 		return yaml_parser_parse_block_mapping_key(parser, event, true)
< 
< 	case yaml_PARSE_BLOCK_MAPPING_KEY_STATE:
< 		return yaml_parser_parse_block_mapping_key(parser, event, false)
< 
< 	case yaml_PARSE_BLOCK_MAPPING_VALUE_STATE:
< 		return yaml_parser_parse_block_mapping_value(parser, event)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE:
< 		return yaml_parser_parse_flow_sequence_entry(parser, event, true)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE:
< 		return yaml_parser_parse_flow_sequence_entry(parser, event, false)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE:
< 		return yaml_parser_parse_flow_sequence_entry_mapping_key(parser, event)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE:
< 		return yaml_parser_parse_flow_sequence_entry_mapping_value(parser, event)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE:
< 		return yaml_parser_parse_flow_sequence_entry_mapping_end(parser, event)
< 
< 	case yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE:
< 		return yaml_parser_parse_flow_mapping_key(parser, event, true)
< 
< 	case yaml_PARSE_FLOW_MAPPING_KEY_STATE:
< 		return yaml_parser_parse_flow_mapping_key(parser, event, false)
< 
< 	case yaml_PARSE_FLOW_MAPPING_VALUE_STATE:
< 		return yaml_parser_parse_flow_mapping_value(parser, event, false)
< 
< 	case yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE:
< 		return yaml_parser_parse_flow_mapping_value(parser, event, true)
< 
< 	default:
< 		panic("invalid parser state")
< 	}
< }
< 
< // Parse the production:
< // stream   ::= STREAM-START implicit_document? explicit_document* STREAM-END
< //              ************
< func yaml_parser_parse_stream_start(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ != yaml_STREAM_START_TOKEN {
< 		return yaml_parser_set_parser_error(parser, "did not find expected <stream-start>", token.start_mark)
< 	}
< 	parser.state = yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE
< 	*event = yaml_event_t{
< 		typ:        yaml_STREAM_START_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.end_mark,
< 		encoding:   token.encoding,
< 	}
< 	skip_token(parser)
< 	return true
< }
< 
< // Parse the productions:
< // implicit_document    ::= block_node DOCUMENT-END*
< //                          *
< // explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
< //                          *************************
< func yaml_parser_parse_document_start(parser *yaml_parser_t, event *yaml_event_t, implicit bool) bool {
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	// Parse extra document end indicators.
< 	if !implicit {
< 		for token.typ == yaml_DOCUMENT_END_TOKEN {
< 			skip_token(parser)
< 			token = peek_token(parser)
< 			if token == nil {
< 				return false
< 			}
< 		}
< 	}
< 
< 	if implicit && token.typ != yaml_VERSION_DIRECTIVE_TOKEN &&
< 		token.typ != yaml_TAG_DIRECTIVE_TOKEN &&
< 		token.typ != yaml_DOCUMENT_START_TOKEN &&
< 		token.typ != yaml_STREAM_END_TOKEN {
< 		// Parse an implicit document.
< 		if !yaml_parser_process_directives(parser, nil, nil) {
< 			return false
< 		}
< 		parser.states = append(parser.states, yaml_PARSE_DOCUMENT_END_STATE)
< 		parser.state = yaml_PARSE_BLOCK_NODE_STATE
< 
< 		*event = yaml_event_t{
< 			typ:        yaml_DOCUMENT_START_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 		}
< 
< 	} else if token.typ != yaml_STREAM_END_TOKEN {
< 		// Parse an explicit document.
< 		var version_directive *yaml_version_directive_t
< 		var tag_directives []yaml_tag_directive_t
< 		start_mark := token.start_mark
< 		if !yaml_parser_process_directives(parser, &version_directive, &tag_directives) {
< 			return false
< 		}
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_DOCUMENT_START_TOKEN {
< 			yaml_parser_set_parser_error(parser,
< 				"did not find expected <document start>", token.start_mark)
< 			return false
< 		}
< 		parser.states = append(parser.states, yaml_PARSE_DOCUMENT_END_STATE)
< 		parser.state = yaml_PARSE_DOCUMENT_CONTENT_STATE
< 		end_mark := token.end_mark
< 
< 		*event = yaml_event_t{
< 			typ:               yaml_DOCUMENT_START_EVENT,
< 			start_mark:        start_mark,
< 			end_mark:          end_mark,
< 			version_directive: version_directive,
< 			tag_directives:    tag_directives,
< 			implicit:          false,
< 		}
< 		skip_token(parser)
< 
< 	} else {
< 		// Parse the stream end.
< 		parser.state = yaml_PARSE_END_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_STREAM_END_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 		}
< 		skip_token(parser)
< 	}
< 
< 	return true
< }
< 
< // Parse the productions:
< // explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
< //                                                    ***********
< //
< func yaml_parser_parse_document_content(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ == yaml_VERSION_DIRECTIVE_TOKEN ||
< 		token.typ == yaml_TAG_DIRECTIVE_TOKEN ||
< 		token.typ == yaml_DOCUMENT_START_TOKEN ||
< 		token.typ == yaml_DOCUMENT_END_TOKEN ||
< 		token.typ == yaml_STREAM_END_TOKEN {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 		return yaml_parser_process_empty_scalar(parser, event,
< 			token.start_mark)
< 	}
< 	return yaml_parser_parse_node(parser, event, true, false)
< }
< 
< // Parse the productions:
< // implicit_document    ::= block_node DOCUMENT-END*
< //                                     *************
< // explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
< //
< func yaml_parser_parse_document_end(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	start_mark := token.start_mark
< 	end_mark := token.start_mark
< 
< 	implicit := true
< 	if token.typ == yaml_DOCUMENT_END_TOKEN {
< 		end_mark = token.end_mark
< 		skip_token(parser)
< 		implicit = false
< 	}
< 
< 	parser.tag_directives = parser.tag_directives[:0]
< 
< 	parser.state = yaml_PARSE_DOCUMENT_START_STATE
< 	*event = yaml_event_t{
< 		typ:        yaml_DOCUMENT_END_EVENT,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		implicit:   implicit,
< 	}
< 	return true
< }
< 
< // Parse the productions:
< // block_node_or_indentless_sequence    ::=
< //                          ALIAS
< //                          *****
< //                          | properties (block_content | indentless_block_sequence)?
< //                            **********  *
< //                          | block_content | indentless_block_sequence
< //                            *
< // block_node           ::= ALIAS
< //                          *****
< //                          | properties block_content?
< //                            ********** *
< //                          | block_content
< //                            *
< // flow_node            ::= ALIAS
< //                          *****
< //                          | properties flow_content?
< //                            ********** *
< //                          | flow_content
< //                            *
< // properties           ::= TAG ANCHOR? | ANCHOR TAG?
< //                          *************************
< // block_content        ::= block_collection | flow_collection | SCALAR
< //                                                               ******
< // flow_content         ::= flow_collection | SCALAR
< //                                            ******
< func yaml_parser_parse_node(parser *yaml_parser_t, event *yaml_event_t, block, indentless_sequence bool) bool {
< 	//defer trace("yaml_parser_parse_node", "block:", block, "indentless_sequence:", indentless_sequence)()
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ == yaml_ALIAS_TOKEN {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 		*event = yaml_event_t{
< 			typ:        yaml_ALIAS_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 			anchor:     token.value,
< 		}
< 		skip_token(parser)
< 		return true
< 	}
< 
< 	start_mark := token.start_mark
< 	end_mark := token.start_mark
< 
< 	var tag_token bool
< 	var tag_handle, tag_suffix, anchor []byte
< 	var tag_mark yaml_mark_t
< 	if token.typ == yaml_ANCHOR_TOKEN {
< 		anchor = token.value
< 		start_mark = token.start_mark
< 		end_mark = token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ == yaml_TAG_TOKEN {
< 			tag_token = true
< 			tag_handle = token.value
< 			tag_suffix = token.suffix
< 			tag_mark = token.start_mark
< 			end_mark = token.end_mark
< 			skip_token(parser)
< 			token = peek_token(parser)
< 			if token == nil {
< 				return false
< 			}
< 		}
< 	} else if token.typ == yaml_TAG_TOKEN {
< 		tag_token = true
< 		tag_handle = token.value
< 		tag_suffix = token.suffix
< 		start_mark = token.start_mark
< 		tag_mark = token.start_mark
< 		end_mark = token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ == yaml_ANCHOR_TOKEN {
< 			anchor = token.value
< 			end_mark = token.end_mark
< 			skip_token(parser)
< 			token = peek_token(parser)
< 			if token == nil {
< 				return false
< 			}
< 		}
< 	}
< 
< 	var tag []byte
< 	if tag_token {
< 		if len(tag_handle) == 0 {
< 			tag = tag_suffix
< 			tag_suffix = nil
< 		} else {
< 			for i := range parser.tag_directives {
< 				if bytes.Equal(parser.tag_directives[i].handle, tag_handle) {
< 					tag = append([]byte(nil), parser.tag_directives[i].prefix...)
< 					tag = append(tag, tag_suffix...)
< 					break
< 				}
< 			}
< 			if len(tag) == 0 {
< 				yaml_parser_set_parser_error_context(parser,
< 					"while parsing a node", start_mark,
< 					"found undefined tag handle", tag_mark)
< 				return false
< 			}
< 		}
< 	}
< 
< 	implicit := len(tag) == 0
< 	if indentless_sequence && token.typ == yaml_BLOCK_ENTRY_TOKEN {
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_SEQUENCE_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_BLOCK_SEQUENCE_STYLE),
< 		}
< 		return true
< 	}
< 	if token.typ == yaml_SCALAR_TOKEN {
< 		var plain_implicit, quoted_implicit bool
< 		end_mark = token.end_mark
< 		if (len(tag) == 0 && token.style == yaml_PLAIN_SCALAR_STYLE) || (len(tag) == 1 && tag[0] == '!') {
< 			plain_implicit = true
< 		} else if len(tag) == 0 {
< 			quoted_implicit = true
< 		}
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 
< 		*event = yaml_event_t{
< 			typ:             yaml_SCALAR_EVENT,
< 			start_mark:      start_mark,
< 			end_mark:        end_mark,
< 			anchor:          anchor,
< 			tag:             tag,
< 			value:           token.value,
< 			implicit:        plain_implicit,
< 			quoted_implicit: quoted_implicit,
< 			style:           yaml_style_t(token.style),
< 		}
< 		skip_token(parser)
< 		return true
< 	}
< 	if token.typ == yaml_FLOW_SEQUENCE_START_TOKEN {
< 		// [Go] Some of the events below can be merged as they differ only on style.
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_SEQUENCE_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_FLOW_SEQUENCE_STYLE),
< 		}
< 		return true
< 	}
< 	if token.typ == yaml_FLOW_MAPPING_START_TOKEN {
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_MAPPING_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_FLOW_MAPPING_STYLE),
< 		}
< 		return true
< 	}
< 	if block && token.typ == yaml_BLOCK_SEQUENCE_START_TOKEN {
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_SEQUENCE_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_BLOCK_SEQUENCE_STYLE),
< 		}
< 		return true
< 	}
< 	if block && token.typ == yaml_BLOCK_MAPPING_START_TOKEN {
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_MAPPING_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_BLOCK_MAPPING_STYLE),
< 		}
< 		return true
< 	}
< 	if len(anchor) > 0 || len(tag) > 0 {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 
< 		*event = yaml_event_t{
< 			typ:             yaml_SCALAR_EVENT,
< 			start_mark:      start_mark,
< 			end_mark:        end_mark,
< 			anchor:          anchor,
< 			tag:             tag,
< 			implicit:        implicit,
< 			quoted_implicit: false,
< 			style:           yaml_style_t(yaml_PLAIN_SCALAR_STYLE),
< 		}
< 		return true
< 	}
< 
< 	context := "while parsing a flow node"
< 	if block {
< 		context = "while parsing a block node"
< 	}
< 	yaml_parser_set_parser_error_context(parser, context, start_mark,
< 		"did not find expected node content", token.start_mark)
< 	return false
< }
< 
< // Parse the productions:
< // block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
< //                    ********************  *********** *             *********
< //
< func yaml_parser_parse_block_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		token := peek_token(parser)
< 		parser.marks = append(parser.marks, token.start_mark)
< 		skip_token(parser)
< 	}
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ == yaml_BLOCK_ENTRY_TOKEN {
< 		mark := token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_BLOCK_ENTRY_TOKEN && token.typ != yaml_BLOCK_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE)
< 			return yaml_parser_parse_node(parser, event, true, false)
< 		} else {
< 			parser.state = yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE
< 			return yaml_parser_process_empty_scalar(parser, event, mark)
< 		}
< 	}
< 	if token.typ == yaml_BLOCK_END_TOKEN {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 		parser.marks = parser.marks[:len(parser.marks)-1]
< 
< 		*event = yaml_event_t{
< 			typ:        yaml_SEQUENCE_END_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 		}
< 
< 		skip_token(parser)
< 		return true
< 	}
< 
< 	context_mark := parser.marks[len(parser.marks)-1]
< 	parser.marks = parser.marks[:len(parser.marks)-1]
< 	return yaml_parser_set_parser_error_context(parser,
< 		"while parsing a block collection", context_mark,
< 		"did not find expected '-' indicator", token.start_mark)
< }
< 
< // Parse the productions:
< // indentless_sequence  ::= (BLOCK-ENTRY block_node?)+
< //                           *********** *
< func yaml_parser_parse_indentless_sequence_entry(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ == yaml_BLOCK_ENTRY_TOKEN {
< 		mark := token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_BLOCK_ENTRY_TOKEN &&
< 			token.typ != yaml_KEY_TOKEN &&
< 			token.typ != yaml_VALUE_TOKEN &&
< 			token.typ != yaml_BLOCK_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE)
< 			return yaml_parser_parse_node(parser, event, true, false)
< 		}
< 		parser.state = yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
< 		return yaml_parser_process_empty_scalar(parser, event, mark)
< 	}
< 	parser.state = parser.states[len(parser.states)-1]
< 	parser.states = parser.states[:len(parser.states)-1]
< 
< 	*event = yaml_event_t{
< 		typ:        yaml_SEQUENCE_END_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.start_mark, // [Go] Shouldn't this be token.end_mark?
< 	}
< 	return true
< }
< 
< // Parse the productions:
< // block_mapping        ::= BLOCK-MAPPING_START
< //                          *******************
< //                          ((KEY block_node_or_indentless_sequence?)?
< //                            *** *
< //                          (VALUE block_node_or_indentless_sequence?)?)*
< //
< //                          BLOCK-END
< //                          *********
< //
< func yaml_parser_parse_block_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		token := peek_token(parser)
< 		parser.marks = append(parser.marks, token.start_mark)
< 		skip_token(parser)
< 	}
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ == yaml_KEY_TOKEN {
< 		mark := token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_KEY_TOKEN &&
< 			token.typ != yaml_VALUE_TOKEN &&
< 			token.typ != yaml_BLOCK_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_BLOCK_MAPPING_VALUE_STATE)
< 			return yaml_parser_parse_node(parser, event, true, true)
< 		} else {
< 			parser.state = yaml_PARSE_BLOCK_MAPPING_VALUE_STATE
< 			return yaml_parser_process_empty_scalar(parser, event, mark)
< 		}
< 	} else if token.typ == yaml_BLOCK_END_TOKEN {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 		parser.marks = parser.marks[:len(parser.marks)-1]
< 		*event = yaml_event_t{
< 			typ:        yaml_MAPPING_END_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 		}
< 		skip_token(parser)
< 		return true
< 	}
< 
< 	context_mark := parser.marks[len(parser.marks)-1]
< 	parser.marks = parser.marks[:len(parser.marks)-1]
< 	return yaml_parser_set_parser_error_context(parser,
< 		"while parsing a block mapping", context_mark,
< 		"did not find expected key", token.start_mark)
< }
< 
< // Parse the productions:
< // block_mapping        ::= BLOCK-MAPPING_START
< //
< //                          ((KEY block_node_or_indentless_sequence?)?
< //
< //                          (VALUE block_node_or_indentless_sequence?)?)*
< //                           ***** *
< //                          BLOCK-END
< //
< //
< func yaml_parser_parse_block_mapping_value(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ == yaml_VALUE_TOKEN {
< 		mark := token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_KEY_TOKEN &&
< 			token.typ != yaml_VALUE_TOKEN &&
< 			token.typ != yaml_BLOCK_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_BLOCK_MAPPING_KEY_STATE)
< 			return yaml_parser_parse_node(parser, event, true, true)
< 		}
< 		parser.state = yaml_PARSE_BLOCK_MAPPING_KEY_STATE
< 		return yaml_parser_process_empty_scalar(parser, event, mark)
< 	}
< 	parser.state = yaml_PARSE_BLOCK_MAPPING_KEY_STATE
< 	return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< }
< 
< // Parse the productions:
< // flow_sequence        ::= FLOW-SEQUENCE-START
< //                          *******************
< //                          (flow_sequence_entry FLOW-ENTRY)*
< //                           *                   **********
< //                          flow_sequence_entry?
< //                          *
< //                          FLOW-SEQUENCE-END
< //                          *****************
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                          *
< //
< func yaml_parser_parse_flow_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		token := peek_token(parser)
< 		parser.marks = append(parser.marks, token.start_mark)
< 		skip_token(parser)
< 	}
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
< 		if !first {
< 			if token.typ == yaml_FLOW_ENTRY_TOKEN {
< 				skip_token(parser)
< 				token = peek_token(parser)
< 				if token == nil {
< 					return false
< 				}
< 			} else {
< 				context_mark := parser.marks[len(parser.marks)-1]
< 				parser.marks = parser.marks[:len(parser.marks)-1]
< 				return yaml_parser_set_parser_error_context(parser,
< 					"while parsing a flow sequence", context_mark,
< 					"did not find expected ',' or ']'", token.start_mark)
< 			}
< 		}
< 
< 		if token.typ == yaml_KEY_TOKEN {
< 			parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE
< 			*event = yaml_event_t{
< 				typ:        yaml_MAPPING_START_EVENT,
< 				start_mark: token.start_mark,
< 				end_mark:   token.end_mark,
< 				implicit:   true,
< 				style:      yaml_style_t(yaml_FLOW_MAPPING_STYLE),
< 			}
< 			skip_token(parser)
< 			return true
< 		} else if token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE)
< 			return yaml_parser_parse_node(parser, event, false, false)
< 		}
< 	}
< 
< 	parser.state = parser.states[len(parser.states)-1]
< 	parser.states = parser.states[:len(parser.states)-1]
< 	parser.marks = parser.marks[:len(parser.marks)-1]
< 
< 	*event = yaml_event_t{
< 		typ:        yaml_SEQUENCE_END_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.end_mark,
< 	}
< 
< 	skip_token(parser)
< 	return true
< }
< 
< //
< // Parse the productions:
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                                      *** *
< //
< func yaml_parser_parse_flow_sequence_entry_mapping_key(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ != yaml_VALUE_TOKEN &&
< 		token.typ != yaml_FLOW_ENTRY_TOKEN &&
< 		token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
< 		parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE)
< 		return yaml_parser_parse_node(parser, event, false, false)
< 	}
< 	mark := token.end_mark
< 	skip_token(parser)
< 	parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE
< 	return yaml_parser_process_empty_scalar(parser, event, mark)
< }
< 
< // Parse the productions:
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                                                      ***** *
< //
< func yaml_parser_parse_flow_sequence_entry_mapping_value(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ == yaml_VALUE_TOKEN {
< 		skip_token(parser)
< 		token := peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_FLOW_ENTRY_TOKEN && token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE)
< 			return yaml_parser_parse_node(parser, event, false, false)
< 		}
< 	}
< 	parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE
< 	return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< }
< 
< // Parse the productions:
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                                                                      *
< //
< func yaml_parser_parse_flow_sequence_entry_mapping_end(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE
< 	*event = yaml_event_t{
< 		typ:        yaml_MAPPING_END_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.start_mark, // [Go] Shouldn't this be end_mark?
< 	}
< 	return true
< }
< 
< // Parse the productions:
< // flow_mapping         ::= FLOW-MAPPING-START
< //                          ******************
< //                          (flow_mapping_entry FLOW-ENTRY)*
< //                           *                  **********
< //                          flow_mapping_entry?
< //                          ******************
< //                          FLOW-MAPPING-END
< //                          ****************
< // flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                          *           *** *
< //
< func yaml_parser_parse_flow_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		token := peek_token(parser)
< 		parser.marks = append(parser.marks, token.start_mark)
< 		skip_token(parser)
< 	}
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ != yaml_FLOW_MAPPING_END_TOKEN {
< 		if !first {
< 			if token.typ == yaml_FLOW_ENTRY_TOKEN {
< 				skip_token(parser)
< 				token = peek_token(parser)
< 				if token == nil {
< 					return false
< 				}
< 			} else {
< 				context_mark := parser.marks[len(parser.marks)-1]
< 				parser.marks = parser.marks[:len(parser.marks)-1]
< 				return yaml_parser_set_parser_error_context(parser,
< 					"while parsing a flow mapping", context_mark,
< 					"did not find expected ',' or '}'", token.start_mark)
< 			}
< 		}
< 
< 		if token.typ == yaml_KEY_TOKEN {
< 			skip_token(parser)
< 			token = peek_token(parser)
< 			if token == nil {
< 				return false
< 			}
< 			if token.typ != yaml_VALUE_TOKEN &&
< 				token.typ != yaml_FLOW_ENTRY_TOKEN &&
< 				token.typ != yaml_FLOW_MAPPING_END_TOKEN {
< 				parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_VALUE_STATE)
< 				return yaml_parser_parse_node(parser, event, false, false)
< 			} else {
< 				parser.state = yaml_PARSE_FLOW_MAPPING_VALUE_STATE
< 				return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< 			}
< 		} else if token.typ != yaml_FLOW_MAPPING_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE)
< 			return yaml_parser_parse_node(parser, event, false, false)
< 		}
< 	}
< 
< 	parser.state = parser.states[len(parser.states)-1]
< 	parser.states = parser.states[:len(parser.states)-1]
< 	parser.marks = parser.marks[:len(parser.marks)-1]
< 	*event = yaml_event_t{
< 		typ:        yaml_MAPPING_END_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.end_mark,
< 	}
< 	skip_token(parser)
< 	return true
< }
< 
< // Parse the productions:
< // flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                                   *                  ***** *
< //
< func yaml_parser_parse_flow_mapping_value(parser *yaml_parser_t, event *yaml_event_t, empty bool) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if empty {
< 		parser.state = yaml_PARSE_FLOW_MAPPING_KEY_STATE
< 		return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< 	}
< 	if token.typ == yaml_VALUE_TOKEN {
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_FLOW_ENTRY_TOKEN && token.typ != yaml_FLOW_MAPPING_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_KEY_STATE)
< 			return yaml_parser_parse_node(parser, event, false, false)
< 		}
< 	}
< 	parser.state = yaml_PARSE_FLOW_MAPPING_KEY_STATE
< 	return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< }
< 
< // Generate an empty scalar event.
< func yaml_parser_process_empty_scalar(parser *yaml_parser_t, event *yaml_event_t, mark yaml_mark_t) bool {
< 	*event = yaml_event_t{
< 		typ:        yaml_SCALAR_EVENT,
< 		start_mark: mark,
< 		end_mark:   mark,
< 		value:      nil, // Empty
< 		implicit:   true,
< 		style:      yaml_style_t(yaml_PLAIN_SCALAR_STYLE),
< 	}
< 	return true
< }
< 
< var default_tag_directives = []yaml_tag_directive_t{
< 	{[]byte("!"), []byte("!")},
< 	{[]byte("!!"), []byte("tag:yaml.org,2002:")},
< }
< 
< // Parse directives.
< func yaml_parser_process_directives(parser *yaml_parser_t,
< 	version_directive_ref **yaml_version_directive_t,
< 	tag_directives_ref *[]yaml_tag_directive_t) bool {
< 
< 	var version_directive *yaml_version_directive_t
< 	var tag_directives []yaml_tag_directive_t
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	for token.typ == yaml_VERSION_DIRECTIVE_TOKEN || token.typ == yaml_TAG_DIRECTIVE_TOKEN {
< 		if token.typ == yaml_VERSION_DIRECTIVE_TOKEN {
< 			if version_directive != nil {
< 				yaml_parser_set_parser_error(parser,
< 					"found duplicate %YAML directive", token.start_mark)
< 				return false
< 			}
< 			if token.major != 1 || token.minor != 1 {
< 				yaml_parser_set_parser_error(parser,
< 					"found incompatible YAML document", token.start_mark)
< 				return false
< 			}
< 			version_directive = &yaml_version_directive_t{
< 				major: token.major,
< 				minor: token.minor,
< 			}
< 		} else if token.typ == yaml_TAG_DIRECTIVE_TOKEN {
< 			value := yaml_tag_directive_t{
< 				handle: token.value,
< 				prefix: token.prefix,
< 			}
< 			if !yaml_parser_append_tag_directive(parser, value, false, token.start_mark) {
< 				return false
< 			}
< 			tag_directives = append(tag_directives, value)
< 		}
< 
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 	}
< 
< 	for i := range default_tag_directives {
< 		if !yaml_parser_append_tag_directive(parser, default_tag_directives[i], true, token.start_mark) {
< 			return false
< 		}
< 	}
< 
< 	if version_directive_ref != nil {
< 		*version_directive_ref = version_directive
< 	}
< 	if tag_directives_ref != nil {
< 		*tag_directives_ref = tag_directives
< 	}
< 	return true
< }
< 
< // Append a tag directive to the directives stack.
< func yaml_parser_append_tag_directive(parser *yaml_parser_t, value yaml_tag_directive_t, allow_duplicates bool, mark yaml_mark_t) bool {
< 	for i := range parser.tag_directives {
< 		if bytes.Equal(value.handle, parser.tag_directives[i].handle) {
< 			if allow_duplicates {
< 				return true
< 			}
< 			return yaml_parser_set_parser_error(parser, "found duplicate %TAG directive", mark)
< 		}
< 	}
< 
< 	// [Go] I suspect the copy is unnecessary. This was likely done
< 	// because there was no way to track ownership of the data.
< 	value_copy := yaml_tag_directive_t{
< 		handle: make([]byte, len(value.handle)),
< 		prefix: make([]byte, len(value.prefix)),
< 	}
< 	copy(value_copy.handle, value.handle)
< 	copy(value_copy.prefix, value.prefix)
< 	parser.tag_directives = append(parser.tag_directives, value_copy)
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/readerc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/readerc.go
1,412d0
< package yaml
< 
< import (
< 	"io"
< )
< 
< // Set the reader error and return 0.
< func yaml_parser_set_reader_error(parser *yaml_parser_t, problem string, offset int, value int) bool {
< 	parser.error = yaml_READER_ERROR
< 	parser.problem = problem
< 	parser.problem_offset = offset
< 	parser.problem_value = value
< 	return false
< }
< 
< // Byte order marks.
< const (
< 	bom_UTF8    = "\xef\xbb\xbf"
< 	bom_UTF16LE = "\xff\xfe"
< 	bom_UTF16BE = "\xfe\xff"
< )
< 
< // Determine the input stream encoding by checking the BOM symbol. If no BOM is
< // found, the UTF-8 encoding is assumed. Return 1 on success, 0 on failure.
< func yaml_parser_determine_encoding(parser *yaml_parser_t) bool {
< 	// Ensure that we had enough bytes in the raw buffer.
< 	for !parser.eof && len(parser.raw_buffer)-parser.raw_buffer_pos < 3 {
< 		if !yaml_parser_update_raw_buffer(parser) {
< 			return false
< 		}
< 	}
< 
< 	// Determine the encoding.
< 	buf := parser.raw_buffer
< 	pos := parser.raw_buffer_pos
< 	avail := len(buf) - pos
< 	if avail >= 2 && buf[pos] == bom_UTF16LE[0] && buf[pos+1] == bom_UTF16LE[1] {
< 		parser.encoding = yaml_UTF16LE_ENCODING
< 		parser.raw_buffer_pos += 2
< 		parser.offset += 2
< 	} else if avail >= 2 && buf[pos] == bom_UTF16BE[0] && buf[pos+1] == bom_UTF16BE[1] {
< 		parser.encoding = yaml_UTF16BE_ENCODING
< 		parser.raw_buffer_pos += 2
< 		parser.offset += 2
< 	} else if avail >= 3 && buf[pos] == bom_UTF8[0] && buf[pos+1] == bom_UTF8[1] && buf[pos+2] == bom_UTF8[2] {
< 		parser.encoding = yaml_UTF8_ENCODING
< 		parser.raw_buffer_pos += 3
< 		parser.offset += 3
< 	} else {
< 		parser.encoding = yaml_UTF8_ENCODING
< 	}
< 	return true
< }
< 
< // Update the raw buffer.
< func yaml_parser_update_raw_buffer(parser *yaml_parser_t) bool {
< 	size_read := 0
< 
< 	// Return if the raw buffer is full.
< 	if parser.raw_buffer_pos == 0 && len(parser.raw_buffer) == cap(parser.raw_buffer) {
< 		return true
< 	}
< 
< 	// Return on EOF.
< 	if parser.eof {
< 		return true
< 	}
< 
< 	// Move the remaining bytes in the raw buffer to the beginning.
< 	if parser.raw_buffer_pos > 0 && parser.raw_buffer_pos < len(parser.raw_buffer) {
< 		copy(parser.raw_buffer, parser.raw_buffer[parser.raw_buffer_pos:])
< 	}
< 	parser.raw_buffer = parser.raw_buffer[:len(parser.raw_buffer)-parser.raw_buffer_pos]
< 	parser.raw_buffer_pos = 0
< 
< 	// Call the read handler to fill the buffer.
< 	size_read, err := parser.read_handler(parser, parser.raw_buffer[len(parser.raw_buffer):cap(parser.raw_buffer)])
< 	parser.raw_buffer = parser.raw_buffer[:len(parser.raw_buffer)+size_read]
< 	if err == io.EOF {
< 		parser.eof = true
< 	} else if err != nil {
< 		return yaml_parser_set_reader_error(parser, "input error: "+err.Error(), parser.offset, -1)
< 	}
< 	return true
< }
< 
< // Ensure that the buffer contains at least `length` characters.
< // Return true on success, false on failure.
< //
< // The length is supposed to be significantly less that the buffer size.
< func yaml_parser_update_buffer(parser *yaml_parser_t, length int) bool {
< 	if parser.read_handler == nil {
< 		panic("read handler must be set")
< 	}
< 
< 	// [Go] This function was changed to guarantee the requested length size at EOF.
< 	// The fact we need to do this is pretty awful, but the description above implies
< 	// for that to be the case, and there are tests 
< 
< 	// If the EOF flag is set and the raw buffer is empty, do nothing.
< 	if parser.eof && parser.raw_buffer_pos == len(parser.raw_buffer) {
< 		// [Go] ACTUALLY! Read the documentation of this function above.
< 		// This is just broken. To return true, we need to have the
< 		// given length in the buffer. Not doing that means every single
< 		// check that calls this function to make sure the buffer has a
< 		// given length is Go) panicking; or C) accessing invalid memory.
< 		//return true
< 	}
< 
< 	// Return if the buffer contains enough characters.
< 	if parser.unread >= length {
< 		return true
< 	}
< 
< 	// Determine the input encoding if it is not known yet.
< 	if parser.encoding == yaml_ANY_ENCODING {
< 		if !yaml_parser_determine_encoding(parser) {
< 			return false
< 		}
< 	}
< 
< 	// Move the unread characters to the beginning of the buffer.
< 	buffer_len := len(parser.buffer)
< 	if parser.buffer_pos > 0 && parser.buffer_pos < buffer_len {
< 		copy(parser.buffer, parser.buffer[parser.buffer_pos:])
< 		buffer_len -= parser.buffer_pos
< 		parser.buffer_pos = 0
< 	} else if parser.buffer_pos == buffer_len {
< 		buffer_len = 0
< 		parser.buffer_pos = 0
< 	}
< 
< 	// Open the whole buffer for writing, and cut it before returning.
< 	parser.buffer = parser.buffer[:cap(parser.buffer)]
< 
< 	// Fill the buffer until it has enough characters.
< 	first := true
< 	for parser.unread < length {
< 
< 		// Fill the raw buffer if necessary.
< 		if !first || parser.raw_buffer_pos == len(parser.raw_buffer) {
< 			if !yaml_parser_update_raw_buffer(parser) {
< 				parser.buffer = parser.buffer[:buffer_len]
< 				return false
< 			}
< 		}
< 		first = false
< 
< 		// Decode the raw buffer.
< 	inner:
< 		for parser.raw_buffer_pos != len(parser.raw_buffer) {
< 			var value rune
< 			var width int
< 
< 			raw_unread := len(parser.raw_buffer) - parser.raw_buffer_pos
< 
< 			// Decode the next character.
< 			switch parser.encoding {
< 			case yaml_UTF8_ENCODING:
< 				// Decode a UTF-8 character.  Check RFC 3629
< 				// (http://www.ietf.org/rfc/rfc3629.txt) for more details.
< 				//
< 				// The following table (taken from the RFC) is used for
< 				// decoding.
< 				//
< 				//    Char. number range |        UTF-8 octet sequence
< 				//      (hexadecimal)    |              (binary)
< 				//   --------------------+------------------------------------
< 				//   0000 0000-0000 007F | 0xxxxxxx
< 				//   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
< 				//   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
< 				//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
< 				//
< 				// Additionally, the characters in the range 0xD800-0xDFFF
< 				// are prohibited as they are reserved for use with UTF-16
< 				// surrogate pairs.
< 
< 				// Determine the length of the UTF-8 sequence.
< 				octet := parser.raw_buffer[parser.raw_buffer_pos]
< 				switch {
< 				case octet&0x80 == 0x00:
< 					width = 1
< 				case octet&0xE0 == 0xC0:
< 					width = 2
< 				case octet&0xF0 == 0xE0:
< 					width = 3
< 				case octet&0xF8 == 0xF0:
< 					width = 4
< 				default:
< 					// The leading octet is invalid.
< 					return yaml_parser_set_reader_error(parser,
< 						"invalid leading UTF-8 octet",
< 						parser.offset, int(octet))
< 				}
< 
< 				// Check if the raw buffer contains an incomplete character.
< 				if width > raw_unread {
< 					if parser.eof {
< 						return yaml_parser_set_reader_error(parser,
< 							"incomplete UTF-8 octet sequence",
< 							parser.offset, -1)
< 					}
< 					break inner
< 				}
< 
< 				// Decode the leading octet.
< 				switch {
< 				case octet&0x80 == 0x00:
< 					value = rune(octet & 0x7F)
< 				case octet&0xE0 == 0xC0:
< 					value = rune(octet & 0x1F)
< 				case octet&0xF0 == 0xE0:
< 					value = rune(octet & 0x0F)
< 				case octet&0xF8 == 0xF0:
< 					value = rune(octet & 0x07)
< 				default:
< 					value = 0
< 				}
< 
< 				// Check and decode the trailing octets.
< 				for k := 1; k < width; k++ {
< 					octet = parser.raw_buffer[parser.raw_buffer_pos+k]
< 
< 					// Check if the octet is valid.
< 					if (octet & 0xC0) != 0x80 {
< 						return yaml_parser_set_reader_error(parser,
< 							"invalid trailing UTF-8 octet",
< 							parser.offset+k, int(octet))
< 					}
< 
< 					// Decode the octet.
< 					value = (value << 6) + rune(octet&0x3F)
< 				}
< 
< 				// Check the length of the sequence against the value.
< 				switch {
< 				case width == 1:
< 				case width == 2 && value >= 0x80:
< 				case width == 3 && value >= 0x800:
< 				case width == 4 && value >= 0x10000:
< 				default:
< 					return yaml_parser_set_reader_error(parser,
< 						"invalid length of a UTF-8 sequence",
< 						parser.offset, -1)
< 				}
< 
< 				// Check the range of the value.
< 				if value >= 0xD800 && value <= 0xDFFF || value > 0x10FFFF {
< 					return yaml_parser_set_reader_error(parser,
< 						"invalid Unicode character",
< 						parser.offset, int(value))
< 				}
< 
< 			case yaml_UTF16LE_ENCODING, yaml_UTF16BE_ENCODING:
< 				var low, high int
< 				if parser.encoding == yaml_UTF16LE_ENCODING {
< 					low, high = 0, 1
< 				} else {
< 					low, high = 1, 0
< 				}
< 
< 				// The UTF-16 encoding is not as simple as one might
< 				// naively think.  Check RFC 2781
< 				// (http://www.ietf.org/rfc/rfc2781.txt).
< 				//
< 				// Normally, two subsequent bytes describe a Unicode
< 				// character.  However a special technique (called a
< 				// surrogate pair) is used for specifying character
< 				// values larger than 0xFFFF.
< 				//
< 				// A surrogate pair consists of two pseudo-characters:
< 				//      high surrogate area (0xD800-0xDBFF)
< 				//      low surrogate area (0xDC00-0xDFFF)
< 				//
< 				// The following formulas are used for decoding
< 				// and encoding characters using surrogate pairs:
< 				//
< 				//  U  = U' + 0x10000   (0x01 00 00 <= U <= 0x10 FF FF)
< 				//  U' = yyyyyyyyyyxxxxxxxxxx   (0 <= U' <= 0x0F FF FF)
< 				//  W1 = 110110yyyyyyyyyy
< 				//  W2 = 110111xxxxxxxxxx
< 				//
< 				// where U is the character value, W1 is the high surrogate
< 				// area, W2 is the low surrogate area.
< 
< 				// Check for incomplete UTF-16 character.
< 				if raw_unread < 2 {
< 					if parser.eof {
< 						return yaml_parser_set_reader_error(parser,
< 							"incomplete UTF-16 character",
< 							parser.offset, -1)
< 					}
< 					break inner
< 				}
< 
< 				// Get the character.
< 				value = rune(parser.raw_buffer[parser.raw_buffer_pos+low]) +
< 					(rune(parser.raw_buffer[parser.raw_buffer_pos+high]) << 8)
< 
< 				// Check for unexpected low surrogate area.
< 				if value&0xFC00 == 0xDC00 {
< 					return yaml_parser_set_reader_error(parser,
< 						"unexpected low surrogate area",
< 						parser.offset, int(value))
< 				}
< 
< 				// Check for a high surrogate area.
< 				if value&0xFC00 == 0xD800 {
< 					width = 4
< 
< 					// Check for incomplete surrogate pair.
< 					if raw_unread < 4 {
< 						if parser.eof {
< 							return yaml_parser_set_reader_error(parser,
< 								"incomplete UTF-16 surrogate pair",
< 								parser.offset, -1)
< 						}
< 						break inner
< 					}
< 
< 					// Get the next character.
< 					value2 := rune(parser.raw_buffer[parser.raw_buffer_pos+low+2]) +
< 						(rune(parser.raw_buffer[parser.raw_buffer_pos+high+2]) << 8)
< 
< 					// Check for a low surrogate area.
< 					if value2&0xFC00 != 0xDC00 {
< 						return yaml_parser_set_reader_error(parser,
< 							"expected low surrogate area",
< 							parser.offset+2, int(value2))
< 					}
< 
< 					// Generate the value of the surrogate pair.
< 					value = 0x10000 + ((value & 0x3FF) << 10) + (value2 & 0x3FF)
< 				} else {
< 					width = 2
< 				}
< 
< 			default:
< 				panic("impossible")
< 			}
< 
< 			// Check if the character is in the allowed range:
< 			//      #x9 | #xA | #xD | [#x20-#x7E]               (8 bit)
< 			//      | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD]    (16 bit)
< 			//      | [#x10000-#x10FFFF]                        (32 bit)
< 			switch {
< 			case value == 0x09:
< 			case value == 0x0A:
< 			case value == 0x0D:
< 			case value >= 0x20 && value <= 0x7E:
< 			case value == 0x85:
< 			case value >= 0xA0 && value <= 0xD7FF:
< 			case value >= 0xE000 && value <= 0xFFFD:
< 			case value >= 0x10000 && value <= 0x10FFFF:
< 			default:
< 				return yaml_parser_set_reader_error(parser,
< 					"control characters are not allowed",
< 					parser.offset, int(value))
< 			}
< 
< 			// Move the raw pointers.
< 			parser.raw_buffer_pos += width
< 			parser.offset += width
< 
< 			// Finally put the character into the buffer.
< 			if value <= 0x7F {
< 				// 0000 0000-0000 007F . 0xxxxxxx
< 				parser.buffer[buffer_len+0] = byte(value)
< 				buffer_len += 1
< 			} else if value <= 0x7FF {
< 				// 0000 0080-0000 07FF . 110xxxxx 10xxxxxx
< 				parser.buffer[buffer_len+0] = byte(0xC0 + (value >> 6))
< 				parser.buffer[buffer_len+1] = byte(0x80 + (value & 0x3F))
< 				buffer_len += 2
< 			} else if value <= 0xFFFF {
< 				// 0000 0800-0000 FFFF . 1110xxxx 10xxxxxx 10xxxxxx
< 				parser.buffer[buffer_len+0] = byte(0xE0 + (value >> 12))
< 				parser.buffer[buffer_len+1] = byte(0x80 + ((value >> 6) & 0x3F))
< 				parser.buffer[buffer_len+2] = byte(0x80 + (value & 0x3F))
< 				buffer_len += 3
< 			} else {
< 				// 0001 0000-0010 FFFF . 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
< 				parser.buffer[buffer_len+0] = byte(0xF0 + (value >> 18))
< 				parser.buffer[buffer_len+1] = byte(0x80 + ((value >> 12) & 0x3F))
< 				parser.buffer[buffer_len+2] = byte(0x80 + ((value >> 6) & 0x3F))
< 				parser.buffer[buffer_len+3] = byte(0x80 + (value & 0x3F))
< 				buffer_len += 4
< 			}
< 
< 			parser.unread++
< 		}
< 
< 		// On EOF, put NUL into the buffer and return.
< 		if parser.eof {
< 			parser.buffer[buffer_len] = 0
< 			buffer_len++
< 			parser.unread++
< 			break
< 		}
< 	}
< 	// [Go] Read the documentation of this function above. To return true,
< 	// we need to have the given length in the buffer. Not doing that means
< 	// every single check that calls this function to make sure the buffer
< 	// has a given length is Go) panicking; or C) accessing invalid memory.
< 	// This happens here due to the EOF above breaking early.
< 	for buffer_len < length {
< 		parser.buffer[buffer_len] = 0
< 		buffer_len++
< 	}
< 	parser.buffer = parser.buffer[:buffer_len]
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/resolve.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/resolve.go
1,258d0
< package yaml
< 
< import (
< 	"encoding/base64"
< 	"math"
< 	"regexp"
< 	"strconv"
< 	"strings"
< 	"time"
< )
< 
< type resolveMapItem struct {
< 	value interface{}
< 	tag   string
< }
< 
< var resolveTable = make([]byte, 256)
< var resolveMap = make(map[string]resolveMapItem)
< 
< func init() {
< 	t := resolveTable
< 	t[int('+')] = 'S' // Sign
< 	t[int('-')] = 'S'
< 	for _, c := range "0123456789" {
< 		t[int(c)] = 'D' // Digit
< 	}
< 	for _, c := range "yYnNtTfFoO~" {
< 		t[int(c)] = 'M' // In map
< 	}
< 	t[int('.')] = '.' // Float (potentially in map)
< 
< 	var resolveMapList = []struct {
< 		v   interface{}
< 		tag string
< 		l   []string
< 	}{
< 		{true, yaml_BOOL_TAG, []string{"y", "Y", "yes", "Yes", "YES"}},
< 		{true, yaml_BOOL_TAG, []string{"true", "True", "TRUE"}},
< 		{true, yaml_BOOL_TAG, []string{"on", "On", "ON"}},
< 		{false, yaml_BOOL_TAG, []string{"n", "N", "no", "No", "NO"}},
< 		{false, yaml_BOOL_TAG, []string{"false", "False", "FALSE"}},
< 		{false, yaml_BOOL_TAG, []string{"off", "Off", "OFF"}},
< 		{nil, yaml_NULL_TAG, []string{"", "~", "null", "Null", "NULL"}},
< 		{math.NaN(), yaml_FLOAT_TAG, []string{".nan", ".NaN", ".NAN"}},
< 		{math.Inf(+1), yaml_FLOAT_TAG, []string{".inf", ".Inf", ".INF"}},
< 		{math.Inf(+1), yaml_FLOAT_TAG, []string{"+.inf", "+.Inf", "+.INF"}},
< 		{math.Inf(-1), yaml_FLOAT_TAG, []string{"-.inf", "-.Inf", "-.INF"}},
< 		{"<<", yaml_MERGE_TAG, []string{"<<"}},
< 	}
< 
< 	m := resolveMap
< 	for _, item := range resolveMapList {
< 		for _, s := range item.l {
< 			m[s] = resolveMapItem{item.v, item.tag}
< 		}
< 	}
< }
< 
< const longTagPrefix = "tag:yaml.org,2002:"
< 
< func shortTag(tag string) string {
< 	// TODO This can easily be made faster and produce less garbage.
< 	if strings.HasPrefix(tag, longTagPrefix) {
< 		return "!!" + tag[len(longTagPrefix):]
< 	}
< 	return tag
< }
< 
< func longTag(tag string) string {
< 	if strings.HasPrefix(tag, "!!") {
< 		return longTagPrefix + tag[2:]
< 	}
< 	return tag
< }
< 
< func resolvableTag(tag string) bool {
< 	switch tag {
< 	case "", yaml_STR_TAG, yaml_BOOL_TAG, yaml_INT_TAG, yaml_FLOAT_TAG, yaml_NULL_TAG, yaml_TIMESTAMP_TAG:
< 		return true
< 	}
< 	return false
< }
< 
< var yamlStyleFloat = regexp.MustCompile(`^[-+]?[0-9]*\.?[0-9]+([eE][-+][0-9]+)?$`)
< 
< func resolve(tag string, in string) (rtag string, out interface{}) {
< 	if !resolvableTag(tag) {
< 		return tag, in
< 	}
< 
< 	defer func() {
< 		switch tag {
< 		case "", rtag, yaml_STR_TAG, yaml_BINARY_TAG:
< 			return
< 		case yaml_FLOAT_TAG:
< 			if rtag == yaml_INT_TAG {
< 				switch v := out.(type) {
< 				case int64:
< 					rtag = yaml_FLOAT_TAG
< 					out = float64(v)
< 					return
< 				case int:
< 					rtag = yaml_FLOAT_TAG
< 					out = float64(v)
< 					return
< 				}
< 			}
< 		}
< 		failf("cannot decode %s `%s` as a %s", shortTag(rtag), in, shortTag(tag))
< 	}()
< 
< 	// Any data is accepted as a !!str or !!binary.
< 	// Otherwise, the prefix is enough of a hint about what it might be.
< 	hint := byte('N')
< 	if in != "" {
< 		hint = resolveTable[in[0]]
< 	}
< 	if hint != 0 && tag != yaml_STR_TAG && tag != yaml_BINARY_TAG {
< 		// Handle things we can lookup in a map.
< 		if item, ok := resolveMap[in]; ok {
< 			return item.tag, item.value
< 		}
< 
< 		// Base 60 floats are a bad idea, were dropped in YAML 1.2, and
< 		// are purposefully unsupported here. They're still quoted on
< 		// the way out for compatibility with other parser, though.
< 
< 		switch hint {
< 		case 'M':
< 			// We've already checked the map above.
< 
< 		case '.':
< 			// Not in the map, so maybe a normal float.
< 			floatv, err := strconv.ParseFloat(in, 64)
< 			if err == nil {
< 				return yaml_FLOAT_TAG, floatv
< 			}
< 
< 		case 'D', 'S':
< 			// Int, float, or timestamp.
< 			// Only try values as a timestamp if the value is unquoted or there's an explicit
< 			// !!timestamp tag.
< 			if tag == "" || tag == yaml_TIMESTAMP_TAG {
< 				t, ok := parseTimestamp(in)
< 				if ok {
< 					return yaml_TIMESTAMP_TAG, t
< 				}
< 			}
< 
< 			plain := strings.Replace(in, "_", "", -1)
< 			intv, err := strconv.ParseInt(plain, 0, 64)
< 			if err == nil {
< 				if intv == int64(int(intv)) {
< 					return yaml_INT_TAG, int(intv)
< 				} else {
< 					return yaml_INT_TAG, intv
< 				}
< 			}
< 			uintv, err := strconv.ParseUint(plain, 0, 64)
< 			if err == nil {
< 				return yaml_INT_TAG, uintv
< 			}
< 			if yamlStyleFloat.MatchString(plain) {
< 				floatv, err := strconv.ParseFloat(plain, 64)
< 				if err == nil {
< 					return yaml_FLOAT_TAG, floatv
< 				}
< 			}
< 			if strings.HasPrefix(plain, "0b") {
< 				intv, err := strconv.ParseInt(plain[2:], 2, 64)
< 				if err == nil {
< 					if intv == int64(int(intv)) {
< 						return yaml_INT_TAG, int(intv)
< 					} else {
< 						return yaml_INT_TAG, intv
< 					}
< 				}
< 				uintv, err := strconv.ParseUint(plain[2:], 2, 64)
< 				if err == nil {
< 					return yaml_INT_TAG, uintv
< 				}
< 			} else if strings.HasPrefix(plain, "-0b") {
< 				intv, err := strconv.ParseInt("-" + plain[3:], 2, 64)
< 				if err == nil {
< 					if true || intv == int64(int(intv)) {
< 						return yaml_INT_TAG, int(intv)
< 					} else {
< 						return yaml_INT_TAG, intv
< 					}
< 				}
< 			}
< 		default:
< 			panic("resolveTable item not yet handled: " + string(rune(hint)) + " (with " + in + ")")
< 		}
< 	}
< 	return yaml_STR_TAG, in
< }
< 
< // encodeBase64 encodes s as base64 that is broken up into multiple lines
< // as appropriate for the resulting length.
< func encodeBase64(s string) string {
< 	const lineLen = 70
< 	encLen := base64.StdEncoding.EncodedLen(len(s))
< 	lines := encLen/lineLen + 1
< 	buf := make([]byte, encLen*2+lines)
< 	in := buf[0:encLen]
< 	out := buf[encLen:]
< 	base64.StdEncoding.Encode(in, []byte(s))
< 	k := 0
< 	for i := 0; i < len(in); i += lineLen {
< 		j := i + lineLen
< 		if j > len(in) {
< 			j = len(in)
< 		}
< 		k += copy(out[k:], in[i:j])
< 		if lines > 1 {
< 			out[k] = '\n'
< 			k++
< 		}
< 	}
< 	return string(out[:k])
< }
< 
< // This is a subset of the formats allowed by the regular expression
< // defined at http://yaml.org/type/timestamp.html.
< var allowedTimestampFormats = []string{
< 	"2006-1-2T15:4:5.999999999Z07:00", // RCF3339Nano with short date fields.
< 	"2006-1-2t15:4:5.999999999Z07:00", // RFC3339Nano with short date fields and lower-case "t".
< 	"2006-1-2 15:4:5.999999999",       // space separated with no time zone
< 	"2006-1-2",                        // date only
< 	// Notable exception: time.Parse cannot handle: "2001-12-14 21:59:43.10 -5"
< 	// from the set of examples.
< }
< 
< // parseTimestamp parses s as a timestamp string and
< // returns the timestamp and reports whether it succeeded.
< // Timestamp formats are defined at http://yaml.org/type/timestamp.html
< func parseTimestamp(s string) (time.Time, bool) {
< 	// TODO write code to check all the formats supported by
< 	// http://yaml.org/type/timestamp.html instead of using time.Parse.
< 
< 	// Quick check: all date formats start with YYYY-.
< 	i := 0
< 	for ; i < len(s); i++ {
< 		if c := s[i]; c < '0' || c > '9' {
< 			break
< 		}
< 	}
< 	if i != 4 || i == len(s) || s[i] != '-' {
< 		return time.Time{}, false
< 	}
< 	for _, format := range allowedTimestampFormats {
< 		if t, err := time.Parse(format, s); err == nil {
< 			return t, true
< 		}
< 	}
< 	return time.Time{}, false
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/scannerc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/scannerc.go
1,2696d0
< package yaml
< 
< import (
< 	"bytes"
< 	"fmt"
< )
< 
< // Introduction
< // ************
< //
< // The following notes assume that you are familiar with the YAML specification
< // (http://yaml.org/spec/1.2/spec.html).  We mostly follow it, although in
< // some cases we are less restrictive that it requires.
< //
< // The process of transforming a YAML stream into a sequence of events is
< // divided on two steps: Scanning and Parsing.
< //
< // The Scanner transforms the input stream into a sequence of tokens, while the
< // parser transform the sequence of tokens produced by the Scanner into a
< // sequence of parsing events.
< //
< // The Scanner is rather clever and complicated. The Parser, on the contrary,
< // is a straightforward implementation of a recursive-descendant parser (or,
< // LL(1) parser, as it is usually called).
< //
< // Actually there are two issues of Scanning that might be called "clever", the
< // rest is quite straightforward.  The issues are "block collection start" and
< // "simple keys".  Both issues are explained below in details.
< //
< // Here the Scanning step is explained and implemented.  We start with the list
< // of all the tokens produced by the Scanner together with short descriptions.
< //
< // Now, tokens:
< //
< //      STREAM-START(encoding)          # The stream start.
< //      STREAM-END                      # The stream end.
< //      VERSION-DIRECTIVE(major,minor)  # The '%YAML' directive.
< //      TAG-DIRECTIVE(handle,prefix)    # The '%TAG' directive.
< //      DOCUMENT-START                  # '---'
< //      DOCUMENT-END                    # '...'
< //      BLOCK-SEQUENCE-START            # Indentation increase denoting a block
< //      BLOCK-MAPPING-START             # sequence or a block mapping.
< //      BLOCK-END                       # Indentation decrease.
< //      FLOW-SEQUENCE-START             # '['
< //      FLOW-SEQUENCE-END               # ']'
< //      BLOCK-SEQUENCE-START            # '{'
< //      BLOCK-SEQUENCE-END              # '}'
< //      BLOCK-ENTRY                     # '-'
< //      FLOW-ENTRY                      # ','
< //      KEY                             # '?' or nothing (simple keys).
< //      VALUE                           # ':'
< //      ALIAS(anchor)                   # '*anchor'
< //      ANCHOR(anchor)                  # '&anchor'
< //      TAG(handle,suffix)              # '!handle!suffix'
< //      SCALAR(value,style)             # A scalar.
< //
< // The following two tokens are "virtual" tokens denoting the beginning and the
< // end of the stream:
< //
< //      STREAM-START(encoding)
< //      STREAM-END
< //
< // We pass the information about the input stream encoding with the
< // STREAM-START token.
< //
< // The next two tokens are responsible for tags:
< //
< //      VERSION-DIRECTIVE(major,minor)
< //      TAG-DIRECTIVE(handle,prefix)
< //
< // Example:
< //
< //      %YAML   1.1
< //      %TAG    !   !foo
< //      %TAG    !yaml!  tag:yaml.org,2002:
< //      ---
< //
< // The correspoding sequence of tokens:
< //
< //      STREAM-START(utf-8)
< //      VERSION-DIRECTIVE(1,1)
< //      TAG-DIRECTIVE("!","!foo")
< //      TAG-DIRECTIVE("!yaml","tag:yaml.org,2002:")
< //      DOCUMENT-START
< //      STREAM-END
< //
< // Note that the VERSION-DIRECTIVE and TAG-DIRECTIVE tokens occupy a whole
< // line.
< //
< // The document start and end indicators are represented by:
< //
< //      DOCUMENT-START
< //      DOCUMENT-END
< //
< // Note that if a YAML stream contains an implicit document (without '---'
< // and '...' indicators), no DOCUMENT-START and DOCUMENT-END tokens will be
< // produced.
< //
< // In the following examples, we present whole documents together with the
< // produced tokens.
< //
< //      1. An implicit document:
< //
< //          'a scalar'
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          SCALAR("a scalar",single-quoted)
< //          STREAM-END
< //
< //      2. An explicit document:
< //
< //          ---
< //          'a scalar'
< //          ...
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          DOCUMENT-START
< //          SCALAR("a scalar",single-quoted)
< //          DOCUMENT-END
< //          STREAM-END
< //
< //      3. Several documents in a stream:
< //
< //          'a scalar'
< //          ---
< //          'another scalar'
< //          ---
< //          'yet another scalar'
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          SCALAR("a scalar",single-quoted)
< //          DOCUMENT-START
< //          SCALAR("another scalar",single-quoted)
< //          DOCUMENT-START
< //          SCALAR("yet another scalar",single-quoted)
< //          STREAM-END
< //
< // We have already introduced the SCALAR token above.  The following tokens are
< // used to describe aliases, anchors, tag, and scalars:
< //
< //      ALIAS(anchor)
< //      ANCHOR(anchor)
< //      TAG(handle,suffix)
< //      SCALAR(value,style)
< //
< // The following series of examples illustrate the usage of these tokens:
< //
< //      1. A recursive sequence:
< //
< //          &A [ *A ]
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          ANCHOR("A")
< //          FLOW-SEQUENCE-START
< //          ALIAS("A")
< //          FLOW-SEQUENCE-END
< //          STREAM-END
< //
< //      2. A tagged scalar:
< //
< //          !!float "3.14"  # A good approximation.
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          TAG("!!","float")
< //          SCALAR("3.14",double-quoted)
< //          STREAM-END
< //
< //      3. Various scalar styles:
< //
< //          --- # Implicit empty plain scalars do not produce tokens.
< //          --- a plain scalar
< //          --- 'a single-quoted scalar'
< //          --- "a double-quoted scalar"
< //          --- |-
< //            a literal scalar
< //          --- >-
< //            a folded
< //            scalar
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          DOCUMENT-START
< //          DOCUMENT-START
< //          SCALAR("a plain scalar",plain)
< //          DOCUMENT-START
< //          SCALAR("a single-quoted scalar",single-quoted)
< //          DOCUMENT-START
< //          SCALAR("a double-quoted scalar",double-quoted)
< //          DOCUMENT-START
< //          SCALAR("a literal scalar",literal)
< //          DOCUMENT-START
< //          SCALAR("a folded scalar",folded)
< //          STREAM-END
< //
< // Now it's time to review collection-related tokens. We will start with
< // flow collections:
< //
< //      FLOW-SEQUENCE-START
< //      FLOW-SEQUENCE-END
< //      FLOW-MAPPING-START
< //      FLOW-MAPPING-END
< //      FLOW-ENTRY
< //      KEY
< //      VALUE
< //
< // The tokens FLOW-SEQUENCE-START, FLOW-SEQUENCE-END, FLOW-MAPPING-START, and
< // FLOW-MAPPING-END represent the indicators '[', ']', '{', and '}'
< // correspondingly.  FLOW-ENTRY represent the ',' indicator.  Finally the
< // indicators '?' and ':', which are used for denoting mapping keys and values,
< // are represented by the KEY and VALUE tokens.
< //
< // The following examples show flow collections:
< //
< //      1. A flow sequence:
< //
< //          [item 1, item 2, item 3]
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          FLOW-SEQUENCE-START
< //          SCALAR("item 1",plain)
< //          FLOW-ENTRY
< //          SCALAR("item 2",plain)
< //          FLOW-ENTRY
< //          SCALAR("item 3",plain)
< //          FLOW-SEQUENCE-END
< //          STREAM-END
< //
< //      2. A flow mapping:
< //
< //          {
< //              a simple key: a value,  # Note that the KEY token is produced.
< //              ? a complex key: another value,
< //          }
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          FLOW-MAPPING-START
< //          KEY
< //          SCALAR("a simple key",plain)
< //          VALUE
< //          SCALAR("a value",plain)
< //          FLOW-ENTRY
< //          KEY
< //          SCALAR("a complex key",plain)
< //          VALUE
< //          SCALAR("another value",plain)
< //          FLOW-ENTRY
< //          FLOW-MAPPING-END
< //          STREAM-END
< //
< // A simple key is a key which is not denoted by the '?' indicator.  Note that
< // the Scanner still produce the KEY token whenever it encounters a simple key.
< //
< // For scanning block collections, the following tokens are used (note that we
< // repeat KEY and VALUE here):
< //
< //      BLOCK-SEQUENCE-START
< //      BLOCK-MAPPING-START
< //      BLOCK-END
< //      BLOCK-ENTRY
< //      KEY
< //      VALUE
< //
< // The tokens BLOCK-SEQUENCE-START and BLOCK-MAPPING-START denote indentation
< // increase that precedes a block collection (cf. the INDENT token in Python).
< // The token BLOCK-END denote indentation decrease that ends a block collection
< // (cf. the DEDENT token in Python).  However YAML has some syntax pecularities
< // that makes detections of these tokens more complex.
< //
< // The tokens BLOCK-ENTRY, KEY, and VALUE are used to represent the indicators
< // '-', '?', and ':' correspondingly.
< //
< // The following examples show how the tokens BLOCK-SEQUENCE-START,
< // BLOCK-MAPPING-START, and BLOCK-END are emitted by the Scanner:
< //
< //      1. Block sequences:
< //
< //          - item 1
< //          - item 2
< //          -
< //            - item 3.1
< //            - item 3.2
< //          -
< //            key 1: value 1
< //            key 2: value 2
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 2",plain)
< //          BLOCK-ENTRY
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 3.1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 3.2",plain)
< //          BLOCK-END
< //          BLOCK-ENTRY
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("key 1",plain)
< //          VALUE
< //          SCALAR("value 1",plain)
< //          KEY
< //          SCALAR("key 2",plain)
< //          VALUE
< //          SCALAR("value 2",plain)
< //          BLOCK-END
< //          BLOCK-END
< //          STREAM-END
< //
< //      2. Block mappings:
< //
< //          a simple key: a value   # The KEY token is produced here.
< //          ? a complex key
< //          : another value
< //          a mapping:
< //            key 1: value 1
< //            key 2: value 2
< //          a sequence:
< //            - item 1
< //            - item 2
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("a simple key",plain)
< //          VALUE
< //          SCALAR("a value",plain)
< //          KEY
< //          SCALAR("a complex key",plain)
< //          VALUE
< //          SCALAR("another value",plain)
< //          KEY
< //          SCALAR("a mapping",plain)
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("key 1",plain)
< //          VALUE
< //          SCALAR("value 1",plain)
< //          KEY
< //          SCALAR("key 2",plain)
< //          VALUE
< //          SCALAR("value 2",plain)
< //          BLOCK-END
< //          KEY
< //          SCALAR("a sequence",plain)
< //          VALUE
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 2",plain)
< //          BLOCK-END
< //          BLOCK-END
< //          STREAM-END
< //
< // YAML does not always require to start a new block collection from a new
< // line.  If the current line contains only '-', '?', and ':' indicators, a new
< // block collection may start at the current line.  The following examples
< // illustrate this case:
< //
< //      1. Collections in a sequence:
< //
< //          - - item 1
< //            - item 2
< //          - key 1: value 1
< //            key 2: value 2
< //          - ? complex key
< //            : complex value
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 2",plain)
< //          BLOCK-END
< //          BLOCK-ENTRY
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("key 1",plain)
< //          VALUE
< //          SCALAR("value 1",plain)
< //          KEY
< //          SCALAR("key 2",plain)
< //          VALUE
< //          SCALAR("value 2",plain)
< //          BLOCK-END
< //          BLOCK-ENTRY
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("complex key")
< //          VALUE
< //          SCALAR("complex value")
< //          BLOCK-END
< //          BLOCK-END
< //          STREAM-END
< //
< //      2. Collections in a mapping:
< //
< //          ? a sequence
< //          : - item 1
< //            - item 2
< //          ? a mapping
< //          : key 1: value 1
< //            key 2: value 2
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("a sequence",plain)
< //          VALUE
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 2",plain)
< //          BLOCK-END
< //          KEY
< //          SCALAR("a mapping",plain)
< //          VALUE
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("key 1",plain)
< //          VALUE
< //          SCALAR("value 1",plain)
< //          KEY
< //          SCALAR("key 2",plain)
< //          VALUE
< //          SCALAR("value 2",plain)
< //          BLOCK-END
< //          BLOCK-END
< //          STREAM-END
< //
< // YAML also permits non-indented sequences if they are included into a block
< // mapping.  In this case, the token BLOCK-SEQUENCE-START is not produced:
< //
< //      key:
< //      - item 1    # BLOCK-SEQUENCE-START is NOT produced here.
< //      - item 2
< //
< // Tokens:
< //
< //      STREAM-START(utf-8)
< //      BLOCK-MAPPING-START
< //      KEY
< //      SCALAR("key",plain)
< //      VALUE
< //      BLOCK-ENTRY
< //      SCALAR("item 1",plain)
< //      BLOCK-ENTRY
< //      SCALAR("item 2",plain)
< //      BLOCK-END
< //
< 
< // Ensure that the buffer contains the required number of characters.
< // Return true on success, false on failure (reader error or memory error).
< func cache(parser *yaml_parser_t, length int) bool {
< 	// [Go] This was inlined: !cache(A, B) -> unread < B && !update(A, B)
< 	return parser.unread >= length || yaml_parser_update_buffer(parser, length)
< }
< 
< // Advance the buffer pointer.
< func skip(parser *yaml_parser_t) {
< 	parser.mark.index++
< 	parser.mark.column++
< 	parser.unread--
< 	parser.buffer_pos += width(parser.buffer[parser.buffer_pos])
< }
< 
< func skip_line(parser *yaml_parser_t) {
< 	if is_crlf(parser.buffer, parser.buffer_pos) {
< 		parser.mark.index += 2
< 		parser.mark.column = 0
< 		parser.mark.line++
< 		parser.unread -= 2
< 		parser.buffer_pos += 2
< 	} else if is_break(parser.buffer, parser.buffer_pos) {
< 		parser.mark.index++
< 		parser.mark.column = 0
< 		parser.mark.line++
< 		parser.unread--
< 		parser.buffer_pos += width(parser.buffer[parser.buffer_pos])
< 	}
< }
< 
< // Copy a character to a string buffer and advance pointers.
< func read(parser *yaml_parser_t, s []byte) []byte {
< 	w := width(parser.buffer[parser.buffer_pos])
< 	if w == 0 {
< 		panic("invalid character sequence")
< 	}
< 	if len(s) == 0 {
< 		s = make([]byte, 0, 32)
< 	}
< 	if w == 1 && len(s)+w <= cap(s) {
< 		s = s[:len(s)+1]
< 		s[len(s)-1] = parser.buffer[parser.buffer_pos]
< 		parser.buffer_pos++
< 	} else {
< 		s = append(s, parser.buffer[parser.buffer_pos:parser.buffer_pos+w]...)
< 		parser.buffer_pos += w
< 	}
< 	parser.mark.index++
< 	parser.mark.column++
< 	parser.unread--
< 	return s
< }
< 
< // Copy a line break character to a string buffer and advance pointers.
< func read_line(parser *yaml_parser_t, s []byte) []byte {
< 	buf := parser.buffer
< 	pos := parser.buffer_pos
< 	switch {
< 	case buf[pos] == '\r' && buf[pos+1] == '\n':
< 		// CR LF . LF
< 		s = append(s, '\n')
< 		parser.buffer_pos += 2
< 		parser.mark.index++
< 		parser.unread--
< 	case buf[pos] == '\r' || buf[pos] == '\n':
< 		// CR|LF . LF
< 		s = append(s, '\n')
< 		parser.buffer_pos += 1
< 	case buf[pos] == '\xC2' && buf[pos+1] == '\x85':
< 		// NEL . LF
< 		s = append(s, '\n')
< 		parser.buffer_pos += 2
< 	case buf[pos] == '\xE2' && buf[pos+1] == '\x80' && (buf[pos+2] == '\xA8' || buf[pos+2] == '\xA9'):
< 		// LS|PS . LS|PS
< 		s = append(s, buf[parser.buffer_pos:pos+3]...)
< 		parser.buffer_pos += 3
< 	default:
< 		return s
< 	}
< 	parser.mark.index++
< 	parser.mark.column = 0
< 	parser.mark.line++
< 	parser.unread--
< 	return s
< }
< 
< // Get the next token.
< func yaml_parser_scan(parser *yaml_parser_t, token *yaml_token_t) bool {
< 	// Erase the token object.
< 	*token = yaml_token_t{} // [Go] Is this necessary?
< 
< 	// No tokens after STREAM-END or error.
< 	if parser.stream_end_produced || parser.error != yaml_NO_ERROR {
< 		return true
< 	}
< 
< 	// Ensure that the tokens queue contains enough tokens.
< 	if !parser.token_available {
< 		if !yaml_parser_fetch_more_tokens(parser) {
< 			return false
< 		}
< 	}
< 
< 	// Fetch the next token from the queue.
< 	*token = parser.tokens[parser.tokens_head]
< 	parser.tokens_head++
< 	parser.tokens_parsed++
< 	parser.token_available = false
< 
< 	if token.typ == yaml_STREAM_END_TOKEN {
< 		parser.stream_end_produced = true
< 	}
< 	return true
< }
< 
< // Set the scanner error and return false.
< func yaml_parser_set_scanner_error(parser *yaml_parser_t, context string, context_mark yaml_mark_t, problem string) bool {
< 	parser.error = yaml_SCANNER_ERROR
< 	parser.context = context
< 	parser.context_mark = context_mark
< 	parser.problem = problem
< 	parser.problem_mark = parser.mark
< 	return false
< }
< 
< func yaml_parser_set_scanner_tag_error(parser *yaml_parser_t, directive bool, context_mark yaml_mark_t, problem string) bool {
< 	context := "while parsing a tag"
< 	if directive {
< 		context = "while parsing a %TAG directive"
< 	}
< 	return yaml_parser_set_scanner_error(parser, context, context_mark, problem)
< }
< 
< func trace(args ...interface{}) func() {
< 	pargs := append([]interface{}{"+++"}, args...)
< 	fmt.Println(pargs...)
< 	pargs = append([]interface{}{"---"}, args...)
< 	return func() { fmt.Println(pargs...) }
< }
< 
< // Ensure that the tokens queue contains at least one token which can be
< // returned to the Parser.
< func yaml_parser_fetch_more_tokens(parser *yaml_parser_t) bool {
< 	// While we need more tokens to fetch, do it.
< 	for {
< 		// Check if we really need to fetch more tokens.
< 		need_more_tokens := false
< 
< 		if parser.tokens_head == len(parser.tokens) {
< 			// Queue is empty.
< 			need_more_tokens = true
< 		} else {
< 			// Check if any potential simple key may occupy the head position.
< 			if !yaml_parser_stale_simple_keys(parser) {
< 				return false
< 			}
< 
< 			for i := range parser.simple_keys {
< 				simple_key := &parser.simple_keys[i]
< 				if simple_key.possible && simple_key.token_number == parser.tokens_parsed {
< 					need_more_tokens = true
< 					break
< 				}
< 			}
< 		}
< 
< 		// We are finished.
< 		if !need_more_tokens {
< 			break
< 		}
< 		// Fetch the next token.
< 		if !yaml_parser_fetch_next_token(parser) {
< 			return false
< 		}
< 	}
< 
< 	parser.token_available = true
< 	return true
< }
< 
< // The dispatcher for token fetchers.
< func yaml_parser_fetch_next_token(parser *yaml_parser_t) bool {
< 	// Ensure that the buffer is initialized.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	// Check if we just started scanning.  Fetch STREAM-START then.
< 	if !parser.stream_start_produced {
< 		return yaml_parser_fetch_stream_start(parser)
< 	}
< 
< 	// Eat whitespaces and comments until we reach the next token.
< 	if !yaml_parser_scan_to_next_token(parser) {
< 		return false
< 	}
< 
< 	// Remove obsolete potential simple keys.
< 	if !yaml_parser_stale_simple_keys(parser) {
< 		return false
< 	}
< 
< 	// Check the indentation level against the current column.
< 	if !yaml_parser_unroll_indent(parser, parser.mark.column) {
< 		return false
< 	}
< 
< 	// Ensure that the buffer contains at least 4 characters.  4 is the length
< 	// of the longest indicators ('--- ' and '... ').
< 	if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
< 		return false
< 	}
< 
< 	// Is it the end of the stream?
< 	if is_z(parser.buffer, parser.buffer_pos) {
< 		return yaml_parser_fetch_stream_end(parser)
< 	}
< 
< 	// Is it a directive?
< 	if parser.mark.column == 0 && parser.buffer[parser.buffer_pos] == '%' {
< 		return yaml_parser_fetch_directive(parser)
< 	}
< 
< 	buf := parser.buffer
< 	pos := parser.buffer_pos
< 
< 	// Is it the document start indicator?
< 	if parser.mark.column == 0 && buf[pos] == '-' && buf[pos+1] == '-' && buf[pos+2] == '-' && is_blankz(buf, pos+3) {
< 		return yaml_parser_fetch_document_indicator(parser, yaml_DOCUMENT_START_TOKEN)
< 	}
< 
< 	// Is it the document end indicator?
< 	if parser.mark.column == 0 && buf[pos] == '.' && buf[pos+1] == '.' && buf[pos+2] == '.' && is_blankz(buf, pos+3) {
< 		return yaml_parser_fetch_document_indicator(parser, yaml_DOCUMENT_END_TOKEN)
< 	}
< 
< 	// Is it the flow sequence start indicator?
< 	if buf[pos] == '[' {
< 		return yaml_parser_fetch_flow_collection_start(parser, yaml_FLOW_SEQUENCE_START_TOKEN)
< 	}
< 
< 	// Is it the flow mapping start indicator?
< 	if parser.buffer[parser.buffer_pos] == '{' {
< 		return yaml_parser_fetch_flow_collection_start(parser, yaml_FLOW_MAPPING_START_TOKEN)
< 	}
< 
< 	// Is it the flow sequence end indicator?
< 	if parser.buffer[parser.buffer_pos] == ']' {
< 		return yaml_parser_fetch_flow_collection_end(parser,
< 			yaml_FLOW_SEQUENCE_END_TOKEN)
< 	}
< 
< 	// Is it the flow mapping end indicator?
< 	if parser.buffer[parser.buffer_pos] == '}' {
< 		return yaml_parser_fetch_flow_collection_end(parser,
< 			yaml_FLOW_MAPPING_END_TOKEN)
< 	}
< 
< 	// Is it the flow entry indicator?
< 	if parser.buffer[parser.buffer_pos] == ',' {
< 		return yaml_parser_fetch_flow_entry(parser)
< 	}
< 
< 	// Is it the block entry indicator?
< 	if parser.buffer[parser.buffer_pos] == '-' && is_blankz(parser.buffer, parser.buffer_pos+1) {
< 		return yaml_parser_fetch_block_entry(parser)
< 	}
< 
< 	// Is it the key indicator?
< 	if parser.buffer[parser.buffer_pos] == '?' && (parser.flow_level > 0 || is_blankz(parser.buffer, parser.buffer_pos+1)) {
< 		return yaml_parser_fetch_key(parser)
< 	}
< 
< 	// Is it the value indicator?
< 	if parser.buffer[parser.buffer_pos] == ':' && (parser.flow_level > 0 || is_blankz(parser.buffer, parser.buffer_pos+1)) {
< 		return yaml_parser_fetch_value(parser)
< 	}
< 
< 	// Is it an alias?
< 	if parser.buffer[parser.buffer_pos] == '*' {
< 		return yaml_parser_fetch_anchor(parser, yaml_ALIAS_TOKEN)
< 	}
< 
< 	// Is it an anchor?
< 	if parser.buffer[parser.buffer_pos] == '&' {
< 		return yaml_parser_fetch_anchor(parser, yaml_ANCHOR_TOKEN)
< 	}
< 
< 	// Is it a tag?
< 	if parser.buffer[parser.buffer_pos] == '!' {
< 		return yaml_parser_fetch_tag(parser)
< 	}
< 
< 	// Is it a literal scalar?
< 	if parser.buffer[parser.buffer_pos] == '|' && parser.flow_level == 0 {
< 		return yaml_parser_fetch_block_scalar(parser, true)
< 	}
< 
< 	// Is it a folded scalar?
< 	if parser.buffer[parser.buffer_pos] == '>' && parser.flow_level == 0 {
< 		return yaml_parser_fetch_block_scalar(parser, false)
< 	}
< 
< 	// Is it a single-quoted scalar?
< 	if parser.buffer[parser.buffer_pos] == '\'' {
< 		return yaml_parser_fetch_flow_scalar(parser, true)
< 	}
< 
< 	// Is it a double-quoted scalar?
< 	if parser.buffer[parser.buffer_pos] == '"' {
< 		return yaml_parser_fetch_flow_scalar(parser, false)
< 	}
< 
< 	// Is it a plain scalar?
< 	//
< 	// A plain scalar may start with any non-blank characters except
< 	//
< 	//      '-', '?', ':', ',', '[', ']', '{', '}',
< 	//      '#', '&', '*', '!', '|', '>', '\'', '\"',
< 	//      '%', '@', '`'.
< 	//
< 	// In the block context (and, for the '-' indicator, in the flow context
< 	// too), it may also start with the characters
< 	//
< 	//      '-', '?', ':'
< 	//
< 	// if it is followed by a non-space character.
< 	//
< 	// The last rule is more restrictive than the specification requires.
< 	// [Go] Make this logic more reasonable.
< 	//switch parser.buffer[parser.buffer_pos] {
< 	//case '-', '?', ':', ',', '?', '-', ',', ':', ']', '[', '}', '{', '&', '#', '!', '*', '>', '|', '"', '\'', '@', '%', '-', '`':
< 	//}
< 	if !(is_blankz(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == '-' ||
< 		parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == ':' ||
< 		parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == '[' ||
< 		parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '{' ||
< 		parser.buffer[parser.buffer_pos] == '}' || parser.buffer[parser.buffer_pos] == '#' ||
< 		parser.buffer[parser.buffer_pos] == '&' || parser.buffer[parser.buffer_pos] == '*' ||
< 		parser.buffer[parser.buffer_pos] == '!' || parser.buffer[parser.buffer_pos] == '|' ||
< 		parser.buffer[parser.buffer_pos] == '>' || parser.buffer[parser.buffer_pos] == '\'' ||
< 		parser.buffer[parser.buffer_pos] == '"' || parser.buffer[parser.buffer_pos] == '%' ||
< 		parser.buffer[parser.buffer_pos] == '@' || parser.buffer[parser.buffer_pos] == '`') ||
< 		(parser.buffer[parser.buffer_pos] == '-' && !is_blank(parser.buffer, parser.buffer_pos+1)) ||
< 		(parser.flow_level == 0 &&
< 			(parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == ':') &&
< 			!is_blankz(parser.buffer, parser.buffer_pos+1)) {
< 		return yaml_parser_fetch_plain_scalar(parser)
< 	}
< 
< 	// If we don't determine the token type so far, it is an error.
< 	return yaml_parser_set_scanner_error(parser,
< 		"while scanning for the next token", parser.mark,
< 		"found character that cannot start any token")
< }
< 
< // Check the list of potential simple keys and remove the positions that
< // cannot contain simple keys anymore.
< func yaml_parser_stale_simple_keys(parser *yaml_parser_t) bool {
< 	// Check for a potential simple key for each flow level.
< 	for i := range parser.simple_keys {
< 		simple_key := &parser.simple_keys[i]
< 
< 		// The specification requires that a simple key
< 		//
< 		//  - is limited to a single line,
< 		//  - is shorter than 1024 characters.
< 		if simple_key.possible && (simple_key.mark.line < parser.mark.line || simple_key.mark.index+1024 < parser.mark.index) {
< 
< 			// Check if the potential simple key to be removed is required.
< 			if simple_key.required {
< 				return yaml_parser_set_scanner_error(parser,
< 					"while scanning a simple key", simple_key.mark,
< 					"could not find expected ':'")
< 			}
< 			simple_key.possible = false
< 		}
< 	}
< 	return true
< }
< 
< // Check if a simple key may start at the current position and add it if
< // needed.
< func yaml_parser_save_simple_key(parser *yaml_parser_t) bool {
< 	// A simple key is required at the current position if the scanner is in
< 	// the block context and the current column coincides with the indentation
< 	// level.
< 
< 	required := parser.flow_level == 0 && parser.indent == parser.mark.column
< 
< 	//
< 	// If the current position may start a simple key, save it.
< 	//
< 	if parser.simple_key_allowed {
< 		simple_key := yaml_simple_key_t{
< 			possible:     true,
< 			required:     required,
< 			token_number: parser.tokens_parsed + (len(parser.tokens) - parser.tokens_head),
< 		}
< 		simple_key.mark = parser.mark
< 
< 		if !yaml_parser_remove_simple_key(parser) {
< 			return false
< 		}
< 		parser.simple_keys[len(parser.simple_keys)-1] = simple_key
< 	}
< 	return true
< }
< 
< // Remove a potential simple key at the current flow level.
< func yaml_parser_remove_simple_key(parser *yaml_parser_t) bool {
< 	i := len(parser.simple_keys) - 1
< 	if parser.simple_keys[i].possible {
< 		// If the key is required, it is an error.
< 		if parser.simple_keys[i].required {
< 			return yaml_parser_set_scanner_error(parser,
< 				"while scanning a simple key", parser.simple_keys[i].mark,
< 				"could not find expected ':'")
< 		}
< 	}
< 	// Remove the key from the stack.
< 	parser.simple_keys[i].possible = false
< 	return true
< }
< 
< // Increase the flow level and resize the simple key list if needed.
< func yaml_parser_increase_flow_level(parser *yaml_parser_t) bool {
< 	// Reset the simple key on the next level.
< 	parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
< 
< 	// Increase the flow level.
< 	parser.flow_level++
< 	return true
< }
< 
< // Decrease the flow level.
< func yaml_parser_decrease_flow_level(parser *yaml_parser_t) bool {
< 	if parser.flow_level > 0 {
< 		parser.flow_level--
< 		parser.simple_keys = parser.simple_keys[:len(parser.simple_keys)-1]
< 	}
< 	return true
< }
< 
< // Push the current indentation level to the stack and set the new level
< // the current column is greater than the indentation level.  In this case,
< // append or insert the specified token into the token queue.
< func yaml_parser_roll_indent(parser *yaml_parser_t, column, number int, typ yaml_token_type_t, mark yaml_mark_t) bool {
< 	// In the flow context, do nothing.
< 	if parser.flow_level > 0 {
< 		return true
< 	}
< 
< 	if parser.indent < column {
< 		// Push the current indentation level to the stack and set the new
< 		// indentation level.
< 		parser.indents = append(parser.indents, parser.indent)
< 		parser.indent = column
< 
< 		// Create a token and insert it into the queue.
< 		token := yaml_token_t{
< 			typ:        typ,
< 			start_mark: mark,
< 			end_mark:   mark,
< 		}
< 		if number > -1 {
< 			number -= parser.tokens_parsed
< 		}
< 		yaml_insert_token(parser, number, &token)
< 	}
< 	return true
< }
< 
< // Pop indentation levels from the indents stack until the current level
< // becomes less or equal to the column.  For each indentation level, append
< // the BLOCK-END token.
< func yaml_parser_unroll_indent(parser *yaml_parser_t, column int) bool {
< 	// In the flow context, do nothing.
< 	if parser.flow_level > 0 {
< 		return true
< 	}
< 
< 	// Loop through the indentation levels in the stack.
< 	for parser.indent > column {
< 		// Create a token and append it to the queue.
< 		token := yaml_token_t{
< 			typ:        yaml_BLOCK_END_TOKEN,
< 			start_mark: parser.mark,
< 			end_mark:   parser.mark,
< 		}
< 		yaml_insert_token(parser, -1, &token)
< 
< 		// Pop the indentation level.
< 		parser.indent = parser.indents[len(parser.indents)-1]
< 		parser.indents = parser.indents[:len(parser.indents)-1]
< 	}
< 	return true
< }
< 
< // Initialize the scanner and produce the STREAM-START token.
< func yaml_parser_fetch_stream_start(parser *yaml_parser_t) bool {
< 
< 	// Set the initial indentation.
< 	parser.indent = -1
< 
< 	// Initialize the simple key stack.
< 	parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
< 
< 	// A simple key is allowed at the beginning of the stream.
< 	parser.simple_key_allowed = true
< 
< 	// We have started.
< 	parser.stream_start_produced = true
< 
< 	// Create the STREAM-START token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_STREAM_START_TOKEN,
< 		start_mark: parser.mark,
< 		end_mark:   parser.mark,
< 		encoding:   parser.encoding,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the STREAM-END token and shut down the scanner.
< func yaml_parser_fetch_stream_end(parser *yaml_parser_t) bool {
< 
< 	// Force new line.
< 	if parser.mark.column != 0 {
< 		parser.mark.column = 0
< 		parser.mark.line++
< 	}
< 
< 	// Reset the indentation level.
< 	if !yaml_parser_unroll_indent(parser, -1) {
< 		return false
< 	}
< 
< 	// Reset simple keys.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	parser.simple_key_allowed = false
< 
< 	// Create the STREAM-END token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_STREAM_END_TOKEN,
< 		start_mark: parser.mark,
< 		end_mark:   parser.mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce a VERSION-DIRECTIVE or TAG-DIRECTIVE token.
< func yaml_parser_fetch_directive(parser *yaml_parser_t) bool {
< 	// Reset the indentation level.
< 	if !yaml_parser_unroll_indent(parser, -1) {
< 		return false
< 	}
< 
< 	// Reset simple keys.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	parser.simple_key_allowed = false
< 
< 	// Create the YAML-DIRECTIVE or TAG-DIRECTIVE token.
< 	token := yaml_token_t{}
< 	if !yaml_parser_scan_directive(parser, &token) {
< 		return false
< 	}
< 	// Append the token to the queue.
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the DOCUMENT-START or DOCUMENT-END token.
< func yaml_parser_fetch_document_indicator(parser *yaml_parser_t, typ yaml_token_type_t) bool {
< 	// Reset the indentation level.
< 	if !yaml_parser_unroll_indent(parser, -1) {
< 		return false
< 	}
< 
< 	// Reset simple keys.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	parser.simple_key_allowed = false
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 
< 	skip(parser)
< 	skip(parser)
< 	skip(parser)
< 
< 	end_mark := parser.mark
< 
< 	// Create the DOCUMENT-START or DOCUMENT-END token.
< 	token := yaml_token_t{
< 		typ:        typ,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	// Append the token to the queue.
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the FLOW-SEQUENCE-START or FLOW-MAPPING-START token.
< func yaml_parser_fetch_flow_collection_start(parser *yaml_parser_t, typ yaml_token_type_t) bool {
< 	// The indicators '[' and '{' may start a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Increase the flow level.
< 	if !yaml_parser_increase_flow_level(parser) {
< 		return false
< 	}
< 
< 	// A simple key may follow the indicators '[' and '{'.
< 	parser.simple_key_allowed = true
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the FLOW-SEQUENCE-START of FLOW-MAPPING-START token.
< 	token := yaml_token_t{
< 		typ:        typ,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	// Append the token to the queue.
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the FLOW-SEQUENCE-END or FLOW-MAPPING-END token.
< func yaml_parser_fetch_flow_collection_end(parser *yaml_parser_t, typ yaml_token_type_t) bool {
< 	// Reset any potential simple key on the current flow level.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Decrease the flow level.
< 	if !yaml_parser_decrease_flow_level(parser) {
< 		return false
< 	}
< 
< 	// No simple keys after the indicators ']' and '}'.
< 	parser.simple_key_allowed = false
< 
< 	// Consume the token.
< 
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the FLOW-SEQUENCE-END of FLOW-MAPPING-END token.
< 	token := yaml_token_t{
< 		typ:        typ,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	// Append the token to the queue.
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the FLOW-ENTRY token.
< func yaml_parser_fetch_flow_entry(parser *yaml_parser_t) bool {
< 	// Reset any potential simple keys on the current flow level.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Simple keys are allowed after ','.
< 	parser.simple_key_allowed = true
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the FLOW-ENTRY token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_FLOW_ENTRY_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the BLOCK-ENTRY token.
< func yaml_parser_fetch_block_entry(parser *yaml_parser_t) bool {
< 	// Check if the scanner is in the block context.
< 	if parser.flow_level == 0 {
< 		// Check if we are allowed to start a new entry.
< 		if !parser.simple_key_allowed {
< 			return yaml_parser_set_scanner_error(parser, "", parser.mark,
< 				"block sequence entries are not allowed in this context")
< 		}
< 		// Add the BLOCK-SEQUENCE-START token if needed.
< 		if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_SEQUENCE_START_TOKEN, parser.mark) {
< 			return false
< 		}
< 	} else {
< 		// It is an error for the '-' indicator to occur in the flow context,
< 		// but we let the Parser detect and report about it because the Parser
< 		// is able to point to the context.
< 	}
< 
< 	// Reset any potential simple keys on the current flow level.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Simple keys are allowed after '-'.
< 	parser.simple_key_allowed = true
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the BLOCK-ENTRY token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_BLOCK_ENTRY_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the KEY token.
< func yaml_parser_fetch_key(parser *yaml_parser_t) bool {
< 
< 	// In the block context, additional checks are required.
< 	if parser.flow_level == 0 {
< 		// Check if we are allowed to start a new key (not nessesary simple).
< 		if !parser.simple_key_allowed {
< 			return yaml_parser_set_scanner_error(parser, "", parser.mark,
< 				"mapping keys are not allowed in this context")
< 		}
< 		// Add the BLOCK-MAPPING-START token if needed.
< 		if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_MAPPING_START_TOKEN, parser.mark) {
< 			return false
< 		}
< 	}
< 
< 	// Reset any potential simple keys on the current flow level.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Simple keys are allowed after '?' in the block context.
< 	parser.simple_key_allowed = parser.flow_level == 0
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the KEY token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_KEY_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the VALUE token.
< func yaml_parser_fetch_value(parser *yaml_parser_t) bool {
< 
< 	simple_key := &parser.simple_keys[len(parser.simple_keys)-1]
< 
< 	// Have we found a simple key?
< 	if simple_key.possible {
< 		// Create the KEY token and insert it into the queue.
< 		token := yaml_token_t{
< 			typ:        yaml_KEY_TOKEN,
< 			start_mark: simple_key.mark,
< 			end_mark:   simple_key.mark,
< 		}
< 		yaml_insert_token(parser, simple_key.token_number-parser.tokens_parsed, &token)
< 
< 		// In the block context, we may need to add the BLOCK-MAPPING-START token.
< 		if !yaml_parser_roll_indent(parser, simple_key.mark.column,
< 			simple_key.token_number,
< 			yaml_BLOCK_MAPPING_START_TOKEN, simple_key.mark) {
< 			return false
< 		}
< 
< 		// Remove the simple key.
< 		simple_key.possible = false
< 
< 		// A simple key cannot follow another simple key.
< 		parser.simple_key_allowed = false
< 
< 	} else {
< 		// The ':' indicator follows a complex key.
< 
< 		// In the block context, extra checks are required.
< 		if parser.flow_level == 0 {
< 
< 			// Check if we are allowed to start a complex value.
< 			if !parser.simple_key_allowed {
< 				return yaml_parser_set_scanner_error(parser, "", parser.mark,
< 					"mapping values are not allowed in this context")
< 			}
< 
< 			// Add the BLOCK-MAPPING-START token if needed.
< 			if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_MAPPING_START_TOKEN, parser.mark) {
< 				return false
< 			}
< 		}
< 
< 		// Simple keys after ':' are allowed in the block context.
< 		parser.simple_key_allowed = parser.flow_level == 0
< 	}
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the VALUE token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_VALUE_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the ALIAS or ANCHOR token.
< func yaml_parser_fetch_anchor(parser *yaml_parser_t, typ yaml_token_type_t) bool {
< 	// An anchor or an alias could be a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key cannot follow an anchor or an alias.
< 	parser.simple_key_allowed = false
< 
< 	// Create the ALIAS or ANCHOR token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_anchor(parser, &token, typ) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the TAG token.
< func yaml_parser_fetch_tag(parser *yaml_parser_t) bool {
< 	// A tag could be a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key cannot follow a tag.
< 	parser.simple_key_allowed = false
< 
< 	// Create the TAG token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_tag(parser, &token) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the SCALAR(...,literal) or SCALAR(...,folded) tokens.
< func yaml_parser_fetch_block_scalar(parser *yaml_parser_t, literal bool) bool {
< 	// Remove any potential simple keys.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key may follow a block scalar.
< 	parser.simple_key_allowed = true
< 
< 	// Create the SCALAR token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_block_scalar(parser, &token, literal) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the SCALAR(...,single-quoted) or SCALAR(...,double-quoted) tokens.
< func yaml_parser_fetch_flow_scalar(parser *yaml_parser_t, single bool) bool {
< 	// A plain scalar could be a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key cannot follow a flow scalar.
< 	parser.simple_key_allowed = false
< 
< 	// Create the SCALAR token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_flow_scalar(parser, &token, single) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the SCALAR(...,plain) token.
< func yaml_parser_fetch_plain_scalar(parser *yaml_parser_t) bool {
< 	// A plain scalar could be a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key cannot follow a flow scalar.
< 	parser.simple_key_allowed = false
< 
< 	// Create the SCALAR token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_plain_scalar(parser, &token) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Eat whitespaces and comments until the next token is found.
< func yaml_parser_scan_to_next_token(parser *yaml_parser_t) bool {
< 
< 	// Until the next token is not found.
< 	for {
< 		// Allow the BOM mark to start a line.
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		if parser.mark.column == 0 && is_bom(parser.buffer, parser.buffer_pos) {
< 			skip(parser)
< 		}
< 
< 		// Eat whitespaces.
< 		// Tabs are allowed:
< 		//  - in the flow context
< 		//  - in the block context, but not at the beginning of the line or
< 		//  after '-', '?', or ':' (complex value).
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 
< 		for parser.buffer[parser.buffer_pos] == ' ' || ((parser.flow_level > 0 || !parser.simple_key_allowed) && parser.buffer[parser.buffer_pos] == '\t') {
< 			skip(parser)
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 
< 		// Eat a comment until a line break.
< 		if parser.buffer[parser.buffer_pos] == '#' {
< 			for !is_breakz(parser.buffer, parser.buffer_pos) {
< 				skip(parser)
< 				if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 					return false
< 				}
< 			}
< 		}
< 
< 		// If it is a line break, eat it.
< 		if is_break(parser.buffer, parser.buffer_pos) {
< 			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 				return false
< 			}
< 			skip_line(parser)
< 
< 			// In the block context, a new line may start a simple key.
< 			if parser.flow_level == 0 {
< 				parser.simple_key_allowed = true
< 			}
< 		} else {
< 			break // We have found a token.
< 		}
< 	}
< 
< 	return true
< }
< 
< // Scan a YAML-DIRECTIVE or TAG-DIRECTIVE token.
< //
< // Scope:
< //      %YAML    1.1    # a comment \n
< //      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
< //      %TAG    !yaml!  tag:yaml.org,2002:  \n
< //      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
< //
< func yaml_parser_scan_directive(parser *yaml_parser_t, token *yaml_token_t) bool {
< 	// Eat '%'.
< 	start_mark := parser.mark
< 	skip(parser)
< 
< 	// Scan the directive name.
< 	var name []byte
< 	if !yaml_parser_scan_directive_name(parser, start_mark, &name) {
< 		return false
< 	}
< 
< 	// Is it a YAML directive?
< 	if bytes.Equal(name, []byte("YAML")) {
< 		// Scan the VERSION directive value.
< 		var major, minor int8
< 		if !yaml_parser_scan_version_directive_value(parser, start_mark, &major, &minor) {
< 			return false
< 		}
< 		end_mark := parser.mark
< 
< 		// Create a VERSION-DIRECTIVE token.
< 		*token = yaml_token_t{
< 			typ:        yaml_VERSION_DIRECTIVE_TOKEN,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			major:      major,
< 			minor:      minor,
< 		}
< 
< 		// Is it a TAG directive?
< 	} else if bytes.Equal(name, []byte("TAG")) {
< 		// Scan the TAG directive value.
< 		var handle, prefix []byte
< 		if !yaml_parser_scan_tag_directive_value(parser, start_mark, &handle, &prefix) {
< 			return false
< 		}
< 		end_mark := parser.mark
< 
< 		// Create a TAG-DIRECTIVE token.
< 		*token = yaml_token_t{
< 			typ:        yaml_TAG_DIRECTIVE_TOKEN,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			value:      handle,
< 			prefix:     prefix,
< 		}
< 
< 		// Unknown directive.
< 	} else {
< 		yaml_parser_set_scanner_error(parser, "while scanning a directive",
< 			start_mark, "found unknown directive name")
< 		return false
< 	}
< 
< 	// Eat the rest of the line including any comments.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	if parser.buffer[parser.buffer_pos] == '#' {
< 		for !is_breakz(parser.buffer, parser.buffer_pos) {
< 			skip(parser)
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 	}
< 
< 	// Check if we are at the end of the line.
< 	if !is_breakz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a directive",
< 			start_mark, "did not find expected comment or line break")
< 		return false
< 	}
< 
< 	// Eat a line break.
< 	if is_break(parser.buffer, parser.buffer_pos) {
< 		if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 			return false
< 		}
< 		skip_line(parser)
< 	}
< 
< 	return true
< }
< 
< // Scan the directive name.
< //
< // Scope:
< //      %YAML   1.1     # a comment \n
< //       ^^^^
< //      %TAG    !yaml!  tag:yaml.org,2002:  \n
< //       ^^^
< //
< func yaml_parser_scan_directive_name(parser *yaml_parser_t, start_mark yaml_mark_t, name *[]byte) bool {
< 	// Consume the directive name.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	var s []byte
< 	for is_alpha(parser.buffer, parser.buffer_pos) {
< 		s = read(parser, s)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Check if the name is empty.
< 	if len(s) == 0 {
< 		yaml_parser_set_scanner_error(parser, "while scanning a directive",
< 			start_mark, "could not find expected directive name")
< 		return false
< 	}
< 
< 	// Check for an blank character after the name.
< 	if !is_blankz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a directive",
< 			start_mark, "found unexpected non-alphabetical character")
< 		return false
< 	}
< 	*name = s
< 	return true
< }
< 
< // Scan the value of VERSION-DIRECTIVE.
< //
< // Scope:
< //      %YAML   1.1     # a comment \n
< //           ^^^^^^
< func yaml_parser_scan_version_directive_value(parser *yaml_parser_t, start_mark yaml_mark_t, major, minor *int8) bool {
< 	// Eat whitespaces.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Consume the major version number.
< 	if !yaml_parser_scan_version_directive_number(parser, start_mark, major) {
< 		return false
< 	}
< 
< 	// Eat '.'.
< 	if parser.buffer[parser.buffer_pos] != '.' {
< 		return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
< 			start_mark, "did not find expected digit or '.' character")
< 	}
< 
< 	skip(parser)
< 
< 	// Consume the minor version number.
< 	if !yaml_parser_scan_version_directive_number(parser, start_mark, minor) {
< 		return false
< 	}
< 	return true
< }
< 
< const max_number_length = 2
< 
< // Scan the version number of VERSION-DIRECTIVE.
< //
< // Scope:
< //      %YAML   1.1     # a comment \n
< //              ^
< //      %YAML   1.1     # a comment \n
< //                ^
< func yaml_parser_scan_version_directive_number(parser *yaml_parser_t, start_mark yaml_mark_t, number *int8) bool {
< 
< 	// Repeat while the next character is digit.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	var value, length int8
< 	for is_digit(parser.buffer, parser.buffer_pos) {
< 		// Check if the number is too long.
< 		length++
< 		if length > max_number_length {
< 			return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
< 				start_mark, "found extremely long version number")
< 		}
< 		value = value*10 + int8(as_digit(parser.buffer, parser.buffer_pos))
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Check if the number was present.
< 	if length == 0 {
< 		return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
< 			start_mark, "did not find expected version number")
< 	}
< 	*number = value
< 	return true
< }
< 
< // Scan the value of a TAG-DIRECTIVE token.
< //
< // Scope:
< //      %TAG    !yaml!  tag:yaml.org,2002:  \n
< //          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
< //
< func yaml_parser_scan_tag_directive_value(parser *yaml_parser_t, start_mark yaml_mark_t, handle, prefix *[]byte) bool {
< 	var handle_value, prefix_value []byte
< 
< 	// Eat whitespaces.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Scan a handle.
< 	if !yaml_parser_scan_tag_handle(parser, true, start_mark, &handle_value) {
< 		return false
< 	}
< 
< 	// Expect a whitespace.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	if !is_blank(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a %TAG directive",
< 			start_mark, "did not find expected whitespace")
< 		return false
< 	}
< 
< 	// Eat whitespaces.
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Scan a prefix.
< 	if !yaml_parser_scan_tag_uri(parser, true, nil, start_mark, &prefix_value) {
< 		return false
< 	}
< 
< 	// Expect a whitespace or line break.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	if !is_blankz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a %TAG directive",
< 			start_mark, "did not find expected whitespace or line break")
< 		return false
< 	}
< 
< 	*handle = handle_value
< 	*prefix = prefix_value
< 	return true
< }
< 
< func yaml_parser_scan_anchor(parser *yaml_parser_t, token *yaml_token_t, typ yaml_token_type_t) bool {
< 	var s []byte
< 
< 	// Eat the indicator character.
< 	start_mark := parser.mark
< 	skip(parser)
< 
< 	// Consume the value.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	for is_alpha(parser.buffer, parser.buffer_pos) {
< 		s = read(parser, s)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	end_mark := parser.mark
< 
< 	/*
< 	 * Check if length of the anchor is greater than 0 and it is followed by
< 	 * a whitespace character or one of the indicators:
< 	 *
< 	 *      '?', ':', ',', ']', '}', '%', '@', '`'.
< 	 */
< 
< 	if len(s) == 0 ||
< 		!(is_blankz(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == '?' ||
< 			parser.buffer[parser.buffer_pos] == ':' || parser.buffer[parser.buffer_pos] == ',' ||
< 			parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '}' ||
< 			parser.buffer[parser.buffer_pos] == '%' || parser.buffer[parser.buffer_pos] == '@' ||
< 			parser.buffer[parser.buffer_pos] == '`') {
< 		context := "while scanning an alias"
< 		if typ == yaml_ANCHOR_TOKEN {
< 			context = "while scanning an anchor"
< 		}
< 		yaml_parser_set_scanner_error(parser, context, start_mark,
< 			"did not find expected alphabetic or numeric character")
< 		return false
< 	}
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        typ,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      s,
< 	}
< 
< 	return true
< }
< 
< /*
<  * Scan a TAG token.
<  */
< 
< func yaml_parser_scan_tag(parser *yaml_parser_t, token *yaml_token_t) bool {
< 	var handle, suffix []byte
< 
< 	start_mark := parser.mark
< 
< 	// Check if the tag is in the canonical form.
< 	if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 		return false
< 	}
< 
< 	if parser.buffer[parser.buffer_pos+1] == '<' {
< 		// Keep the handle as ''
< 
< 		// Eat '!<'
< 		skip(parser)
< 		skip(parser)
< 
< 		// Consume the tag value.
< 		if !yaml_parser_scan_tag_uri(parser, false, nil, start_mark, &suffix) {
< 			return false
< 		}
< 
< 		// Check for '>' and eat it.
< 		if parser.buffer[parser.buffer_pos] != '>' {
< 			yaml_parser_set_scanner_error(parser, "while scanning a tag",
< 				start_mark, "did not find the expected '>'")
< 			return false
< 		}
< 
< 		skip(parser)
< 	} else {
< 		// The tag has either the '!suffix' or the '!handle!suffix' form.
< 
< 		// First, try to scan a handle.
< 		if !yaml_parser_scan_tag_handle(parser, false, start_mark, &handle) {
< 			return false
< 		}
< 
< 		// Check if it is, indeed, handle.
< 		if handle[0] == '!' && len(handle) > 1 && handle[len(handle)-1] == '!' {
< 			// Scan the suffix now.
< 			if !yaml_parser_scan_tag_uri(parser, false, nil, start_mark, &suffix) {
< 				return false
< 			}
< 		} else {
< 			// It wasn't a handle after all.  Scan the rest of the tag.
< 			if !yaml_parser_scan_tag_uri(parser, false, handle, start_mark, &suffix) {
< 				return false
< 			}
< 
< 			// Set the handle to '!'.
< 			handle = []byte{'!'}
< 
< 			// A special case: the '!' tag.  Set the handle to '' and the
< 			// suffix to '!'.
< 			if len(suffix) == 0 {
< 				handle, suffix = suffix, handle
< 			}
< 		}
< 	}
< 
< 	// Check the character which ends the tag.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	if !is_blankz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a tag",
< 			start_mark, "did not find expected whitespace or line break")
< 		return false
< 	}
< 
< 	end_mark := parser.mark
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        yaml_TAG_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      handle,
< 		suffix:     suffix,
< 	}
< 	return true
< }
< 
< // Scan a tag handle.
< func yaml_parser_scan_tag_handle(parser *yaml_parser_t, directive bool, start_mark yaml_mark_t, handle *[]byte) bool {
< 	// Check the initial '!' character.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	if parser.buffer[parser.buffer_pos] != '!' {
< 		yaml_parser_set_scanner_tag_error(parser, directive,
< 			start_mark, "did not find expected '!'")
< 		return false
< 	}
< 
< 	var s []byte
< 
< 	// Copy the '!' character.
< 	s = read(parser, s)
< 
< 	// Copy all subsequent alphabetical and numerical characters.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	for is_alpha(parser.buffer, parser.buffer_pos) {
< 		s = read(parser, s)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Check if the trailing character is '!' and copy it.
< 	if parser.buffer[parser.buffer_pos] == '!' {
< 		s = read(parser, s)
< 	} else {
< 		// It's either the '!' tag or not really a tag handle.  If it's a %TAG
< 		// directive, it's an error.  If it's a tag token, it must be a part of URI.
< 		if directive && string(s) != "!" {
< 			yaml_parser_set_scanner_tag_error(parser, directive,
< 				start_mark, "did not find expected '!'")
< 			return false
< 		}
< 	}
< 
< 	*handle = s
< 	return true
< }
< 
< // Scan a tag.
< func yaml_parser_scan_tag_uri(parser *yaml_parser_t, directive bool, head []byte, start_mark yaml_mark_t, uri *[]byte) bool {
< 	//size_t length = head ? strlen((char *)head) : 0
< 	var s []byte
< 	hasTag := len(head) > 0
< 
< 	// Copy the head if needed.
< 	//
< 	// Note that we don't copy the leading '!' character.
< 	if len(head) > 1 {
< 		s = append(s, head[1:]...)
< 	}
< 
< 	// Scan the tag.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	// The set of characters that may appear in URI is as follows:
< 	//
< 	//      '0'-'9', 'A'-'Z', 'a'-'z', '_', '-', ';', '/', '?', ':', '@', '&',
< 	//      '=', '+', '$', ',', '.', '!', '~', '*', '\'', '(', ')', '[', ']',
< 	//      '%'.
< 	// [Go] Convert this into more reasonable logic.
< 	for is_alpha(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == ';' ||
< 		parser.buffer[parser.buffer_pos] == '/' || parser.buffer[parser.buffer_pos] == '?' ||
< 		parser.buffer[parser.buffer_pos] == ':' || parser.buffer[parser.buffer_pos] == '@' ||
< 		parser.buffer[parser.buffer_pos] == '&' || parser.buffer[parser.buffer_pos] == '=' ||
< 		parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '$' ||
< 		parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == '.' ||
< 		parser.buffer[parser.buffer_pos] == '!' || parser.buffer[parser.buffer_pos] == '~' ||
< 		parser.buffer[parser.buffer_pos] == '*' || parser.buffer[parser.buffer_pos] == '\'' ||
< 		parser.buffer[parser.buffer_pos] == '(' || parser.buffer[parser.buffer_pos] == ')' ||
< 		parser.buffer[parser.buffer_pos] == '[' || parser.buffer[parser.buffer_pos] == ']' ||
< 		parser.buffer[parser.buffer_pos] == '%' {
< 		// Check if it is a URI-escape sequence.
< 		if parser.buffer[parser.buffer_pos] == '%' {
< 			if !yaml_parser_scan_uri_escapes(parser, directive, start_mark, &s) {
< 				return false
< 			}
< 		} else {
< 			s = read(parser, s)
< 		}
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		hasTag = true
< 	}
< 
< 	if !hasTag {
< 		yaml_parser_set_scanner_tag_error(parser, directive,
< 			start_mark, "did not find expected tag URI")
< 		return false
< 	}
< 	*uri = s
< 	return true
< }
< 
< // Decode an URI-escape sequence corresponding to a single UTF-8 character.
< func yaml_parser_scan_uri_escapes(parser *yaml_parser_t, directive bool, start_mark yaml_mark_t, s *[]byte) bool {
< 
< 	// Decode the required number of characters.
< 	w := 1024
< 	for w > 0 {
< 		// Check for a URI-escaped octet.
< 		if parser.unread < 3 && !yaml_parser_update_buffer(parser, 3) {
< 			return false
< 		}
< 
< 		if !(parser.buffer[parser.buffer_pos] == '%' &&
< 			is_hex(parser.buffer, parser.buffer_pos+1) &&
< 			is_hex(parser.buffer, parser.buffer_pos+2)) {
< 			return yaml_parser_set_scanner_tag_error(parser, directive,
< 				start_mark, "did not find URI escaped octet")
< 		}
< 
< 		// Get the octet.
< 		octet := byte((as_hex(parser.buffer, parser.buffer_pos+1) << 4) + as_hex(parser.buffer, parser.buffer_pos+2))
< 
< 		// If it is the leading octet, determine the length of the UTF-8 sequence.
< 		if w == 1024 {
< 			w = width(octet)
< 			if w == 0 {
< 				return yaml_parser_set_scanner_tag_error(parser, directive,
< 					start_mark, "found an incorrect leading UTF-8 octet")
< 			}
< 		} else {
< 			// Check if the trailing octet is correct.
< 			if octet&0xC0 != 0x80 {
< 				return yaml_parser_set_scanner_tag_error(parser, directive,
< 					start_mark, "found an incorrect trailing UTF-8 octet")
< 			}
< 		}
< 
< 		// Copy the octet and move the pointers.
< 		*s = append(*s, octet)
< 		skip(parser)
< 		skip(parser)
< 		skip(parser)
< 		w--
< 	}
< 	return true
< }
< 
< // Scan a block scalar.
< func yaml_parser_scan_block_scalar(parser *yaml_parser_t, token *yaml_token_t, literal bool) bool {
< 	// Eat the indicator '|' or '>'.
< 	start_mark := parser.mark
< 	skip(parser)
< 
< 	// Scan the additional block scalar indicators.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	// Check for a chomping indicator.
< 	var chomping, increment int
< 	if parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '-' {
< 		// Set the chomping method and eat the indicator.
< 		if parser.buffer[parser.buffer_pos] == '+' {
< 			chomping = +1
< 		} else {
< 			chomping = -1
< 		}
< 		skip(parser)
< 
< 		// Check for an indentation indicator.
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		if is_digit(parser.buffer, parser.buffer_pos) {
< 			// Check that the indentation is greater than 0.
< 			if parser.buffer[parser.buffer_pos] == '0' {
< 				yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
< 					start_mark, "found an indentation indicator equal to 0")
< 				return false
< 			}
< 
< 			// Get the indentation level and eat the indicator.
< 			increment = as_digit(parser.buffer, parser.buffer_pos)
< 			skip(parser)
< 		}
< 
< 	} else if is_digit(parser.buffer, parser.buffer_pos) {
< 		// Do the same as above, but in the opposite order.
< 
< 		if parser.buffer[parser.buffer_pos] == '0' {
< 			yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
< 				start_mark, "found an indentation indicator equal to 0")
< 			return false
< 		}
< 		increment = as_digit(parser.buffer, parser.buffer_pos)
< 		skip(parser)
< 
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		if parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '-' {
< 			if parser.buffer[parser.buffer_pos] == '+' {
< 				chomping = +1
< 			} else {
< 				chomping = -1
< 			}
< 			skip(parser)
< 		}
< 	}
< 
< 	// Eat whitespaces and comments to the end of the line.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 	if parser.buffer[parser.buffer_pos] == '#' {
< 		for !is_breakz(parser.buffer, parser.buffer_pos) {
< 			skip(parser)
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 	}
< 
< 	// Check if we are at the end of the line.
< 	if !is_breakz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
< 			start_mark, "did not find expected comment or line break")
< 		return false
< 	}
< 
< 	// Eat a line break.
< 	if is_break(parser.buffer, parser.buffer_pos) {
< 		if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 			return false
< 		}
< 		skip_line(parser)
< 	}
< 
< 	end_mark := parser.mark
< 
< 	// Set the indentation level if it was specified.
< 	var indent int
< 	if increment > 0 {
< 		if parser.indent >= 0 {
< 			indent = parser.indent + increment
< 		} else {
< 			indent = increment
< 		}
< 	}
< 
< 	// Scan the leading line breaks and determine the indentation level if needed.
< 	var s, leading_break, trailing_breaks []byte
< 	if !yaml_parser_scan_block_scalar_breaks(parser, &indent, &trailing_breaks, start_mark, &end_mark) {
< 		return false
< 	}
< 
< 	// Scan the block scalar content.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	var leading_blank, trailing_blank bool
< 	for parser.mark.column == indent && !is_z(parser.buffer, parser.buffer_pos) {
< 		// We are at the beginning of a non-empty line.
< 
< 		// Is it a trailing whitespace?
< 		trailing_blank = is_blank(parser.buffer, parser.buffer_pos)
< 
< 		// Check if we need to fold the leading line break.
< 		if !literal && !leading_blank && !trailing_blank && len(leading_break) > 0 && leading_break[0] == '\n' {
< 			// Do we need to join the lines by space?
< 			if len(trailing_breaks) == 0 {
< 				s = append(s, ' ')
< 			}
< 		} else {
< 			s = append(s, leading_break...)
< 		}
< 		leading_break = leading_break[:0]
< 
< 		// Append the remaining line breaks.
< 		s = append(s, trailing_breaks...)
< 		trailing_breaks = trailing_breaks[:0]
< 
< 		// Is it a leading whitespace?
< 		leading_blank = is_blank(parser.buffer, parser.buffer_pos)
< 
< 		// Consume the current line.
< 		for !is_breakz(parser.buffer, parser.buffer_pos) {
< 			s = read(parser, s)
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 
< 		// Consume the line break.
< 		if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 			return false
< 		}
< 
< 		leading_break = read_line(parser, leading_break)
< 
< 		// Eat the following indentation spaces and line breaks.
< 		if !yaml_parser_scan_block_scalar_breaks(parser, &indent, &trailing_breaks, start_mark, &end_mark) {
< 			return false
< 		}
< 	}
< 
< 	// Chomp the tail.
< 	if chomping != -1 {
< 		s = append(s, leading_break...)
< 	}
< 	if chomping == 1 {
< 		s = append(s, trailing_breaks...)
< 	}
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        yaml_SCALAR_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      s,
< 		style:      yaml_LITERAL_SCALAR_STYLE,
< 	}
< 	if !literal {
< 		token.style = yaml_FOLDED_SCALAR_STYLE
< 	}
< 	return true
< }
< 
< // Scan indentation spaces and line breaks for a block scalar.  Determine the
< // indentation level if needed.
< func yaml_parser_scan_block_scalar_breaks(parser *yaml_parser_t, indent *int, breaks *[]byte, start_mark yaml_mark_t, end_mark *yaml_mark_t) bool {
< 	*end_mark = parser.mark
< 
< 	// Eat the indentation spaces and line breaks.
< 	max_indent := 0
< 	for {
< 		// Eat the indentation spaces.
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		for (*indent == 0 || parser.mark.column < *indent) && is_space(parser.buffer, parser.buffer_pos) {
< 			skip(parser)
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 		if parser.mark.column > max_indent {
< 			max_indent = parser.mark.column
< 		}
< 
< 		// Check for a tab character messing the indentation.
< 		if (*indent == 0 || parser.mark.column < *indent) && is_tab(parser.buffer, parser.buffer_pos) {
< 			return yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
< 				start_mark, "found a tab character where an indentation space is expected")
< 		}
< 
< 		// Have we found a non-empty line?
< 		if !is_break(parser.buffer, parser.buffer_pos) {
< 			break
< 		}
< 
< 		// Consume the line break.
< 		if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 			return false
< 		}
< 		// [Go] Should really be returning breaks instead.
< 		*breaks = read_line(parser, *breaks)
< 		*end_mark = parser.mark
< 	}
< 
< 	// Determine the indentation level if needed.
< 	if *indent == 0 {
< 		*indent = max_indent
< 		if *indent < parser.indent+1 {
< 			*indent = parser.indent + 1
< 		}
< 		if *indent < 1 {
< 			*indent = 1
< 		}
< 	}
< 	return true
< }
< 
< // Scan a quoted scalar.
< func yaml_parser_scan_flow_scalar(parser *yaml_parser_t, token *yaml_token_t, single bool) bool {
< 	// Eat the left quote.
< 	start_mark := parser.mark
< 	skip(parser)
< 
< 	// Consume the content of the quoted scalar.
< 	var s, leading_break, trailing_breaks, whitespaces []byte
< 	for {
< 		// Check that there are no document indicators at the beginning of the line.
< 		if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
< 			return false
< 		}
< 
< 		if parser.mark.column == 0 &&
< 			((parser.buffer[parser.buffer_pos+0] == '-' &&
< 				parser.buffer[parser.buffer_pos+1] == '-' &&
< 				parser.buffer[parser.buffer_pos+2] == '-') ||
< 				(parser.buffer[parser.buffer_pos+0] == '.' &&
< 					parser.buffer[parser.buffer_pos+1] == '.' &&
< 					parser.buffer[parser.buffer_pos+2] == '.')) &&
< 			is_blankz(parser.buffer, parser.buffer_pos+3) {
< 			yaml_parser_set_scanner_error(parser, "while scanning a quoted scalar",
< 				start_mark, "found unexpected document indicator")
< 			return false
< 		}
< 
< 		// Check for EOF.
< 		if is_z(parser.buffer, parser.buffer_pos) {
< 			yaml_parser_set_scanner_error(parser, "while scanning a quoted scalar",
< 				start_mark, "found unexpected end of stream")
< 			return false
< 		}
< 
< 		// Consume non-blank characters.
< 		leading_blanks := false
< 		for !is_blankz(parser.buffer, parser.buffer_pos) {
< 			if single && parser.buffer[parser.buffer_pos] == '\'' && parser.buffer[parser.buffer_pos+1] == '\'' {
< 				// Is is an escaped single quote.
< 				s = append(s, '\'')
< 				skip(parser)
< 				skip(parser)
< 
< 			} else if single && parser.buffer[parser.buffer_pos] == '\'' {
< 				// It is a right single quote.
< 				break
< 			} else if !single && parser.buffer[parser.buffer_pos] == '"' {
< 				// It is a right double quote.
< 				break
< 
< 			} else if !single && parser.buffer[parser.buffer_pos] == '\\' && is_break(parser.buffer, parser.buffer_pos+1) {
< 				// It is an escaped line break.
< 				if parser.unread < 3 && !yaml_parser_update_buffer(parser, 3) {
< 					return false
< 				}
< 				skip(parser)
< 				skip_line(parser)
< 				leading_blanks = true
< 				break
< 
< 			} else if !single && parser.buffer[parser.buffer_pos] == '\\' {
< 				// It is an escape sequence.
< 				code_length := 0
< 
< 				// Check the escape character.
< 				switch parser.buffer[parser.buffer_pos+1] {
< 				case '0':
< 					s = append(s, 0)
< 				case 'a':
< 					s = append(s, '\x07')
< 				case 'b':
< 					s = append(s, '\x08')
< 				case 't', '\t':
< 					s = append(s, '\x09')
< 				case 'n':
< 					s = append(s, '\x0A')
< 				case 'v':
< 					s = append(s, '\x0B')
< 				case 'f':
< 					s = append(s, '\x0C')
< 				case 'r':
< 					s = append(s, '\x0D')
< 				case 'e':
< 					s = append(s, '\x1B')
< 				case ' ':
< 					s = append(s, '\x20')
< 				case '"':
< 					s = append(s, '"')
< 				case '\'':
< 					s = append(s, '\'')
< 				case '\\':
< 					s = append(s, '\\')
< 				case 'N': // NEL (#x85)
< 					s = append(s, '\xC2')
< 					s = append(s, '\x85')
< 				case '_': // #xA0
< 					s = append(s, '\xC2')
< 					s = append(s, '\xA0')
< 				case 'L': // LS (#x2028)
< 					s = append(s, '\xE2')
< 					s = append(s, '\x80')
< 					s = append(s, '\xA8')
< 				case 'P': // PS (#x2029)
< 					s = append(s, '\xE2')
< 					s = append(s, '\x80')
< 					s = append(s, '\xA9')
< 				case 'x':
< 					code_length = 2
< 				case 'u':
< 					code_length = 4
< 				case 'U':
< 					code_length = 8
< 				default:
< 					yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
< 						start_mark, "found unknown escape character")
< 					return false
< 				}
< 
< 				skip(parser)
< 				skip(parser)
< 
< 				// Consume an arbitrary escape code.
< 				if code_length > 0 {
< 					var value int
< 
< 					// Scan the character value.
< 					if parser.unread < code_length && !yaml_parser_update_buffer(parser, code_length) {
< 						return false
< 					}
< 					for k := 0; k < code_length; k++ {
< 						if !is_hex(parser.buffer, parser.buffer_pos+k) {
< 							yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
< 								start_mark, "did not find expected hexdecimal number")
< 							return false
< 						}
< 						value = (value << 4) + as_hex(parser.buffer, parser.buffer_pos+k)
< 					}
< 
< 					// Check the value and write the character.
< 					if (value >= 0xD800 && value <= 0xDFFF) || value > 0x10FFFF {
< 						yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
< 							start_mark, "found invalid Unicode character escape code")
< 						return false
< 					}
< 					if value <= 0x7F {
< 						s = append(s, byte(value))
< 					} else if value <= 0x7FF {
< 						s = append(s, byte(0xC0+(value>>6)))
< 						s = append(s, byte(0x80+(value&0x3F)))
< 					} else if value <= 0xFFFF {
< 						s = append(s, byte(0xE0+(value>>12)))
< 						s = append(s, byte(0x80+((value>>6)&0x3F)))
< 						s = append(s, byte(0x80+(value&0x3F)))
< 					} else {
< 						s = append(s, byte(0xF0+(value>>18)))
< 						s = append(s, byte(0x80+((value>>12)&0x3F)))
< 						s = append(s, byte(0x80+((value>>6)&0x3F)))
< 						s = append(s, byte(0x80+(value&0x3F)))
< 					}
< 
< 					// Advance the pointer.
< 					for k := 0; k < code_length; k++ {
< 						skip(parser)
< 					}
< 				}
< 			} else {
< 				// It is a non-escaped non-blank character.
< 				s = read(parser, s)
< 			}
< 			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 				return false
< 			}
< 		}
< 
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 
< 		// Check if we are at the end of the scalar.
< 		if single {
< 			if parser.buffer[parser.buffer_pos] == '\'' {
< 				break
< 			}
< 		} else {
< 			if parser.buffer[parser.buffer_pos] == '"' {
< 				break
< 			}
< 		}
< 
< 		// Consume blank characters.
< 		for is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos) {
< 			if is_blank(parser.buffer, parser.buffer_pos) {
< 				// Consume a space or a tab character.
< 				if !leading_blanks {
< 					whitespaces = read(parser, whitespaces)
< 				} else {
< 					skip(parser)
< 				}
< 			} else {
< 				if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 					return false
< 				}
< 
< 				// Check if it is a first line break.
< 				if !leading_blanks {
< 					whitespaces = whitespaces[:0]
< 					leading_break = read_line(parser, leading_break)
< 					leading_blanks = true
< 				} else {
< 					trailing_breaks = read_line(parser, trailing_breaks)
< 				}
< 			}
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 
< 		// Join the whitespaces or fold line breaks.
< 		if leading_blanks {
< 			// Do we need to fold line breaks?
< 			if len(leading_break) > 0 && leading_break[0] == '\n' {
< 				if len(trailing_breaks) == 0 {
< 					s = append(s, ' ')
< 				} else {
< 					s = append(s, trailing_breaks...)
< 				}
< 			} else {
< 				s = append(s, leading_break...)
< 				s = append(s, trailing_breaks...)
< 			}
< 			trailing_breaks = trailing_breaks[:0]
< 			leading_break = leading_break[:0]
< 		} else {
< 			s = append(s, whitespaces...)
< 			whitespaces = whitespaces[:0]
< 		}
< 	}
< 
< 	// Eat the right quote.
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        yaml_SCALAR_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      s,
< 		style:      yaml_SINGLE_QUOTED_SCALAR_STYLE,
< 	}
< 	if !single {
< 		token.style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 	}
< 	return true
< }
< 
< // Scan a plain scalar.
< func yaml_parser_scan_plain_scalar(parser *yaml_parser_t, token *yaml_token_t) bool {
< 
< 	var s, leading_break, trailing_breaks, whitespaces []byte
< 	var leading_blanks bool
< 	var indent = parser.indent + 1
< 
< 	start_mark := parser.mark
< 	end_mark := parser.mark
< 
< 	// Consume the content of the plain scalar.
< 	for {
< 		// Check for a document indicator.
< 		if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
< 			return false
< 		}
< 		if parser.mark.column == 0 &&
< 			((parser.buffer[parser.buffer_pos+0] == '-' &&
< 				parser.buffer[parser.buffer_pos+1] == '-' &&
< 				parser.buffer[parser.buffer_pos+2] == '-') ||
< 				(parser.buffer[parser.buffer_pos+0] == '.' &&
< 					parser.buffer[parser.buffer_pos+1] == '.' &&
< 					parser.buffer[parser.buffer_pos+2] == '.')) &&
< 			is_blankz(parser.buffer, parser.buffer_pos+3) {
< 			break
< 		}
< 
< 		// Check for a comment.
< 		if parser.buffer[parser.buffer_pos] == '#' {
< 			break
< 		}
< 
< 		// Consume non-blank characters.
< 		for !is_blankz(parser.buffer, parser.buffer_pos) {
< 
< 			// Check for indicators that may end a plain scalar.
< 			if (parser.buffer[parser.buffer_pos] == ':' && is_blankz(parser.buffer, parser.buffer_pos+1)) ||
< 				(parser.flow_level > 0 &&
< 					(parser.buffer[parser.buffer_pos] == ',' ||
< 						parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == '[' ||
< 						parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '{' ||
< 						parser.buffer[parser.buffer_pos] == '}')) {
< 				break
< 			}
< 
< 			// Check if we need to join whitespaces and breaks.
< 			if leading_blanks || len(whitespaces) > 0 {
< 				if leading_blanks {
< 					// Do we need to fold line breaks?
< 					if leading_break[0] == '\n' {
< 						if len(trailing_breaks) == 0 {
< 							s = append(s, ' ')
< 						} else {
< 							s = append(s, trailing_breaks...)
< 						}
< 					} else {
< 						s = append(s, leading_break...)
< 						s = append(s, trailing_breaks...)
< 					}
< 					trailing_breaks = trailing_breaks[:0]
< 					leading_break = leading_break[:0]
< 					leading_blanks = false
< 				} else {
< 					s = append(s, whitespaces...)
< 					whitespaces = whitespaces[:0]
< 				}
< 			}
< 
< 			// Copy the character.
< 			s = read(parser, s)
< 
< 			end_mark = parser.mark
< 			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 				return false
< 			}
< 		}
< 
< 		// Is it the end?
< 		if !(is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos)) {
< 			break
< 		}
< 
< 		// Consume blank characters.
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 
< 		for is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos) {
< 			if is_blank(parser.buffer, parser.buffer_pos) {
< 
< 				// Check for tab characters that abuse indentation.
< 				if leading_blanks && parser.mark.column < indent && is_tab(parser.buffer, parser.buffer_pos) {
< 					yaml_parser_set_scanner_error(parser, "while scanning a plain scalar",
< 						start_mark, "found a tab character that violates indentation")
< 					return false
< 				}
< 
< 				// Consume a space or a tab character.
< 				if !leading_blanks {
< 					whitespaces = read(parser, whitespaces)
< 				} else {
< 					skip(parser)
< 				}
< 			} else {
< 				if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 					return false
< 				}
< 
< 				// Check if it is a first line break.
< 				if !leading_blanks {
< 					whitespaces = whitespaces[:0]
< 					leading_break = read_line(parser, leading_break)
< 					leading_blanks = true
< 				} else {
< 					trailing_breaks = read_line(parser, trailing_breaks)
< 				}
< 			}
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 
< 		// Check indentation level.
< 		if parser.flow_level == 0 && parser.mark.column < indent {
< 			break
< 		}
< 	}
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        yaml_SCALAR_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      s,
< 		style:      yaml_PLAIN_SCALAR_STYLE,
< 	}
< 
< 	// Note that we change the 'simple_key_allowed' flag.
< 	if leading_blanks {
< 		parser.simple_key_allowed = true
< 	}
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/sorter.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/sorter.go
1,113d0
< package yaml
< 
< import (
< 	"reflect"
< 	"unicode"
< )
< 
< type keyList []reflect.Value
< 
< func (l keyList) Len() int      { return len(l) }
< func (l keyList) Swap(i, j int) { l[i], l[j] = l[j], l[i] }
< func (l keyList) Less(i, j int) bool {
< 	a := l[i]
< 	b := l[j]
< 	ak := a.Kind()
< 	bk := b.Kind()
< 	for (ak == reflect.Interface || ak == reflect.Ptr) && !a.IsNil() {
< 		a = a.Elem()
< 		ak = a.Kind()
< 	}
< 	for (bk == reflect.Interface || bk == reflect.Ptr) && !b.IsNil() {
< 		b = b.Elem()
< 		bk = b.Kind()
< 	}
< 	af, aok := keyFloat(a)
< 	bf, bok := keyFloat(b)
< 	if aok && bok {
< 		if af != bf {
< 			return af < bf
< 		}
< 		if ak != bk {
< 			return ak < bk
< 		}
< 		return numLess(a, b)
< 	}
< 	if ak != reflect.String || bk != reflect.String {
< 		return ak < bk
< 	}
< 	ar, br := []rune(a.String()), []rune(b.String())
< 	for i := 0; i < len(ar) && i < len(br); i++ {
< 		if ar[i] == br[i] {
< 			continue
< 		}
< 		al := unicode.IsLetter(ar[i])
< 		bl := unicode.IsLetter(br[i])
< 		if al && bl {
< 			return ar[i] < br[i]
< 		}
< 		if al || bl {
< 			return bl
< 		}
< 		var ai, bi int
< 		var an, bn int64
< 		if ar[i] == '0' || br[i] == '0' {
< 			for j := i-1; j >= 0 && unicode.IsDigit(ar[j]); j-- {
< 				if ar[j] != '0' {
< 					an = 1
< 					bn = 1
< 					break
< 				}
< 			}
< 		}
< 		for ai = i; ai < len(ar) && unicode.IsDigit(ar[ai]); ai++ {
< 			an = an*10 + int64(ar[ai]-'0')
< 		}
< 		for bi = i; bi < len(br) && unicode.IsDigit(br[bi]); bi++ {
< 			bn = bn*10 + int64(br[bi]-'0')
< 		}
< 		if an != bn {
< 			return an < bn
< 		}
< 		if ai != bi {
< 			return ai < bi
< 		}
< 		return ar[i] < br[i]
< 	}
< 	return len(ar) < len(br)
< }
< 
< // keyFloat returns a float value for v if it is a number/bool
< // and whether it is a number/bool or not.
< func keyFloat(v reflect.Value) (f float64, ok bool) {
< 	switch v.Kind() {
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return float64(v.Int()), true
< 	case reflect.Float32, reflect.Float64:
< 		return v.Float(), true
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return float64(v.Uint()), true
< 	case reflect.Bool:
< 		if v.Bool() {
< 			return 1, true
< 		}
< 		return 0, true
< 	}
< 	return 0, false
< }
< 
< // numLess returns whether a < b.
< // a and b must necessarily have the same kind.
< func numLess(a, b reflect.Value) bool {
< 	switch a.Kind() {
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return a.Int() < b.Int()
< 	case reflect.Float32, reflect.Float64:
< 		return a.Float() < b.Float()
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return a.Uint() < b.Uint()
< 	case reflect.Bool:
< 		return !a.Bool() && b.Bool()
< 	}
< 	panic("not a number")
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/writerc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/writerc.go
1,26d0
< package yaml
< 
< // Set the writer error and return false.
< func yaml_emitter_set_writer_error(emitter *yaml_emitter_t, problem string) bool {
< 	emitter.error = yaml_WRITER_ERROR
< 	emitter.problem = problem
< 	return false
< }
< 
< // Flush the output buffer.
< func yaml_emitter_flush(emitter *yaml_emitter_t) bool {
< 	if emitter.write_handler == nil {
< 		panic("write handler not set")
< 	}
< 
< 	// Check if the buffer is empty.
< 	if emitter.buffer_pos == 0 {
< 		return true
< 	}
< 
< 	if err := emitter.write_handler(emitter, emitter.buffer[:emitter.buffer_pos]); err != nil {
< 		return yaml_emitter_set_writer_error(emitter, "write error: "+err.Error())
< 	}
< 	emitter.buffer_pos = 0
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/yaml.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/yaml.go
1,466d0
< // Package yaml implements YAML support for the Go language.
< //
< // Source code and other details for the project are available at GitHub:
< //
< //   https://github.com/go-yaml/yaml
< //
< package yaml
< 
< import (
< 	"errors"
< 	"fmt"
< 	"io"
< 	"reflect"
< 	"strings"
< 	"sync"
< )
< 
< // MapSlice encodes and decodes as a YAML map.
< // The order of keys is preserved when encoding and decoding.
< type MapSlice []MapItem
< 
< // MapItem is an item in a MapSlice.
< type MapItem struct {
< 	Key, Value interface{}
< }
< 
< // The Unmarshaler interface may be implemented by types to customize their
< // behavior when being unmarshaled from a YAML document. The UnmarshalYAML
< // method receives a function that may be called to unmarshal the original
< // YAML value into a field or variable. It is safe to call the unmarshal
< // function parameter more than once if necessary.
< type Unmarshaler interface {
< 	UnmarshalYAML(unmarshal func(interface{}) error) error
< }
< 
< // The Marshaler interface may be implemented by types to customize their
< // behavior when being marshaled into a YAML document. The returned value
< // is marshaled in place of the original value implementing Marshaler.
< //
< // If an error is returned by MarshalYAML, the marshaling procedure stops
< // and returns with the provided error.
< type Marshaler interface {
< 	MarshalYAML() (interface{}, error)
< }
< 
< // Unmarshal decodes the first document found within the in byte slice
< // and assigns decoded values into the out value.
< //
< // Maps and pointers (to a struct, string, int, etc) are accepted as out
< // values. If an internal pointer within a struct is not initialized,
< // the yaml package will initialize it if necessary for unmarshalling
< // the provided data. The out parameter must not be nil.
< //
< // The type of the decoded values should be compatible with the respective
< // values in out. If one or more values cannot be decoded due to a type
< // mismatches, decoding continues partially until the end of the YAML
< // content, and a *yaml.TypeError is returned with details for all
< // missed values.
< //
< // Struct fields are only unmarshalled if they are exported (have an
< // upper case first letter), and are unmarshalled using the field name
< // lowercased as the default key. Custom keys may be defined via the
< // "yaml" name in the field tag: the content preceding the first comma
< // is used as the key, and the following comma-separated options are
< // used to tweak the marshalling process (see Marshal).
< // Conflicting names result in a runtime error.
< //
< // For example:
< //
< //     type T struct {
< //         F int `yaml:"a,omitempty"`
< //         B int
< //     }
< //     var t T
< //     yaml.Unmarshal([]byte("a: 1\nb: 2"), &t)
< //
< // See the documentation of Marshal for the format of tags and a list of
< // supported tag options.
< //
< func Unmarshal(in []byte, out interface{}) (err error) {
< 	return unmarshal(in, out, false)
< }
< 
< // UnmarshalStrict is like Unmarshal except that any fields that are found
< // in the data that do not have corresponding struct members, or mapping
< // keys that are duplicates, will result in
< // an error.
< func UnmarshalStrict(in []byte, out interface{}) (err error) {
< 	return unmarshal(in, out, true)
< }
< 
< // A Decorder reads and decodes YAML values from an input stream.
< type Decoder struct {
< 	strict bool
< 	parser *parser
< }
< 
< // NewDecoder returns a new decoder that reads from r.
< //
< // The decoder introduces its own buffering and may read
< // data from r beyond the YAML values requested.
< func NewDecoder(r io.Reader) *Decoder {
< 	return &Decoder{
< 		parser: newParserFromReader(r),
< 	}
< }
< 
< // SetStrict sets whether strict decoding behaviour is enabled when
< // decoding items in the data (see UnmarshalStrict). By default, decoding is not strict.
< func (dec *Decoder) SetStrict(strict bool) {
< 	dec.strict = strict
< }
< 
< // Decode reads the next YAML-encoded value from its input
< // and stores it in the value pointed to by v.
< //
< // See the documentation for Unmarshal for details about the
< // conversion of YAML into a Go value.
< func (dec *Decoder) Decode(v interface{}) (err error) {
< 	d := newDecoder(dec.strict)
< 	defer handleErr(&err)
< 	node := dec.parser.parse()
< 	if node == nil {
< 		return io.EOF
< 	}
< 	out := reflect.ValueOf(v)
< 	if out.Kind() == reflect.Ptr && !out.IsNil() {
< 		out = out.Elem()
< 	}
< 	d.unmarshal(node, out)
< 	if len(d.terrors) > 0 {
< 		return &TypeError{d.terrors}
< 	}
< 	return nil
< }
< 
< func unmarshal(in []byte, out interface{}, strict bool) (err error) {
< 	defer handleErr(&err)
< 	d := newDecoder(strict)
< 	p := newParser(in)
< 	defer p.destroy()
< 	node := p.parse()
< 	if node != nil {
< 		v := reflect.ValueOf(out)
< 		if v.Kind() == reflect.Ptr && !v.IsNil() {
< 			v = v.Elem()
< 		}
< 		d.unmarshal(node, v)
< 	}
< 	if len(d.terrors) > 0 {
< 		return &TypeError{d.terrors}
< 	}
< 	return nil
< }
< 
< // Marshal serializes the value provided into a YAML document. The structure
< // of the generated document will reflect the structure of the value itself.
< // Maps and pointers (to struct, string, int, etc) are accepted as the in value.
< //
< // Struct fields are only marshalled if they are exported (have an upper case
< // first letter), and are marshalled using the field name lowercased as the
< // default key. Custom keys may be defined via the "yaml" name in the field
< // tag: the content preceding the first comma is used as the key, and the
< // following comma-separated options are used to tweak the marshalling process.
< // Conflicting names result in a runtime error.
< //
< // The field tag format accepted is:
< //
< //     `(...) yaml:"[<key>][,<flag1>[,<flag2>]]" (...)`
< //
< // The following flags are currently supported:
< //
< //     omitempty    Only include the field if it's not set to the zero
< //                  value for the type or to empty slices or maps.
< //                  Zero valued structs will be omitted if all their public
< //                  fields are zero, unless they implement an IsZero
< //                  method (see the IsZeroer interface type), in which
< //                  case the field will be included if that method returns true.
< //
< //     flow         Marshal using a flow style (useful for structs,
< //                  sequences and maps).
< //
< //     inline       Inline the field, which must be a struct or a map,
< //                  causing all of its fields or keys to be processed as if
< //                  they were part of the outer struct. For maps, keys must
< //                  not conflict with the yaml keys of other struct fields.
< //
< // In addition, if the key is "-", the field is ignored.
< //
< // For example:
< //
< //     type T struct {
< //         F int `yaml:"a,omitempty"`
< //         B int
< //     }
< //     yaml.Marshal(&T{B: 2}) // Returns "b: 2\n"
< //     yaml.Marshal(&T{F: 1}} // Returns "a: 1\nb: 0\n"
< //
< func Marshal(in interface{}) (out []byte, err error) {
< 	defer handleErr(&err)
< 	e := newEncoder()
< 	defer e.destroy()
< 	e.marshalDoc("", reflect.ValueOf(in))
< 	e.finish()
< 	out = e.out
< 	return
< }
< 
< // An Encoder writes YAML values to an output stream.
< type Encoder struct {
< 	encoder *encoder
< }
< 
< // NewEncoder returns a new encoder that writes to w.
< // The Encoder should be closed after use to flush all data
< // to w.
< func NewEncoder(w io.Writer) *Encoder {
< 	return &Encoder{
< 		encoder: newEncoderWithWriter(w),
< 	}
< }
< 
< // Encode writes the YAML encoding of v to the stream.
< // If multiple items are encoded to the stream, the
< // second and subsequent document will be preceded
< // with a "---" document separator, but the first will not.
< //
< // See the documentation for Marshal for details about the conversion of Go
< // values to YAML.
< func (e *Encoder) Encode(v interface{}) (err error) {
< 	defer handleErr(&err)
< 	e.encoder.marshalDoc("", reflect.ValueOf(v))
< 	return nil
< }
< 
< // Close closes the encoder by writing any remaining data.
< // It does not write a stream terminating string "...".
< func (e *Encoder) Close() (err error) {
< 	defer handleErr(&err)
< 	e.encoder.finish()
< 	return nil
< }
< 
< func handleErr(err *error) {
< 	if v := recover(); v != nil {
< 		if e, ok := v.(yamlError); ok {
< 			*err = e.err
< 		} else {
< 			panic(v)
< 		}
< 	}
< }
< 
< type yamlError struct {
< 	err error
< }
< 
< func fail(err error) {
< 	panic(yamlError{err})
< }
< 
< func failf(format string, args ...interface{}) {
< 	panic(yamlError{fmt.Errorf("yaml: "+format, args...)})
< }
< 
< // A TypeError is returned by Unmarshal when one or more fields in
< // the YAML document cannot be properly decoded into the requested
< // types. When this error is returned, the value is still
< // unmarshaled partially.
< type TypeError struct {
< 	Errors []string
< }
< 
< func (e *TypeError) Error() string {
< 	return fmt.Sprintf("yaml: unmarshal errors:\n  %s", strings.Join(e.Errors, "\n  "))
< }
< 
< // --------------------------------------------------------------------------
< // Maintain a mapping of keys to structure field indexes
< 
< // The code in this section was copied from mgo/bson.
< 
< // structInfo holds details for the serialization of fields of
< // a given struct.
< type structInfo struct {
< 	FieldsMap  map[string]fieldInfo
< 	FieldsList []fieldInfo
< 
< 	// InlineMap is the number of the field in the struct that
< 	// contains an ,inline map, or -1 if there's none.
< 	InlineMap int
< }
< 
< type fieldInfo struct {
< 	Key       string
< 	Num       int
< 	OmitEmpty bool
< 	Flow      bool
< 	// Id holds the unique field identifier, so we can cheaply
< 	// check for field duplicates without maintaining an extra map.
< 	Id int
< 
< 	// Inline holds the field index if the field is part of an inlined struct.
< 	Inline []int
< }
< 
< var structMap = make(map[reflect.Type]*structInfo)
< var fieldMapMutex sync.RWMutex
< 
< func getStructInfo(st reflect.Type) (*structInfo, error) {
< 	fieldMapMutex.RLock()
< 	sinfo, found := structMap[st]
< 	fieldMapMutex.RUnlock()
< 	if found {
< 		return sinfo, nil
< 	}
< 
< 	n := st.NumField()
< 	fieldsMap := make(map[string]fieldInfo)
< 	fieldsList := make([]fieldInfo, 0, n)
< 	inlineMap := -1
< 	for i := 0; i != n; i++ {
< 		field := st.Field(i)
< 		if field.PkgPath != "" && !field.Anonymous {
< 			continue // Private field
< 		}
< 
< 		info := fieldInfo{Num: i}
< 
< 		tag := field.Tag.Get("yaml")
< 		if tag == "" && strings.Index(string(field.Tag), ":") < 0 {
< 			tag = string(field.Tag)
< 		}
< 		if tag == "-" {
< 			continue
< 		}
< 
< 		inline := false
< 		fields := strings.Split(tag, ",")
< 		if len(fields) > 1 {
< 			for _, flag := range fields[1:] {
< 				switch flag {
< 				case "omitempty":
< 					info.OmitEmpty = true
< 				case "flow":
< 					info.Flow = true
< 				case "inline":
< 					inline = true
< 				default:
< 					return nil, errors.New(fmt.Sprintf("Unsupported flag %q in tag %q of type %s", flag, tag, st))
< 				}
< 			}
< 			tag = fields[0]
< 		}
< 
< 		if inline {
< 			switch field.Type.Kind() {
< 			case reflect.Map:
< 				if inlineMap >= 0 {
< 					return nil, errors.New("Multiple ,inline maps in struct " + st.String())
< 				}
< 				if field.Type.Key() != reflect.TypeOf("") {
< 					return nil, errors.New("Option ,inline needs a map with string keys in struct " + st.String())
< 				}
< 				inlineMap = info.Num
< 			case reflect.Struct:
< 				sinfo, err := getStructInfo(field.Type)
< 				if err != nil {
< 					return nil, err
< 				}
< 				for _, finfo := range sinfo.FieldsList {
< 					if _, found := fieldsMap[finfo.Key]; found {
< 						msg := "Duplicated key '" + finfo.Key + "' in struct " + st.String()
< 						return nil, errors.New(msg)
< 					}
< 					if finfo.Inline == nil {
< 						finfo.Inline = []int{i, finfo.Num}
< 					} else {
< 						finfo.Inline = append([]int{i}, finfo.Inline...)
< 					}
< 					finfo.Id = len(fieldsList)
< 					fieldsMap[finfo.Key] = finfo
< 					fieldsList = append(fieldsList, finfo)
< 				}
< 			default:
< 				//return nil, errors.New("Option ,inline needs a struct value or map field")
< 				return nil, errors.New("Option ,inline needs a struct value field")
< 			}
< 			continue
< 		}
< 
< 		if tag != "" {
< 			info.Key = tag
< 		} else {
< 			info.Key = strings.ToLower(field.Name)
< 		}
< 
< 		if _, found = fieldsMap[info.Key]; found {
< 			msg := "Duplicated key '" + info.Key + "' in struct " + st.String()
< 			return nil, errors.New(msg)
< 		}
< 
< 		info.Id = len(fieldsList)
< 		fieldsList = append(fieldsList, info)
< 		fieldsMap[info.Key] = info
< 	}
< 
< 	sinfo = &structInfo{
< 		FieldsMap:  fieldsMap,
< 		FieldsList: fieldsList,
< 		InlineMap:  inlineMap,
< 	}
< 
< 	fieldMapMutex.Lock()
< 	structMap[st] = sinfo
< 	fieldMapMutex.Unlock()
< 	return sinfo, nil
< }
< 
< // IsZeroer is used to check whether an object is zero to
< // determine whether it should be omitted when marshaling
< // with the omitempty flag. One notable implementation
< // is time.Time.
< type IsZeroer interface {
< 	IsZero() bool
< }
< 
< func isZero(v reflect.Value) bool {
< 	kind := v.Kind()
< 	if z, ok := v.Interface().(IsZeroer); ok {
< 		if (kind == reflect.Ptr || kind == reflect.Interface) && v.IsNil() {
< 			return true
< 		}
< 		return z.IsZero()
< 	}
< 	switch kind {
< 	case reflect.String:
< 		return len(v.String()) == 0
< 	case reflect.Interface, reflect.Ptr:
< 		return v.IsNil()
< 	case reflect.Slice:
< 		return v.Len() == 0
< 	case reflect.Map:
< 		return v.Len() == 0
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return v.Int() == 0
< 	case reflect.Float32, reflect.Float64:
< 		return v.Float() == 0
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return v.Uint() == 0
< 	case reflect.Bool:
< 		return !v.Bool()
< 	case reflect.Struct:
< 		vt := v.Type()
< 		for i := v.NumField() - 1; i >= 0; i-- {
< 			if vt.Field(i).PkgPath != "" {
< 				continue // Private field
< 			}
< 			if !isZero(v.Field(i)) {
< 				return false
< 			}
< 		}
< 		return true
< 	}
< 	return false
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/yamlh.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/yamlh.go
1,738d0
< package yaml
< 
< import (
< 	"fmt"
< 	"io"
< )
< 
< // The version directive data.
< type yaml_version_directive_t struct {
< 	major int8 // The major version number.
< 	minor int8 // The minor version number.
< }
< 
< // The tag directive data.
< type yaml_tag_directive_t struct {
< 	handle []byte // The tag handle.
< 	prefix []byte // The tag prefix.
< }
< 
< type yaml_encoding_t int
< 
< // The stream encoding.
< const (
< 	// Let the parser choose the encoding.
< 	yaml_ANY_ENCODING yaml_encoding_t = iota
< 
< 	yaml_UTF8_ENCODING    // The default UTF-8 encoding.
< 	yaml_UTF16LE_ENCODING // The UTF-16-LE encoding with BOM.
< 	yaml_UTF16BE_ENCODING // The UTF-16-BE encoding with BOM.
< )
< 
< type yaml_break_t int
< 
< // Line break types.
< const (
< 	// Let the parser choose the break type.
< 	yaml_ANY_BREAK yaml_break_t = iota
< 
< 	yaml_CR_BREAK   // Use CR for line breaks (Mac style).
< 	yaml_LN_BREAK   // Use LN for line breaks (Unix style).
< 	yaml_CRLN_BREAK // Use CR LN for line breaks (DOS style).
< )
< 
< type yaml_error_type_t int
< 
< // Many bad things could happen with the parser and emitter.
< const (
< 	// No error is produced.
< 	yaml_NO_ERROR yaml_error_type_t = iota
< 
< 	yaml_MEMORY_ERROR   // Cannot allocate or reallocate a block of memory.
< 	yaml_READER_ERROR   // Cannot read or decode the input stream.
< 	yaml_SCANNER_ERROR  // Cannot scan the input stream.
< 	yaml_PARSER_ERROR   // Cannot parse the input stream.
< 	yaml_COMPOSER_ERROR // Cannot compose a YAML document.
< 	yaml_WRITER_ERROR   // Cannot write to the output stream.
< 	yaml_EMITTER_ERROR  // Cannot emit a YAML stream.
< )
< 
< // The pointer position.
< type yaml_mark_t struct {
< 	index  int // The position index.
< 	line   int // The position line.
< 	column int // The position column.
< }
< 
< // Node Styles
< 
< type yaml_style_t int8
< 
< type yaml_scalar_style_t yaml_style_t
< 
< // Scalar styles.
< const (
< 	// Let the emitter choose the style.
< 	yaml_ANY_SCALAR_STYLE yaml_scalar_style_t = iota
< 
< 	yaml_PLAIN_SCALAR_STYLE         // The plain scalar style.
< 	yaml_SINGLE_QUOTED_SCALAR_STYLE // The single-quoted scalar style.
< 	yaml_DOUBLE_QUOTED_SCALAR_STYLE // The double-quoted scalar style.
< 	yaml_LITERAL_SCALAR_STYLE       // The literal scalar style.
< 	yaml_FOLDED_SCALAR_STYLE        // The folded scalar style.
< )
< 
< type yaml_sequence_style_t yaml_style_t
< 
< // Sequence styles.
< const (
< 	// Let the emitter choose the style.
< 	yaml_ANY_SEQUENCE_STYLE yaml_sequence_style_t = iota
< 
< 	yaml_BLOCK_SEQUENCE_STYLE // The block sequence style.
< 	yaml_FLOW_SEQUENCE_STYLE  // The flow sequence style.
< )
< 
< type yaml_mapping_style_t yaml_style_t
< 
< // Mapping styles.
< const (
< 	// Let the emitter choose the style.
< 	yaml_ANY_MAPPING_STYLE yaml_mapping_style_t = iota
< 
< 	yaml_BLOCK_MAPPING_STYLE // The block mapping style.
< 	yaml_FLOW_MAPPING_STYLE  // The flow mapping style.
< )
< 
< // Tokens
< 
< type yaml_token_type_t int
< 
< // Token types.
< const (
< 	// An empty token.
< 	yaml_NO_TOKEN yaml_token_type_t = iota
< 
< 	yaml_STREAM_START_TOKEN // A STREAM-START token.
< 	yaml_STREAM_END_TOKEN   // A STREAM-END token.
< 
< 	yaml_VERSION_DIRECTIVE_TOKEN // A VERSION-DIRECTIVE token.
< 	yaml_TAG_DIRECTIVE_TOKEN     // A TAG-DIRECTIVE token.
< 	yaml_DOCUMENT_START_TOKEN    // A DOCUMENT-START token.
< 	yaml_DOCUMENT_END_TOKEN      // A DOCUMENT-END token.
< 
< 	yaml_BLOCK_SEQUENCE_START_TOKEN // A BLOCK-SEQUENCE-START token.
< 	yaml_BLOCK_MAPPING_START_TOKEN  // A BLOCK-SEQUENCE-END token.
< 	yaml_BLOCK_END_TOKEN            // A BLOCK-END token.
< 
< 	yaml_FLOW_SEQUENCE_START_TOKEN // A FLOW-SEQUENCE-START token.
< 	yaml_FLOW_SEQUENCE_END_TOKEN   // A FLOW-SEQUENCE-END token.
< 	yaml_FLOW_MAPPING_START_TOKEN  // A FLOW-MAPPING-START token.
< 	yaml_FLOW_MAPPING_END_TOKEN    // A FLOW-MAPPING-END token.
< 
< 	yaml_BLOCK_ENTRY_TOKEN // A BLOCK-ENTRY token.
< 	yaml_FLOW_ENTRY_TOKEN  // A FLOW-ENTRY token.
< 	yaml_KEY_TOKEN         // A KEY token.
< 	yaml_VALUE_TOKEN       // A VALUE token.
< 
< 	yaml_ALIAS_TOKEN  // An ALIAS token.
< 	yaml_ANCHOR_TOKEN // An ANCHOR token.
< 	yaml_TAG_TOKEN    // A TAG token.
< 	yaml_SCALAR_TOKEN // A SCALAR token.
< )
< 
< func (tt yaml_token_type_t) String() string {
< 	switch tt {
< 	case yaml_NO_TOKEN:
< 		return "yaml_NO_TOKEN"
< 	case yaml_STREAM_START_TOKEN:
< 		return "yaml_STREAM_START_TOKEN"
< 	case yaml_STREAM_END_TOKEN:
< 		return "yaml_STREAM_END_TOKEN"
< 	case yaml_VERSION_DIRECTIVE_TOKEN:
< 		return "yaml_VERSION_DIRECTIVE_TOKEN"
< 	case yaml_TAG_DIRECTIVE_TOKEN:
< 		return "yaml_TAG_DIRECTIVE_TOKEN"
< 	case yaml_DOCUMENT_START_TOKEN:
< 		return "yaml_DOCUMENT_START_TOKEN"
< 	case yaml_DOCUMENT_END_TOKEN:
< 		return "yaml_DOCUMENT_END_TOKEN"
< 	case yaml_BLOCK_SEQUENCE_START_TOKEN:
< 		return "yaml_BLOCK_SEQUENCE_START_TOKEN"
< 	case yaml_BLOCK_MAPPING_START_TOKEN:
< 		return "yaml_BLOCK_MAPPING_START_TOKEN"
< 	case yaml_BLOCK_END_TOKEN:
< 		return "yaml_BLOCK_END_TOKEN"
< 	case yaml_FLOW_SEQUENCE_START_TOKEN:
< 		return "yaml_FLOW_SEQUENCE_START_TOKEN"
< 	case yaml_FLOW_SEQUENCE_END_TOKEN:
< 		return "yaml_FLOW_SEQUENCE_END_TOKEN"
< 	case yaml_FLOW_MAPPING_START_TOKEN:
< 		return "yaml_FLOW_MAPPING_START_TOKEN"
< 	case yaml_FLOW_MAPPING_END_TOKEN:
< 		return "yaml_FLOW_MAPPING_END_TOKEN"
< 	case yaml_BLOCK_ENTRY_TOKEN:
< 		return "yaml_BLOCK_ENTRY_TOKEN"
< 	case yaml_FLOW_ENTRY_TOKEN:
< 		return "yaml_FLOW_ENTRY_TOKEN"
< 	case yaml_KEY_TOKEN:
< 		return "yaml_KEY_TOKEN"
< 	case yaml_VALUE_TOKEN:
< 		return "yaml_VALUE_TOKEN"
< 	case yaml_ALIAS_TOKEN:
< 		return "yaml_ALIAS_TOKEN"
< 	case yaml_ANCHOR_TOKEN:
< 		return "yaml_ANCHOR_TOKEN"
< 	case yaml_TAG_TOKEN:
< 		return "yaml_TAG_TOKEN"
< 	case yaml_SCALAR_TOKEN:
< 		return "yaml_SCALAR_TOKEN"
< 	}
< 	return "<unknown token>"
< }
< 
< // The token structure.
< type yaml_token_t struct {
< 	// The token type.
< 	typ yaml_token_type_t
< 
< 	// The start/end of the token.
< 	start_mark, end_mark yaml_mark_t
< 
< 	// The stream encoding (for yaml_STREAM_START_TOKEN).
< 	encoding yaml_encoding_t
< 
< 	// The alias/anchor/scalar value or tag/tag directive handle
< 	// (for yaml_ALIAS_TOKEN, yaml_ANCHOR_TOKEN, yaml_SCALAR_TOKEN, yaml_TAG_TOKEN, yaml_TAG_DIRECTIVE_TOKEN).
< 	value []byte
< 
< 	// The tag suffix (for yaml_TAG_TOKEN).
< 	suffix []byte
< 
< 	// The tag directive prefix (for yaml_TAG_DIRECTIVE_TOKEN).
< 	prefix []byte
< 
< 	// The scalar style (for yaml_SCALAR_TOKEN).
< 	style yaml_scalar_style_t
< 
< 	// The version directive major/minor (for yaml_VERSION_DIRECTIVE_TOKEN).
< 	major, minor int8
< }
< 
< // Events
< 
< type yaml_event_type_t int8
< 
< // Event types.
< const (
< 	// An empty event.
< 	yaml_NO_EVENT yaml_event_type_t = iota
< 
< 	yaml_STREAM_START_EVENT   // A STREAM-START event.
< 	yaml_STREAM_END_EVENT     // A STREAM-END event.
< 	yaml_DOCUMENT_START_EVENT // A DOCUMENT-START event.
< 	yaml_DOCUMENT_END_EVENT   // A DOCUMENT-END event.
< 	yaml_ALIAS_EVENT          // An ALIAS event.
< 	yaml_SCALAR_EVENT         // A SCALAR event.
< 	yaml_SEQUENCE_START_EVENT // A SEQUENCE-START event.
< 	yaml_SEQUENCE_END_EVENT   // A SEQUENCE-END event.
< 	yaml_MAPPING_START_EVENT  // A MAPPING-START event.
< 	yaml_MAPPING_END_EVENT    // A MAPPING-END event.
< )
< 
< var eventStrings = []string{
< 	yaml_NO_EVENT:             "none",
< 	yaml_STREAM_START_EVENT:   "stream start",
< 	yaml_STREAM_END_EVENT:     "stream end",
< 	yaml_DOCUMENT_START_EVENT: "document start",
< 	yaml_DOCUMENT_END_EVENT:   "document end",
< 	yaml_ALIAS_EVENT:          "alias",
< 	yaml_SCALAR_EVENT:         "scalar",
< 	yaml_SEQUENCE_START_EVENT: "sequence start",
< 	yaml_SEQUENCE_END_EVENT:   "sequence end",
< 	yaml_MAPPING_START_EVENT:  "mapping start",
< 	yaml_MAPPING_END_EVENT:    "mapping end",
< }
< 
< func (e yaml_event_type_t) String() string {
< 	if e < 0 || int(e) >= len(eventStrings) {
< 		return fmt.Sprintf("unknown event %d", e)
< 	}
< 	return eventStrings[e]
< }
< 
< // The event structure.
< type yaml_event_t struct {
< 
< 	// The event type.
< 	typ yaml_event_type_t
< 
< 	// The start and end of the event.
< 	start_mark, end_mark yaml_mark_t
< 
< 	// The document encoding (for yaml_STREAM_START_EVENT).
< 	encoding yaml_encoding_t
< 
< 	// The version directive (for yaml_DOCUMENT_START_EVENT).
< 	version_directive *yaml_version_directive_t
< 
< 	// The list of tag directives (for yaml_DOCUMENT_START_EVENT).
< 	tag_directives []yaml_tag_directive_t
< 
< 	// The anchor (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_ALIAS_EVENT).
< 	anchor []byte
< 
< 	// The tag (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
< 	tag []byte
< 
< 	// The scalar value (for yaml_SCALAR_EVENT).
< 	value []byte
< 
< 	// Is the document start/end indicator implicit, or the tag optional?
< 	// (for yaml_DOCUMENT_START_EVENT, yaml_DOCUMENT_END_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_SCALAR_EVENT).
< 	implicit bool
< 
< 	// Is the tag optional for any non-plain style? (for yaml_SCALAR_EVENT).
< 	quoted_implicit bool
< 
< 	// The style (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
< 	style yaml_style_t
< }
< 
< func (e *yaml_event_t) scalar_style() yaml_scalar_style_t     { return yaml_scalar_style_t(e.style) }
< func (e *yaml_event_t) sequence_style() yaml_sequence_style_t { return yaml_sequence_style_t(e.style) }
< func (e *yaml_event_t) mapping_style() yaml_mapping_style_t   { return yaml_mapping_style_t(e.style) }
< 
< // Nodes
< 
< const (
< 	yaml_NULL_TAG      = "tag:yaml.org,2002:null"      // The tag !!null with the only possible value: null.
< 	yaml_BOOL_TAG      = "tag:yaml.org,2002:bool"      // The tag !!bool with the values: true and false.
< 	yaml_STR_TAG       = "tag:yaml.org,2002:str"       // The tag !!str for string values.
< 	yaml_INT_TAG       = "tag:yaml.org,2002:int"       // The tag !!int for integer values.
< 	yaml_FLOAT_TAG     = "tag:yaml.org,2002:float"     // The tag !!float for float values.
< 	yaml_TIMESTAMP_TAG = "tag:yaml.org,2002:timestamp" // The tag !!timestamp for date and time values.
< 
< 	yaml_SEQ_TAG = "tag:yaml.org,2002:seq" // The tag !!seq is used to denote sequences.
< 	yaml_MAP_TAG = "tag:yaml.org,2002:map" // The tag !!map is used to denote mapping.
< 
< 	// Not in original libyaml.
< 	yaml_BINARY_TAG = "tag:yaml.org,2002:binary"
< 	yaml_MERGE_TAG  = "tag:yaml.org,2002:merge"
< 
< 	yaml_DEFAULT_SCALAR_TAG   = yaml_STR_TAG // The default scalar tag is !!str.
< 	yaml_DEFAULT_SEQUENCE_TAG = yaml_SEQ_TAG // The default sequence tag is !!seq.
< 	yaml_DEFAULT_MAPPING_TAG  = yaml_MAP_TAG // The default mapping tag is !!map.
< )
< 
< type yaml_node_type_t int
< 
< // Node types.
< const (
< 	// An empty node.
< 	yaml_NO_NODE yaml_node_type_t = iota
< 
< 	yaml_SCALAR_NODE   // A scalar node.
< 	yaml_SEQUENCE_NODE // A sequence node.
< 	yaml_MAPPING_NODE  // A mapping node.
< )
< 
< // An element of a sequence node.
< type yaml_node_item_t int
< 
< // An element of a mapping node.
< type yaml_node_pair_t struct {
< 	key   int // The key of the element.
< 	value int // The value of the element.
< }
< 
< // The node structure.
< type yaml_node_t struct {
< 	typ yaml_node_type_t // The node type.
< 	tag []byte           // The node tag.
< 
< 	// The node data.
< 
< 	// The scalar parameters (for yaml_SCALAR_NODE).
< 	scalar struct {
< 		value  []byte              // The scalar value.
< 		length int                 // The length of the scalar value.
< 		style  yaml_scalar_style_t // The scalar style.
< 	}
< 
< 	// The sequence parameters (for YAML_SEQUENCE_NODE).
< 	sequence struct {
< 		items_data []yaml_node_item_t    // The stack of sequence items.
< 		style      yaml_sequence_style_t // The sequence style.
< 	}
< 
< 	// The mapping parameters (for yaml_MAPPING_NODE).
< 	mapping struct {
< 		pairs_data  []yaml_node_pair_t   // The stack of mapping pairs (key, value).
< 		pairs_start *yaml_node_pair_t    // The beginning of the stack.
< 		pairs_end   *yaml_node_pair_t    // The end of the stack.
< 		pairs_top   *yaml_node_pair_t    // The top of the stack.
< 		style       yaml_mapping_style_t // The mapping style.
< 	}
< 
< 	start_mark yaml_mark_t // The beginning of the node.
< 	end_mark   yaml_mark_t // The end of the node.
< 
< }
< 
< // The document structure.
< type yaml_document_t struct {
< 
< 	// The document nodes.
< 	nodes []yaml_node_t
< 
< 	// The version directive.
< 	version_directive *yaml_version_directive_t
< 
< 	// The list of tag directives.
< 	tag_directives_data  []yaml_tag_directive_t
< 	tag_directives_start int // The beginning of the tag directives list.
< 	tag_directives_end   int // The end of the tag directives list.
< 
< 	start_implicit int // Is the document start indicator implicit?
< 	end_implicit   int // Is the document end indicator implicit?
< 
< 	// The start/end of the document.
< 	start_mark, end_mark yaml_mark_t
< }
< 
< // The prototype of a read handler.
< //
< // The read handler is called when the parser needs to read more bytes from the
< // source. The handler should write not more than size bytes to the buffer.
< // The number of written bytes should be set to the size_read variable.
< //
< // [in,out]   data        A pointer to an application data specified by
< //                        yaml_parser_set_input().
< // [out]      buffer      The buffer to write the data from the source.
< // [in]       size        The size of the buffer.
< // [out]      size_read   The actual number of bytes read from the source.
< //
< // On success, the handler should return 1.  If the handler failed,
< // the returned value should be 0. On EOF, the handler should set the
< // size_read to 0 and return 1.
< type yaml_read_handler_t func(parser *yaml_parser_t, buffer []byte) (n int, err error)
< 
< // This structure holds information about a potential simple key.
< type yaml_simple_key_t struct {
< 	possible     bool        // Is a simple key possible?
< 	required     bool        // Is a simple key required?
< 	token_number int         // The number of the token.
< 	mark         yaml_mark_t // The position mark.
< }
< 
< // The states of the parser.
< type yaml_parser_state_t int
< 
< const (
< 	yaml_PARSE_STREAM_START_STATE yaml_parser_state_t = iota
< 
< 	yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE           // Expect the beginning of an implicit document.
< 	yaml_PARSE_DOCUMENT_START_STATE                    // Expect DOCUMENT-START.
< 	yaml_PARSE_DOCUMENT_CONTENT_STATE                  // Expect the content of a document.
< 	yaml_PARSE_DOCUMENT_END_STATE                      // Expect DOCUMENT-END.
< 	yaml_PARSE_BLOCK_NODE_STATE                        // Expect a block node.
< 	yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE // Expect a block node or indentless sequence.
< 	yaml_PARSE_FLOW_NODE_STATE                         // Expect a flow node.
< 	yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE        // Expect the first entry of a block sequence.
< 	yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE              // Expect an entry of a block sequence.
< 	yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE         // Expect an entry of an indentless sequence.
< 	yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE           // Expect the first key of a block mapping.
< 	yaml_PARSE_BLOCK_MAPPING_KEY_STATE                 // Expect a block mapping key.
< 	yaml_PARSE_BLOCK_MAPPING_VALUE_STATE               // Expect a block mapping value.
< 	yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE         // Expect the first entry of a flow sequence.
< 	yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE               // Expect an entry of a flow sequence.
< 	yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE   // Expect a key of an ordered mapping.
< 	yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE // Expect a value of an ordered mapping.
< 	yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE   // Expect the and of an ordered mapping entry.
< 	yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE            // Expect the first key of a flow mapping.
< 	yaml_PARSE_FLOW_MAPPING_KEY_STATE                  // Expect a key of a flow mapping.
< 	yaml_PARSE_FLOW_MAPPING_VALUE_STATE                // Expect a value of a flow mapping.
< 	yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE          // Expect an empty value of a flow mapping.
< 	yaml_PARSE_END_STATE                               // Expect nothing.
< )
< 
< func (ps yaml_parser_state_t) String() string {
< 	switch ps {
< 	case yaml_PARSE_STREAM_START_STATE:
< 		return "yaml_PARSE_STREAM_START_STATE"
< 	case yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE:
< 		return "yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE"
< 	case yaml_PARSE_DOCUMENT_START_STATE:
< 		return "yaml_PARSE_DOCUMENT_START_STATE"
< 	case yaml_PARSE_DOCUMENT_CONTENT_STATE:
< 		return "yaml_PARSE_DOCUMENT_CONTENT_STATE"
< 	case yaml_PARSE_DOCUMENT_END_STATE:
< 		return "yaml_PARSE_DOCUMENT_END_STATE"
< 	case yaml_PARSE_BLOCK_NODE_STATE:
< 		return "yaml_PARSE_BLOCK_NODE_STATE"
< 	case yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE:
< 		return "yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE"
< 	case yaml_PARSE_FLOW_NODE_STATE:
< 		return "yaml_PARSE_FLOW_NODE_STATE"
< 	case yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE:
< 		return "yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE"
< 	case yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE:
< 		return "yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE"
< 	case yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE:
< 		return "yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE"
< 	case yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE:
< 		return "yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE"
< 	case yaml_PARSE_BLOCK_MAPPING_KEY_STATE:
< 		return "yaml_PARSE_BLOCK_MAPPING_KEY_STATE"
< 	case yaml_PARSE_BLOCK_MAPPING_VALUE_STATE:
< 		return "yaml_PARSE_BLOCK_MAPPING_VALUE_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE"
< 	case yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE:
< 		return "yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE"
< 	case yaml_PARSE_FLOW_MAPPING_KEY_STATE:
< 		return "yaml_PARSE_FLOW_MAPPING_KEY_STATE"
< 	case yaml_PARSE_FLOW_MAPPING_VALUE_STATE:
< 		return "yaml_PARSE_FLOW_MAPPING_VALUE_STATE"
< 	case yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE:
< 		return "yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE"
< 	case yaml_PARSE_END_STATE:
< 		return "yaml_PARSE_END_STATE"
< 	}
< 	return "<unknown parser state>"
< }
< 
< // This structure holds aliases data.
< type yaml_alias_data_t struct {
< 	anchor []byte      // The anchor.
< 	index  int         // The node id.
< 	mark   yaml_mark_t // The anchor mark.
< }
< 
< // The parser structure.
< //
< // All members are internal. Manage the structure using the
< // yaml_parser_ family of functions.
< type yaml_parser_t struct {
< 
< 	// Error handling
< 
< 	error yaml_error_type_t // Error type.
< 
< 	problem string // Error description.
< 
< 	// The byte about which the problem occurred.
< 	problem_offset int
< 	problem_value  int
< 	problem_mark   yaml_mark_t
< 
< 	// The error context.
< 	context      string
< 	context_mark yaml_mark_t
< 
< 	// Reader stuff
< 
< 	read_handler yaml_read_handler_t // Read handler.
< 
< 	input_reader io.Reader // File input data.
< 	input        []byte    // String input data.
< 	input_pos    int
< 
< 	eof bool // EOF flag
< 
< 	buffer     []byte // The working buffer.
< 	buffer_pos int    // The current position of the buffer.
< 
< 	unread int // The number of unread characters in the buffer.
< 
< 	raw_buffer     []byte // The raw buffer.
< 	raw_buffer_pos int    // The current position of the buffer.
< 
< 	encoding yaml_encoding_t // The input encoding.
< 
< 	offset int         // The offset of the current position (in bytes).
< 	mark   yaml_mark_t // The mark of the current position.
< 
< 	// Scanner stuff
< 
< 	stream_start_produced bool // Have we started to scan the input stream?
< 	stream_end_produced   bool // Have we reached the end of the input stream?
< 
< 	flow_level int // The number of unclosed '[' and '{' indicators.
< 
< 	tokens          []yaml_token_t // The tokens queue.
< 	tokens_head     int            // The head of the tokens queue.
< 	tokens_parsed   int            // The number of tokens fetched from the queue.
< 	token_available bool           // Does the tokens queue contain a token ready for dequeueing.
< 
< 	indent  int   // The current indentation level.
< 	indents []int // The indentation levels stack.
< 
< 	simple_key_allowed bool                // May a simple key occur at the current position?
< 	simple_keys        []yaml_simple_key_t // The stack of simple keys.
< 
< 	// Parser stuff
< 
< 	state          yaml_parser_state_t    // The current parser state.
< 	states         []yaml_parser_state_t  // The parser states stack.
< 	marks          []yaml_mark_t          // The stack of marks.
< 	tag_directives []yaml_tag_directive_t // The list of TAG directives.
< 
< 	// Dumper stuff
< 
< 	aliases []yaml_alias_data_t // The alias data.
< 
< 	document *yaml_document_t // The currently parsed document.
< }
< 
< // Emitter Definitions
< 
< // The prototype of a write handler.
< //
< // The write handler is called when the emitter needs to flush the accumulated
< // characters to the output.  The handler should write @a size bytes of the
< // @a buffer to the output.
< //
< // @param[in,out]   data        A pointer to an application data specified by
< //                              yaml_emitter_set_output().
< // @param[in]       buffer      The buffer with bytes to be written.
< // @param[in]       size        The size of the buffer.
< //
< // @returns On success, the handler should return @c 1.  If the handler failed,
< // the returned value should be @c 0.
< //
< type yaml_write_handler_t func(emitter *yaml_emitter_t, buffer []byte) error
< 
< type yaml_emitter_state_t int
< 
< // The emitter states.
< const (
< 	// Expect STREAM-START.
< 	yaml_EMIT_STREAM_START_STATE yaml_emitter_state_t = iota
< 
< 	yaml_EMIT_FIRST_DOCUMENT_START_STATE       // Expect the first DOCUMENT-START or STREAM-END.
< 	yaml_EMIT_DOCUMENT_START_STATE             // Expect DOCUMENT-START or STREAM-END.
< 	yaml_EMIT_DOCUMENT_CONTENT_STATE           // Expect the content of a document.
< 	yaml_EMIT_DOCUMENT_END_STATE               // Expect DOCUMENT-END.
< 	yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE   // Expect the first item of a flow sequence.
< 	yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE         // Expect an item of a flow sequence.
< 	yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE     // Expect the first key of a flow mapping.
< 	yaml_EMIT_FLOW_MAPPING_KEY_STATE           // Expect a key of a flow mapping.
< 	yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE  // Expect a value for a simple key of a flow mapping.
< 	yaml_EMIT_FLOW_MAPPING_VALUE_STATE         // Expect a value of a flow mapping.
< 	yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE  // Expect the first item of a block sequence.
< 	yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE        // Expect an item of a block sequence.
< 	yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE    // Expect the first key of a block mapping.
< 	yaml_EMIT_BLOCK_MAPPING_KEY_STATE          // Expect the key of a block mapping.
< 	yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE // Expect a value for a simple key of a block mapping.
< 	yaml_EMIT_BLOCK_MAPPING_VALUE_STATE        // Expect a value of a block mapping.
< 	yaml_EMIT_END_STATE                        // Expect nothing.
< )
< 
< // The emitter structure.
< //
< // All members are internal.  Manage the structure using the @c yaml_emitter_
< // family of functions.
< type yaml_emitter_t struct {
< 
< 	// Error handling
< 
< 	error   yaml_error_type_t // Error type.
< 	problem string            // Error description.
< 
< 	// Writer stuff
< 
< 	write_handler yaml_write_handler_t // Write handler.
< 
< 	output_buffer *[]byte   // String output data.
< 	output_writer io.Writer // File output data.
< 
< 	buffer     []byte // The working buffer.
< 	buffer_pos int    // The current position of the buffer.
< 
< 	raw_buffer     []byte // The raw buffer.
< 	raw_buffer_pos int    // The current position of the buffer.
< 
< 	encoding yaml_encoding_t // The stream encoding.
< 
< 	// Emitter stuff
< 
< 	canonical   bool         // If the output is in the canonical style?
< 	best_indent int          // The number of indentation spaces.
< 	best_width  int          // The preferred width of the output lines.
< 	unicode     bool         // Allow unescaped non-ASCII characters?
< 	line_break  yaml_break_t // The preferred line break.
< 
< 	state  yaml_emitter_state_t   // The current emitter state.
< 	states []yaml_emitter_state_t // The stack of states.
< 
< 	events      []yaml_event_t // The event queue.
< 	events_head int            // The head of the event queue.
< 
< 	indents []int // The stack of indentation levels.
< 
< 	tag_directives []yaml_tag_directive_t // The list of tag directives.
< 
< 	indent int // The current indentation level.
< 
< 	flow_level int // The current flow level.
< 
< 	root_context       bool // Is it the document root context?
< 	sequence_context   bool // Is it a sequence context?
< 	mapping_context    bool // Is it a mapping context?
< 	simple_key_context bool // Is it a simple mapping key context?
< 
< 	line       int  // The current line.
< 	column     int  // The current column.
< 	whitespace bool // If the last character was a whitespace?
< 	indention  bool // If the last character was an indentation character (' ', '-', '?', ':')?
< 	open_ended bool // If an explicit document end is required?
< 
< 	// Anchor analysis.
< 	anchor_data struct {
< 		anchor []byte // The anchor value.
< 		alias  bool   // Is it an alias?
< 	}
< 
< 	// Tag analysis.
< 	tag_data struct {
< 		handle []byte // The tag handle.
< 		suffix []byte // The tag suffix.
< 	}
< 
< 	// Scalar analysis.
< 	scalar_data struct {
< 		value                 []byte              // The scalar value.
< 		multiline             bool                // Does the scalar contain line breaks?
< 		flow_plain_allowed    bool                // Can the scalar be expessed in the flow plain style?
< 		block_plain_allowed   bool                // Can the scalar be expressed in the block plain style?
< 		single_quoted_allowed bool                // Can the scalar be expressed in the single quoted style?
< 		block_allowed         bool                // Can the scalar be expressed in the literal or folded styles?
< 		style                 yaml_scalar_style_t // The output style.
< 	}
< 
< 	// Dumper stuff
< 
< 	opened bool // If the stream was already opened?
< 	closed bool // If the stream was already closed?
< 
< 	// The information associated with the document nodes.
< 	anchors *struct {
< 		references int  // The number of references.
< 		anchor     int  // The anchor id.
< 		serialized bool // If the node has been emitted?
< 	}
< 
< 	last_anchor_id int // The last assigned anchor id.
< 
< 	document *yaml_document_t // The currently emitted document.
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/yamlprivateh.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v2/yamlprivateh.go
1,173d0
< package yaml
< 
< const (
< 	// The size of the input raw buffer.
< 	input_raw_buffer_size = 512
< 
< 	// The size of the input buffer.
< 	// It should be possible to decode the whole raw buffer.
< 	input_buffer_size = input_raw_buffer_size * 3
< 
< 	// The size of the output buffer.
< 	output_buffer_size = 128
< 
< 	// The size of the output raw buffer.
< 	// It should be possible to encode the whole output buffer.
< 	output_raw_buffer_size = (output_buffer_size*2 + 2)
< 
< 	// The size of other stacks and queues.
< 	initial_stack_size  = 16
< 	initial_queue_size  = 16
< 	initial_string_size = 16
< )
< 
< // Check if the character at the specified position is an alphabetical
< // character, a digit, '_', or '-'.
< func is_alpha(b []byte, i int) bool {
< 	return b[i] >= '0' && b[i] <= '9' || b[i] >= 'A' && b[i] <= 'Z' || b[i] >= 'a' && b[i] <= 'z' || b[i] == '_' || b[i] == '-'
< }
< 
< // Check if the character at the specified position is a digit.
< func is_digit(b []byte, i int) bool {
< 	return b[i] >= '0' && b[i] <= '9'
< }
< 
< // Get the value of a digit.
< func as_digit(b []byte, i int) int {
< 	return int(b[i]) - '0'
< }
< 
< // Check if the character at the specified position is a hex-digit.
< func is_hex(b []byte, i int) bool {
< 	return b[i] >= '0' && b[i] <= '9' || b[i] >= 'A' && b[i] <= 'F' || b[i] >= 'a' && b[i] <= 'f'
< }
< 
< // Get the value of a hex-digit.
< func as_hex(b []byte, i int) int {
< 	bi := b[i]
< 	if bi >= 'A' && bi <= 'F' {
< 		return int(bi) - 'A' + 10
< 	}
< 	if bi >= 'a' && bi <= 'f' {
< 		return int(bi) - 'a' + 10
< 	}
< 	return int(bi) - '0'
< }
< 
< // Check if the character is ASCII.
< func is_ascii(b []byte, i int) bool {
< 	return b[i] <= 0x7F
< }
< 
< // Check if the character at the start of the buffer can be printed unescaped.
< func is_printable(b []byte, i int) bool {
< 	return ((b[i] == 0x0A) || // . == #x0A
< 		(b[i] >= 0x20 && b[i] <= 0x7E) || // #x20 <= . <= #x7E
< 		(b[i] == 0xC2 && b[i+1] >= 0xA0) || // #0xA0 <= . <= #xD7FF
< 		(b[i] > 0xC2 && b[i] < 0xED) ||
< 		(b[i] == 0xED && b[i+1] < 0xA0) ||
< 		(b[i] == 0xEE) ||
< 		(b[i] == 0xEF && // #xE000 <= . <= #xFFFD
< 			!(b[i+1] == 0xBB && b[i+2] == 0xBF) && // && . != #xFEFF
< 			!(b[i+1] == 0xBF && (b[i+2] == 0xBE || b[i+2] == 0xBF))))
< }
< 
< // Check if the character at the specified position is NUL.
< func is_z(b []byte, i int) bool {
< 	return b[i] == 0x00
< }
< 
< // Check if the beginning of the buffer is a BOM.
< func is_bom(b []byte, i int) bool {
< 	return b[0] == 0xEF && b[1] == 0xBB && b[2] == 0xBF
< }
< 
< // Check if the character at the specified position is space.
< func is_space(b []byte, i int) bool {
< 	return b[i] == ' '
< }
< 
< // Check if the character at the specified position is tab.
< func is_tab(b []byte, i int) bool {
< 	return b[i] == '\t'
< }
< 
< // Check if the character at the specified position is blank (space or tab).
< func is_blank(b []byte, i int) bool {
< 	//return is_space(b, i) || is_tab(b, i)
< 	return b[i] == ' ' || b[i] == '\t'
< }
< 
< // Check if the character at the specified position is a line break.
< func is_break(b []byte, i int) bool {
< 	return (b[i] == '\r' || // CR (#xD)
< 		b[i] == '\n' || // LF (#xA)
< 		b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9) // PS (#x2029)
< }
< 
< func is_crlf(b []byte, i int) bool {
< 	return b[i] == '\r' && b[i+1] == '\n'
< }
< 
< // Check if the character is a line break or NUL.
< func is_breakz(b []byte, i int) bool {
< 	//return is_break(b, i) || is_z(b, i)
< 	return (        // is_break:
< 	b[i] == '\r' || // CR (#xD)
< 		b[i] == '\n' || // LF (#xA)
< 		b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
< 		// is_z:
< 		b[i] == 0)
< }
< 
< // Check if the character is a line break, space, or NUL.
< func is_spacez(b []byte, i int) bool {
< 	//return is_space(b, i) || is_breakz(b, i)
< 	return ( // is_space:
< 	b[i] == ' ' ||
< 		// is_breakz:
< 		b[i] == '\r' || // CR (#xD)
< 		b[i] == '\n' || // LF (#xA)
< 		b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
< 		b[i] == 0)
< }
< 
< // Check if the character is a line break, space, tab, or NUL.
< func is_blankz(b []byte, i int) bool {
< 	//return is_blank(b, i) || is_breakz(b, i)
< 	return ( // is_blank:
< 	b[i] == ' ' || b[i] == '\t' ||
< 		// is_breakz:
< 		b[i] == '\r' || // CR (#xD)
< 		b[i] == '\n' || // LF (#xA)
< 		b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
< 		b[i] == 0)
< }
< 
< // Determine the width of the character.
< func width(b byte) int {
< 	// Don't replace these by a switch without first
< 	// confirming that it is being inlined.
< 	if b&0x80 == 0x00 {
< 		return 1
< 	}
< 	if b&0xE0 == 0xC0 {
< 		return 2
< 	}
< 	if b&0xF0 == 0xE0 {
< 		return 3
< 	}
< 	if b&0xF8 == 0xF0 {
< 		return 4
< 	}
< 	return 0
< 
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/.travis.yml updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/.travis.yml
1,15d0
< language: go
< 
< go:
<     - "1.4"
<     - "1.5"
<     - "1.6"
<     - "1.7"
<     - "1.8"
<     - "1.9"
<     - "1.10"
<     - "1.11"
<     - "1.12"
<     - tip
< 
< go_import_path: gopkg.in/yaml.v3
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/LICENSE updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/LICENSE
1,50d0
< 
< This project is covered by two different licenses: MIT and Apache.
< 
< #### MIT License ####
< 
< The following files were ported to Go from C files of libyaml, and thus
< are still covered by their original MIT license, with the additional
< copyright staring in 2011 when the project was ported over:
< 
<     apic.go emitterc.go parserc.go readerc.go scannerc.go
<     writerc.go yamlh.go yamlprivateh.go
< 
< Copyright (c) 2006-2010 Kirill Simonov
< Copyright (c) 2006-2011 Kirill Simonov
< 
< Permission is hereby granted, free of charge, to any person obtaining a copy of
< this software and associated documentation files (the "Software"), to deal in
< the Software without restriction, including without limitation the rights to
< use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< of the Software, and to permit persons to whom the Software is furnished to do
< so, subject to the following conditions:
< 
< The above copyright notice and this permission notice shall be included in all
< copies or substantial portions of the Software.
< 
< THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< SOFTWARE.
< 
< ### Apache License ###
< 
< All the remaining project files are covered by the Apache license:
< 
< Copyright (c) 2011-2019 Canonical Ltd
< 
< Licensed under the Apache License, Version 2.0 (the "License");
< you may not use this file except in compliance with the License.
< You may obtain a copy of the License at
< 
<     http://www.apache.org/licenses/LICENSE-2.0
< 
< Unless required by applicable law or agreed to in writing, software
< distributed under the License is distributed on an "AS IS" BASIS,
< WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< See the License for the specific language governing permissions and
< limitations under the License.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/NOTICE updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/NOTICE
1,13d0
< Copyright 2011-2016 Canonical Ltd.
< 
< Licensed under the Apache License, Version 2.0 (the "License");
< you may not use this file except in compliance with the License.
< You may obtain a copy of the License at
< 
<     http://www.apache.org/licenses/LICENSE-2.0
< 
< Unless required by applicable law or agreed to in writing, software
< distributed under the License is distributed on an "AS IS" BASIS,
< WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< See the License for the specific language governing permissions and
< limitations under the License.
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/README.md updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/README.md
1,150d0
< # YAML support for the Go language
< 
< Introduction
< ------------
< 
< The yaml package enables Go programs to comfortably encode and decode YAML
< values. It was developed within [Canonical](https://www.canonical.com) as
< part of the [juju](https://juju.ubuntu.com) project, and is based on a
< pure Go port of the well-known [libyaml](http://pyyaml.org/wiki/LibYAML)
< C library to parse and generate YAML data quickly and reliably.
< 
< Compatibility
< -------------
< 
< The yaml package supports most of YAML 1.2, but preserves some behavior
< from 1.1 for backwards compatibility.
< 
< Specifically, as of v3 of the yaml package:
< 
<  - YAML 1.1 bools (_yes/no, on/off_) are supported as long as they are being
<    decoded into a typed bool value. Otherwise they behave as a string. Booleans
<    in YAML 1.2 are _true/false_ only.
<  - Octals encode and decode as _0777_ per YAML 1.1, rather than _0o777_
<    as specified in YAML 1.2, because most parsers still use the old format.
<    Octals in the  _0o777_ format are supported though, so new files work.
<  - Does not support base-60 floats. These are gone from YAML 1.2, and were
<    actually never supported by this package as it's clearly a poor choice.
< 
< and offers backwards
< compatibility with YAML 1.1 in some cases.
< 1.2, including support for
< anchors, tags, map merging, etc. Multi-document unmarshalling is not yet
< implemented, and base-60 floats from YAML 1.1 are purposefully not
< supported since they're a poor design and are gone in YAML 1.2.
< 
< Installation and usage
< ----------------------
< 
< The import path for the package is *gopkg.in/yaml.v3*.
< 
< To install it, run:
< 
<     go get gopkg.in/yaml.v3
< 
< API documentation
< -----------------
< 
< If opened in a browser, the import path itself leads to the API documentation:
< 
<   - [https://gopkg.in/yaml.v3](https://gopkg.in/yaml.v3)
< 
< API stability
< -------------
< 
< The package API for yaml v3 will remain stable as described in [gopkg.in](https://gopkg.in).
< 
< 
< License
< -------
< 
< The yaml package is licensed under the MIT and Apache License 2.0 licenses.
< Please see the LICENSE file for details.
< 
< 
< Example
< -------
< 
< ```Go
< package main
< 
< import (
<         "fmt"
<         "log"
< 
<         "gopkg.in/yaml.v3"
< )
< 
< var data = `
< a: Easy!
< b:
<   c: 2
<   d: [3, 4]
< `
< 
< // Note: struct fields must be public in order for unmarshal to
< // correctly populate the data.
< type T struct {
<         A string
<         B struct {
<                 RenamedC int   `yaml:"c"`
<                 D        []int `yaml:",flow"`
<         }
< }
< 
< func main() {
<         t := T{}
<     
<         err := yaml.Unmarshal([]byte(data), &t)
<         if err != nil {
<                 log.Fatalf("error: %v", err)
<         }
<         fmt.Printf("--- t:\n%v\n\n", t)
<     
<         d, err := yaml.Marshal(&t)
<         if err != nil {
<                 log.Fatalf("error: %v", err)
<         }
<         fmt.Printf("--- t dump:\n%s\n\n", string(d))
<     
<         m := make(map[interface{}]interface{})
<     
<         err = yaml.Unmarshal([]byte(data), &m)
<         if err != nil {
<                 log.Fatalf("error: %v", err)
<         }
<         fmt.Printf("--- m:\n%v\n\n", m)
<     
<         d, err = yaml.Marshal(&m)
<         if err != nil {
<                 log.Fatalf("error: %v", err)
<         }
<         fmt.Printf("--- m dump:\n%s\n\n", string(d))
< }
< ```
< 
< This example will generate the following output:
< 
< ```
< --- t:
< {Easy! {2 [3 4]}}
< 
< --- t dump:
< a: Easy!
< b:
<   c: 2
<   d: [3, 4]
< 
< 
< --- m:
< map[a:Easy! b:map[c:2 d:[3 4]]]
< 
< --- m dump:
< a: Easy!
< b:
<   c: 2
<   d:
<   - 3
<   - 4
< ```
< 
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/apic.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/apic.go
1,746d0
< // 
< // Copyright (c) 2011-2019 Canonical Ltd
< // Copyright (c) 2006-2010 Kirill Simonov
< // 
< // Permission is hereby granted, free of charge, to any person obtaining a copy of
< // this software and associated documentation files (the "Software"), to deal in
< // the Software without restriction, including without limitation the rights to
< // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< // of the Software, and to permit persons to whom the Software is furnished to do
< // so, subject to the following conditions:
< // 
< // The above copyright notice and this permission notice shall be included in all
< // copies or substantial portions of the Software.
< // 
< // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< // SOFTWARE.
< 
< package yaml
< 
< import (
< 	"io"
< )
< 
< func yaml_insert_token(parser *yaml_parser_t, pos int, token *yaml_token_t) {
< 	//fmt.Println("yaml_insert_token", "pos:", pos, "typ:", token.typ, "head:", parser.tokens_head, "len:", len(parser.tokens))
< 
< 	// Check if we can move the queue at the beginning of the buffer.
< 	if parser.tokens_head > 0 && len(parser.tokens) == cap(parser.tokens) {
< 		if parser.tokens_head != len(parser.tokens) {
< 			copy(parser.tokens, parser.tokens[parser.tokens_head:])
< 		}
< 		parser.tokens = parser.tokens[:len(parser.tokens)-parser.tokens_head]
< 		parser.tokens_head = 0
< 	}
< 	parser.tokens = append(parser.tokens, *token)
< 	if pos < 0 {
< 		return
< 	}
< 	copy(parser.tokens[parser.tokens_head+pos+1:], parser.tokens[parser.tokens_head+pos:])
< 	parser.tokens[parser.tokens_head+pos] = *token
< }
< 
< // Create a new parser object.
< func yaml_parser_initialize(parser *yaml_parser_t) bool {
< 	*parser = yaml_parser_t{
< 		raw_buffer: make([]byte, 0, input_raw_buffer_size),
< 		buffer:     make([]byte, 0, input_buffer_size),
< 	}
< 	return true
< }
< 
< // Destroy a parser object.
< func yaml_parser_delete(parser *yaml_parser_t) {
< 	*parser = yaml_parser_t{}
< }
< 
< // String read handler.
< func yaml_string_read_handler(parser *yaml_parser_t, buffer []byte) (n int, err error) {
< 	if parser.input_pos == len(parser.input) {
< 		return 0, io.EOF
< 	}
< 	n = copy(buffer, parser.input[parser.input_pos:])
< 	parser.input_pos += n
< 	return n, nil
< }
< 
< // Reader read handler.
< func yaml_reader_read_handler(parser *yaml_parser_t, buffer []byte) (n int, err error) {
< 	return parser.input_reader.Read(buffer)
< }
< 
< // Set a string input.
< func yaml_parser_set_input_string(parser *yaml_parser_t, input []byte) {
< 	if parser.read_handler != nil {
< 		panic("must set the input source only once")
< 	}
< 	parser.read_handler = yaml_string_read_handler
< 	parser.input = input
< 	parser.input_pos = 0
< }
< 
< // Set a file input.
< func yaml_parser_set_input_reader(parser *yaml_parser_t, r io.Reader) {
< 	if parser.read_handler != nil {
< 		panic("must set the input source only once")
< 	}
< 	parser.read_handler = yaml_reader_read_handler
< 	parser.input_reader = r
< }
< 
< // Set the source encoding.
< func yaml_parser_set_encoding(parser *yaml_parser_t, encoding yaml_encoding_t) {
< 	if parser.encoding != yaml_ANY_ENCODING {
< 		panic("must set the encoding only once")
< 	}
< 	parser.encoding = encoding
< }
< 
< // Create a new emitter object.
< func yaml_emitter_initialize(emitter *yaml_emitter_t) {
< 	*emitter = yaml_emitter_t{
< 		buffer:     make([]byte, output_buffer_size),
< 		raw_buffer: make([]byte, 0, output_raw_buffer_size),
< 		states:     make([]yaml_emitter_state_t, 0, initial_stack_size),
< 		events:     make([]yaml_event_t, 0, initial_queue_size),
< 	}
< }
< 
< // Destroy an emitter object.
< func yaml_emitter_delete(emitter *yaml_emitter_t) {
< 	*emitter = yaml_emitter_t{}
< }
< 
< // String write handler.
< func yaml_string_write_handler(emitter *yaml_emitter_t, buffer []byte) error {
< 	*emitter.output_buffer = append(*emitter.output_buffer, buffer...)
< 	return nil
< }
< 
< // yaml_writer_write_handler uses emitter.output_writer to write the
< // emitted text.
< func yaml_writer_write_handler(emitter *yaml_emitter_t, buffer []byte) error {
< 	_, err := emitter.output_writer.Write(buffer)
< 	return err
< }
< 
< // Set a string output.
< func yaml_emitter_set_output_string(emitter *yaml_emitter_t, output_buffer *[]byte) {
< 	if emitter.write_handler != nil {
< 		panic("must set the output target only once")
< 	}
< 	emitter.write_handler = yaml_string_write_handler
< 	emitter.output_buffer = output_buffer
< }
< 
< // Set a file output.
< func yaml_emitter_set_output_writer(emitter *yaml_emitter_t, w io.Writer) {
< 	if emitter.write_handler != nil {
< 		panic("must set the output target only once")
< 	}
< 	emitter.write_handler = yaml_writer_write_handler
< 	emitter.output_writer = w
< }
< 
< // Set the output encoding.
< func yaml_emitter_set_encoding(emitter *yaml_emitter_t, encoding yaml_encoding_t) {
< 	if emitter.encoding != yaml_ANY_ENCODING {
< 		panic("must set the output encoding only once")
< 	}
< 	emitter.encoding = encoding
< }
< 
< // Set the canonical output style.
< func yaml_emitter_set_canonical(emitter *yaml_emitter_t, canonical bool) {
< 	emitter.canonical = canonical
< }
< 
< // Set the indentation increment.
< func yaml_emitter_set_indent(emitter *yaml_emitter_t, indent int) {
< 	if indent < 2 || indent > 9 {
< 		indent = 2
< 	}
< 	emitter.best_indent = indent
< }
< 
< // Set the preferred line width.
< func yaml_emitter_set_width(emitter *yaml_emitter_t, width int) {
< 	if width < 0 {
< 		width = -1
< 	}
< 	emitter.best_width = width
< }
< 
< // Set if unescaped non-ASCII characters are allowed.
< func yaml_emitter_set_unicode(emitter *yaml_emitter_t, unicode bool) {
< 	emitter.unicode = unicode
< }
< 
< // Set the preferred line break character.
< func yaml_emitter_set_break(emitter *yaml_emitter_t, line_break yaml_break_t) {
< 	emitter.line_break = line_break
< }
< 
< ///*
< // * Destroy a token object.
< // */
< //
< //YAML_DECLARE(void)
< //yaml_token_delete(yaml_token_t *token)
< //{
< //    assert(token);  // Non-NULL token object expected.
< //
< //    switch (token.type)
< //    {
< //        case YAML_TAG_DIRECTIVE_TOKEN:
< //            yaml_free(token.data.tag_directive.handle);
< //            yaml_free(token.data.tag_directive.prefix);
< //            break;
< //
< //        case YAML_ALIAS_TOKEN:
< //            yaml_free(token.data.alias.value);
< //            break;
< //
< //        case YAML_ANCHOR_TOKEN:
< //            yaml_free(token.data.anchor.value);
< //            break;
< //
< //        case YAML_TAG_TOKEN:
< //            yaml_free(token.data.tag.handle);
< //            yaml_free(token.data.tag.suffix);
< //            break;
< //
< //        case YAML_SCALAR_TOKEN:
< //            yaml_free(token.data.scalar.value);
< //            break;
< //
< //        default:
< //            break;
< //    }
< //
< //    memset(token, 0, sizeof(yaml_token_t));
< //}
< //
< ///*
< // * Check if a string is a valid UTF-8 sequence.
< // *
< // * Check 'reader.c' for more details on UTF-8 encoding.
< // */
< //
< //static int
< //yaml_check_utf8(yaml_char_t *start, size_t length)
< //{
< //    yaml_char_t *end = start+length;
< //    yaml_char_t *pointer = start;
< //
< //    while (pointer < end) {
< //        unsigned char octet;
< //        unsigned int width;
< //        unsigned int value;
< //        size_t k;
< //
< //        octet = pointer[0];
< //        width = (octet & 0x80) == 0x00 ? 1 :
< //                (octet & 0xE0) == 0xC0 ? 2 :
< //                (octet & 0xF0) == 0xE0 ? 3 :
< //                (octet & 0xF8) == 0xF0 ? 4 : 0;
< //        value = (octet & 0x80) == 0x00 ? octet & 0x7F :
< //                (octet & 0xE0) == 0xC0 ? octet & 0x1F :
< //                (octet & 0xF0) == 0xE0 ? octet & 0x0F :
< //                (octet & 0xF8) == 0xF0 ? octet & 0x07 : 0;
< //        if (!width) return 0;
< //        if (pointer+width > end) return 0;
< //        for (k = 1; k < width; k ++) {
< //            octet = pointer[k];
< //            if ((octet & 0xC0) != 0x80) return 0;
< //            value = (value << 6) + (octet & 0x3F);
< //        }
< //        if (!((width == 1) ||
< //            (width == 2 && value >= 0x80) ||
< //            (width == 3 && value >= 0x800) ||
< //            (width == 4 && value >= 0x10000))) return 0;
< //
< //        pointer += width;
< //    }
< //
< //    return 1;
< //}
< //
< 
< // Create STREAM-START.
< func yaml_stream_start_event_initialize(event *yaml_event_t, encoding yaml_encoding_t) {
< 	*event = yaml_event_t{
< 		typ:      yaml_STREAM_START_EVENT,
< 		encoding: encoding,
< 	}
< }
< 
< // Create STREAM-END.
< func yaml_stream_end_event_initialize(event *yaml_event_t) {
< 	*event = yaml_event_t{
< 		typ: yaml_STREAM_END_EVENT,
< 	}
< }
< 
< // Create DOCUMENT-START.
< func yaml_document_start_event_initialize(
< 	event *yaml_event_t,
< 	version_directive *yaml_version_directive_t,
< 	tag_directives []yaml_tag_directive_t,
< 	implicit bool,
< ) {
< 	*event = yaml_event_t{
< 		typ:               yaml_DOCUMENT_START_EVENT,
< 		version_directive: version_directive,
< 		tag_directives:    tag_directives,
< 		implicit:          implicit,
< 	}
< }
< 
< // Create DOCUMENT-END.
< func yaml_document_end_event_initialize(event *yaml_event_t, implicit bool) {
< 	*event = yaml_event_t{
< 		typ:      yaml_DOCUMENT_END_EVENT,
< 		implicit: implicit,
< 	}
< }
< 
< // Create ALIAS.
< func yaml_alias_event_initialize(event *yaml_event_t, anchor []byte) bool {
< 	*event = yaml_event_t{
< 		typ:    yaml_ALIAS_EVENT,
< 		anchor: anchor,
< 	}
< 	return true
< }
< 
< // Create SCALAR.
< func yaml_scalar_event_initialize(event *yaml_event_t, anchor, tag, value []byte, plain_implicit, quoted_implicit bool, style yaml_scalar_style_t) bool {
< 	*event = yaml_event_t{
< 		typ:             yaml_SCALAR_EVENT,
< 		anchor:          anchor,
< 		tag:             tag,
< 		value:           value,
< 		implicit:        plain_implicit,
< 		quoted_implicit: quoted_implicit,
< 		style:           yaml_style_t(style),
< 	}
< 	return true
< }
< 
< // Create SEQUENCE-START.
< func yaml_sequence_start_event_initialize(event *yaml_event_t, anchor, tag []byte, implicit bool, style yaml_sequence_style_t) bool {
< 	*event = yaml_event_t{
< 		typ:      yaml_SEQUENCE_START_EVENT,
< 		anchor:   anchor,
< 		tag:      tag,
< 		implicit: implicit,
< 		style:    yaml_style_t(style),
< 	}
< 	return true
< }
< 
< // Create SEQUENCE-END.
< func yaml_sequence_end_event_initialize(event *yaml_event_t) bool {
< 	*event = yaml_event_t{
< 		typ: yaml_SEQUENCE_END_EVENT,
< 	}
< 	return true
< }
< 
< // Create MAPPING-START.
< func yaml_mapping_start_event_initialize(event *yaml_event_t, anchor, tag []byte, implicit bool, style yaml_mapping_style_t) {
< 	*event = yaml_event_t{
< 		typ:      yaml_MAPPING_START_EVENT,
< 		anchor:   anchor,
< 		tag:      tag,
< 		implicit: implicit,
< 		style:    yaml_style_t(style),
< 	}
< }
< 
< // Create MAPPING-END.
< func yaml_mapping_end_event_initialize(event *yaml_event_t) {
< 	*event = yaml_event_t{
< 		typ: yaml_MAPPING_END_EVENT,
< 	}
< }
< 
< // Destroy an event object.
< func yaml_event_delete(event *yaml_event_t) {
< 	*event = yaml_event_t{}
< }
< 
< ///*
< // * Create a document object.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_initialize(document *yaml_document_t,
< //        version_directive *yaml_version_directive_t,
< //        tag_directives_start *yaml_tag_directive_t,
< //        tag_directives_end *yaml_tag_directive_t,
< //        start_implicit int, end_implicit int)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    struct {
< //        start *yaml_node_t
< //        end *yaml_node_t
< //        top *yaml_node_t
< //    } nodes = { NULL, NULL, NULL }
< //    version_directive_copy *yaml_version_directive_t = NULL
< //    struct {
< //        start *yaml_tag_directive_t
< //        end *yaml_tag_directive_t
< //        top *yaml_tag_directive_t
< //    } tag_directives_copy = { NULL, NULL, NULL }
< //    value yaml_tag_directive_t = { NULL, NULL }
< //    mark yaml_mark_t = { 0, 0, 0 }
< //
< //    assert(document) // Non-NULL document object is expected.
< //    assert((tag_directives_start && tag_directives_end) ||
< //            (tag_directives_start == tag_directives_end))
< //                            // Valid tag directives are expected.
< //
< //    if (!STACK_INIT(&context, nodes, INITIAL_STACK_SIZE)) goto error
< //
< //    if (version_directive) {
< //        version_directive_copy = yaml_malloc(sizeof(yaml_version_directive_t))
< //        if (!version_directive_copy) goto error
< //        version_directive_copy.major = version_directive.major
< //        version_directive_copy.minor = version_directive.minor
< //    }
< //
< //    if (tag_directives_start != tag_directives_end) {
< //        tag_directive *yaml_tag_directive_t
< //        if (!STACK_INIT(&context, tag_directives_copy, INITIAL_STACK_SIZE))
< //            goto error
< //        for (tag_directive = tag_directives_start
< //                tag_directive != tag_directives_end; tag_directive ++) {
< //            assert(tag_directive.handle)
< //            assert(tag_directive.prefix)
< //            if (!yaml_check_utf8(tag_directive.handle,
< //                        strlen((char *)tag_directive.handle)))
< //                goto error
< //            if (!yaml_check_utf8(tag_directive.prefix,
< //                        strlen((char *)tag_directive.prefix)))
< //                goto error
< //            value.handle = yaml_strdup(tag_directive.handle)
< //            value.prefix = yaml_strdup(tag_directive.prefix)
< //            if (!value.handle || !value.prefix) goto error
< //            if (!PUSH(&context, tag_directives_copy, value))
< //                goto error
< //            value.handle = NULL
< //            value.prefix = NULL
< //        }
< //    }
< //
< //    DOCUMENT_INIT(*document, nodes.start, nodes.end, version_directive_copy,
< //            tag_directives_copy.start, tag_directives_copy.top,
< //            start_implicit, end_implicit, mark, mark)
< //
< //    return 1
< //
< //error:
< //    STACK_DEL(&context, nodes)
< //    yaml_free(version_directive_copy)
< //    while (!STACK_EMPTY(&context, tag_directives_copy)) {
< //        value yaml_tag_directive_t = POP(&context, tag_directives_copy)
< //        yaml_free(value.handle)
< //        yaml_free(value.prefix)
< //    }
< //    STACK_DEL(&context, tag_directives_copy)
< //    yaml_free(value.handle)
< //    yaml_free(value.prefix)
< //
< //    return 0
< //}
< //
< ///*
< // * Destroy a document object.
< // */
< //
< //YAML_DECLARE(void)
< //yaml_document_delete(document *yaml_document_t)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    tag_directive *yaml_tag_directive_t
< //
< //    context.error = YAML_NO_ERROR // Eliminate a compiler warning.
< //
< //    assert(document) // Non-NULL document object is expected.
< //
< //    while (!STACK_EMPTY(&context, document.nodes)) {
< //        node yaml_node_t = POP(&context, document.nodes)
< //        yaml_free(node.tag)
< //        switch (node.type) {
< //            case YAML_SCALAR_NODE:
< //                yaml_free(node.data.scalar.value)
< //                break
< //            case YAML_SEQUENCE_NODE:
< //                STACK_DEL(&context, node.data.sequence.items)
< //                break
< //            case YAML_MAPPING_NODE:
< //                STACK_DEL(&context, node.data.mapping.pairs)
< //                break
< //            default:
< //                assert(0) // Should not happen.
< //        }
< //    }
< //    STACK_DEL(&context, document.nodes)
< //
< //    yaml_free(document.version_directive)
< //    for (tag_directive = document.tag_directives.start
< //            tag_directive != document.tag_directives.end
< //            tag_directive++) {
< //        yaml_free(tag_directive.handle)
< //        yaml_free(tag_directive.prefix)
< //    }
< //    yaml_free(document.tag_directives.start)
< //
< //    memset(document, 0, sizeof(yaml_document_t))
< //}
< //
< ///**
< // * Get a document node.
< // */
< //
< //YAML_DECLARE(yaml_node_t *)
< //yaml_document_get_node(document *yaml_document_t, index int)
< //{
< //    assert(document) // Non-NULL document object is expected.
< //
< //    if (index > 0 && document.nodes.start + index <= document.nodes.top) {
< //        return document.nodes.start + index - 1
< //    }
< //    return NULL
< //}
< //
< ///**
< // * Get the root object.
< // */
< //
< //YAML_DECLARE(yaml_node_t *)
< //yaml_document_get_root_node(document *yaml_document_t)
< //{
< //    assert(document) // Non-NULL document object is expected.
< //
< //    if (document.nodes.top != document.nodes.start) {
< //        return document.nodes.start
< //    }
< //    return NULL
< //}
< //
< ///*
< // * Add a scalar node to a document.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_add_scalar(document *yaml_document_t,
< //        tag *yaml_char_t, value *yaml_char_t, length int,
< //        style yaml_scalar_style_t)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    mark yaml_mark_t = { 0, 0, 0 }
< //    tag_copy *yaml_char_t = NULL
< //    value_copy *yaml_char_t = NULL
< //    node yaml_node_t
< //
< //    assert(document) // Non-NULL document object is expected.
< //    assert(value) // Non-NULL value is expected.
< //
< //    if (!tag) {
< //        tag = (yaml_char_t *)YAML_DEFAULT_SCALAR_TAG
< //    }
< //
< //    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
< //    tag_copy = yaml_strdup(tag)
< //    if (!tag_copy) goto error
< //
< //    if (length < 0) {
< //        length = strlen((char *)value)
< //    }
< //
< //    if (!yaml_check_utf8(value, length)) goto error
< //    value_copy = yaml_malloc(length+1)
< //    if (!value_copy) goto error
< //    memcpy(value_copy, value, length)
< //    value_copy[length] = '\0'
< //
< //    SCALAR_NODE_INIT(node, tag_copy, value_copy, length, style, mark, mark)
< //    if (!PUSH(&context, document.nodes, node)) goto error
< //
< //    return document.nodes.top - document.nodes.start
< //
< //error:
< //    yaml_free(tag_copy)
< //    yaml_free(value_copy)
< //
< //    return 0
< //}
< //
< ///*
< // * Add a sequence node to a document.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_add_sequence(document *yaml_document_t,
< //        tag *yaml_char_t, style yaml_sequence_style_t)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    mark yaml_mark_t = { 0, 0, 0 }
< //    tag_copy *yaml_char_t = NULL
< //    struct {
< //        start *yaml_node_item_t
< //        end *yaml_node_item_t
< //        top *yaml_node_item_t
< //    } items = { NULL, NULL, NULL }
< //    node yaml_node_t
< //
< //    assert(document) // Non-NULL document object is expected.
< //
< //    if (!tag) {
< //        tag = (yaml_char_t *)YAML_DEFAULT_SEQUENCE_TAG
< //    }
< //
< //    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
< //    tag_copy = yaml_strdup(tag)
< //    if (!tag_copy) goto error
< //
< //    if (!STACK_INIT(&context, items, INITIAL_STACK_SIZE)) goto error
< //
< //    SEQUENCE_NODE_INIT(node, tag_copy, items.start, items.end,
< //            style, mark, mark)
< //    if (!PUSH(&context, document.nodes, node)) goto error
< //
< //    return document.nodes.top - document.nodes.start
< //
< //error:
< //    STACK_DEL(&context, items)
< //    yaml_free(tag_copy)
< //
< //    return 0
< //}
< //
< ///*
< // * Add a mapping node to a document.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_add_mapping(document *yaml_document_t,
< //        tag *yaml_char_t, style yaml_mapping_style_t)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //    mark yaml_mark_t = { 0, 0, 0 }
< //    tag_copy *yaml_char_t = NULL
< //    struct {
< //        start *yaml_node_pair_t
< //        end *yaml_node_pair_t
< //        top *yaml_node_pair_t
< //    } pairs = { NULL, NULL, NULL }
< //    node yaml_node_t
< //
< //    assert(document) // Non-NULL document object is expected.
< //
< //    if (!tag) {
< //        tag = (yaml_char_t *)YAML_DEFAULT_MAPPING_TAG
< //    }
< //
< //    if (!yaml_check_utf8(tag, strlen((char *)tag))) goto error
< //    tag_copy = yaml_strdup(tag)
< //    if (!tag_copy) goto error
< //
< //    if (!STACK_INIT(&context, pairs, INITIAL_STACK_SIZE)) goto error
< //
< //    MAPPING_NODE_INIT(node, tag_copy, pairs.start, pairs.end,
< //            style, mark, mark)
< //    if (!PUSH(&context, document.nodes, node)) goto error
< //
< //    return document.nodes.top - document.nodes.start
< //
< //error:
< //    STACK_DEL(&context, pairs)
< //    yaml_free(tag_copy)
< //
< //    return 0
< //}
< //
< ///*
< // * Append an item to a sequence node.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_append_sequence_item(document *yaml_document_t,
< //        sequence int, item int)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //
< //    assert(document) // Non-NULL document is required.
< //    assert(sequence > 0
< //            && document.nodes.start + sequence <= document.nodes.top)
< //                            // Valid sequence id is required.
< //    assert(document.nodes.start[sequence-1].type == YAML_SEQUENCE_NODE)
< //                            // A sequence node is required.
< //    assert(item > 0 && document.nodes.start + item <= document.nodes.top)
< //                            // Valid item id is required.
< //
< //    if (!PUSH(&context,
< //                document.nodes.start[sequence-1].data.sequence.items, item))
< //        return 0
< //
< //    return 1
< //}
< //
< ///*
< // * Append a pair of a key and a value to a mapping node.
< // */
< //
< //YAML_DECLARE(int)
< //yaml_document_append_mapping_pair(document *yaml_document_t,
< //        mapping int, key int, value int)
< //{
< //    struct {
< //        error yaml_error_type_t
< //    } context
< //
< //    pair yaml_node_pair_t
< //
< //    assert(document) // Non-NULL document is required.
< //    assert(mapping > 0
< //            && document.nodes.start + mapping <= document.nodes.top)
< //                            // Valid mapping id is required.
< //    assert(document.nodes.start[mapping-1].type == YAML_MAPPING_NODE)
< //                            // A mapping node is required.
< //    assert(key > 0 && document.nodes.start + key <= document.nodes.top)
< //                            // Valid key id is required.
< //    assert(value > 0 && document.nodes.start + value <= document.nodes.top)
< //                            // Valid value id is required.
< //
< //    pair.key = key
< //    pair.value = value
< //
< //    if (!PUSH(&context,
< //                document.nodes.start[mapping-1].data.mapping.pairs, pair))
< //        return 0
< //
< //    return 1
< //}
< //
< //
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/decode.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/decode.go
1,931d0
< //
< // Copyright (c) 2011-2019 Canonical Ltd
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package yaml
< 
< import (
< 	"encoding"
< 	"encoding/base64"
< 	"fmt"
< 	"io"
< 	"math"
< 	"reflect"
< 	"strconv"
< 	"time"
< )
< 
< // ----------------------------------------------------------------------------
< // Parser, produces a node tree out of a libyaml event stream.
< 
< type parser struct {
< 	parser   yaml_parser_t
< 	event    yaml_event_t
< 	doc      *Node
< 	anchors  map[string]*Node
< 	doneInit bool
< }
< 
< func newParser(b []byte) *parser {
< 	p := parser{}
< 	if !yaml_parser_initialize(&p.parser) {
< 		panic("failed to initialize YAML emitter")
< 	}
< 	if len(b) == 0 {
< 		b = []byte{'\n'}
< 	}
< 	yaml_parser_set_input_string(&p.parser, b)
< 	return &p
< }
< 
< func newParserFromReader(r io.Reader) *parser {
< 	p := parser{}
< 	if !yaml_parser_initialize(&p.parser) {
< 		panic("failed to initialize YAML emitter")
< 	}
< 	yaml_parser_set_input_reader(&p.parser, r)
< 	return &p
< }
< 
< func (p *parser) init() {
< 	if p.doneInit {
< 		return
< 	}
< 	p.anchors = make(map[string]*Node)
< 	p.expect(yaml_STREAM_START_EVENT)
< 	p.doneInit = true
< }
< 
< func (p *parser) destroy() {
< 	if p.event.typ != yaml_NO_EVENT {
< 		yaml_event_delete(&p.event)
< 	}
< 	yaml_parser_delete(&p.parser)
< }
< 
< // expect consumes an event from the event stream and
< // checks that it's of the expected type.
< func (p *parser) expect(e yaml_event_type_t) {
< 	if p.event.typ == yaml_NO_EVENT {
< 		if !yaml_parser_parse(&p.parser, &p.event) {
< 			p.fail()
< 		}
< 	}
< 	if p.event.typ == yaml_STREAM_END_EVENT {
< 		failf("attempted to go past the end of stream; corrupted value?")
< 	}
< 	if p.event.typ != e {
< 		p.parser.problem = fmt.Sprintf("expected %s event but got %s", e, p.event.typ)
< 		p.fail()
< 	}
< 	yaml_event_delete(&p.event)
< 	p.event.typ = yaml_NO_EVENT
< }
< 
< // peek peeks at the next event in the event stream,
< // puts the results into p.event and returns the event type.
< func (p *parser) peek() yaml_event_type_t {
< 	if p.event.typ != yaml_NO_EVENT {
< 		return p.event.typ
< 	}
< 	if !yaml_parser_parse(&p.parser, &p.event) {
< 		p.fail()
< 	}
< 	return p.event.typ
< }
< 
< func (p *parser) fail() {
< 	var where string
< 	var line int
< 	if p.parser.problem_mark.line != 0 {
< 		line = p.parser.problem_mark.line
< 		// Scanner errors don't iterate line before returning error
< 		if p.parser.error == yaml_SCANNER_ERROR {
< 			line++
< 		}
< 	} else if p.parser.context_mark.line != 0 {
< 		line = p.parser.context_mark.line
< 	}
< 	if line != 0 {
< 		where = "line " + strconv.Itoa(line) + ": "
< 	}
< 	var msg string
< 	if len(p.parser.problem) > 0 {
< 		msg = p.parser.problem
< 	} else {
< 		msg = "unknown problem parsing YAML content"
< 	}
< 	failf("%s%s", where, msg)
< }
< 
< func (p *parser) anchor(n *Node, anchor []byte) {
< 	if anchor != nil {
< 		n.Anchor = string(anchor)
< 		p.anchors[n.Anchor] = n
< 	}
< }
< 
< func (p *parser) parse() *Node {
< 	p.init()
< 	switch p.peek() {
< 	case yaml_SCALAR_EVENT:
< 		return p.scalar()
< 	case yaml_ALIAS_EVENT:
< 		return p.alias()
< 	case yaml_MAPPING_START_EVENT:
< 		return p.mapping()
< 	case yaml_SEQUENCE_START_EVENT:
< 		return p.sequence()
< 	case yaml_DOCUMENT_START_EVENT:
< 		return p.document()
< 	case yaml_STREAM_END_EVENT:
< 		// Happens when attempting to decode an empty buffer.
< 		return nil
< 	case yaml_TAIL_COMMENT_EVENT:
< 		panic("internal error: unexpected tail comment event (please report)")
< 	default:
< 		panic("internal error: attempted to parse unknown event (please report): " + p.event.typ.String())
< 	}
< }
< 
< func (p *parser) node(kind Kind, defaultTag, tag, value string) *Node {
< 	var style Style
< 	if tag != "" && tag != "!" {
< 		tag = shortTag(tag)
< 		style = TaggedStyle
< 	} else if defaultTag != "" {
< 		tag = defaultTag
< 	} else if kind == ScalarNode {
< 		tag, _ = resolve("", value)
< 	}
< 	return &Node{
< 		Kind:        kind,
< 		Tag:         tag,
< 		Value:       value,
< 		Style:       style,
< 		Line:        p.event.start_mark.line + 1,
< 		Column:      p.event.start_mark.column + 1,
< 		HeadComment: string(p.event.head_comment),
< 		LineComment: string(p.event.line_comment),
< 		FootComment: string(p.event.foot_comment),
< 	}
< }
< 
< func (p *parser) parseChild(parent *Node) *Node {
< 	child := p.parse()
< 	parent.Content = append(parent.Content, child)
< 	return child
< }
< 
< func (p *parser) document() *Node {
< 	n := p.node(DocumentNode, "", "", "")
< 	p.doc = n
< 	p.expect(yaml_DOCUMENT_START_EVENT)
< 	p.parseChild(n)
< 	if p.peek() == yaml_DOCUMENT_END_EVENT {
< 		n.FootComment = string(p.event.foot_comment)
< 	}
< 	p.expect(yaml_DOCUMENT_END_EVENT)
< 	return n
< }
< 
< func (p *parser) alias() *Node {
< 	n := p.node(AliasNode, "", "", string(p.event.anchor))
< 	n.Alias = p.anchors[n.Value]
< 	if n.Alias == nil {
< 		failf("unknown anchor '%s' referenced", n.Value)
< 	}
< 	p.expect(yaml_ALIAS_EVENT)
< 	return n
< }
< 
< func (p *parser) scalar() *Node {
< 	var parsedStyle = p.event.scalar_style()
< 	var nodeStyle Style
< 	switch {
< 	case parsedStyle&yaml_DOUBLE_QUOTED_SCALAR_STYLE != 0:
< 		nodeStyle = DoubleQuotedStyle
< 	case parsedStyle&yaml_SINGLE_QUOTED_SCALAR_STYLE != 0:
< 		nodeStyle = SingleQuotedStyle
< 	case parsedStyle&yaml_LITERAL_SCALAR_STYLE != 0:
< 		nodeStyle = LiteralStyle
< 	case parsedStyle&yaml_FOLDED_SCALAR_STYLE != 0:
< 		nodeStyle = FoldedStyle
< 	}
< 	var nodeValue = string(p.event.value)
< 	var nodeTag = string(p.event.tag)
< 	var defaultTag string
< 	if nodeStyle == 0 {
< 		if nodeValue == "<<" {
< 			defaultTag = mergeTag
< 		}
< 	} else {
< 		defaultTag = strTag
< 	}
< 	n := p.node(ScalarNode, defaultTag, nodeTag, nodeValue)
< 	n.Style |= nodeStyle
< 	p.anchor(n, p.event.anchor)
< 	p.expect(yaml_SCALAR_EVENT)
< 	return n
< }
< 
< func (p *parser) sequence() *Node {
< 	n := p.node(SequenceNode, seqTag, string(p.event.tag), "")
< 	if p.event.sequence_style()&yaml_FLOW_SEQUENCE_STYLE != 0 {
< 		n.Style |= FlowStyle
< 	}
< 	p.anchor(n, p.event.anchor)
< 	p.expect(yaml_SEQUENCE_START_EVENT)
< 	for p.peek() != yaml_SEQUENCE_END_EVENT {
< 		p.parseChild(n)
< 	}
< 	n.LineComment = string(p.event.line_comment)
< 	n.FootComment = string(p.event.foot_comment)
< 	p.expect(yaml_SEQUENCE_END_EVENT)
< 	return n
< }
< 
< func (p *parser) mapping() *Node {
< 	n := p.node(MappingNode, mapTag, string(p.event.tag), "")
< 	block := true
< 	if p.event.mapping_style()&yaml_FLOW_MAPPING_STYLE != 0 {
< 		block = false
< 		n.Style |= FlowStyle
< 	}
< 	p.anchor(n, p.event.anchor)
< 	p.expect(yaml_MAPPING_START_EVENT)
< 	for p.peek() != yaml_MAPPING_END_EVENT {
< 		k := p.parseChild(n)
< 		if block && k.FootComment != "" {
< 			// Must be a foot comment for the prior value when being dedented.
< 			if len(n.Content) > 2 {
< 				n.Content[len(n.Content)-3].FootComment = k.FootComment
< 				k.FootComment = ""
< 			}
< 		}
< 		v := p.parseChild(n)
< 		if k.FootComment == "" && v.FootComment != "" {
< 			k.FootComment = v.FootComment
< 			v.FootComment = ""
< 		}
< 		if p.peek() == yaml_TAIL_COMMENT_EVENT {
< 			if k.FootComment == "" {
< 				k.FootComment = string(p.event.foot_comment)
< 			}
< 			p.expect(yaml_TAIL_COMMENT_EVENT)
< 		}
< 	}
< 	n.LineComment = string(p.event.line_comment)
< 	n.FootComment = string(p.event.foot_comment)
< 	if n.Style&FlowStyle == 0 && n.FootComment != "" && len(n.Content) > 1 {
< 		n.Content[len(n.Content)-2].FootComment = n.FootComment
< 		n.FootComment = ""
< 	}
< 	p.expect(yaml_MAPPING_END_EVENT)
< 	return n
< }
< 
< // ----------------------------------------------------------------------------
< // Decoder, unmarshals a node into a provided value.
< 
< type decoder struct {
< 	doc     *Node
< 	aliases map[*Node]bool
< 	terrors []string
< 
< 	stringMapType  reflect.Type
< 	generalMapType reflect.Type
< 
< 	knownFields bool
< 	uniqueKeys  bool
< 	decodeCount int
< 	aliasCount  int
< 	aliasDepth  int
< }
< 
< var (
< 	nodeType       = reflect.TypeOf(Node{})
< 	durationType   = reflect.TypeOf(time.Duration(0))
< 	stringMapType  = reflect.TypeOf(map[string]interface{}{})
< 	generalMapType = reflect.TypeOf(map[interface{}]interface{}{})
< 	ifaceType      = generalMapType.Elem()
< 	timeType       = reflect.TypeOf(time.Time{})
< 	ptrTimeType    = reflect.TypeOf(&time.Time{})
< )
< 
< func newDecoder() *decoder {
< 	d := &decoder{
< 		stringMapType:  stringMapType,
< 		generalMapType: generalMapType,
< 		uniqueKeys:     true,
< 	}
< 	d.aliases = make(map[*Node]bool)
< 	return d
< }
< 
< func (d *decoder) terror(n *Node, tag string, out reflect.Value) {
< 	if n.Tag != "" {
< 		tag = n.Tag
< 	}
< 	value := n.Value
< 	if tag != seqTag && tag != mapTag {
< 		if len(value) > 10 {
< 			value = " `" + value[:7] + "...`"
< 		} else {
< 			value = " `" + value + "`"
< 		}
< 	}
< 	d.terrors = append(d.terrors, fmt.Sprintf("line %d: cannot unmarshal %s%s into %s", n.Line, shortTag(tag), value, out.Type()))
< }
< 
< func (d *decoder) callUnmarshaler(n *Node, u Unmarshaler) (good bool) {
< 	err := u.UnmarshalYAML(n)
< 	if e, ok := err.(*TypeError); ok {
< 		d.terrors = append(d.terrors, e.Errors...)
< 		return false
< 	}
< 	if err != nil {
< 		fail(err)
< 	}
< 	return true
< }
< 
< func (d *decoder) callObsoleteUnmarshaler(n *Node, u obsoleteUnmarshaler) (good bool) {
< 	terrlen := len(d.terrors)
< 	err := u.UnmarshalYAML(func(v interface{}) (err error) {
< 		defer handleErr(&err)
< 		d.unmarshal(n, reflect.ValueOf(v))
< 		if len(d.terrors) > terrlen {
< 			issues := d.terrors[terrlen:]
< 			d.terrors = d.terrors[:terrlen]
< 			return &TypeError{issues}
< 		}
< 		return nil
< 	})
< 	if e, ok := err.(*TypeError); ok {
< 		d.terrors = append(d.terrors, e.Errors...)
< 		return false
< 	}
< 	if err != nil {
< 		fail(err)
< 	}
< 	return true
< }
< 
< // d.prepare initializes and dereferences pointers and calls UnmarshalYAML
< // if a value is found to implement it.
< // It returns the initialized and dereferenced out value, whether
< // unmarshalling was already done by UnmarshalYAML, and if so whether
< // its types unmarshalled appropriately.
< //
< // If n holds a null value, prepare returns before doing anything.
< func (d *decoder) prepare(n *Node, out reflect.Value) (newout reflect.Value, unmarshaled, good bool) {
< 	if n.ShortTag() == nullTag {
< 		return out, false, false
< 	}
< 	again := true
< 	for again {
< 		again = false
< 		if out.Kind() == reflect.Ptr {
< 			if out.IsNil() {
< 				out.Set(reflect.New(out.Type().Elem()))
< 			}
< 			out = out.Elem()
< 			again = true
< 		}
< 		if out.CanAddr() {
< 			outi := out.Addr().Interface()
< 			if u, ok := outi.(Unmarshaler); ok {
< 				good = d.callUnmarshaler(n, u)
< 				return out, true, good
< 			}
< 			if u, ok := outi.(obsoleteUnmarshaler); ok {
< 				good = d.callObsoleteUnmarshaler(n, u)
< 				return out, true, good
< 			}
< 		}
< 	}
< 	return out, false, false
< }
< 
< func (d *decoder) fieldByIndex(n *Node, v reflect.Value, index []int) (field reflect.Value) {
< 	if n.ShortTag() == nullTag {
< 		return reflect.Value{}
< 	}
< 	for _, num := range index {
< 		for {
< 			if v.Kind() == reflect.Ptr {
< 				if v.IsNil() {
< 					v.Set(reflect.New(v.Type().Elem()))
< 				}
< 				v = v.Elem()
< 				continue
< 			}
< 			break
< 		}
< 		v = v.Field(num)
< 	}
< 	return v
< }
< 
< const (
< 	// 400,000 decode operations is ~500kb of dense object declarations, or
< 	// ~5kb of dense object declarations with 10000% alias expansion
< 	alias_ratio_range_low = 400000
< 
< 	// 4,000,000 decode operations is ~5MB of dense object declarations, or
< 	// ~4.5MB of dense object declarations with 10% alias expansion
< 	alias_ratio_range_high = 4000000
< 
< 	// alias_ratio_range is the range over which we scale allowed alias ratios
< 	alias_ratio_range = float64(alias_ratio_range_high - alias_ratio_range_low)
< )
< 
< func allowedAliasRatio(decodeCount int) float64 {
< 	switch {
< 	case decodeCount <= alias_ratio_range_low:
< 		// allow 99% to come from alias expansion for small-to-medium documents
< 		return 0.99
< 	case decodeCount >= alias_ratio_range_high:
< 		// allow 10% to come from alias expansion for very large documents
< 		return 0.10
< 	default:
< 		// scale smoothly from 99% down to 10% over the range.
< 		// this maps to 396,000 - 400,000 allowed alias-driven decodes over the range.
< 		// 400,000 decode operations is ~100MB of allocations in worst-case scenarios (single-item maps).
< 		return 0.99 - 0.89*(float64(decodeCount-alias_ratio_range_low)/alias_ratio_range)
< 	}
< }
< 
< func (d *decoder) unmarshal(n *Node, out reflect.Value) (good bool) {
< 	d.decodeCount++
< 	if d.aliasDepth > 0 {
< 		d.aliasCount++
< 	}
< 	if d.aliasCount > 100 && d.decodeCount > 1000 && float64(d.aliasCount)/float64(d.decodeCount) > allowedAliasRatio(d.decodeCount) {
< 		failf("document contains excessive aliasing")
< 	}
< 	if out.Type() == nodeType {
< 		out.Set(reflect.ValueOf(n).Elem())
< 		return true
< 	}
< 	switch n.Kind {
< 	case DocumentNode:
< 		return d.document(n, out)
< 	case AliasNode:
< 		return d.alias(n, out)
< 	}
< 	out, unmarshaled, good := d.prepare(n, out)
< 	if unmarshaled {
< 		return good
< 	}
< 	switch n.Kind {
< 	case ScalarNode:
< 		good = d.scalar(n, out)
< 	case MappingNode:
< 		good = d.mapping(n, out)
< 	case SequenceNode:
< 		good = d.sequence(n, out)
< 	default:
< 		panic("internal error: unknown node kind: " + strconv.Itoa(int(n.Kind)))
< 	}
< 	return good
< }
< 
< func (d *decoder) document(n *Node, out reflect.Value) (good bool) {
< 	if len(n.Content) == 1 {
< 		d.doc = n
< 		d.unmarshal(n.Content[0], out)
< 		return true
< 	}
< 	return false
< }
< 
< func (d *decoder) alias(n *Node, out reflect.Value) (good bool) {
< 	if d.aliases[n] {
< 		// TODO this could actually be allowed in some circumstances.
< 		failf("anchor '%s' value contains itself", n.Value)
< 	}
< 	d.aliases[n] = true
< 	d.aliasDepth++
< 	good = d.unmarshal(n.Alias, out)
< 	d.aliasDepth--
< 	delete(d.aliases, n)
< 	return good
< }
< 
< var zeroValue reflect.Value
< 
< func resetMap(out reflect.Value) {
< 	for _, k := range out.MapKeys() {
< 		out.SetMapIndex(k, zeroValue)
< 	}
< }
< 
< func (d *decoder) scalar(n *Node, out reflect.Value) bool {
< 	var tag string
< 	var resolved interface{}
< 	if n.indicatedString() {
< 		tag = strTag
< 		resolved = n.Value
< 	} else {
< 		tag, resolved = resolve(n.Tag, n.Value)
< 		if tag == binaryTag {
< 			data, err := base64.StdEncoding.DecodeString(resolved.(string))
< 			if err != nil {
< 				failf("!!binary value contains invalid base64 data")
< 			}
< 			resolved = string(data)
< 		}
< 	}
< 	if resolved == nil {
< 		if out.CanAddr() {
< 			switch out.Kind() {
< 			case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:
< 				out.Set(reflect.Zero(out.Type()))
< 				return true
< 			}
< 		}
< 		return false
< 	}
< 	if resolvedv := reflect.ValueOf(resolved); out.Type() == resolvedv.Type() {
< 		// We've resolved to exactly the type we want, so use that.
< 		out.Set(resolvedv)
< 		return true
< 	}
< 	// Perhaps we can use the value as a TextUnmarshaler to
< 	// set its value.
< 	if out.CanAddr() {
< 		u, ok := out.Addr().Interface().(encoding.TextUnmarshaler)
< 		if ok {
< 			var text []byte
< 			if tag == binaryTag {
< 				text = []byte(resolved.(string))
< 			} else {
< 				// We let any value be unmarshaled into TextUnmarshaler.
< 				// That might be more lax than we'd like, but the
< 				// TextUnmarshaler itself should bowl out any dubious values.
< 				text = []byte(n.Value)
< 			}
< 			err := u.UnmarshalText(text)
< 			if err != nil {
< 				fail(err)
< 			}
< 			return true
< 		}
< 	}
< 	switch out.Kind() {
< 	case reflect.String:
< 		if tag == binaryTag {
< 			out.SetString(resolved.(string))
< 			return true
< 		}
< 		out.SetString(n.Value)
< 		return true
< 	case reflect.Interface:
< 		out.Set(reflect.ValueOf(resolved))
< 		return true
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		// This used to work in v2, but it's very unfriendly.
< 		isDuration := out.Type() == durationType
< 
< 		switch resolved := resolved.(type) {
< 		case int:
< 			if !isDuration && !out.OverflowInt(int64(resolved)) {
< 				out.SetInt(int64(resolved))
< 				return true
< 			}
< 		case int64:
< 			if !isDuration && !out.OverflowInt(resolved) {
< 				out.SetInt(resolved)
< 				return true
< 			}
< 		case uint64:
< 			if !isDuration && resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {
< 				out.SetInt(int64(resolved))
< 				return true
< 			}
< 		case float64:
< 			if !isDuration && resolved <= math.MaxInt64 && !out.OverflowInt(int64(resolved)) {
< 				out.SetInt(int64(resolved))
< 				return true
< 			}
< 		case string:
< 			if out.Type() == durationType {
< 				d, err := time.ParseDuration(resolved)
< 				if err == nil {
< 					out.SetInt(int64(d))
< 					return true
< 				}
< 			}
< 		}
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		switch resolved := resolved.(type) {
< 		case int:
< 			if resolved >= 0 && !out.OverflowUint(uint64(resolved)) {
< 				out.SetUint(uint64(resolved))
< 				return true
< 			}
< 		case int64:
< 			if resolved >= 0 && !out.OverflowUint(uint64(resolved)) {
< 				out.SetUint(uint64(resolved))
< 				return true
< 			}
< 		case uint64:
< 			if !out.OverflowUint(uint64(resolved)) {
< 				out.SetUint(uint64(resolved))
< 				return true
< 			}
< 		case float64:
< 			if resolved <= math.MaxUint64 && !out.OverflowUint(uint64(resolved)) {
< 				out.SetUint(uint64(resolved))
< 				return true
< 			}
< 		}
< 	case reflect.Bool:
< 		switch resolved := resolved.(type) {
< 		case bool:
< 			out.SetBool(resolved)
< 			return true
< 		case string:
< 			// This offers some compatibility with the 1.1 spec (https://yaml.org/type/bool.html).
< 			// It only works if explicitly attempting to unmarshal into a typed bool value.
< 			switch resolved {
< 			case "y", "Y", "yes", "Yes", "YES", "on", "On", "ON":
< 				out.SetBool(true)
< 				return true
< 			case "n", "N", "no", "No", "NO", "off", "Off", "OFF":
< 				out.SetBool(false)
< 				return true
< 			}
< 		}
< 	case reflect.Float32, reflect.Float64:
< 		switch resolved := resolved.(type) {
< 		case int:
< 			out.SetFloat(float64(resolved))
< 			return true
< 		case int64:
< 			out.SetFloat(float64(resolved))
< 			return true
< 		case uint64:
< 			out.SetFloat(float64(resolved))
< 			return true
< 		case float64:
< 			out.SetFloat(resolved)
< 			return true
< 		}
< 	case reflect.Struct:
< 		if resolvedv := reflect.ValueOf(resolved); out.Type() == resolvedv.Type() {
< 			out.Set(resolvedv)
< 			return true
< 		}
< 	case reflect.Ptr:
< 		panic("yaml internal error: please report the issue")
< 	}
< 	d.terror(n, tag, out)
< 	return false
< }
< 
< func settableValueOf(i interface{}) reflect.Value {
< 	v := reflect.ValueOf(i)
< 	sv := reflect.New(v.Type()).Elem()
< 	sv.Set(v)
< 	return sv
< }
< 
< func (d *decoder) sequence(n *Node, out reflect.Value) (good bool) {
< 	l := len(n.Content)
< 
< 	var iface reflect.Value
< 	switch out.Kind() {
< 	case reflect.Slice:
< 		out.Set(reflect.MakeSlice(out.Type(), l, l))
< 	case reflect.Array:
< 		if l != out.Len() {
< 			failf("invalid array: want %d elements but got %d", out.Len(), l)
< 		}
< 	case reflect.Interface:
< 		// No type hints. Will have to use a generic sequence.
< 		iface = out
< 		out = settableValueOf(make([]interface{}, l))
< 	default:
< 		d.terror(n, seqTag, out)
< 		return false
< 	}
< 	et := out.Type().Elem()
< 
< 	j := 0
< 	for i := 0; i < l; i++ {
< 		e := reflect.New(et).Elem()
< 		if ok := d.unmarshal(n.Content[i], e); ok {
< 			out.Index(j).Set(e)
< 			j++
< 		}
< 	}
< 	if out.Kind() != reflect.Array {
< 		out.Set(out.Slice(0, j))
< 	}
< 	if iface.IsValid() {
< 		iface.Set(out)
< 	}
< 	return true
< }
< 
< func (d *decoder) mapping(n *Node, out reflect.Value) (good bool) {
< 	l := len(n.Content)
< 	if d.uniqueKeys {
< 		nerrs := len(d.terrors)
< 		for i := 0; i < l; i += 2 {
< 			ni := n.Content[i]
< 			for j := i + 2; j < l; j += 2 {
< 				nj := n.Content[j]
< 				if ni.Kind == nj.Kind && ni.Value == nj.Value {
< 					d.terrors = append(d.terrors, fmt.Sprintf("line %d: mapping key %#v already defined at line %d", nj.Line, nj.Value, ni.Line))
< 				}
< 			}
< 		}
< 		if len(d.terrors) > nerrs {
< 			return false
< 		}
< 	}
< 	switch out.Kind() {
< 	case reflect.Struct:
< 		return d.mappingStruct(n, out)
< 	case reflect.Map:
< 		// okay
< 	case reflect.Interface:
< 		iface := out
< 		if isStringMap(n) {
< 			out = reflect.MakeMap(d.stringMapType)
< 		} else {
< 			out = reflect.MakeMap(d.generalMapType)
< 		}
< 		iface.Set(out)
< 	default:
< 		d.terror(n, mapTag, out)
< 		return false
< 	}
< 
< 	outt := out.Type()
< 	kt := outt.Key()
< 	et := outt.Elem()
< 
< 	stringMapType := d.stringMapType
< 	generalMapType := d.generalMapType
< 	if outt.Elem() == ifaceType {
< 		if outt.Key().Kind() == reflect.String {
< 			d.stringMapType = outt
< 		} else if outt.Key() == ifaceType {
< 			d.generalMapType = outt
< 		}
< 	}
< 
< 	if out.IsNil() {
< 		out.Set(reflect.MakeMap(outt))
< 	}
< 	for i := 0; i < l; i += 2 {
< 		if isMerge(n.Content[i]) {
< 			d.merge(n.Content[i+1], out)
< 			continue
< 		}
< 		k := reflect.New(kt).Elem()
< 		if d.unmarshal(n.Content[i], k) {
< 			kkind := k.Kind()
< 			if kkind == reflect.Interface {
< 				kkind = k.Elem().Kind()
< 			}
< 			if kkind == reflect.Map || kkind == reflect.Slice {
< 				failf("invalid map key: %#v", k.Interface())
< 			}
< 			e := reflect.New(et).Elem()
< 			if d.unmarshal(n.Content[i+1], e) {
< 				out.SetMapIndex(k, e)
< 			}
< 		}
< 	}
< 	d.stringMapType = stringMapType
< 	d.generalMapType = generalMapType
< 	return true
< }
< 
< func isStringMap(n *Node) bool {
< 	if n.Kind != MappingNode {
< 		return false
< 	}
< 	l := len(n.Content)
< 	for i := 0; i < l; i += 2 {
< 		if n.Content[i].ShortTag() != strTag {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< func (d *decoder) mappingStruct(n *Node, out reflect.Value) (good bool) {
< 	sinfo, err := getStructInfo(out.Type())
< 	if err != nil {
< 		panic(err)
< 	}
< 
< 	var inlineMap reflect.Value
< 	var elemType reflect.Type
< 	if sinfo.InlineMap != -1 {
< 		inlineMap = out.Field(sinfo.InlineMap)
< 		inlineMap.Set(reflect.New(inlineMap.Type()).Elem())
< 		elemType = inlineMap.Type().Elem()
< 	}
< 
< 	for _, index := range sinfo.InlineUnmarshalers {
< 		field := d.fieldByIndex(n, out, index)
< 		d.prepare(n, field)
< 	}
< 
< 	var doneFields []bool
< 	if d.uniqueKeys {
< 		doneFields = make([]bool, len(sinfo.FieldsList))
< 	}
< 	name := settableValueOf("")
< 	l := len(n.Content)
< 	for i := 0; i < l; i += 2 {
< 		ni := n.Content[i]
< 		if isMerge(ni) {
< 			d.merge(n.Content[i+1], out)
< 			continue
< 		}
< 		if !d.unmarshal(ni, name) {
< 			continue
< 		}
< 		if info, ok := sinfo.FieldsMap[name.String()]; ok {
< 			if d.uniqueKeys {
< 				if doneFields[info.Id] {
< 					d.terrors = append(d.terrors, fmt.Sprintf("line %d: field %s already set in type %s", ni.Line, name.String(), out.Type()))
< 					continue
< 				}
< 				doneFields[info.Id] = true
< 			}
< 			var field reflect.Value
< 			if info.Inline == nil {
< 				field = out.Field(info.Num)
< 			} else {
< 				field = d.fieldByIndex(n, out, info.Inline)
< 			}
< 			d.unmarshal(n.Content[i+1], field)
< 		} else if sinfo.InlineMap != -1 {
< 			if inlineMap.IsNil() {
< 				inlineMap.Set(reflect.MakeMap(inlineMap.Type()))
< 			}
< 			value := reflect.New(elemType).Elem()
< 			d.unmarshal(n.Content[i+1], value)
< 			inlineMap.SetMapIndex(name, value)
< 		} else if d.knownFields {
< 			d.terrors = append(d.terrors, fmt.Sprintf("line %d: field %s not found in type %s", ni.Line, name.String(), out.Type()))
< 		}
< 	}
< 	return true
< }
< 
< func failWantMap() {
< 	failf("map merge requires map or sequence of maps as the value")
< }
< 
< func (d *decoder) merge(n *Node, out reflect.Value) {
< 	switch n.Kind {
< 	case MappingNode:
< 		d.unmarshal(n, out)
< 	case AliasNode:
< 		if n.Alias != nil && n.Alias.Kind != MappingNode {
< 			failWantMap()
< 		}
< 		d.unmarshal(n, out)
< 	case SequenceNode:
< 		// Step backwards as earlier nodes take precedence.
< 		for i := len(n.Content) - 1; i >= 0; i-- {
< 			ni := n.Content[i]
< 			if ni.Kind == AliasNode {
< 				if ni.Alias != nil && ni.Alias.Kind != MappingNode {
< 					failWantMap()
< 				}
< 			} else if ni.Kind != MappingNode {
< 				failWantMap()
< 			}
< 			d.unmarshal(ni, out)
< 		}
< 	default:
< 		failWantMap()
< 	}
< }
< 
< func isMerge(n *Node) bool {
< 	return n.Kind == ScalarNode && n.Value == "<<" && (n.Tag == "" || n.Tag == "!" || shortTag(n.Tag) == mergeTag)
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/emitterc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/emitterc.go
1,1992d0
< //
< // Copyright (c) 2011-2019 Canonical Ltd
< // Copyright (c) 2006-2010 Kirill Simonov
< //
< // Permission is hereby granted, free of charge, to any person obtaining a copy of
< // this software and associated documentation files (the "Software"), to deal in
< // the Software without restriction, including without limitation the rights to
< // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< // of the Software, and to permit persons to whom the Software is furnished to do
< // so, subject to the following conditions:
< //
< // The above copyright notice and this permission notice shall be included in all
< // copies or substantial portions of the Software.
< //
< // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< // SOFTWARE.
< 
< package yaml
< 
< import (
< 	"bytes"
< 	"fmt"
< )
< 
< // Flush the buffer if needed.
< func flush(emitter *yaml_emitter_t) bool {
< 	if emitter.buffer_pos+5 >= len(emitter.buffer) {
< 		return yaml_emitter_flush(emitter)
< 	}
< 	return true
< }
< 
< // Put a character to the output buffer.
< func put(emitter *yaml_emitter_t, value byte) bool {
< 	if emitter.buffer_pos+5 >= len(emitter.buffer) && !yaml_emitter_flush(emitter) {
< 		return false
< 	}
< 	emitter.buffer[emitter.buffer_pos] = value
< 	emitter.buffer_pos++
< 	emitter.column++
< 	return true
< }
< 
< // Put a line break to the output buffer.
< func put_break(emitter *yaml_emitter_t) bool {
< 	if emitter.buffer_pos+5 >= len(emitter.buffer) && !yaml_emitter_flush(emitter) {
< 		return false
< 	}
< 	switch emitter.line_break {
< 	case yaml_CR_BREAK:
< 		emitter.buffer[emitter.buffer_pos] = '\r'
< 		emitter.buffer_pos += 1
< 	case yaml_LN_BREAK:
< 		emitter.buffer[emitter.buffer_pos] = '\n'
< 		emitter.buffer_pos += 1
< 	case yaml_CRLN_BREAK:
< 		emitter.buffer[emitter.buffer_pos+0] = '\r'
< 		emitter.buffer[emitter.buffer_pos+1] = '\n'
< 		emitter.buffer_pos += 2
< 	default:
< 		panic("unknown line break setting")
< 	}
< 	if emitter.column == 0 {
< 		emitter.space_above = true
< 	}
< 	emitter.column = 0
< 	emitter.line++
< 	// [Go] Do this here and below and drop from everywhere else (see commented lines).
< 	emitter.indention = true
< 	return true
< }
< 
< // Copy a character from a string into buffer.
< func write(emitter *yaml_emitter_t, s []byte, i *int) bool {
< 	if emitter.buffer_pos+5 >= len(emitter.buffer) && !yaml_emitter_flush(emitter) {
< 		return false
< 	}
< 	p := emitter.buffer_pos
< 	w := width(s[*i])
< 	switch w {
< 	case 4:
< 		emitter.buffer[p+3] = s[*i+3]
< 		fallthrough
< 	case 3:
< 		emitter.buffer[p+2] = s[*i+2]
< 		fallthrough
< 	case 2:
< 		emitter.buffer[p+1] = s[*i+1]
< 		fallthrough
< 	case 1:
< 		emitter.buffer[p+0] = s[*i+0]
< 	default:
< 		panic("unknown character width")
< 	}
< 	emitter.column++
< 	emitter.buffer_pos += w
< 	*i += w
< 	return true
< }
< 
< // Write a whole string into buffer.
< func write_all(emitter *yaml_emitter_t, s []byte) bool {
< 	for i := 0; i < len(s); {
< 		if !write(emitter, s, &i) {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< // Copy a line break character from a string into buffer.
< func write_break(emitter *yaml_emitter_t, s []byte, i *int) bool {
< 	if s[*i] == '\n' {
< 		if !put_break(emitter) {
< 			return false
< 		}
< 		*i++
< 	} else {
< 		if !write(emitter, s, i) {
< 			return false
< 		}
< 		if emitter.column == 0 {
< 			emitter.space_above = true
< 		}
< 		emitter.column = 0
< 		emitter.line++
< 		// [Go] Do this here and above and drop from everywhere else (see commented lines).
< 		emitter.indention = true
< 	}
< 	return true
< }
< 
< // Set an emitter error and return false.
< func yaml_emitter_set_emitter_error(emitter *yaml_emitter_t, problem string) bool {
< 	emitter.error = yaml_EMITTER_ERROR
< 	emitter.problem = problem
< 	return false
< }
< 
< // Emit an event.
< func yaml_emitter_emit(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	emitter.events = append(emitter.events, *event)
< 	for !yaml_emitter_need_more_events(emitter) {
< 		event := &emitter.events[emitter.events_head]
< 		if !yaml_emitter_analyze_event(emitter, event) {
< 			return false
< 		}
< 		if !yaml_emitter_state_machine(emitter, event) {
< 			return false
< 		}
< 		yaml_event_delete(event)
< 		emitter.events_head++
< 	}
< 	return true
< }
< 
< // Check if we need to accumulate more events before emitting.
< //
< // We accumulate extra
< //  - 1 event for DOCUMENT-START
< //  - 2 events for SEQUENCE-START
< //  - 3 events for MAPPING-START
< //
< func yaml_emitter_need_more_events(emitter *yaml_emitter_t) bool {
< 	if emitter.events_head == len(emitter.events) {
< 		return true
< 	}
< 	var accumulate int
< 	switch emitter.events[emitter.events_head].typ {
< 	case yaml_DOCUMENT_START_EVENT:
< 		accumulate = 1
< 		break
< 	case yaml_SEQUENCE_START_EVENT:
< 		accumulate = 2
< 		break
< 	case yaml_MAPPING_START_EVENT:
< 		accumulate = 3
< 		break
< 	default:
< 		return false
< 	}
< 	if len(emitter.events)-emitter.events_head > accumulate {
< 		return false
< 	}
< 	var level int
< 	for i := emitter.events_head; i < len(emitter.events); i++ {
< 		switch emitter.events[i].typ {
< 		case yaml_STREAM_START_EVENT, yaml_DOCUMENT_START_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT:
< 			level++
< 		case yaml_STREAM_END_EVENT, yaml_DOCUMENT_END_EVENT, yaml_SEQUENCE_END_EVENT, yaml_MAPPING_END_EVENT:
< 			level--
< 		}
< 		if level == 0 {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< // Append a directive to the directives stack.
< func yaml_emitter_append_tag_directive(emitter *yaml_emitter_t, value *yaml_tag_directive_t, allow_duplicates bool) bool {
< 	for i := 0; i < len(emitter.tag_directives); i++ {
< 		if bytes.Equal(value.handle, emitter.tag_directives[i].handle) {
< 			if allow_duplicates {
< 				return true
< 			}
< 			return yaml_emitter_set_emitter_error(emitter, "duplicate %TAG directive")
< 		}
< 	}
< 
< 	// [Go] Do we actually need to copy this given garbage collection
< 	// and the lack of deallocating destructors?
< 	tag_copy := yaml_tag_directive_t{
< 		handle: make([]byte, len(value.handle)),
< 		prefix: make([]byte, len(value.prefix)),
< 	}
< 	copy(tag_copy.handle, value.handle)
< 	copy(tag_copy.prefix, value.prefix)
< 	emitter.tag_directives = append(emitter.tag_directives, tag_copy)
< 	return true
< }
< 
< // Increase the indentation level.
< func yaml_emitter_increase_indent(emitter *yaml_emitter_t, flow, indentless bool) bool {
< 	emitter.indents = append(emitter.indents, emitter.indent)
< 	if emitter.indent < 0 {
< 		if flow {
< 			emitter.indent = emitter.best_indent
< 		} else {
< 			emitter.indent = 0
< 		}
< 	} else if !indentless {
< 		emitter.indent += emitter.best_indent
< 		// [Go] If inside a block sequence item, discount the space taken by the indicator.
< 		if emitter.best_indent > 2 && emitter.states[len(emitter.states)-1] == yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE {
< 			emitter.indent -= 2
< 		}
< 	}
< 	return true
< }
< 
< // State dispatcher.
< func yaml_emitter_state_machine(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	switch emitter.state {
< 	default:
< 	case yaml_EMIT_STREAM_START_STATE:
< 		return yaml_emitter_emit_stream_start(emitter, event)
< 
< 	case yaml_EMIT_FIRST_DOCUMENT_START_STATE:
< 		return yaml_emitter_emit_document_start(emitter, event, true)
< 
< 	case yaml_EMIT_DOCUMENT_START_STATE:
< 		return yaml_emitter_emit_document_start(emitter, event, false)
< 
< 	case yaml_EMIT_DOCUMENT_CONTENT_STATE:
< 		return yaml_emitter_emit_document_content(emitter, event)
< 
< 	case yaml_EMIT_DOCUMENT_END_STATE:
< 		return yaml_emitter_emit_document_end(emitter, event)
< 
< 	case yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE:
< 		return yaml_emitter_emit_flow_sequence_item(emitter, event, true, false)
< 
< 	case yaml_EMIT_FLOW_SEQUENCE_TRAIL_ITEM_STATE:
< 		return yaml_emitter_emit_flow_sequence_item(emitter, event, false, true)
< 
< 	case yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE:
< 		return yaml_emitter_emit_flow_sequence_item(emitter, event, false, false)
< 
< 	case yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE:
< 		return yaml_emitter_emit_flow_mapping_key(emitter, event, true, false)
< 
< 	case yaml_EMIT_FLOW_MAPPING_TRAIL_KEY_STATE:
< 		return yaml_emitter_emit_flow_mapping_key(emitter, event, false, true)
< 
< 	case yaml_EMIT_FLOW_MAPPING_KEY_STATE:
< 		return yaml_emitter_emit_flow_mapping_key(emitter, event, false, false)
< 
< 	case yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE:
< 		return yaml_emitter_emit_flow_mapping_value(emitter, event, true)
< 
< 	case yaml_EMIT_FLOW_MAPPING_VALUE_STATE:
< 		return yaml_emitter_emit_flow_mapping_value(emitter, event, false)
< 
< 	case yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE:
< 		return yaml_emitter_emit_block_sequence_item(emitter, event, true)
< 
< 	case yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE:
< 		return yaml_emitter_emit_block_sequence_item(emitter, event, false)
< 
< 	case yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE:
< 		return yaml_emitter_emit_block_mapping_key(emitter, event, true)
< 
< 	case yaml_EMIT_BLOCK_MAPPING_KEY_STATE:
< 		return yaml_emitter_emit_block_mapping_key(emitter, event, false)
< 
< 	case yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE:
< 		return yaml_emitter_emit_block_mapping_value(emitter, event, true)
< 
< 	case yaml_EMIT_BLOCK_MAPPING_VALUE_STATE:
< 		return yaml_emitter_emit_block_mapping_value(emitter, event, false)
< 
< 	case yaml_EMIT_END_STATE:
< 		return yaml_emitter_set_emitter_error(emitter, "expected nothing after STREAM-END")
< 	}
< 	panic("invalid emitter state")
< }
< 
< // Expect STREAM-START.
< func yaml_emitter_emit_stream_start(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if event.typ != yaml_STREAM_START_EVENT {
< 		return yaml_emitter_set_emitter_error(emitter, "expected STREAM-START")
< 	}
< 	if emitter.encoding == yaml_ANY_ENCODING {
< 		emitter.encoding = event.encoding
< 		if emitter.encoding == yaml_ANY_ENCODING {
< 			emitter.encoding = yaml_UTF8_ENCODING
< 		}
< 	}
< 	if emitter.best_indent < 2 || emitter.best_indent > 9 {
< 		emitter.best_indent = 2
< 	}
< 	if emitter.best_width >= 0 && emitter.best_width <= emitter.best_indent*2 {
< 		emitter.best_width = 80
< 	}
< 	if emitter.best_width < 0 {
< 		emitter.best_width = 1<<31 - 1
< 	}
< 	if emitter.line_break == yaml_ANY_BREAK {
< 		emitter.line_break = yaml_LN_BREAK
< 	}
< 
< 	emitter.indent = -1
< 	emitter.line = 0
< 	emitter.column = 0
< 	emitter.whitespace = true
< 	emitter.indention = true
< 	emitter.space_above = true
< 	emitter.foot_indent = -1
< 
< 	if emitter.encoding != yaml_UTF8_ENCODING {
< 		if !yaml_emitter_write_bom(emitter) {
< 			return false
< 		}
< 	}
< 	emitter.state = yaml_EMIT_FIRST_DOCUMENT_START_STATE
< 	return true
< }
< 
< // Expect DOCUMENT-START or STREAM-END.
< func yaml_emitter_emit_document_start(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
< 
< 	if event.typ == yaml_DOCUMENT_START_EVENT {
< 
< 		if event.version_directive != nil {
< 			if !yaml_emitter_analyze_version_directive(emitter, event.version_directive) {
< 				return false
< 			}
< 		}
< 
< 		for i := 0; i < len(event.tag_directives); i++ {
< 			tag_directive := &event.tag_directives[i]
< 			if !yaml_emitter_analyze_tag_directive(emitter, tag_directive) {
< 				return false
< 			}
< 			if !yaml_emitter_append_tag_directive(emitter, tag_directive, false) {
< 				return false
< 			}
< 		}
< 
< 		for i := 0; i < len(default_tag_directives); i++ {
< 			tag_directive := &default_tag_directives[i]
< 			if !yaml_emitter_append_tag_directive(emitter, tag_directive, true) {
< 				return false
< 			}
< 		}
< 
< 		implicit := event.implicit
< 		if !first || emitter.canonical {
< 			implicit = false
< 		}
< 
< 		if emitter.open_ended && (event.version_directive != nil || len(event.tag_directives) > 0) {
< 			if !yaml_emitter_write_indicator(emitter, []byte("..."), true, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 
< 		if event.version_directive != nil {
< 			implicit = false
< 			if !yaml_emitter_write_indicator(emitter, []byte("%YAML"), true, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indicator(emitter, []byte("1.1"), true, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 
< 		if len(event.tag_directives) > 0 {
< 			implicit = false
< 			for i := 0; i < len(event.tag_directives); i++ {
< 				tag_directive := &event.tag_directives[i]
< 				if !yaml_emitter_write_indicator(emitter, []byte("%TAG"), true, false, false) {
< 					return false
< 				}
< 				if !yaml_emitter_write_tag_handle(emitter, tag_directive.handle) {
< 					return false
< 				}
< 				if !yaml_emitter_write_tag_content(emitter, tag_directive.prefix, true) {
< 					return false
< 				}
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 		}
< 
< 		if yaml_emitter_check_empty_document(emitter) {
< 			implicit = false
< 		}
< 		if !implicit {
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indicator(emitter, []byte("---"), true, false, false) {
< 				return false
< 			}
< 			if emitter.canonical || true {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 		}
< 
< 		if len(emitter.head_comment) > 0 {
< 			if !yaml_emitter_process_head_comment(emitter) {
< 				return false
< 			}
< 			if !put_break(emitter) {
< 				return false
< 			}
< 		}
< 
< 		emitter.state = yaml_EMIT_DOCUMENT_CONTENT_STATE
< 		return true
< 	}
< 
< 	if event.typ == yaml_STREAM_END_EVENT {
< 		if emitter.open_ended {
< 			if !yaml_emitter_write_indicator(emitter, []byte("..."), true, false, false) {
< 				return false
< 			}
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_flush(emitter) {
< 			return false
< 		}
< 		emitter.state = yaml_EMIT_END_STATE
< 		return true
< 	}
< 
< 	return yaml_emitter_set_emitter_error(emitter, "expected DOCUMENT-START or STREAM-END")
< }
< 
< // Expect the root node.
< func yaml_emitter_emit_document_content(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	emitter.states = append(emitter.states, yaml_EMIT_DOCUMENT_END_STATE)
< 
< 	if !yaml_emitter_process_head_comment(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_emit_node(emitter, event, true, false, false, false) {
< 		return false
< 	}
< 	if !yaml_emitter_process_line_comment(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_foot_comment(emitter) {
< 		return false
< 	}
< 	return true
< }
< 
< // Expect DOCUMENT-END.
< func yaml_emitter_emit_document_end(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if event.typ != yaml_DOCUMENT_END_EVENT {
< 		return yaml_emitter_set_emitter_error(emitter, "expected DOCUMENT-END")
< 	}
< 	// [Go] Force document foot separation.
< 	emitter.foot_indent = 0
< 	if !yaml_emitter_process_foot_comment(emitter) {
< 		return false
< 	}
< 	emitter.foot_indent = -1
< 	if !yaml_emitter_write_indent(emitter) {
< 		return false
< 	}
< 	if !event.implicit {
< 		// [Go] Allocate the slice elsewhere.
< 		if !yaml_emitter_write_indicator(emitter, []byte("..."), true, false, false) {
< 			return false
< 		}
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 	}
< 	if !yaml_emitter_flush(emitter) {
< 		return false
< 	}
< 	emitter.state = yaml_EMIT_DOCUMENT_START_STATE
< 	emitter.tag_directives = emitter.tag_directives[:0]
< 	return true
< }
< 
< // Expect a flow item node.
< func yaml_emitter_emit_flow_sequence_item(emitter *yaml_emitter_t, event *yaml_event_t, first, trail bool) bool {
< 	if first {
< 		if !yaml_emitter_write_indicator(emitter, []byte{'['}, true, true, false) {
< 			return false
< 		}
< 		if !yaml_emitter_increase_indent(emitter, true, false) {
< 			return false
< 		}
< 		emitter.flow_level++
< 	}
< 
< 	if event.typ == yaml_SEQUENCE_END_EVENT {
< 		if emitter.canonical && !first && !trail {
< 			if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 				return false
< 			}
< 		}
< 		emitter.flow_level--
< 		emitter.indent = emitter.indents[len(emitter.indents)-1]
< 		emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 		if emitter.column == 0 || emitter.canonical && !first {
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{']'}, false, false, false) {
< 			return false
< 		}
< 		if !yaml_emitter_process_line_comment(emitter) {
< 			return false
< 		}
< 		if !yaml_emitter_process_foot_comment(emitter) {
< 			return false
< 		}
< 		emitter.state = emitter.states[len(emitter.states)-1]
< 		emitter.states = emitter.states[:len(emitter.states)-1]
< 
< 		return true
< 	}
< 
< 	if !first && !trail {
< 		if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 			return false
< 		}
< 	}
< 
< 	if !yaml_emitter_process_head_comment(emitter) {
< 		return false
< 	}
< 	if emitter.column == 0 {
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 	}
< 
< 	if emitter.canonical || emitter.column > emitter.best_width {
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 	}
< 	if len(emitter.line_comment)+len(emitter.foot_comment)+len(emitter.tail_comment) > 0 {
< 		emitter.states = append(emitter.states, yaml_EMIT_FLOW_SEQUENCE_TRAIL_ITEM_STATE)
< 	} else {
< 		emitter.states = append(emitter.states, yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE)
< 	}
< 	if !yaml_emitter_emit_node(emitter, event, false, true, false, false) {
< 		return false
< 	}
< 	if len(emitter.line_comment)+len(emitter.foot_comment)+len(emitter.tail_comment) > 0 {
< 		if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 			return false
< 		}
< 	}
< 	if !yaml_emitter_process_line_comment(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_foot_comment(emitter) {
< 		return false
< 	}
< 	return true
< }
< 
< // Expect a flow key node.
< func yaml_emitter_emit_flow_mapping_key(emitter *yaml_emitter_t, event *yaml_event_t, first, trail bool) bool {
< 	if first {
< 		if !yaml_emitter_write_indicator(emitter, []byte{'{'}, true, true, false) {
< 			return false
< 		}
< 		if !yaml_emitter_increase_indent(emitter, true, false) {
< 			return false
< 		}
< 		emitter.flow_level++
< 	}
< 
< 	if event.typ == yaml_MAPPING_END_EVENT {
< 		if (emitter.canonical || len(emitter.head_comment)+len(emitter.foot_comment)+len(emitter.tail_comment) > 0) && !first && !trail {
< 			if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_process_head_comment(emitter) {
< 			return false
< 		}
< 		emitter.flow_level--
< 		emitter.indent = emitter.indents[len(emitter.indents)-1]
< 		emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 		if emitter.canonical && !first {
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{'}'}, false, false, false) {
< 			return false
< 		}
< 		if !yaml_emitter_process_line_comment(emitter) {
< 			return false
< 		}
< 		if !yaml_emitter_process_foot_comment(emitter) {
< 			return false
< 		}
< 		emitter.state = emitter.states[len(emitter.states)-1]
< 		emitter.states = emitter.states[:len(emitter.states)-1]
< 		return true
< 	}
< 
< 	if !first && !trail {
< 		if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 			return false
< 		}
< 	}
< 
< 	if !yaml_emitter_process_head_comment(emitter) {
< 		return false
< 	}
< 
< 	if emitter.column == 0 {
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 	}
< 
< 	if emitter.canonical || emitter.column > emitter.best_width {
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 	}
< 
< 	if !emitter.canonical && yaml_emitter_check_simple_key(emitter) {
< 		emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE)
< 		return yaml_emitter_emit_node(emitter, event, false, false, true, true)
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'?'}, true, false, false) {
< 		return false
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_VALUE_STATE)
< 	return yaml_emitter_emit_node(emitter, event, false, false, true, false)
< }
< 
< // Expect a flow value node.
< func yaml_emitter_emit_flow_mapping_value(emitter *yaml_emitter_t, event *yaml_event_t, simple bool) bool {
< 	if simple {
< 		if !yaml_emitter_write_indicator(emitter, []byte{':'}, false, false, false) {
< 			return false
< 		}
< 	} else {
< 		if emitter.canonical || emitter.column > emitter.best_width {
< 			if !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{':'}, true, false, false) {
< 			return false
< 		}
< 	}
< 	if len(emitter.line_comment)+len(emitter.foot_comment)+len(emitter.tail_comment) > 0 {
< 		emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_TRAIL_KEY_STATE)
< 	} else {
< 		emitter.states = append(emitter.states, yaml_EMIT_FLOW_MAPPING_KEY_STATE)
< 	}
< 	if !yaml_emitter_emit_node(emitter, event, false, false, true, false) {
< 		return false
< 	}
< 	if len(emitter.line_comment)+len(emitter.foot_comment)+len(emitter.tail_comment) > 0 {
< 		if !yaml_emitter_write_indicator(emitter, []byte{','}, false, false, false) {
< 			return false
< 		}
< 	}
< 	if !yaml_emitter_process_line_comment(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_foot_comment(emitter) {
< 		return false
< 	}
< 	return true
< }
< 
< // Expect a block item node.
< func yaml_emitter_emit_block_sequence_item(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		// [Go] The original logic here would not indent the sequence when inside a mapping.
< 		// In Go we always indent it, but take the sequence indicator out of the indentation.
< 		indentless := emitter.best_indent == 2 && emitter.mapping_context && (emitter.column == 0 || !emitter.indention)
< 		original := emitter.indent
< 		if !yaml_emitter_increase_indent(emitter, false, indentless) {
< 			return false
< 		}
< 		if emitter.indent > original+2 {
< 			emitter.indent -= 2
< 		}
< 	}
< 	if event.typ == yaml_SEQUENCE_END_EVENT {
< 		emitter.indent = emitter.indents[len(emitter.indents)-1]
< 		emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 		emitter.state = emitter.states[len(emitter.states)-1]
< 		emitter.states = emitter.states[:len(emitter.states)-1]
< 		return true
< 	}
< 	if !yaml_emitter_process_head_comment(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_write_indent(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'-'}, true, false, true) {
< 		return false
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE)
< 	if !yaml_emitter_emit_node(emitter, event, false, true, false, false) {
< 		return false
< 	}
< 	if !yaml_emitter_process_line_comment(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_foot_comment(emitter) {
< 		return false
< 	}
< 	return true
< }
< 
< // Expect a block key node.
< func yaml_emitter_emit_block_mapping_key(emitter *yaml_emitter_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		if !yaml_emitter_increase_indent(emitter, false, false) {
< 			return false
< 		}
< 	}
< 	if !yaml_emitter_process_head_comment(emitter) {
< 		return false
< 	}
< 	if event.typ == yaml_MAPPING_END_EVENT {
< 		emitter.indent = emitter.indents[len(emitter.indents)-1]
< 		emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 		emitter.state = emitter.states[len(emitter.states)-1]
< 		emitter.states = emitter.states[:len(emitter.states)-1]
< 		return true
< 	}
< 	if !yaml_emitter_write_indent(emitter) {
< 		return false
< 	}
< 	if yaml_emitter_check_simple_key(emitter) {
< 		emitter.states = append(emitter.states, yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE)
< 		return yaml_emitter_emit_node(emitter, event, false, false, true, true)
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'?'}, true, false, true) {
< 		return false
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_BLOCK_MAPPING_VALUE_STATE)
< 	return yaml_emitter_emit_node(emitter, event, false, false, true, false)
< }
< 
< // Expect a block value node.
< func yaml_emitter_emit_block_mapping_value(emitter *yaml_emitter_t, event *yaml_event_t, simple bool) bool {
< 	if simple {
< 		if !yaml_emitter_write_indicator(emitter, []byte{':'}, false, false, false) {
< 			return false
< 		}
< 	} else {
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{':'}, true, false, true) {
< 			return false
< 		}
< 	}
< 	emitter.states = append(emitter.states, yaml_EMIT_BLOCK_MAPPING_KEY_STATE)
< 	if !yaml_emitter_emit_node(emitter, event, false, false, true, false) {
< 		return false
< 	}
< 	if !yaml_emitter_process_line_comment(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_foot_comment(emitter) {
< 		return false
< 	}
< 	return true
< }
< 
< // Expect a node.
< func yaml_emitter_emit_node(emitter *yaml_emitter_t, event *yaml_event_t,
< 	root bool, sequence bool, mapping bool, simple_key bool) bool {
< 
< 	emitter.root_context = root
< 	emitter.sequence_context = sequence
< 	emitter.mapping_context = mapping
< 	emitter.simple_key_context = simple_key
< 
< 	switch event.typ {
< 	case yaml_ALIAS_EVENT:
< 		return yaml_emitter_emit_alias(emitter, event)
< 	case yaml_SCALAR_EVENT:
< 		return yaml_emitter_emit_scalar(emitter, event)
< 	case yaml_SEQUENCE_START_EVENT:
< 		return yaml_emitter_emit_sequence_start(emitter, event)
< 	case yaml_MAPPING_START_EVENT:
< 		return yaml_emitter_emit_mapping_start(emitter, event)
< 	default:
< 		return yaml_emitter_set_emitter_error(emitter,
< 			fmt.Sprintf("expected SCALAR, SEQUENCE-START, MAPPING-START, or ALIAS, but got %v", event.typ))
< 	}
< }
< 
< // Expect ALIAS.
< func yaml_emitter_emit_alias(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if !yaml_emitter_process_anchor(emitter) {
< 		return false
< 	}
< 	emitter.state = emitter.states[len(emitter.states)-1]
< 	emitter.states = emitter.states[:len(emitter.states)-1]
< 	return true
< }
< 
< // Expect SCALAR.
< func yaml_emitter_emit_scalar(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if !yaml_emitter_select_scalar_style(emitter, event) {
< 		return false
< 	}
< 	if !yaml_emitter_process_anchor(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_tag(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_increase_indent(emitter, true, false) {
< 		return false
< 	}
< 	if !yaml_emitter_process_scalar(emitter) {
< 		return false
< 	}
< 	emitter.indent = emitter.indents[len(emitter.indents)-1]
< 	emitter.indents = emitter.indents[:len(emitter.indents)-1]
< 	emitter.state = emitter.states[len(emitter.states)-1]
< 	emitter.states = emitter.states[:len(emitter.states)-1]
< 	return true
< }
< 
< // Expect SEQUENCE-START.
< func yaml_emitter_emit_sequence_start(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if !yaml_emitter_process_anchor(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_tag(emitter) {
< 		return false
< 	}
< 	if emitter.flow_level > 0 || emitter.canonical || event.sequence_style() == yaml_FLOW_SEQUENCE_STYLE ||
< 		yaml_emitter_check_empty_sequence(emitter) {
< 		emitter.state = yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE
< 	} else {
< 		emitter.state = yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE
< 	}
< 	return true
< }
< 
< // Expect MAPPING-START.
< func yaml_emitter_emit_mapping_start(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 	if !yaml_emitter_process_anchor(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_process_tag(emitter) {
< 		return false
< 	}
< 	if emitter.flow_level > 0 || emitter.canonical || event.mapping_style() == yaml_FLOW_MAPPING_STYLE ||
< 		yaml_emitter_check_empty_mapping(emitter) {
< 		emitter.state = yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE
< 	} else {
< 		emitter.state = yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE
< 	}
< 	return true
< }
< 
< // Check if the document content is an empty scalar.
< func yaml_emitter_check_empty_document(emitter *yaml_emitter_t) bool {
< 	return false // [Go] Huh?
< }
< 
< // Check if the next events represent an empty sequence.
< func yaml_emitter_check_empty_sequence(emitter *yaml_emitter_t) bool {
< 	if len(emitter.events)-emitter.events_head < 2 {
< 		return false
< 	}
< 	return emitter.events[emitter.events_head].typ == yaml_SEQUENCE_START_EVENT &&
< 		emitter.events[emitter.events_head+1].typ == yaml_SEQUENCE_END_EVENT
< }
< 
< // Check if the next events represent an empty mapping.
< func yaml_emitter_check_empty_mapping(emitter *yaml_emitter_t) bool {
< 	if len(emitter.events)-emitter.events_head < 2 {
< 		return false
< 	}
< 	return emitter.events[emitter.events_head].typ == yaml_MAPPING_START_EVENT &&
< 		emitter.events[emitter.events_head+1].typ == yaml_MAPPING_END_EVENT
< }
< 
< // Check if the next node can be expressed as a simple key.
< func yaml_emitter_check_simple_key(emitter *yaml_emitter_t) bool {
< 	length := 0
< 	switch emitter.events[emitter.events_head].typ {
< 	case yaml_ALIAS_EVENT:
< 		length += len(emitter.anchor_data.anchor)
< 	case yaml_SCALAR_EVENT:
< 		if emitter.scalar_data.multiline {
< 			return false
< 		}
< 		length += len(emitter.anchor_data.anchor) +
< 			len(emitter.tag_data.handle) +
< 			len(emitter.tag_data.suffix) +
< 			len(emitter.scalar_data.value)
< 	case yaml_SEQUENCE_START_EVENT:
< 		if !yaml_emitter_check_empty_sequence(emitter) {
< 			return false
< 		}
< 		length += len(emitter.anchor_data.anchor) +
< 			len(emitter.tag_data.handle) +
< 			len(emitter.tag_data.suffix)
< 	case yaml_MAPPING_START_EVENT:
< 		if !yaml_emitter_check_empty_mapping(emitter) {
< 			return false
< 		}
< 		length += len(emitter.anchor_data.anchor) +
< 			len(emitter.tag_data.handle) +
< 			len(emitter.tag_data.suffix)
< 	default:
< 		return false
< 	}
< 	return length <= 128
< }
< 
< // Determine an acceptable scalar style.
< func yaml_emitter_select_scalar_style(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 
< 	no_tag := len(emitter.tag_data.handle) == 0 && len(emitter.tag_data.suffix) == 0
< 	if no_tag && !event.implicit && !event.quoted_implicit {
< 		return yaml_emitter_set_emitter_error(emitter, "neither tag nor implicit flags are specified")
< 	}
< 
< 	style := event.scalar_style()
< 	if style == yaml_ANY_SCALAR_STYLE {
< 		style = yaml_PLAIN_SCALAR_STYLE
< 	}
< 	if emitter.canonical {
< 		style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 	}
< 	if emitter.simple_key_context && emitter.scalar_data.multiline {
< 		style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 	}
< 
< 	if style == yaml_PLAIN_SCALAR_STYLE {
< 		if emitter.flow_level > 0 && !emitter.scalar_data.flow_plain_allowed ||
< 			emitter.flow_level == 0 && !emitter.scalar_data.block_plain_allowed {
< 			style = yaml_SINGLE_QUOTED_SCALAR_STYLE
< 		}
< 		if len(emitter.scalar_data.value) == 0 && (emitter.flow_level > 0 || emitter.simple_key_context) {
< 			style = yaml_SINGLE_QUOTED_SCALAR_STYLE
< 		}
< 		if no_tag && !event.implicit {
< 			style = yaml_SINGLE_QUOTED_SCALAR_STYLE
< 		}
< 	}
< 	if style == yaml_SINGLE_QUOTED_SCALAR_STYLE {
< 		if !emitter.scalar_data.single_quoted_allowed {
< 			style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 		}
< 	}
< 	if style == yaml_LITERAL_SCALAR_STYLE || style == yaml_FOLDED_SCALAR_STYLE {
< 		if !emitter.scalar_data.block_allowed || emitter.flow_level > 0 || emitter.simple_key_context {
< 			style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 		}
< 	}
< 
< 	if no_tag && !event.quoted_implicit && style != yaml_PLAIN_SCALAR_STYLE {
< 		emitter.tag_data.handle = []byte{'!'}
< 	}
< 	emitter.scalar_data.style = style
< 	return true
< }
< 
< // Write an anchor.
< func yaml_emitter_process_anchor(emitter *yaml_emitter_t) bool {
< 	if emitter.anchor_data.anchor == nil {
< 		return true
< 	}
< 	c := []byte{'&'}
< 	if emitter.anchor_data.alias {
< 		c[0] = '*'
< 	}
< 	if !yaml_emitter_write_indicator(emitter, c, true, false, false) {
< 		return false
< 	}
< 	return yaml_emitter_write_anchor(emitter, emitter.anchor_data.anchor)
< }
< 
< // Write a tag.
< func yaml_emitter_process_tag(emitter *yaml_emitter_t) bool {
< 	if len(emitter.tag_data.handle) == 0 && len(emitter.tag_data.suffix) == 0 {
< 		return true
< 	}
< 	if len(emitter.tag_data.handle) > 0 {
< 		if !yaml_emitter_write_tag_handle(emitter, emitter.tag_data.handle) {
< 			return false
< 		}
< 		if len(emitter.tag_data.suffix) > 0 {
< 			if !yaml_emitter_write_tag_content(emitter, emitter.tag_data.suffix, false) {
< 				return false
< 			}
< 		}
< 	} else {
< 		// [Go] Allocate these slices elsewhere.
< 		if !yaml_emitter_write_indicator(emitter, []byte("!<"), true, false, false) {
< 			return false
< 		}
< 		if !yaml_emitter_write_tag_content(emitter, emitter.tag_data.suffix, false) {
< 			return false
< 		}
< 		if !yaml_emitter_write_indicator(emitter, []byte{'>'}, false, false, false) {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< // Write a scalar.
< func yaml_emitter_process_scalar(emitter *yaml_emitter_t) bool {
< 	switch emitter.scalar_data.style {
< 	case yaml_PLAIN_SCALAR_STYLE:
< 		return yaml_emitter_write_plain_scalar(emitter, emitter.scalar_data.value, !emitter.simple_key_context)
< 
< 	case yaml_SINGLE_QUOTED_SCALAR_STYLE:
< 		return yaml_emitter_write_single_quoted_scalar(emitter, emitter.scalar_data.value, !emitter.simple_key_context)
< 
< 	case yaml_DOUBLE_QUOTED_SCALAR_STYLE:
< 		return yaml_emitter_write_double_quoted_scalar(emitter, emitter.scalar_data.value, !emitter.simple_key_context)
< 
< 	case yaml_LITERAL_SCALAR_STYLE:
< 		return yaml_emitter_write_literal_scalar(emitter, emitter.scalar_data.value)
< 
< 	case yaml_FOLDED_SCALAR_STYLE:
< 		return yaml_emitter_write_folded_scalar(emitter, emitter.scalar_data.value)
< 	}
< 	panic("unknown scalar style")
< }
< 
< // Write a head comment.
< func yaml_emitter_process_head_comment(emitter *yaml_emitter_t) bool {
< 	if len(emitter.tail_comment) > 0 {
< 		if !yaml_emitter_write_indent(emitter) {
< 			return false
< 		}
< 		if !yaml_emitter_write_comment(emitter, emitter.tail_comment) {
< 			return false
< 		}
< 		emitter.tail_comment = emitter.tail_comment[:0]
< 		emitter.foot_indent = emitter.indent
< 		if emitter.foot_indent < 0 {
< 			emitter.foot_indent = 0
< 		}
< 	}
< 
< 	if len(emitter.head_comment) == 0 {
< 		return true
< 	}
< 	if !yaml_emitter_write_indent(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_write_comment(emitter, emitter.head_comment) {
< 		return false
< 	}
< 	emitter.head_comment = emitter.head_comment[:0]
< 	return true
< }
< 
< // Write an line comment.
< func yaml_emitter_process_line_comment(emitter *yaml_emitter_t) bool {
< 	if len(emitter.line_comment) == 0 {
< 		return true
< 	}
< 	if !emitter.whitespace {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 	if !yaml_emitter_write_comment(emitter, emitter.line_comment) {
< 		return false
< 	}
< 	emitter.line_comment = emitter.line_comment[:0]
< 	return true
< }
< 
< // Write a foot comment.
< func yaml_emitter_process_foot_comment(emitter *yaml_emitter_t) bool {
< 	if len(emitter.foot_comment) == 0 {
< 		return true
< 	}
< 	if !yaml_emitter_write_indent(emitter) {
< 		return false
< 	}
< 	if !yaml_emitter_write_comment(emitter, emitter.foot_comment) {
< 		return false
< 	}
< 	emitter.foot_comment = emitter.foot_comment[:0]
< 	emitter.foot_indent = emitter.indent
< 	if emitter.foot_indent < 0 {
< 		emitter.foot_indent = 0
< 	}
< 	return true
< }
< 
< // Check if a %YAML directive is valid.
< func yaml_emitter_analyze_version_directive(emitter *yaml_emitter_t, version_directive *yaml_version_directive_t) bool {
< 	if version_directive.major != 1 || version_directive.minor != 1 {
< 		return yaml_emitter_set_emitter_error(emitter, "incompatible %YAML directive")
< 	}
< 	return true
< }
< 
< // Check if a %TAG directive is valid.
< func yaml_emitter_analyze_tag_directive(emitter *yaml_emitter_t, tag_directive *yaml_tag_directive_t) bool {
< 	handle := tag_directive.handle
< 	prefix := tag_directive.prefix
< 	if len(handle) == 0 {
< 		return yaml_emitter_set_emitter_error(emitter, "tag handle must not be empty")
< 	}
< 	if handle[0] != '!' {
< 		return yaml_emitter_set_emitter_error(emitter, "tag handle must start with '!'")
< 	}
< 	if handle[len(handle)-1] != '!' {
< 		return yaml_emitter_set_emitter_error(emitter, "tag handle must end with '!'")
< 	}
< 	for i := 1; i < len(handle)-1; i += width(handle[i]) {
< 		if !is_alpha(handle, i) {
< 			return yaml_emitter_set_emitter_error(emitter, "tag handle must contain alphanumerical characters only")
< 		}
< 	}
< 	if len(prefix) == 0 {
< 		return yaml_emitter_set_emitter_error(emitter, "tag prefix must not be empty")
< 	}
< 	return true
< }
< 
< // Check if an anchor is valid.
< func yaml_emitter_analyze_anchor(emitter *yaml_emitter_t, anchor []byte, alias bool) bool {
< 	if len(anchor) == 0 {
< 		problem := "anchor value must not be empty"
< 		if alias {
< 			problem = "alias value must not be empty"
< 		}
< 		return yaml_emitter_set_emitter_error(emitter, problem)
< 	}
< 	for i := 0; i < len(anchor); i += width(anchor[i]) {
< 		if !is_alpha(anchor, i) {
< 			problem := "anchor value must contain alphanumerical characters only"
< 			if alias {
< 				problem = "alias value must contain alphanumerical characters only"
< 			}
< 			return yaml_emitter_set_emitter_error(emitter, problem)
< 		}
< 	}
< 	emitter.anchor_data.anchor = anchor
< 	emitter.anchor_data.alias = alias
< 	return true
< }
< 
< // Check if a tag is valid.
< func yaml_emitter_analyze_tag(emitter *yaml_emitter_t, tag []byte) bool {
< 	if len(tag) == 0 {
< 		return yaml_emitter_set_emitter_error(emitter, "tag value must not be empty")
< 	}
< 	for i := 0; i < len(emitter.tag_directives); i++ {
< 		tag_directive := &emitter.tag_directives[i]
< 		if bytes.HasPrefix(tag, tag_directive.prefix) {
< 			emitter.tag_data.handle = tag_directive.handle
< 			emitter.tag_data.suffix = tag[len(tag_directive.prefix):]
< 			return true
< 		}
< 	}
< 	emitter.tag_data.suffix = tag
< 	return true
< }
< 
< // Check if a scalar is valid.
< func yaml_emitter_analyze_scalar(emitter *yaml_emitter_t, value []byte) bool {
< 	var (
< 		block_indicators   = false
< 		flow_indicators    = false
< 		line_breaks        = false
< 		special_characters = false
< 		tab_characters     = false
< 
< 		leading_space  = false
< 		leading_break  = false
< 		trailing_space = false
< 		trailing_break = false
< 		break_space    = false
< 		space_break    = false
< 
< 		preceded_by_whitespace = false
< 		followed_by_whitespace = false
< 		previous_space         = false
< 		previous_break         = false
< 	)
< 
< 	emitter.scalar_data.value = value
< 
< 	if len(value) == 0 {
< 		emitter.scalar_data.multiline = false
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = true
< 		emitter.scalar_data.single_quoted_allowed = true
< 		emitter.scalar_data.block_allowed = false
< 		return true
< 	}
< 
< 	if len(value) >= 3 && ((value[0] == '-' && value[1] == '-' && value[2] == '-') || (value[0] == '.' && value[1] == '.' && value[2] == '.')) {
< 		block_indicators = true
< 		flow_indicators = true
< 	}
< 
< 	preceded_by_whitespace = true
< 	for i, w := 0, 0; i < len(value); i += w {
< 		w = width(value[i])
< 		followed_by_whitespace = i+w >= len(value) || is_blank(value, i+w)
< 
< 		if i == 0 {
< 			switch value[i] {
< 			case '#', ',', '[', ']', '{', '}', '&', '*', '!', '|', '>', '\'', '"', '%', '@', '`':
< 				flow_indicators = true
< 				block_indicators = true
< 			case '?', ':':
< 				flow_indicators = true
< 				if followed_by_whitespace {
< 					block_indicators = true
< 				}
< 			case '-':
< 				if followed_by_whitespace {
< 					flow_indicators = true
< 					block_indicators = true
< 				}
< 			}
< 		} else {
< 			switch value[i] {
< 			case ',', '?', '[', ']', '{', '}':
< 				flow_indicators = true
< 			case ':':
< 				flow_indicators = true
< 				if followed_by_whitespace {
< 					block_indicators = true
< 				}
< 			case '#':
< 				if preceded_by_whitespace {
< 					flow_indicators = true
< 					block_indicators = true
< 				}
< 			}
< 		}
< 
< 		if value[i] == '\t' {
< 			tab_characters = true
< 		} else if !is_printable(value, i) || !is_ascii(value, i) && !emitter.unicode {
< 			special_characters = true
< 		}
< 		if is_space(value, i) {
< 			if i == 0 {
< 				leading_space = true
< 			}
< 			if i+width(value[i]) == len(value) {
< 				trailing_space = true
< 			}
< 			if previous_break {
< 				break_space = true
< 			}
< 			previous_space = true
< 			previous_break = false
< 		} else if is_break(value, i) {
< 			line_breaks = true
< 			if i == 0 {
< 				leading_break = true
< 			}
< 			if i+width(value[i]) == len(value) {
< 				trailing_break = true
< 			}
< 			if previous_space {
< 				space_break = true
< 			}
< 			previous_space = false
< 			previous_break = true
< 		} else {
< 			previous_space = false
< 			previous_break = false
< 		}
< 
< 		// [Go]: Why 'z'? Couldn't be the end of the string as that's the loop condition.
< 		preceded_by_whitespace = is_blankz(value, i)
< 	}
< 
< 	emitter.scalar_data.multiline = line_breaks
< 	emitter.scalar_data.flow_plain_allowed = true
< 	emitter.scalar_data.block_plain_allowed = true
< 	emitter.scalar_data.single_quoted_allowed = true
< 	emitter.scalar_data.block_allowed = true
< 
< 	if leading_space || leading_break || trailing_space || trailing_break {
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = false
< 	}
< 	if trailing_space {
< 		emitter.scalar_data.block_allowed = false
< 	}
< 	if break_space {
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = false
< 		emitter.scalar_data.single_quoted_allowed = false
< 	}
< 	if space_break || tab_characters || special_characters {
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = false
< 		emitter.scalar_data.single_quoted_allowed = false
< 	}
< 	if space_break || special_characters {
< 		emitter.scalar_data.block_allowed = false
< 	}
< 	if line_breaks {
< 		emitter.scalar_data.flow_plain_allowed = false
< 		emitter.scalar_data.block_plain_allowed = false
< 	}
< 	if flow_indicators {
< 		emitter.scalar_data.flow_plain_allowed = false
< 	}
< 	if block_indicators {
< 		emitter.scalar_data.block_plain_allowed = false
< 	}
< 	return true
< }
< 
< // Check if the event data is valid.
< func yaml_emitter_analyze_event(emitter *yaml_emitter_t, event *yaml_event_t) bool {
< 
< 	emitter.anchor_data.anchor = nil
< 	emitter.tag_data.handle = nil
< 	emitter.tag_data.suffix = nil
< 	emitter.scalar_data.value = nil
< 
< 	if len(event.head_comment) > 0 {
< 		emitter.head_comment = event.head_comment
< 	}
< 	if len(event.line_comment) > 0 {
< 		emitter.line_comment = event.line_comment
< 	}
< 	if len(event.foot_comment) > 0 {
< 		emitter.foot_comment = event.foot_comment
< 	}
< 	if len(event.tail_comment) > 0 {
< 		emitter.tail_comment = event.tail_comment
< 	}
< 
< 	switch event.typ {
< 	case yaml_ALIAS_EVENT:
< 		if !yaml_emitter_analyze_anchor(emitter, event.anchor, true) {
< 			return false
< 		}
< 
< 	case yaml_SCALAR_EVENT:
< 		if len(event.anchor) > 0 {
< 			if !yaml_emitter_analyze_anchor(emitter, event.anchor, false) {
< 				return false
< 			}
< 		}
< 		if len(event.tag) > 0 && (emitter.canonical || (!event.implicit && !event.quoted_implicit)) {
< 			if !yaml_emitter_analyze_tag(emitter, event.tag) {
< 				return false
< 			}
< 		}
< 		if !yaml_emitter_analyze_scalar(emitter, event.value) {
< 			return false
< 		}
< 
< 	case yaml_SEQUENCE_START_EVENT:
< 		if len(event.anchor) > 0 {
< 			if !yaml_emitter_analyze_anchor(emitter, event.anchor, false) {
< 				return false
< 			}
< 		}
< 		if len(event.tag) > 0 && (emitter.canonical || !event.implicit) {
< 			if !yaml_emitter_analyze_tag(emitter, event.tag) {
< 				return false
< 			}
< 		}
< 
< 	case yaml_MAPPING_START_EVENT:
< 		if len(event.anchor) > 0 {
< 			if !yaml_emitter_analyze_anchor(emitter, event.anchor, false) {
< 				return false
< 			}
< 		}
< 		if len(event.tag) > 0 && (emitter.canonical || !event.implicit) {
< 			if !yaml_emitter_analyze_tag(emitter, event.tag) {
< 				return false
< 			}
< 		}
< 	}
< 	return true
< }
< 
< // Write the BOM character.
< func yaml_emitter_write_bom(emitter *yaml_emitter_t) bool {
< 	if !flush(emitter) {
< 		return false
< 	}
< 	pos := emitter.buffer_pos
< 	emitter.buffer[pos+0] = '\xEF'
< 	emitter.buffer[pos+1] = '\xBB'
< 	emitter.buffer[pos+2] = '\xBF'
< 	emitter.buffer_pos += 3
< 	return true
< }
< 
< func yaml_emitter_write_indent(emitter *yaml_emitter_t) bool {
< 	indent := emitter.indent
< 	if indent < 0 {
< 		indent = 0
< 	}
< 	if !emitter.indention || emitter.column > indent || (emitter.column == indent && !emitter.whitespace) {
< 		if !put_break(emitter) {
< 			return false
< 		}
< 	}
< 	if emitter.foot_indent == indent {
< 		if !put_break(emitter) {
< 			return false
< 		}
< 	}
< 	for emitter.column < indent {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 	emitter.whitespace = true
< 	//emitter.indention = true
< 	emitter.space_above = false
< 	emitter.foot_indent = -1
< 	return true
< }
< 
< func yaml_emitter_write_indicator(emitter *yaml_emitter_t, indicator []byte, need_whitespace, is_whitespace, is_indention bool) bool {
< 	if need_whitespace && !emitter.whitespace {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 	if !write_all(emitter, indicator) {
< 		return false
< 	}
< 	emitter.whitespace = is_whitespace
< 	emitter.indention = (emitter.indention && is_indention)
< 	emitter.open_ended = false
< 	return true
< }
< 
< func yaml_emitter_write_anchor(emitter *yaml_emitter_t, value []byte) bool {
< 	if !write_all(emitter, value) {
< 		return false
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_tag_handle(emitter *yaml_emitter_t, value []byte) bool {
< 	if !emitter.whitespace {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 	if !write_all(emitter, value) {
< 		return false
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_tag_content(emitter *yaml_emitter_t, value []byte, need_whitespace bool) bool {
< 	if need_whitespace && !emitter.whitespace {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 	for i := 0; i < len(value); {
< 		var must_write bool
< 		switch value[i] {
< 		case ';', '/', '?', ':', '@', '&', '=', '+', '$', ',', '_', '.', '~', '*', '\'', '(', ')', '[', ']':
< 			must_write = true
< 		default:
< 			must_write = is_alpha(value, i)
< 		}
< 		if must_write {
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 		} else {
< 			w := width(value[i])
< 			for k := 0; k < w; k++ {
< 				octet := value[i]
< 				i++
< 				if !put(emitter, '%') {
< 					return false
< 				}
< 
< 				c := octet >> 4
< 				if c < 10 {
< 					c += '0'
< 				} else {
< 					c += 'A' - 10
< 				}
< 				if !put(emitter, c) {
< 					return false
< 				}
< 
< 				c = octet & 0x0f
< 				if c < 10 {
< 					c += '0'
< 				} else {
< 					c += 'A' - 10
< 				}
< 				if !put(emitter, c) {
< 					return false
< 				}
< 			}
< 		}
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_plain_scalar(emitter *yaml_emitter_t, value []byte, allow_breaks bool) bool {
< 	if len(value) > 0 && !emitter.whitespace {
< 		if !put(emitter, ' ') {
< 			return false
< 		}
< 	}
< 
< 	spaces := false
< 	breaks := false
< 	for i := 0; i < len(value); {
< 		if is_space(value, i) {
< 			if allow_breaks && !spaces && emitter.column > emitter.best_width && !is_space(value, i+1) {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				i += width(value[i])
< 			} else {
< 				if !write(emitter, value, &i) {
< 					return false
< 				}
< 			}
< 			spaces = true
< 		} else if is_break(value, i) {
< 			if !breaks && value[i] == '\n' {
< 				if !put_break(emitter) {
< 					return false
< 				}
< 			}
< 			if !write_break(emitter, value, &i) {
< 				return false
< 			}
< 			//emitter.indention = true
< 			breaks = true
< 		} else {
< 			if breaks {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = false
< 			spaces = false
< 			breaks = false
< 		}
< 	}
< 
< 	if len(value) > 0 {
< 		emitter.whitespace = false
< 	}
< 	emitter.indention = false
< 	if emitter.root_context {
< 		emitter.open_ended = true
< 	}
< 
< 	return true
< }
< 
< func yaml_emitter_write_single_quoted_scalar(emitter *yaml_emitter_t, value []byte, allow_breaks bool) bool {
< 
< 	if !yaml_emitter_write_indicator(emitter, []byte{'\''}, true, false, false) {
< 		return false
< 	}
< 
< 	spaces := false
< 	breaks := false
< 	for i := 0; i < len(value); {
< 		if is_space(value, i) {
< 			if allow_breaks && !spaces && emitter.column > emitter.best_width && i > 0 && i < len(value)-1 && !is_space(value, i+1) {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				i += width(value[i])
< 			} else {
< 				if !write(emitter, value, &i) {
< 					return false
< 				}
< 			}
< 			spaces = true
< 		} else if is_break(value, i) {
< 			if !breaks && value[i] == '\n' {
< 				if !put_break(emitter) {
< 					return false
< 				}
< 			}
< 			if !write_break(emitter, value, &i) {
< 				return false
< 			}
< 			//emitter.indention = true
< 			breaks = true
< 		} else {
< 			if breaks {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 			if value[i] == '\'' {
< 				if !put(emitter, '\'') {
< 					return false
< 				}
< 			}
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = false
< 			spaces = false
< 			breaks = false
< 		}
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'\''}, false, false, false) {
< 		return false
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_double_quoted_scalar(emitter *yaml_emitter_t, value []byte, allow_breaks bool) bool {
< 	spaces := false
< 	if !yaml_emitter_write_indicator(emitter, []byte{'"'}, true, false, false) {
< 		return false
< 	}
< 
< 	for i := 0; i < len(value); {
< 		if !is_printable(value, i) || (!emitter.unicode && !is_ascii(value, i)) ||
< 			is_bom(value, i) || is_break(value, i) ||
< 			value[i] == '"' || value[i] == '\\' {
< 
< 			octet := value[i]
< 
< 			var w int
< 			var v rune
< 			switch {
< 			case octet&0x80 == 0x00:
< 				w, v = 1, rune(octet&0x7F)
< 			case octet&0xE0 == 0xC0:
< 				w, v = 2, rune(octet&0x1F)
< 			case octet&0xF0 == 0xE0:
< 				w, v = 3, rune(octet&0x0F)
< 			case octet&0xF8 == 0xF0:
< 				w, v = 4, rune(octet&0x07)
< 			}
< 			for k := 1; k < w; k++ {
< 				octet = value[i+k]
< 				v = (v << 6) + (rune(octet) & 0x3F)
< 			}
< 			i += w
< 
< 			if !put(emitter, '\\') {
< 				return false
< 			}
< 
< 			var ok bool
< 			switch v {
< 			case 0x00:
< 				ok = put(emitter, '0')
< 			case 0x07:
< 				ok = put(emitter, 'a')
< 			case 0x08:
< 				ok = put(emitter, 'b')
< 			case 0x09:
< 				ok = put(emitter, 't')
< 			case 0x0A:
< 				ok = put(emitter, 'n')
< 			case 0x0b:
< 				ok = put(emitter, 'v')
< 			case 0x0c:
< 				ok = put(emitter, 'f')
< 			case 0x0d:
< 				ok = put(emitter, 'r')
< 			case 0x1b:
< 				ok = put(emitter, 'e')
< 			case 0x22:
< 				ok = put(emitter, '"')
< 			case 0x5c:
< 				ok = put(emitter, '\\')
< 			case 0x85:
< 				ok = put(emitter, 'N')
< 			case 0xA0:
< 				ok = put(emitter, '_')
< 			case 0x2028:
< 				ok = put(emitter, 'L')
< 			case 0x2029:
< 				ok = put(emitter, 'P')
< 			default:
< 				if v <= 0xFF {
< 					ok = put(emitter, 'x')
< 					w = 2
< 				} else if v <= 0xFFFF {
< 					ok = put(emitter, 'u')
< 					w = 4
< 				} else {
< 					ok = put(emitter, 'U')
< 					w = 8
< 				}
< 				for k := (w - 1) * 4; ok && k >= 0; k -= 4 {
< 					digit := byte((v >> uint(k)) & 0x0F)
< 					if digit < 10 {
< 						ok = put(emitter, digit+'0')
< 					} else {
< 						ok = put(emitter, digit+'A'-10)
< 					}
< 				}
< 			}
< 			if !ok {
< 				return false
< 			}
< 			spaces = false
< 		} else if is_space(value, i) {
< 			if allow_breaks && !spaces && emitter.column > emitter.best_width && i > 0 && i < len(value)-1 {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				if is_space(value, i+1) {
< 					if !put(emitter, '\\') {
< 						return false
< 					}
< 				}
< 				i += width(value[i])
< 			} else if !write(emitter, value, &i) {
< 				return false
< 			}
< 			spaces = true
< 		} else {
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 			spaces = false
< 		}
< 	}
< 	if !yaml_emitter_write_indicator(emitter, []byte{'"'}, false, false, false) {
< 		return false
< 	}
< 	emitter.whitespace = false
< 	emitter.indention = false
< 	return true
< }
< 
< func yaml_emitter_write_block_scalar_hints(emitter *yaml_emitter_t, value []byte) bool {
< 	if is_space(value, 0) || is_break(value, 0) {
< 		indent_hint := []byte{'0' + byte(emitter.best_indent)}
< 		if !yaml_emitter_write_indicator(emitter, indent_hint, false, false, false) {
< 			return false
< 		}
< 	}
< 
< 	emitter.open_ended = false
< 
< 	var chomp_hint [1]byte
< 	if len(value) == 0 {
< 		chomp_hint[0] = '-'
< 	} else {
< 		i := len(value) - 1
< 		for value[i]&0xC0 == 0x80 {
< 			i--
< 		}
< 		if !is_break(value, i) {
< 			chomp_hint[0] = '-'
< 		} else if i == 0 {
< 			chomp_hint[0] = '+'
< 			emitter.open_ended = true
< 		} else {
< 			i--
< 			for value[i]&0xC0 == 0x80 {
< 				i--
< 			}
< 			if is_break(value, i) {
< 				chomp_hint[0] = '+'
< 				emitter.open_ended = true
< 			}
< 		}
< 	}
< 	if chomp_hint[0] != 0 {
< 		if !yaml_emitter_write_indicator(emitter, chomp_hint[:], false, false, false) {
< 			return false
< 		}
< 	}
< 	return true
< }
< 
< func yaml_emitter_write_literal_scalar(emitter *yaml_emitter_t, value []byte) bool {
< 	if !yaml_emitter_write_indicator(emitter, []byte{'|'}, true, false, false) {
< 		return false
< 	}
< 	if !yaml_emitter_write_block_scalar_hints(emitter, value) {
< 		return false
< 	}
< 	if !put_break(emitter) {
< 		return false
< 	}
< 	//emitter.indention = true
< 	emitter.whitespace = true
< 	breaks := true
< 	for i := 0; i < len(value); {
< 		if is_break(value, i) {
< 			if !write_break(emitter, value, &i) {
< 				return false
< 			}
< 			//emitter.indention = true
< 			breaks = true
< 		} else {
< 			if breaks {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 			}
< 			if !write(emitter, value, &i) {
< 				return false
< 			}
< 			emitter.indention = false
< 			breaks = false
< 		}
< 	}
< 
< 	return true
< }
< 
< func yaml_emitter_write_folded_scalar(emitter *yaml_emitter_t, value []byte) bool {
< 	if !yaml_emitter_write_indicator(emitter, []byte{'>'}, true, false, false) {
< 		return false
< 	}
< 	if !yaml_emitter_write_block_scalar_hints(emitter, value) {
< 		return false
< 	}
< 
< 	if !put_break(emitter) {
< 		return false
< 	}
< 	//emitter.indention = true
< 	emitter.whitespace = true
< 
< 	breaks := true
< 	leading_spaces := true
< 	for i := 0; i < len(value); {
< 		if is_break(value, i) {
< 			if !breaks && !leading_spaces && value[i] == '\n' {
< 				k := 0
< 				for is_break(value, k) {
< 					k += width(value[k])
< 				}
< 				if !is_blankz(value, k) {
< 					if !put_break(emitter) {
< 						return false
< 					}
< 				}
< 			}
< 			if !write_break(emitter, value, &i) {
< 				return false
< 			}
< 			//emitter.indention = true
< 			breaks = true
< 		} else {
< 			if breaks {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				leading_spaces = is_blank(value, i)
< 			}
< 			if !breaks && is_space(value, i) && !is_space(value, i+1) && emitter.column > emitter.best_width {
< 				if !yaml_emitter_write_indent(emitter) {
< 					return false
< 				}
< 				i += width(value[i])
< 			} else {
< 				if !write(emitter, value, &i) {
< 					return false
< 				}
< 			}
< 			emitter.indention = false
< 			breaks = false
< 		}
< 	}
< 	return true
< }
< 
< func yaml_emitter_write_comment(emitter *yaml_emitter_t, comment []byte) bool {
< 	breaks := false
< 	pound := false
< 	for i := 0; i < len(comment); {
< 		if is_break(comment, i) {
< 			if !write_break(emitter, comment, &i) {
< 				return false
< 			}
< 			//emitter.indention = true
< 			breaks = true
< 			pound = false
< 		} else {
< 			if breaks && !yaml_emitter_write_indent(emitter) {
< 				return false
< 			}
< 			if !pound {
< 				if comment[i] != '#' && (!put(emitter, '#') || !put(emitter, ' ')) {
< 					return false
< 				}
< 				pound = true
< 			}
< 			if !write(emitter, comment, &i) {
< 				return false
< 			}
< 			emitter.indention = false
< 			breaks = false
< 		}
< 	}
< 	if !breaks && !put_break(emitter) {
< 		return false
< 	}
< 
< 	emitter.whitespace = true
< 	//emitter.indention = true
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/encode.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/encode.go
1,542d0
< //
< // Copyright (c) 2011-2019 Canonical Ltd
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package yaml
< 
< import (
< 	"encoding"
< 	"fmt"
< 	"io"
< 	"reflect"
< 	"regexp"
< 	"sort"
< 	"strconv"
< 	"strings"
< 	"time"
< 	"unicode/utf8"
< )
< 
< type encoder struct {
< 	emitter  yaml_emitter_t
< 	event    yaml_event_t
< 	out      []byte
< 	flow     bool
< 	indent   int
< 	doneInit bool
< }
< 
< func newEncoder() *encoder {
< 	e := &encoder{}
< 	yaml_emitter_initialize(&e.emitter)
< 	yaml_emitter_set_output_string(&e.emitter, &e.out)
< 	yaml_emitter_set_unicode(&e.emitter, true)
< 	return e
< }
< 
< func newEncoderWithWriter(w io.Writer) *encoder {
< 	e := &encoder{}
< 	yaml_emitter_initialize(&e.emitter)
< 	yaml_emitter_set_output_writer(&e.emitter, w)
< 	yaml_emitter_set_unicode(&e.emitter, true)
< 	return e
< }
< 
< func (e *encoder) init() {
< 	if e.doneInit {
< 		return
< 	}
< 	if e.indent == 0 {
< 		e.indent = 4
< 	}
< 	e.emitter.best_indent = e.indent
< 	yaml_stream_start_event_initialize(&e.event, yaml_UTF8_ENCODING)
< 	e.emit()
< 	e.doneInit = true
< }
< 
< func (e *encoder) finish() {
< 	e.emitter.open_ended = false
< 	yaml_stream_end_event_initialize(&e.event)
< 	e.emit()
< }
< 
< func (e *encoder) destroy() {
< 	yaml_emitter_delete(&e.emitter)
< }
< 
< func (e *encoder) emit() {
< 	// This will internally delete the e.event value.
< 	e.must(yaml_emitter_emit(&e.emitter, &e.event))
< }
< 
< func (e *encoder) must(ok bool) {
< 	if !ok {
< 		msg := e.emitter.problem
< 		if msg == "" {
< 			msg = "unknown problem generating YAML content"
< 		}
< 		failf("%s", msg)
< 	}
< }
< 
< func (e *encoder) marshalDoc(tag string, in reflect.Value) {
< 	e.init()
< 	var node *Node
< 	if in.IsValid() {
< 		node, _ = in.Interface().(*Node)
< 	}
< 	if node != nil && node.Kind == DocumentNode {
< 		e.nodev(in)
< 	} else {
< 		yaml_document_start_event_initialize(&e.event, nil, nil, true)
< 		e.emit()
< 		e.marshal(tag, in)
< 		yaml_document_end_event_initialize(&e.event, true)
< 		e.emit()
< 	}
< }
< 
< func (e *encoder) marshal(tag string, in reflect.Value) {
< 	tag = shortTag(tag)
< 	if !in.IsValid() || in.Kind() == reflect.Ptr && in.IsNil() {
< 		e.nilv()
< 		return
< 	}
< 	iface := in.Interface()
< 	switch value := iface.(type) {
< 	case *Node:
< 		e.nodev(in)
< 		return
< 	case time.Time:
< 		e.timev(tag, in)
< 		return
< 	case *time.Time:
< 		e.timev(tag, in.Elem())
< 		return
< 	case time.Duration:
< 		e.stringv(tag, reflect.ValueOf(value.String()))
< 		return
< 	case Marshaler:
< 		v, err := value.MarshalYAML()
< 		if err != nil {
< 			fail(err)
< 		}
< 		if v == nil {
< 			e.nilv()
< 			return
< 		}
< 		e.marshal(tag, reflect.ValueOf(v))
< 		return
< 	case encoding.TextMarshaler:
< 		text, err := value.MarshalText()
< 		if err != nil {
< 			fail(err)
< 		}
< 		in = reflect.ValueOf(string(text))
< 	case nil:
< 		e.nilv()
< 		return
< 	}
< 	switch in.Kind() {
< 	case reflect.Interface:
< 		e.marshal(tag, in.Elem())
< 	case reflect.Map:
< 		e.mapv(tag, in)
< 	case reflect.Ptr:
< 		e.marshal(tag, in.Elem())
< 	case reflect.Struct:
< 		e.structv(tag, in)
< 	case reflect.Slice, reflect.Array:
< 		e.slicev(tag, in)
< 	case reflect.String:
< 		e.stringv(tag, in)
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		e.intv(tag, in)
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		e.uintv(tag, in)
< 	case reflect.Float32, reflect.Float64:
< 		e.floatv(tag, in)
< 	case reflect.Bool:
< 		e.boolv(tag, in)
< 	default:
< 		panic("cannot marshal type: " + in.Type().String())
< 	}
< }
< 
< func (e *encoder) mapv(tag string, in reflect.Value) {
< 	e.mappingv(tag, func() {
< 		keys := keyList(in.MapKeys())
< 		sort.Sort(keys)
< 		for _, k := range keys {
< 			e.marshal("", k)
< 			e.marshal("", in.MapIndex(k))
< 		}
< 	})
< }
< 
< func (e *encoder) fieldByIndex(v reflect.Value, index []int) (field reflect.Value) {
< 	for _, num := range index {
< 		for {
< 			if v.Kind() == reflect.Ptr {
< 				if v.IsNil() {
< 					return reflect.Value{}
< 				}
< 				v = v.Elem()
< 				continue
< 			}
< 			break
< 		}
< 		v = v.Field(num)
< 	}
< 	return v
< }
< 
< func (e *encoder) structv(tag string, in reflect.Value) {
< 	sinfo, err := getStructInfo(in.Type())
< 	if err != nil {
< 		panic(err)
< 	}
< 	e.mappingv(tag, func() {
< 		for _, info := range sinfo.FieldsList {
< 			var value reflect.Value
< 			if info.Inline == nil {
< 				value = in.Field(info.Num)
< 			} else {
< 				value = e.fieldByIndex(in, info.Inline)
< 				if !value.IsValid() {
< 					continue
< 				}
< 			}
< 			if info.OmitEmpty && isZero(value) {
< 				continue
< 			}
< 			e.marshal("", reflect.ValueOf(info.Key))
< 			e.flow = info.Flow
< 			e.marshal("", value)
< 		}
< 		if sinfo.InlineMap >= 0 {
< 			m := in.Field(sinfo.InlineMap)
< 			if m.Len() > 0 {
< 				e.flow = false
< 				keys := keyList(m.MapKeys())
< 				sort.Sort(keys)
< 				for _, k := range keys {
< 					if _, found := sinfo.FieldsMap[k.String()]; found {
< 						panic(fmt.Sprintf("cannot have key %q in inlined map: conflicts with struct field", k.String()))
< 					}
< 					e.marshal("", k)
< 					e.flow = false
< 					e.marshal("", m.MapIndex(k))
< 				}
< 			}
< 		}
< 	})
< }
< 
< func (e *encoder) mappingv(tag string, f func()) {
< 	implicit := tag == ""
< 	style := yaml_BLOCK_MAPPING_STYLE
< 	if e.flow {
< 		e.flow = false
< 		style = yaml_FLOW_MAPPING_STYLE
< 	}
< 	yaml_mapping_start_event_initialize(&e.event, nil, []byte(tag), implicit, style)
< 	e.emit()
< 	f()
< 	yaml_mapping_end_event_initialize(&e.event)
< 	e.emit()
< }
< 
< func (e *encoder) slicev(tag string, in reflect.Value) {
< 	implicit := tag == ""
< 	style := yaml_BLOCK_SEQUENCE_STYLE
< 	if e.flow {
< 		e.flow = false
< 		style = yaml_FLOW_SEQUENCE_STYLE
< 	}
< 	e.must(yaml_sequence_start_event_initialize(&e.event, nil, []byte(tag), implicit, style))
< 	e.emit()
< 	n := in.Len()
< 	for i := 0; i < n; i++ {
< 		e.marshal("", in.Index(i))
< 	}
< 	e.must(yaml_sequence_end_event_initialize(&e.event))
< 	e.emit()
< }
< 
< // isBase60 returns whether s is in base 60 notation as defined in YAML 1.1.
< //
< // The base 60 float notation in YAML 1.1 is a terrible idea and is unsupported
< // in YAML 1.2 and by this package, but these should be marshalled quoted for
< // the time being for compatibility with other parsers.
< func isBase60Float(s string) (result bool) {
< 	// Fast path.
< 	if s == "" {
< 		return false
< 	}
< 	c := s[0]
< 	if !(c == '+' || c == '-' || c >= '0' && c <= '9') || strings.IndexByte(s, ':') < 0 {
< 		return false
< 	}
< 	// Do the full match.
< 	return base60float.MatchString(s)
< }
< 
< // From http://yaml.org/type/float.html, except the regular expression there
< // is bogus. In practice parsers do not enforce the "\.[0-9_]*" suffix.
< var base60float = regexp.MustCompile(`^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+(?:\.[0-9_]*)?$`)
< 
< func (e *encoder) stringv(tag string, in reflect.Value) {
< 	var style yaml_scalar_style_t
< 	s := in.String()
< 	canUsePlain := true
< 	switch {
< 	case !utf8.ValidString(s):
< 		if tag == binaryTag {
< 			failf("explicitly tagged !!binary data must be base64-encoded")
< 		}
< 		if tag != "" {
< 			failf("cannot marshal invalid UTF-8 data as %s", shortTag(tag))
< 		}
< 		// It can't be encoded directly as YAML so use a binary tag
< 		// and encode it as base64.
< 		tag = binaryTag
< 		s = encodeBase64(s)
< 	case tag == "":
< 		// Check to see if it would resolve to a specific
< 		// tag when encoded unquoted. If it doesn't,
< 		// there's no need to quote it.
< 		rtag, _ := resolve("", s)
< 		canUsePlain = rtag == strTag && !isBase60Float(s)
< 	}
< 	// Note: it's possible for user code to emit invalid YAML
< 	// if they explicitly specify a tag and a string containing
< 	// text that's incompatible with that tag.
< 	switch {
< 	case strings.Contains(s, "\n"):
< 		if e.flow {
< 			style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 		} else {
< 			style = yaml_LITERAL_SCALAR_STYLE
< 		}
< 	case canUsePlain:
< 		style = yaml_PLAIN_SCALAR_STYLE
< 	default:
< 		style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 	}
< 	e.emitScalar(s, "", tag, style, nil, nil, nil, nil)
< }
< 
< func (e *encoder) boolv(tag string, in reflect.Value) {
< 	var s string
< 	if in.Bool() {
< 		s = "true"
< 	} else {
< 		s = "false"
< 	}
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE, nil, nil, nil, nil)
< }
< 
< func (e *encoder) intv(tag string, in reflect.Value) {
< 	s := strconv.FormatInt(in.Int(), 10)
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE, nil, nil, nil, nil)
< }
< 
< func (e *encoder) uintv(tag string, in reflect.Value) {
< 	s := strconv.FormatUint(in.Uint(), 10)
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE, nil, nil, nil, nil)
< }
< 
< func (e *encoder) timev(tag string, in reflect.Value) {
< 	t := in.Interface().(time.Time)
< 	s := t.Format(time.RFC3339Nano)
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE, nil, nil, nil, nil)
< }
< 
< func (e *encoder) floatv(tag string, in reflect.Value) {
< 	// Issue #352: When formatting, use the precision of the underlying value
< 	precision := 64
< 	if in.Kind() == reflect.Float32 {
< 		precision = 32
< 	}
< 
< 	s := strconv.FormatFloat(in.Float(), 'g', -1, precision)
< 	switch s {
< 	case "+Inf":
< 		s = ".inf"
< 	case "-Inf":
< 		s = "-.inf"
< 	case "NaN":
< 		s = ".nan"
< 	}
< 	e.emitScalar(s, "", tag, yaml_PLAIN_SCALAR_STYLE, nil, nil, nil, nil)
< }
< 
< func (e *encoder) nilv() {
< 	e.emitScalar("null", "", "", yaml_PLAIN_SCALAR_STYLE, nil, nil, nil, nil)
< }
< 
< func (e *encoder) emitScalar(value, anchor, tag string, style yaml_scalar_style_t, head, line, foot, tail []byte) {
< 	// TODO Kill this function. Replace all initialize calls by their underlining Go literals.
< 	implicit := tag == ""
< 	if !implicit {
< 		tag = longTag(tag)
< 	}
< 	e.must(yaml_scalar_event_initialize(&e.event, []byte(anchor), []byte(tag), []byte(value), implicit, implicit, style))
< 	e.event.head_comment = head
< 	e.event.line_comment = line
< 	e.event.foot_comment = foot
< 	e.event.tail_comment = tail
< 	e.emit()
< }
< 
< func (e *encoder) nodev(in reflect.Value) {
< 	e.node(in.Interface().(*Node), "")
< }
< 
< func (e *encoder) node(node *Node, tail string) {
< 	// If the tag was not explicitly requested, and dropping it won't change the
< 	// implicit tag of the value, don't include it in the presentation.
< 	var tag = node.Tag
< 	var stag = shortTag(tag)
< 	var rtag string
< 	var forceQuoting bool
< 	if tag != "" && node.Style&TaggedStyle == 0 {
< 		if node.Kind == ScalarNode {
< 			if stag == strTag && node.Style&(SingleQuotedStyle|DoubleQuotedStyle|LiteralStyle|FoldedStyle) != 0 {
< 				tag = ""
< 			} else {
< 				rtag, _ = resolve("", node.Value)
< 				if rtag == stag {
< 					tag = ""
< 				} else if stag == strTag {
< 					tag = ""
< 					forceQuoting = true
< 				}
< 			}
< 		} else {
< 			switch node.Kind {
< 			case MappingNode:
< 				rtag = mapTag
< 			case SequenceNode:
< 				rtag = seqTag
< 			}
< 			if rtag == stag {
< 				tag = ""
< 			}
< 		}
< 	}
< 
< 	switch node.Kind {
< 	case DocumentNode:
< 		yaml_document_start_event_initialize(&e.event, nil, nil, true)
< 		e.event.head_comment = []byte(node.HeadComment)
< 		e.emit()
< 		for _, node := range node.Content {
< 			e.node(node, "")
< 		}
< 		yaml_document_end_event_initialize(&e.event, true)
< 		e.event.foot_comment = []byte(node.FootComment)
< 		e.emit()
< 
< 	case SequenceNode:
< 		style := yaml_BLOCK_SEQUENCE_STYLE
< 		if node.Style&FlowStyle != 0 {
< 			style = yaml_FLOW_SEQUENCE_STYLE
< 		}
< 		e.must(yaml_sequence_start_event_initialize(&e.event, []byte(node.Anchor), []byte(tag), tag == "", style))
< 		e.event.head_comment = []byte(node.HeadComment)
< 		e.emit()
< 		for _, node := range node.Content {
< 			e.node(node, "")
< 		}
< 		e.must(yaml_sequence_end_event_initialize(&e.event))
< 		e.event.line_comment = []byte(node.LineComment)
< 		e.event.foot_comment = []byte(node.FootComment)
< 		e.emit()
< 
< 	case MappingNode:
< 		style := yaml_BLOCK_MAPPING_STYLE
< 		if node.Style&FlowStyle != 0 {
< 			style = yaml_FLOW_MAPPING_STYLE
< 		}
< 		yaml_mapping_start_event_initialize(&e.event, []byte(node.Anchor), []byte(tag), tag == "", style)
< 		e.event.tail_comment = []byte(tail)
< 		e.event.head_comment = []byte(node.HeadComment)
< 		e.emit()
< 
< 		// The tail logic below moves the foot comment of prior keys to the following key,
< 		// since the value for each key may be a nested structure and the foot needs to be
< 		// processed only the entirety of the value is streamed. The last tail is processed
< 		// with the mapping end event.
< 		var tail string
< 		for i := 0; i+1 < len(node.Content); i += 2 {
< 			k := node.Content[i]
< 			foot := k.FootComment
< 			k.FootComment = ""
< 			e.node(k, tail)
< 			tail = foot
< 
< 			v := node.Content[i+1]
< 			e.node(v, "")
< 		}
< 
< 		yaml_mapping_end_event_initialize(&e.event)
< 		e.event.tail_comment = []byte(tail)
< 		e.event.line_comment = []byte(node.LineComment)
< 		e.event.foot_comment = []byte(node.FootComment)
< 		e.emit()
< 
< 	case AliasNode:
< 		yaml_alias_event_initialize(&e.event, []byte(node.Value))
< 		e.event.head_comment = []byte(node.HeadComment)
< 		e.event.line_comment = []byte(node.LineComment)
< 		e.event.foot_comment = []byte(node.FootComment)
< 		e.emit()
< 
< 	case ScalarNode:
< 		value := node.Value
< 		if !utf8.ValidString(value) {
< 			if tag == binaryTag {
< 				failf("explicitly tagged !!binary data must be base64-encoded")
< 			}
< 			if tag != "" {
< 				failf("cannot marshal invalid UTF-8 data as %s", shortTag(tag))
< 			}
< 			// It can't be encoded directly as YAML so use a binary tag
< 			// and encode it as base64.
< 			tag = binaryTag
< 			value = encodeBase64(value)
< 		}
< 
< 		style := yaml_PLAIN_SCALAR_STYLE
< 		switch {
< 		case node.Style&DoubleQuotedStyle != 0:
< 			style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 		case node.Style&SingleQuotedStyle != 0:
< 			style = yaml_SINGLE_QUOTED_SCALAR_STYLE
< 		case node.Style&LiteralStyle != 0:
< 			style = yaml_LITERAL_SCALAR_STYLE
< 		case node.Style&FoldedStyle != 0:
< 			style = yaml_FOLDED_SCALAR_STYLE
< 		case strings.Contains(value, "\n"):
< 			style = yaml_LITERAL_SCALAR_STYLE
< 		case forceQuoting:
< 			style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 		}
< 
< 		e.emitScalar(value, node.Anchor, tag, style, []byte(node.HeadComment), []byte(node.LineComment), []byte(node.FootComment), []byte(tail))
< 	}
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/go.mod updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/go.mod
1,5d0
< module "gopkg.in/yaml.v3"
< 
< require (
< 	"gopkg.in/check.v1" v0.0.0-20161208181325-20d25e280405
< )
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/parserc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/parserc.go
1,1210d0
< //
< // Copyright (c) 2011-2019 Canonical Ltd
< // Copyright (c) 2006-2010 Kirill Simonov
< //
< // Permission is hereby granted, free of charge, to any person obtaining a copy of
< // this software and associated documentation files (the "Software"), to deal in
< // the Software without restriction, including without limitation the rights to
< // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< // of the Software, and to permit persons to whom the Software is furnished to do
< // so, subject to the following conditions:
< //
< // The above copyright notice and this permission notice shall be included in all
< // copies or substantial portions of the Software.
< //
< // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< // SOFTWARE.
< 
< package yaml
< 
< import (
< 	"bytes"
< )
< 
< // The parser implements the following grammar:
< //
< // stream               ::= STREAM-START implicit_document? explicit_document* STREAM-END
< // implicit_document    ::= block_node DOCUMENT-END*
< // explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
< // block_node_or_indentless_sequence    ::=
< //                          ALIAS
< //                          | properties (block_content | indentless_block_sequence)?
< //                          | block_content
< //                          | indentless_block_sequence
< // block_node           ::= ALIAS
< //                          | properties block_content?
< //                          | block_content
< // flow_node            ::= ALIAS
< //                          | properties flow_content?
< //                          | flow_content
< // properties           ::= TAG ANCHOR? | ANCHOR TAG?
< // block_content        ::= block_collection | flow_collection | SCALAR
< // flow_content         ::= flow_collection | SCALAR
< // block_collection     ::= block_sequence | block_mapping
< // flow_collection      ::= flow_sequence | flow_mapping
< // block_sequence       ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
< // indentless_sequence  ::= (BLOCK-ENTRY block_node?)+
< // block_mapping        ::= BLOCK-MAPPING_START
< //                          ((KEY block_node_or_indentless_sequence?)?
< //                          (VALUE block_node_or_indentless_sequence?)?)*
< //                          BLOCK-END
< // flow_sequence        ::= FLOW-SEQUENCE-START
< //                          (flow_sequence_entry FLOW-ENTRY)*
< //                          flow_sequence_entry?
< //                          FLOW-SEQUENCE-END
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< // flow_mapping         ::= FLOW-MAPPING-START
< //                          (flow_mapping_entry FLOW-ENTRY)*
< //                          flow_mapping_entry?
< //                          FLOW-MAPPING-END
< // flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< 
< // Peek the next token in the token queue.
< func peek_token(parser *yaml_parser_t) *yaml_token_t {
< 	if parser.token_available || yaml_parser_fetch_more_tokens(parser) {
< 		token := &parser.tokens[parser.tokens_head]
< 		yaml_parser_unfold_comments(parser, token)
< 		return token
< 	}
< 	return nil
< }
< 
< // yaml_parser_unfold_comments walks through the comments queue and joins all
< // comments behind the position of the provided token into the respective
< // top-level comment slices in the parser.
< func yaml_parser_unfold_comments(parser *yaml_parser_t, token *yaml_token_t) {
< 	for parser.comments_head < len(parser.comments) && token.start_mark.index >= parser.comments[parser.comments_head].token_mark.index {
< 		comment := &parser.comments[parser.comments_head]
< 		if len(comment.head) > 0 {
< 			if token.typ == yaml_BLOCK_END_TOKEN {
< 				// No heads on ends, so keep comment.head for a follow up token.
< 				break
< 			}
< 			if len(parser.head_comment) > 0 {
< 				parser.head_comment = append(parser.head_comment, '\n')
< 			}
< 			parser.head_comment = append(parser.head_comment, comment.head...)
< 		}
< 		if len(comment.foot) > 0 {
< 			if len(parser.foot_comment) > 0 {
< 				parser.foot_comment = append(parser.foot_comment, '\n')
< 			}
< 			parser.foot_comment = append(parser.foot_comment, comment.foot...)
< 		}
< 		if len(comment.line) > 0 {
< 			if len(parser.line_comment) > 0 {
< 				parser.line_comment = append(parser.line_comment, '\n')
< 			}
< 			parser.line_comment = append(parser.line_comment, comment.line...)
< 		}
< 		*comment = yaml_comment_t{}
< 		parser.comments_head++
< 	}
< }
< 
< // Remove the next token from the queue (must be called after peek_token).
< func skip_token(parser *yaml_parser_t) {
< 	parser.token_available = false
< 	parser.tokens_parsed++
< 	parser.stream_end_produced = parser.tokens[parser.tokens_head].typ == yaml_STREAM_END_TOKEN
< 	parser.tokens_head++
< }
< 
< // Get the next event.
< func yaml_parser_parse(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	// Erase the event object.
< 	*event = yaml_event_t{}
< 
< 	// No events after the end of the stream or error.
< 	if parser.stream_end_produced || parser.error != yaml_NO_ERROR || parser.state == yaml_PARSE_END_STATE {
< 		return true
< 	}
< 
< 	// Generate the next event.
< 	return yaml_parser_state_machine(parser, event)
< }
< 
< // Set parser error.
< func yaml_parser_set_parser_error(parser *yaml_parser_t, problem string, problem_mark yaml_mark_t) bool {
< 	parser.error = yaml_PARSER_ERROR
< 	parser.problem = problem
< 	parser.problem_mark = problem_mark
< 	return false
< }
< 
< func yaml_parser_set_parser_error_context(parser *yaml_parser_t, context string, context_mark yaml_mark_t, problem string, problem_mark yaml_mark_t) bool {
< 	parser.error = yaml_PARSER_ERROR
< 	parser.context = context
< 	parser.context_mark = context_mark
< 	parser.problem = problem
< 	parser.problem_mark = problem_mark
< 	return false
< }
< 
< // State dispatcher.
< func yaml_parser_state_machine(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	//trace("yaml_parser_state_machine", "state:", parser.state.String())
< 
< 	switch parser.state {
< 	case yaml_PARSE_STREAM_START_STATE:
< 		return yaml_parser_parse_stream_start(parser, event)
< 
< 	case yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE:
< 		return yaml_parser_parse_document_start(parser, event, true)
< 
< 	case yaml_PARSE_DOCUMENT_START_STATE:
< 		return yaml_parser_parse_document_start(parser, event, false)
< 
< 	case yaml_PARSE_DOCUMENT_CONTENT_STATE:
< 		return yaml_parser_parse_document_content(parser, event)
< 
< 	case yaml_PARSE_DOCUMENT_END_STATE:
< 		return yaml_parser_parse_document_end(parser, event)
< 
< 	case yaml_PARSE_BLOCK_NODE_STATE:
< 		return yaml_parser_parse_node(parser, event, true, false)
< 
< 	case yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE:
< 		return yaml_parser_parse_node(parser, event, true, true)
< 
< 	case yaml_PARSE_FLOW_NODE_STATE:
< 		return yaml_parser_parse_node(parser, event, false, false)
< 
< 	case yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE:
< 		return yaml_parser_parse_block_sequence_entry(parser, event, true)
< 
< 	case yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE:
< 		return yaml_parser_parse_block_sequence_entry(parser, event, false)
< 
< 	case yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE:
< 		return yaml_parser_parse_indentless_sequence_entry(parser, event)
< 
< 	case yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE:
< 		return yaml_parser_parse_block_mapping_key(parser, event, true)
< 
< 	case yaml_PARSE_BLOCK_MAPPING_KEY_STATE:
< 		return yaml_parser_parse_block_mapping_key(parser, event, false)
< 
< 	case yaml_PARSE_BLOCK_MAPPING_VALUE_STATE:
< 		return yaml_parser_parse_block_mapping_value(parser, event)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE:
< 		return yaml_parser_parse_flow_sequence_entry(parser, event, true)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE:
< 		return yaml_parser_parse_flow_sequence_entry(parser, event, false)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE:
< 		return yaml_parser_parse_flow_sequence_entry_mapping_key(parser, event)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE:
< 		return yaml_parser_parse_flow_sequence_entry_mapping_value(parser, event)
< 
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE:
< 		return yaml_parser_parse_flow_sequence_entry_mapping_end(parser, event)
< 
< 	case yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE:
< 		return yaml_parser_parse_flow_mapping_key(parser, event, true)
< 
< 	case yaml_PARSE_FLOW_MAPPING_KEY_STATE:
< 		return yaml_parser_parse_flow_mapping_key(parser, event, false)
< 
< 	case yaml_PARSE_FLOW_MAPPING_VALUE_STATE:
< 		return yaml_parser_parse_flow_mapping_value(parser, event, false)
< 
< 	case yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE:
< 		return yaml_parser_parse_flow_mapping_value(parser, event, true)
< 
< 	default:
< 		panic("invalid parser state")
< 	}
< }
< 
< // Parse the production:
< // stream   ::= STREAM-START implicit_document? explicit_document* STREAM-END
< //              ************
< func yaml_parser_parse_stream_start(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ != yaml_STREAM_START_TOKEN {
< 		return yaml_parser_set_parser_error(parser, "did not find expected <stream-start>", token.start_mark)
< 	}
< 	parser.state = yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE
< 	*event = yaml_event_t{
< 		typ:        yaml_STREAM_START_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.end_mark,
< 		encoding:   token.encoding,
< 	}
< 	skip_token(parser)
< 	return true
< }
< 
< // Parse the productions:
< // implicit_document    ::= block_node DOCUMENT-END*
< //                          *
< // explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
< //                          *************************
< func yaml_parser_parse_document_start(parser *yaml_parser_t, event *yaml_event_t, implicit bool) bool {
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	// Parse extra document end indicators.
< 	if !implicit {
< 		for token.typ == yaml_DOCUMENT_END_TOKEN {
< 			skip_token(parser)
< 			token = peek_token(parser)
< 			if token == nil {
< 				return false
< 			}
< 		}
< 	}
< 
< 	if implicit && token.typ != yaml_VERSION_DIRECTIVE_TOKEN &&
< 		token.typ != yaml_TAG_DIRECTIVE_TOKEN &&
< 		token.typ != yaml_DOCUMENT_START_TOKEN &&
< 		token.typ != yaml_STREAM_END_TOKEN {
< 		// Parse an implicit document.
< 		if !yaml_parser_process_directives(parser, nil, nil) {
< 			return false
< 		}
< 		parser.states = append(parser.states, yaml_PARSE_DOCUMENT_END_STATE)
< 		parser.state = yaml_PARSE_BLOCK_NODE_STATE
< 
< 		var head_comment []byte
< 		if len(parser.head_comment) > 0 {
< 			// [Go] Scan the header comment backwards, and if an empty line is found, break
< 			//      the header so the part before the last empty line goes into the
< 			//      document header, while the bottom of it goes into a follow up event.
< 			for i := len(parser.head_comment) - 1; i > 0; i-- {
< 				if parser.head_comment[i] == '\n' {
< 					if i == len(parser.head_comment)-1 {
< 						head_comment = parser.head_comment[:i]
< 						parser.head_comment = parser.head_comment[i+1:]
< 						break
< 					} else if parser.head_comment[i-1] == '\n' {
< 						head_comment = parser.head_comment[:i-1]
< 						parser.head_comment = parser.head_comment[i+1:]
< 						break
< 					}
< 				}
< 			}
< 		}
< 
< 		*event = yaml_event_t{
< 			typ:        yaml_DOCUMENT_START_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 
< 			head_comment: head_comment,
< 		}
< 
< 	} else if token.typ != yaml_STREAM_END_TOKEN {
< 		// Parse an explicit document.
< 		var version_directive *yaml_version_directive_t
< 		var tag_directives []yaml_tag_directive_t
< 		start_mark := token.start_mark
< 		if !yaml_parser_process_directives(parser, &version_directive, &tag_directives) {
< 			return false
< 		}
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_DOCUMENT_START_TOKEN {
< 			yaml_parser_set_parser_error(parser,
< 				"did not find expected <document start>", token.start_mark)
< 			return false
< 		}
< 		parser.states = append(parser.states, yaml_PARSE_DOCUMENT_END_STATE)
< 		parser.state = yaml_PARSE_DOCUMENT_CONTENT_STATE
< 		end_mark := token.end_mark
< 
< 		*event = yaml_event_t{
< 			typ:               yaml_DOCUMENT_START_EVENT,
< 			start_mark:        start_mark,
< 			end_mark:          end_mark,
< 			version_directive: version_directive,
< 			tag_directives:    tag_directives,
< 			implicit:          false,
< 		}
< 		skip_token(parser)
< 
< 	} else {
< 		// Parse the stream end.
< 		parser.state = yaml_PARSE_END_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_STREAM_END_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 		}
< 		skip_token(parser)
< 	}
< 
< 	return true
< }
< 
< // Parse the productions:
< // explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
< //                                                    ***********
< //
< func yaml_parser_parse_document_content(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ == yaml_VERSION_DIRECTIVE_TOKEN ||
< 		token.typ == yaml_TAG_DIRECTIVE_TOKEN ||
< 		token.typ == yaml_DOCUMENT_START_TOKEN ||
< 		token.typ == yaml_DOCUMENT_END_TOKEN ||
< 		token.typ == yaml_STREAM_END_TOKEN {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 		return yaml_parser_process_empty_scalar(parser, event,
< 			token.start_mark)
< 	}
< 	return yaml_parser_parse_node(parser, event, true, false)
< }
< 
< // Parse the productions:
< // implicit_document    ::= block_node DOCUMENT-END*
< //                                     *************
< // explicit_document    ::= DIRECTIVE* DOCUMENT-START block_node? DOCUMENT-END*
< //
< func yaml_parser_parse_document_end(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	start_mark := token.start_mark
< 	end_mark := token.start_mark
< 
< 	implicit := true
< 	if token.typ == yaml_DOCUMENT_END_TOKEN {
< 		end_mark = token.end_mark
< 		skip_token(parser)
< 		implicit = false
< 	}
< 
< 	parser.tag_directives = parser.tag_directives[:0]
< 
< 	parser.state = yaml_PARSE_DOCUMENT_START_STATE
< 	*event = yaml_event_t{
< 		typ:        yaml_DOCUMENT_END_EVENT,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		implicit:   implicit,
< 	}
< 	yaml_parser_set_event_comments(parser, event)
< 	if len(event.head_comment) > 0 && len(event.foot_comment) == 0 {
< 		event.foot_comment = event.head_comment
< 		event.head_comment = nil
< 	}
< 	return true
< }
< 
< func yaml_parser_set_event_comments(parser *yaml_parser_t, event *yaml_event_t) {
< 	event.head_comment = parser.head_comment
< 	event.line_comment = parser.line_comment
< 	event.foot_comment = parser.foot_comment
< 	parser.head_comment = nil
< 	parser.line_comment = nil
< 	parser.foot_comment = nil
< 	parser.tail_comment = nil
< }
< 
< // Parse the productions:
< // block_node_or_indentless_sequence    ::=
< //                          ALIAS
< //                          *****
< //                          | properties (block_content | indentless_block_sequence)?
< //                            **********  *
< //                          | block_content | indentless_block_sequence
< //                            *
< // block_node           ::= ALIAS
< //                          *****
< //                          | properties block_content?
< //                            ********** *
< //                          | block_content
< //                            *
< // flow_node            ::= ALIAS
< //                          *****
< //                          | properties flow_content?
< //                            ********** *
< //                          | flow_content
< //                            *
< // properties           ::= TAG ANCHOR? | ANCHOR TAG?
< //                          *************************
< // block_content        ::= block_collection | flow_collection | SCALAR
< //                                                               ******
< // flow_content         ::= flow_collection | SCALAR
< //                                            ******
< func yaml_parser_parse_node(parser *yaml_parser_t, event *yaml_event_t, block, indentless_sequence bool) bool {
< 	//defer trace("yaml_parser_parse_node", "block:", block, "indentless_sequence:", indentless_sequence)()
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ == yaml_ALIAS_TOKEN {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 		*event = yaml_event_t{
< 			typ:        yaml_ALIAS_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 			anchor:     token.value,
< 		}
< 		yaml_parser_set_event_comments(parser, event)
< 		skip_token(parser)
< 		return true
< 	}
< 
< 	start_mark := token.start_mark
< 	end_mark := token.start_mark
< 
< 	var tag_token bool
< 	var tag_handle, tag_suffix, anchor []byte
< 	var tag_mark yaml_mark_t
< 	if token.typ == yaml_ANCHOR_TOKEN {
< 		anchor = token.value
< 		start_mark = token.start_mark
< 		end_mark = token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ == yaml_TAG_TOKEN {
< 			tag_token = true
< 			tag_handle = token.value
< 			tag_suffix = token.suffix
< 			tag_mark = token.start_mark
< 			end_mark = token.end_mark
< 			skip_token(parser)
< 			token = peek_token(parser)
< 			if token == nil {
< 				return false
< 			}
< 		}
< 	} else if token.typ == yaml_TAG_TOKEN {
< 		tag_token = true
< 		tag_handle = token.value
< 		tag_suffix = token.suffix
< 		start_mark = token.start_mark
< 		tag_mark = token.start_mark
< 		end_mark = token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ == yaml_ANCHOR_TOKEN {
< 			anchor = token.value
< 			end_mark = token.end_mark
< 			skip_token(parser)
< 			token = peek_token(parser)
< 			if token == nil {
< 				return false
< 			}
< 		}
< 	}
< 
< 	var tag []byte
< 	if tag_token {
< 		if len(tag_handle) == 0 {
< 			tag = tag_suffix
< 			tag_suffix = nil
< 		} else {
< 			for i := range parser.tag_directives {
< 				if bytes.Equal(parser.tag_directives[i].handle, tag_handle) {
< 					tag = append([]byte(nil), parser.tag_directives[i].prefix...)
< 					tag = append(tag, tag_suffix...)
< 					break
< 				}
< 			}
< 			if len(tag) == 0 {
< 				yaml_parser_set_parser_error_context(parser,
< 					"while parsing a node", start_mark,
< 					"found undefined tag handle", tag_mark)
< 				return false
< 			}
< 		}
< 	}
< 
< 	implicit := len(tag) == 0
< 	if indentless_sequence && token.typ == yaml_BLOCK_ENTRY_TOKEN {
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_SEQUENCE_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_BLOCK_SEQUENCE_STYLE),
< 		}
< 		return true
< 	}
< 	if token.typ == yaml_SCALAR_TOKEN {
< 		var plain_implicit, quoted_implicit bool
< 		end_mark = token.end_mark
< 		if (len(tag) == 0 && token.style == yaml_PLAIN_SCALAR_STYLE) || (len(tag) == 1 && tag[0] == '!') {
< 			plain_implicit = true
< 		} else if len(tag) == 0 {
< 			quoted_implicit = true
< 		}
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 
< 		*event = yaml_event_t{
< 			typ:             yaml_SCALAR_EVENT,
< 			start_mark:      start_mark,
< 			end_mark:        end_mark,
< 			anchor:          anchor,
< 			tag:             tag,
< 			value:           token.value,
< 			implicit:        plain_implicit,
< 			quoted_implicit: quoted_implicit,
< 			style:           yaml_style_t(token.style),
< 		}
< 		yaml_parser_set_event_comments(parser, event)
< 		skip_token(parser)
< 		return true
< 	}
< 	if token.typ == yaml_FLOW_SEQUENCE_START_TOKEN {
< 		// [Go] Some of the events below can be merged as they differ only on style.
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_SEQUENCE_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_FLOW_SEQUENCE_STYLE),
< 		}
< 		yaml_parser_set_event_comments(parser, event)
< 		return true
< 	}
< 	if token.typ == yaml_FLOW_MAPPING_START_TOKEN {
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_MAPPING_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_FLOW_MAPPING_STYLE),
< 		}
< 		yaml_parser_set_event_comments(parser, event)
< 		return true
< 	}
< 	if block && token.typ == yaml_BLOCK_SEQUENCE_START_TOKEN {
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_SEQUENCE_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_BLOCK_SEQUENCE_STYLE),
< 		}
< 		return true
< 	}
< 	if block && token.typ == yaml_BLOCK_MAPPING_START_TOKEN {
< 		end_mark = token.end_mark
< 		parser.state = yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE
< 		*event = yaml_event_t{
< 			typ:        yaml_MAPPING_START_EVENT,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			anchor:     anchor,
< 			tag:        tag,
< 			implicit:   implicit,
< 			style:      yaml_style_t(yaml_BLOCK_MAPPING_STYLE),
< 		}
< 		return true
< 	}
< 	if len(anchor) > 0 || len(tag) > 0 {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 
< 		*event = yaml_event_t{
< 			typ:             yaml_SCALAR_EVENT,
< 			start_mark:      start_mark,
< 			end_mark:        end_mark,
< 			anchor:          anchor,
< 			tag:             tag,
< 			implicit:        implicit,
< 			quoted_implicit: false,
< 			style:           yaml_style_t(yaml_PLAIN_SCALAR_STYLE),
< 		}
< 		return true
< 	}
< 
< 	context := "while parsing a flow node"
< 	if block {
< 		context = "while parsing a block node"
< 	}
< 	yaml_parser_set_parser_error_context(parser, context, start_mark,
< 		"did not find expected node content", token.start_mark)
< 	return false
< }
< 
< // Parse the productions:
< // block_sequence ::= BLOCK-SEQUENCE-START (BLOCK-ENTRY block_node?)* BLOCK-END
< //                    ********************  *********** *             *********
< //
< func yaml_parser_parse_block_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		token := peek_token(parser)
< 		parser.marks = append(parser.marks, token.start_mark)
< 		skip_token(parser)
< 	}
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ == yaml_BLOCK_ENTRY_TOKEN {
< 		mark := token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_BLOCK_ENTRY_TOKEN && token.typ != yaml_BLOCK_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE)
< 			return yaml_parser_parse_node(parser, event, true, false)
< 		} else {
< 			parser.state = yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE
< 			return yaml_parser_process_empty_scalar(parser, event, mark)
< 		}
< 	}
< 	if token.typ == yaml_BLOCK_END_TOKEN {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 		parser.marks = parser.marks[:len(parser.marks)-1]
< 
< 		*event = yaml_event_t{
< 			typ:        yaml_SEQUENCE_END_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 		}
< 
< 		skip_token(parser)
< 		return true
< 	}
< 
< 	context_mark := parser.marks[len(parser.marks)-1]
< 	parser.marks = parser.marks[:len(parser.marks)-1]
< 	return yaml_parser_set_parser_error_context(parser,
< 		"while parsing a block collection", context_mark,
< 		"did not find expected '-' indicator", token.start_mark)
< }
< 
< // Parse the productions:
< // indentless_sequence  ::= (BLOCK-ENTRY block_node?)+
< //                           *********** *
< func yaml_parser_parse_indentless_sequence_entry(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ == yaml_BLOCK_ENTRY_TOKEN {
< 		mark := token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_BLOCK_ENTRY_TOKEN &&
< 			token.typ != yaml_KEY_TOKEN &&
< 			token.typ != yaml_VALUE_TOKEN &&
< 			token.typ != yaml_BLOCK_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE)
< 			return yaml_parser_parse_node(parser, event, true, false)
< 		}
< 		parser.state = yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE
< 		return yaml_parser_process_empty_scalar(parser, event, mark)
< 	}
< 	parser.state = parser.states[len(parser.states)-1]
< 	parser.states = parser.states[:len(parser.states)-1]
< 
< 	*event = yaml_event_t{
< 		typ:        yaml_SEQUENCE_END_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.start_mark, // [Go] Shouldn't this be token.end_mark?
< 	}
< 	return true
< }
< 
< // Parse the productions:
< // block_mapping        ::= BLOCK-MAPPING_START
< //                          *******************
< //                          ((KEY block_node_or_indentless_sequence?)?
< //                            *** *
< //                          (VALUE block_node_or_indentless_sequence?)?)*
< //
< //                          BLOCK-END
< //                          *********
< //
< func yaml_parser_parse_block_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		token := peek_token(parser)
< 		parser.marks = append(parser.marks, token.start_mark)
< 		skip_token(parser)
< 	}
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	// [Go] A tail comment was left from the prior mapping value processed. Emit an event
< 	//      as it needs to be processed with that value and not the following key.
< 	if len(parser.tail_comment) > 0 {
< 		*event = yaml_event_t{
< 			typ:          yaml_TAIL_COMMENT_EVENT,
< 			start_mark:   token.start_mark,
< 			end_mark:     token.end_mark,
< 			foot_comment: parser.tail_comment,
< 		}
< 		parser.tail_comment = nil
< 		return true
< 	}
< 
< 	if token.typ == yaml_KEY_TOKEN {
< 		mark := token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_KEY_TOKEN &&
< 			token.typ != yaml_VALUE_TOKEN &&
< 			token.typ != yaml_BLOCK_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_BLOCK_MAPPING_VALUE_STATE)
< 			return yaml_parser_parse_node(parser, event, true, true)
< 		} else {
< 			parser.state = yaml_PARSE_BLOCK_MAPPING_VALUE_STATE
< 			return yaml_parser_process_empty_scalar(parser, event, mark)
< 		}
< 	} else if token.typ == yaml_BLOCK_END_TOKEN {
< 		parser.state = parser.states[len(parser.states)-1]
< 		parser.states = parser.states[:len(parser.states)-1]
< 		parser.marks = parser.marks[:len(parser.marks)-1]
< 		*event = yaml_event_t{
< 			typ:        yaml_MAPPING_END_EVENT,
< 			start_mark: token.start_mark,
< 			end_mark:   token.end_mark,
< 		}
< 		yaml_parser_set_event_comments(parser, event)
< 		skip_token(parser)
< 		return true
< 	}
< 
< 	context_mark := parser.marks[len(parser.marks)-1]
< 	parser.marks = parser.marks[:len(parser.marks)-1]
< 	return yaml_parser_set_parser_error_context(parser,
< 		"while parsing a block mapping", context_mark,
< 		"did not find expected key", token.start_mark)
< }
< 
< // Parse the productions:
< // block_mapping        ::= BLOCK-MAPPING_START
< //
< //                          ((KEY block_node_or_indentless_sequence?)?
< //
< //                          (VALUE block_node_or_indentless_sequence?)?)*
< //                           ***** *
< //                          BLOCK-END
< //
< //
< func yaml_parser_parse_block_mapping_value(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ == yaml_VALUE_TOKEN {
< 		mark := token.end_mark
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_KEY_TOKEN &&
< 			token.typ != yaml_VALUE_TOKEN &&
< 			token.typ != yaml_BLOCK_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_BLOCK_MAPPING_KEY_STATE)
< 			return yaml_parser_parse_node(parser, event, true, true)
< 		}
< 		parser.state = yaml_PARSE_BLOCK_MAPPING_KEY_STATE
< 		return yaml_parser_process_empty_scalar(parser, event, mark)
< 	}
< 	parser.state = yaml_PARSE_BLOCK_MAPPING_KEY_STATE
< 	return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< }
< 
< // Parse the productions:
< // flow_sequence        ::= FLOW-SEQUENCE-START
< //                          *******************
< //                          (flow_sequence_entry FLOW-ENTRY)*
< //                           *                   **********
< //                          flow_sequence_entry?
< //                          *
< //                          FLOW-SEQUENCE-END
< //                          *****************
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                          *
< //
< func yaml_parser_parse_flow_sequence_entry(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		token := peek_token(parser)
< 		parser.marks = append(parser.marks, token.start_mark)
< 		skip_token(parser)
< 	}
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
< 		if !first {
< 			if token.typ == yaml_FLOW_ENTRY_TOKEN {
< 				skip_token(parser)
< 				token = peek_token(parser)
< 				if token == nil {
< 					return false
< 				}
< 			} else {
< 				context_mark := parser.marks[len(parser.marks)-1]
< 				parser.marks = parser.marks[:len(parser.marks)-1]
< 				return yaml_parser_set_parser_error_context(parser,
< 					"while parsing a flow sequence", context_mark,
< 					"did not find expected ',' or ']'", token.start_mark)
< 			}
< 		}
< 
< 		if token.typ == yaml_KEY_TOKEN {
< 			parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE
< 			*event = yaml_event_t{
< 				typ:        yaml_MAPPING_START_EVENT,
< 				start_mark: token.start_mark,
< 				end_mark:   token.end_mark,
< 				implicit:   true,
< 				style:      yaml_style_t(yaml_FLOW_MAPPING_STYLE),
< 			}
< 			skip_token(parser)
< 			return true
< 		} else if token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE)
< 			return yaml_parser_parse_node(parser, event, false, false)
< 		}
< 	}
< 
< 	parser.state = parser.states[len(parser.states)-1]
< 	parser.states = parser.states[:len(parser.states)-1]
< 	parser.marks = parser.marks[:len(parser.marks)-1]
< 
< 	*event = yaml_event_t{
< 		typ:        yaml_SEQUENCE_END_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.end_mark,
< 	}
< 	yaml_parser_set_event_comments(parser, event)
< 
< 	skip_token(parser)
< 	return true
< }
< 
< //
< // Parse the productions:
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                                      *** *
< //
< func yaml_parser_parse_flow_sequence_entry_mapping_key(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ != yaml_VALUE_TOKEN &&
< 		token.typ != yaml_FLOW_ENTRY_TOKEN &&
< 		token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
< 		parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE)
< 		return yaml_parser_parse_node(parser, event, false, false)
< 	}
< 	mark := token.end_mark
< 	skip_token(parser)
< 	parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE
< 	return yaml_parser_process_empty_scalar(parser, event, mark)
< }
< 
< // Parse the productions:
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                                                      ***** *
< //
< func yaml_parser_parse_flow_sequence_entry_mapping_value(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if token.typ == yaml_VALUE_TOKEN {
< 		skip_token(parser)
< 		token := peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_FLOW_ENTRY_TOKEN && token.typ != yaml_FLOW_SEQUENCE_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE)
< 			return yaml_parser_parse_node(parser, event, false, false)
< 		}
< 	}
< 	parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE
< 	return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< }
< 
< // Parse the productions:
< // flow_sequence_entry  ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                                                                      *
< //
< func yaml_parser_parse_flow_sequence_entry_mapping_end(parser *yaml_parser_t, event *yaml_event_t) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	parser.state = yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE
< 	*event = yaml_event_t{
< 		typ:        yaml_MAPPING_END_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.start_mark, // [Go] Shouldn't this be end_mark?
< 	}
< 	return true
< }
< 
< // Parse the productions:
< // flow_mapping         ::= FLOW-MAPPING-START
< //                          ******************
< //                          (flow_mapping_entry FLOW-ENTRY)*
< //                           *                  **********
< //                          flow_mapping_entry?
< //                          ******************
< //                          FLOW-MAPPING-END
< //                          ****************
< // flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                          *           *** *
< //
< func yaml_parser_parse_flow_mapping_key(parser *yaml_parser_t, event *yaml_event_t, first bool) bool {
< 	if first {
< 		token := peek_token(parser)
< 		parser.marks = append(parser.marks, token.start_mark)
< 		skip_token(parser)
< 	}
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	if token.typ != yaml_FLOW_MAPPING_END_TOKEN {
< 		if !first {
< 			if token.typ == yaml_FLOW_ENTRY_TOKEN {
< 				skip_token(parser)
< 				token = peek_token(parser)
< 				if token == nil {
< 					return false
< 				}
< 			} else {
< 				context_mark := parser.marks[len(parser.marks)-1]
< 				parser.marks = parser.marks[:len(parser.marks)-1]
< 				return yaml_parser_set_parser_error_context(parser,
< 					"while parsing a flow mapping", context_mark,
< 					"did not find expected ',' or '}'", token.start_mark)
< 			}
< 		}
< 
< 		if token.typ == yaml_KEY_TOKEN {
< 			skip_token(parser)
< 			token = peek_token(parser)
< 			if token == nil {
< 				return false
< 			}
< 			if token.typ != yaml_VALUE_TOKEN &&
< 				token.typ != yaml_FLOW_ENTRY_TOKEN &&
< 				token.typ != yaml_FLOW_MAPPING_END_TOKEN {
< 				parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_VALUE_STATE)
< 				return yaml_parser_parse_node(parser, event, false, false)
< 			} else {
< 				parser.state = yaml_PARSE_FLOW_MAPPING_VALUE_STATE
< 				return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< 			}
< 		} else if token.typ != yaml_FLOW_MAPPING_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE)
< 			return yaml_parser_parse_node(parser, event, false, false)
< 		}
< 	}
< 
< 	parser.state = parser.states[len(parser.states)-1]
< 	parser.states = parser.states[:len(parser.states)-1]
< 	parser.marks = parser.marks[:len(parser.marks)-1]
< 	*event = yaml_event_t{
< 		typ:        yaml_MAPPING_END_EVENT,
< 		start_mark: token.start_mark,
< 		end_mark:   token.end_mark,
< 	}
< 	yaml_parser_set_event_comments(parser, event)
< 	skip_token(parser)
< 	return true
< }
< 
< // Parse the productions:
< // flow_mapping_entry   ::= flow_node | KEY flow_node? (VALUE flow_node?)?
< //                                   *                  ***** *
< //
< func yaml_parser_parse_flow_mapping_value(parser *yaml_parser_t, event *yaml_event_t, empty bool) bool {
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 	if empty {
< 		parser.state = yaml_PARSE_FLOW_MAPPING_KEY_STATE
< 		return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< 	}
< 	if token.typ == yaml_VALUE_TOKEN {
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 		if token.typ != yaml_FLOW_ENTRY_TOKEN && token.typ != yaml_FLOW_MAPPING_END_TOKEN {
< 			parser.states = append(parser.states, yaml_PARSE_FLOW_MAPPING_KEY_STATE)
< 			return yaml_parser_parse_node(parser, event, false, false)
< 		}
< 	}
< 	parser.state = yaml_PARSE_FLOW_MAPPING_KEY_STATE
< 	return yaml_parser_process_empty_scalar(parser, event, token.start_mark)
< }
< 
< // Generate an empty scalar event.
< func yaml_parser_process_empty_scalar(parser *yaml_parser_t, event *yaml_event_t, mark yaml_mark_t) bool {
< 	*event = yaml_event_t{
< 		typ:        yaml_SCALAR_EVENT,
< 		start_mark: mark,
< 		end_mark:   mark,
< 		value:      nil, // Empty
< 		implicit:   true,
< 		style:      yaml_style_t(yaml_PLAIN_SCALAR_STYLE),
< 	}
< 	return true
< }
< 
< var default_tag_directives = []yaml_tag_directive_t{
< 	{[]byte("!"), []byte("!")},
< 	{[]byte("!!"), []byte("tag:yaml.org,2002:")},
< }
< 
< // Parse directives.
< func yaml_parser_process_directives(parser *yaml_parser_t,
< 	version_directive_ref **yaml_version_directive_t,
< 	tag_directives_ref *[]yaml_tag_directive_t) bool {
< 
< 	var version_directive *yaml_version_directive_t
< 	var tag_directives []yaml_tag_directive_t
< 
< 	token := peek_token(parser)
< 	if token == nil {
< 		return false
< 	}
< 
< 	for token.typ == yaml_VERSION_DIRECTIVE_TOKEN || token.typ == yaml_TAG_DIRECTIVE_TOKEN {
< 		if token.typ == yaml_VERSION_DIRECTIVE_TOKEN {
< 			if version_directive != nil {
< 				yaml_parser_set_parser_error(parser,
< 					"found duplicate %YAML directive", token.start_mark)
< 				return false
< 			}
< 			if token.major != 1 || token.minor != 1 {
< 				yaml_parser_set_parser_error(parser,
< 					"found incompatible YAML document", token.start_mark)
< 				return false
< 			}
< 			version_directive = &yaml_version_directive_t{
< 				major: token.major,
< 				minor: token.minor,
< 			}
< 		} else if token.typ == yaml_TAG_DIRECTIVE_TOKEN {
< 			value := yaml_tag_directive_t{
< 				handle: token.value,
< 				prefix: token.prefix,
< 			}
< 			if !yaml_parser_append_tag_directive(parser, value, false, token.start_mark) {
< 				return false
< 			}
< 			tag_directives = append(tag_directives, value)
< 		}
< 
< 		skip_token(parser)
< 		token = peek_token(parser)
< 		if token == nil {
< 			return false
< 		}
< 	}
< 
< 	for i := range default_tag_directives {
< 		if !yaml_parser_append_tag_directive(parser, default_tag_directives[i], true, token.start_mark) {
< 			return false
< 		}
< 	}
< 
< 	if version_directive_ref != nil {
< 		*version_directive_ref = version_directive
< 	}
< 	if tag_directives_ref != nil {
< 		*tag_directives_ref = tag_directives
< 	}
< 	return true
< }
< 
< // Append a tag directive to the directives stack.
< func yaml_parser_append_tag_directive(parser *yaml_parser_t, value yaml_tag_directive_t, allow_duplicates bool, mark yaml_mark_t) bool {
< 	for i := range parser.tag_directives {
< 		if bytes.Equal(value.handle, parser.tag_directives[i].handle) {
< 			if allow_duplicates {
< 				return true
< 			}
< 			return yaml_parser_set_parser_error(parser, "found duplicate %TAG directive", mark)
< 		}
< 	}
< 
< 	// [Go] I suspect the copy is unnecessary. This was likely done
< 	// because there was no way to track ownership of the data.
< 	value_copy := yaml_tag_directive_t{
< 		handle: make([]byte, len(value.handle)),
< 		prefix: make([]byte, len(value.prefix)),
< 	}
< 	copy(value_copy.handle, value.handle)
< 	copy(value_copy.prefix, value.prefix)
< 	parser.tag_directives = append(parser.tag_directives, value_copy)
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/readerc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/readerc.go
1,434d0
< // 
< // Copyright (c) 2011-2019 Canonical Ltd
< // Copyright (c) 2006-2010 Kirill Simonov
< // 
< // Permission is hereby granted, free of charge, to any person obtaining a copy of
< // this software and associated documentation files (the "Software"), to deal in
< // the Software without restriction, including without limitation the rights to
< // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< // of the Software, and to permit persons to whom the Software is furnished to do
< // so, subject to the following conditions:
< // 
< // The above copyright notice and this permission notice shall be included in all
< // copies or substantial portions of the Software.
< // 
< // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< // SOFTWARE.
< 
< package yaml
< 
< import (
< 	"io"
< )
< 
< // Set the reader error and return 0.
< func yaml_parser_set_reader_error(parser *yaml_parser_t, problem string, offset int, value int) bool {
< 	parser.error = yaml_READER_ERROR
< 	parser.problem = problem
< 	parser.problem_offset = offset
< 	parser.problem_value = value
< 	return false
< }
< 
< // Byte order marks.
< const (
< 	bom_UTF8    = "\xef\xbb\xbf"
< 	bom_UTF16LE = "\xff\xfe"
< 	bom_UTF16BE = "\xfe\xff"
< )
< 
< // Determine the input stream encoding by checking the BOM symbol. If no BOM is
< // found, the UTF-8 encoding is assumed. Return 1 on success, 0 on failure.
< func yaml_parser_determine_encoding(parser *yaml_parser_t) bool {
< 	// Ensure that we had enough bytes in the raw buffer.
< 	for !parser.eof && len(parser.raw_buffer)-parser.raw_buffer_pos < 3 {
< 		if !yaml_parser_update_raw_buffer(parser) {
< 			return false
< 		}
< 	}
< 
< 	// Determine the encoding.
< 	buf := parser.raw_buffer
< 	pos := parser.raw_buffer_pos
< 	avail := len(buf) - pos
< 	if avail >= 2 && buf[pos] == bom_UTF16LE[0] && buf[pos+1] == bom_UTF16LE[1] {
< 		parser.encoding = yaml_UTF16LE_ENCODING
< 		parser.raw_buffer_pos += 2
< 		parser.offset += 2
< 	} else if avail >= 2 && buf[pos] == bom_UTF16BE[0] && buf[pos+1] == bom_UTF16BE[1] {
< 		parser.encoding = yaml_UTF16BE_ENCODING
< 		parser.raw_buffer_pos += 2
< 		parser.offset += 2
< 	} else if avail >= 3 && buf[pos] == bom_UTF8[0] && buf[pos+1] == bom_UTF8[1] && buf[pos+2] == bom_UTF8[2] {
< 		parser.encoding = yaml_UTF8_ENCODING
< 		parser.raw_buffer_pos += 3
< 		parser.offset += 3
< 	} else {
< 		parser.encoding = yaml_UTF8_ENCODING
< 	}
< 	return true
< }
< 
< // Update the raw buffer.
< func yaml_parser_update_raw_buffer(parser *yaml_parser_t) bool {
< 	size_read := 0
< 
< 	// Return if the raw buffer is full.
< 	if parser.raw_buffer_pos == 0 && len(parser.raw_buffer) == cap(parser.raw_buffer) {
< 		return true
< 	}
< 
< 	// Return on EOF.
< 	if parser.eof {
< 		return true
< 	}
< 
< 	// Move the remaining bytes in the raw buffer to the beginning.
< 	if parser.raw_buffer_pos > 0 && parser.raw_buffer_pos < len(parser.raw_buffer) {
< 		copy(parser.raw_buffer, parser.raw_buffer[parser.raw_buffer_pos:])
< 	}
< 	parser.raw_buffer = parser.raw_buffer[:len(parser.raw_buffer)-parser.raw_buffer_pos]
< 	parser.raw_buffer_pos = 0
< 
< 	// Call the read handler to fill the buffer.
< 	size_read, err := parser.read_handler(parser, parser.raw_buffer[len(parser.raw_buffer):cap(parser.raw_buffer)])
< 	parser.raw_buffer = parser.raw_buffer[:len(parser.raw_buffer)+size_read]
< 	if err == io.EOF {
< 		parser.eof = true
< 	} else if err != nil {
< 		return yaml_parser_set_reader_error(parser, "input error: "+err.Error(), parser.offset, -1)
< 	}
< 	return true
< }
< 
< // Ensure that the buffer contains at least `length` characters.
< // Return true on success, false on failure.
< //
< // The length is supposed to be significantly less that the buffer size.
< func yaml_parser_update_buffer(parser *yaml_parser_t, length int) bool {
< 	if parser.read_handler == nil {
< 		panic("read handler must be set")
< 	}
< 
< 	// [Go] This function was changed to guarantee the requested length size at EOF.
< 	// The fact we need to do this is pretty awful, but the description above implies
< 	// for that to be the case, and there are tests
< 
< 	// If the EOF flag is set and the raw buffer is empty, do nothing.
< 	if parser.eof && parser.raw_buffer_pos == len(parser.raw_buffer) {
< 		// [Go] ACTUALLY! Read the documentation of this function above.
< 		// This is just broken. To return true, we need to have the
< 		// given length in the buffer. Not doing that means every single
< 		// check that calls this function to make sure the buffer has a
< 		// given length is Go) panicking; or C) accessing invalid memory.
< 		//return true
< 	}
< 
< 	// Return if the buffer contains enough characters.
< 	if parser.unread >= length {
< 		return true
< 	}
< 
< 	// Determine the input encoding if it is not known yet.
< 	if parser.encoding == yaml_ANY_ENCODING {
< 		if !yaml_parser_determine_encoding(parser) {
< 			return false
< 		}
< 	}
< 
< 	// Move the unread characters to the beginning of the buffer.
< 	buffer_len := len(parser.buffer)
< 	if parser.buffer_pos > 0 && parser.buffer_pos < buffer_len {
< 		copy(parser.buffer, parser.buffer[parser.buffer_pos:])
< 		buffer_len -= parser.buffer_pos
< 		parser.buffer_pos = 0
< 	} else if parser.buffer_pos == buffer_len {
< 		buffer_len = 0
< 		parser.buffer_pos = 0
< 	}
< 
< 	// Open the whole buffer for writing, and cut it before returning.
< 	parser.buffer = parser.buffer[:cap(parser.buffer)]
< 
< 	// Fill the buffer until it has enough characters.
< 	first := true
< 	for parser.unread < length {
< 
< 		// Fill the raw buffer if necessary.
< 		if !first || parser.raw_buffer_pos == len(parser.raw_buffer) {
< 			if !yaml_parser_update_raw_buffer(parser) {
< 				parser.buffer = parser.buffer[:buffer_len]
< 				return false
< 			}
< 		}
< 		first = false
< 
< 		// Decode the raw buffer.
< 	inner:
< 		for parser.raw_buffer_pos != len(parser.raw_buffer) {
< 			var value rune
< 			var width int
< 
< 			raw_unread := len(parser.raw_buffer) - parser.raw_buffer_pos
< 
< 			// Decode the next character.
< 			switch parser.encoding {
< 			case yaml_UTF8_ENCODING:
< 				// Decode a UTF-8 character.  Check RFC 3629
< 				// (http://www.ietf.org/rfc/rfc3629.txt) for more details.
< 				//
< 				// The following table (taken from the RFC) is used for
< 				// decoding.
< 				//
< 				//    Char. number range |        UTF-8 octet sequence
< 				//      (hexadecimal)    |              (binary)
< 				//   --------------------+------------------------------------
< 				//   0000 0000-0000 007F | 0xxxxxxx
< 				//   0000 0080-0000 07FF | 110xxxxx 10xxxxxx
< 				//   0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
< 				//   0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
< 				//
< 				// Additionally, the characters in the range 0xD800-0xDFFF
< 				// are prohibited as they are reserved for use with UTF-16
< 				// surrogate pairs.
< 
< 				// Determine the length of the UTF-8 sequence.
< 				octet := parser.raw_buffer[parser.raw_buffer_pos]
< 				switch {
< 				case octet&0x80 == 0x00:
< 					width = 1
< 				case octet&0xE0 == 0xC0:
< 					width = 2
< 				case octet&0xF0 == 0xE0:
< 					width = 3
< 				case octet&0xF8 == 0xF0:
< 					width = 4
< 				default:
< 					// The leading octet is invalid.
< 					return yaml_parser_set_reader_error(parser,
< 						"invalid leading UTF-8 octet",
< 						parser.offset, int(octet))
< 				}
< 
< 				// Check if the raw buffer contains an incomplete character.
< 				if width > raw_unread {
< 					if parser.eof {
< 						return yaml_parser_set_reader_error(parser,
< 							"incomplete UTF-8 octet sequence",
< 							parser.offset, -1)
< 					}
< 					break inner
< 				}
< 
< 				// Decode the leading octet.
< 				switch {
< 				case octet&0x80 == 0x00:
< 					value = rune(octet & 0x7F)
< 				case octet&0xE0 == 0xC0:
< 					value = rune(octet & 0x1F)
< 				case octet&0xF0 == 0xE0:
< 					value = rune(octet & 0x0F)
< 				case octet&0xF8 == 0xF0:
< 					value = rune(octet & 0x07)
< 				default:
< 					value = 0
< 				}
< 
< 				// Check and decode the trailing octets.
< 				for k := 1; k < width; k++ {
< 					octet = parser.raw_buffer[parser.raw_buffer_pos+k]
< 
< 					// Check if the octet is valid.
< 					if (octet & 0xC0) != 0x80 {
< 						return yaml_parser_set_reader_error(parser,
< 							"invalid trailing UTF-8 octet",
< 							parser.offset+k, int(octet))
< 					}
< 
< 					// Decode the octet.
< 					value = (value << 6) + rune(octet&0x3F)
< 				}
< 
< 				// Check the length of the sequence against the value.
< 				switch {
< 				case width == 1:
< 				case width == 2 && value >= 0x80:
< 				case width == 3 && value >= 0x800:
< 				case width == 4 && value >= 0x10000:
< 				default:
< 					return yaml_parser_set_reader_error(parser,
< 						"invalid length of a UTF-8 sequence",
< 						parser.offset, -1)
< 				}
< 
< 				// Check the range of the value.
< 				if value >= 0xD800 && value <= 0xDFFF || value > 0x10FFFF {
< 					return yaml_parser_set_reader_error(parser,
< 						"invalid Unicode character",
< 						parser.offset, int(value))
< 				}
< 
< 			case yaml_UTF16LE_ENCODING, yaml_UTF16BE_ENCODING:
< 				var low, high int
< 				if parser.encoding == yaml_UTF16LE_ENCODING {
< 					low, high = 0, 1
< 				} else {
< 					low, high = 1, 0
< 				}
< 
< 				// The UTF-16 encoding is not as simple as one might
< 				// naively think.  Check RFC 2781
< 				// (http://www.ietf.org/rfc/rfc2781.txt).
< 				//
< 				// Normally, two subsequent bytes describe a Unicode
< 				// character.  However a special technique (called a
< 				// surrogate pair) is used for specifying character
< 				// values larger than 0xFFFF.
< 				//
< 				// A surrogate pair consists of two pseudo-characters:
< 				//      high surrogate area (0xD800-0xDBFF)
< 				//      low surrogate area (0xDC00-0xDFFF)
< 				//
< 				// The following formulas are used for decoding
< 				// and encoding characters using surrogate pairs:
< 				//
< 				//  U  = U' + 0x10000   (0x01 00 00 <= U <= 0x10 FF FF)
< 				//  U' = yyyyyyyyyyxxxxxxxxxx   (0 <= U' <= 0x0F FF FF)
< 				//  W1 = 110110yyyyyyyyyy
< 				//  W2 = 110111xxxxxxxxxx
< 				//
< 				// where U is the character value, W1 is the high surrogate
< 				// area, W2 is the low surrogate area.
< 
< 				// Check for incomplete UTF-16 character.
< 				if raw_unread < 2 {
< 					if parser.eof {
< 						return yaml_parser_set_reader_error(parser,
< 							"incomplete UTF-16 character",
< 							parser.offset, -1)
< 					}
< 					break inner
< 				}
< 
< 				// Get the character.
< 				value = rune(parser.raw_buffer[parser.raw_buffer_pos+low]) +
< 					(rune(parser.raw_buffer[parser.raw_buffer_pos+high]) << 8)
< 
< 				// Check for unexpected low surrogate area.
< 				if value&0xFC00 == 0xDC00 {
< 					return yaml_parser_set_reader_error(parser,
< 						"unexpected low surrogate area",
< 						parser.offset, int(value))
< 				}
< 
< 				// Check for a high surrogate area.
< 				if value&0xFC00 == 0xD800 {
< 					width = 4
< 
< 					// Check for incomplete surrogate pair.
< 					if raw_unread < 4 {
< 						if parser.eof {
< 							return yaml_parser_set_reader_error(parser,
< 								"incomplete UTF-16 surrogate pair",
< 								parser.offset, -1)
< 						}
< 						break inner
< 					}
< 
< 					// Get the next character.
< 					value2 := rune(parser.raw_buffer[parser.raw_buffer_pos+low+2]) +
< 						(rune(parser.raw_buffer[parser.raw_buffer_pos+high+2]) << 8)
< 
< 					// Check for a low surrogate area.
< 					if value2&0xFC00 != 0xDC00 {
< 						return yaml_parser_set_reader_error(parser,
< 							"expected low surrogate area",
< 							parser.offset+2, int(value2))
< 					}
< 
< 					// Generate the value of the surrogate pair.
< 					value = 0x10000 + ((value & 0x3FF) << 10) + (value2 & 0x3FF)
< 				} else {
< 					width = 2
< 				}
< 
< 			default:
< 				panic("impossible")
< 			}
< 
< 			// Check if the character is in the allowed range:
< 			//      #x9 | #xA | #xD | [#x20-#x7E]               (8 bit)
< 			//      | #x85 | [#xA0-#xD7FF] | [#xE000-#xFFFD]    (16 bit)
< 			//      | [#x10000-#x10FFFF]                        (32 bit)
< 			switch {
< 			case value == 0x09:
< 			case value == 0x0A:
< 			case value == 0x0D:
< 			case value >= 0x20 && value <= 0x7E:
< 			case value == 0x85:
< 			case value >= 0xA0 && value <= 0xD7FF:
< 			case value >= 0xE000 && value <= 0xFFFD:
< 			case value >= 0x10000 && value <= 0x10FFFF:
< 			default:
< 				return yaml_parser_set_reader_error(parser,
< 					"control characters are not allowed",
< 					parser.offset, int(value))
< 			}
< 
< 			// Move the raw pointers.
< 			parser.raw_buffer_pos += width
< 			parser.offset += width
< 
< 			// Finally put the character into the buffer.
< 			if value <= 0x7F {
< 				// 0000 0000-0000 007F . 0xxxxxxx
< 				parser.buffer[buffer_len+0] = byte(value)
< 				buffer_len += 1
< 			} else if value <= 0x7FF {
< 				// 0000 0080-0000 07FF . 110xxxxx 10xxxxxx
< 				parser.buffer[buffer_len+0] = byte(0xC0 + (value >> 6))
< 				parser.buffer[buffer_len+1] = byte(0x80 + (value & 0x3F))
< 				buffer_len += 2
< 			} else if value <= 0xFFFF {
< 				// 0000 0800-0000 FFFF . 1110xxxx 10xxxxxx 10xxxxxx
< 				parser.buffer[buffer_len+0] = byte(0xE0 + (value >> 12))
< 				parser.buffer[buffer_len+1] = byte(0x80 + ((value >> 6) & 0x3F))
< 				parser.buffer[buffer_len+2] = byte(0x80 + (value & 0x3F))
< 				buffer_len += 3
< 			} else {
< 				// 0001 0000-0010 FFFF . 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
< 				parser.buffer[buffer_len+0] = byte(0xF0 + (value >> 18))
< 				parser.buffer[buffer_len+1] = byte(0x80 + ((value >> 12) & 0x3F))
< 				parser.buffer[buffer_len+2] = byte(0x80 + ((value >> 6) & 0x3F))
< 				parser.buffer[buffer_len+3] = byte(0x80 + (value & 0x3F))
< 				buffer_len += 4
< 			}
< 
< 			parser.unread++
< 		}
< 
< 		// On EOF, put NUL into the buffer and return.
< 		if parser.eof {
< 			parser.buffer[buffer_len] = 0
< 			buffer_len++
< 			parser.unread++
< 			break
< 		}
< 	}
< 	// [Go] Read the documentation of this function above. To return true,
< 	// we need to have the given length in the buffer. Not doing that means
< 	// every single check that calls this function to make sure the buffer
< 	// has a given length is Go) panicking; or C) accessing invalid memory.
< 	// This happens here due to the EOF above breaking early.
< 	for buffer_len < length {
< 		parser.buffer[buffer_len] = 0
< 		buffer_len++
< 	}
< 	parser.buffer = parser.buffer[:buffer_len]
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/resolve.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/resolve.go
1,326d0
< //
< // Copyright (c) 2011-2019 Canonical Ltd
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package yaml
< 
< import (
< 	"encoding/base64"
< 	"math"
< 	"regexp"
< 	"strconv"
< 	"strings"
< 	"time"
< )
< 
< type resolveMapItem struct {
< 	value interface{}
< 	tag   string
< }
< 
< var resolveTable = make([]byte, 256)
< var resolveMap = make(map[string]resolveMapItem)
< 
< func init() {
< 	t := resolveTable
< 	t[int('+')] = 'S' // Sign
< 	t[int('-')] = 'S'
< 	for _, c := range "0123456789" {
< 		t[int(c)] = 'D' // Digit
< 	}
< 	for _, c := range "yYnNtTfFoO~" {
< 		t[int(c)] = 'M' // In map
< 	}
< 	t[int('.')] = '.' // Float (potentially in map)
< 
< 	var resolveMapList = []struct {
< 		v   interface{}
< 		tag string
< 		l   []string
< 	}{
< 		{true, boolTag, []string{"true", "True", "TRUE"}},
< 		{false, boolTag, []string{"false", "False", "FALSE"}},
< 		{nil, nullTag, []string{"", "~", "null", "Null", "NULL"}},
< 		{math.NaN(), floatTag, []string{".nan", ".NaN", ".NAN"}},
< 		{math.Inf(+1), floatTag, []string{".inf", ".Inf", ".INF"}},
< 		{math.Inf(+1), floatTag, []string{"+.inf", "+.Inf", "+.INF"}},
< 		{math.Inf(-1), floatTag, []string{"-.inf", "-.Inf", "-.INF"}},
< 		{"<<", mergeTag, []string{"<<"}},
< 	}
< 
< 	m := resolveMap
< 	for _, item := range resolveMapList {
< 		for _, s := range item.l {
< 			m[s] = resolveMapItem{item.v, item.tag}
< 		}
< 	}
< }
< 
< const (
< 	nullTag      = "!!null"
< 	boolTag      = "!!bool"
< 	strTag       = "!!str"
< 	intTag       = "!!int"
< 	floatTag     = "!!float"
< 	timestampTag = "!!timestamp"
< 	seqTag       = "!!seq"
< 	mapTag       = "!!map"
< 	binaryTag    = "!!binary"
< 	mergeTag     = "!!merge"
< )
< 
< var longTags = make(map[string]string)
< var shortTags = make(map[string]string)
< 
< func init() {
< 	for _, stag := range []string{nullTag, boolTag, strTag, intTag, floatTag, timestampTag, seqTag, mapTag, binaryTag, mergeTag} {
< 		ltag := longTag(stag)
< 		longTags[stag] = ltag
< 		shortTags[ltag] = stag
< 	}
< }
< 
< const longTagPrefix = "tag:yaml.org,2002:"
< 
< func shortTag(tag string) string {
< 	if strings.HasPrefix(tag, longTagPrefix) {
< 		if stag, ok := shortTags[tag]; ok {
< 			return stag
< 		}
< 		return "!!" + tag[len(longTagPrefix):]
< 	}
< 	return tag
< }
< 
< func longTag(tag string) string {
< 	if strings.HasPrefix(tag, "!!") {
< 		if ltag, ok := longTags[tag]; ok {
< 			return ltag
< 		}
< 		return longTagPrefix + tag[2:]
< 	}
< 	return tag
< }
< 
< func resolvableTag(tag string) bool {
< 	switch tag {
< 	case "", strTag, boolTag, intTag, floatTag, nullTag, timestampTag:
< 		return true
< 	}
< 	return false
< }
< 
< var yamlStyleFloat = regexp.MustCompile(`^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$`)
< 
< func resolve(tag string, in string) (rtag string, out interface{}) {
< 	tag = shortTag(tag)
< 	if !resolvableTag(tag) {
< 		return tag, in
< 	}
< 
< 	defer func() {
< 		switch tag {
< 		case "", rtag, strTag, binaryTag:
< 			return
< 		case floatTag:
< 			if rtag == intTag {
< 				switch v := out.(type) {
< 				case int64:
< 					rtag = floatTag
< 					out = float64(v)
< 					return
< 				case int:
< 					rtag = floatTag
< 					out = float64(v)
< 					return
< 				}
< 			}
< 		}
< 		failf("cannot decode %s `%s` as a %s", shortTag(rtag), in, shortTag(tag))
< 	}()
< 
< 	// Any data is accepted as a !!str or !!binary.
< 	// Otherwise, the prefix is enough of a hint about what it might be.
< 	hint := byte('N')
< 	if in != "" {
< 		hint = resolveTable[in[0]]
< 	}
< 	if hint != 0 && tag != strTag && tag != binaryTag {
< 		// Handle things we can lookup in a map.
< 		if item, ok := resolveMap[in]; ok {
< 			return item.tag, item.value
< 		}
< 
< 		// Base 60 floats are a bad idea, were dropped in YAML 1.2, and
< 		// are purposefully unsupported here. They're still quoted on
< 		// the way out for compatibility with other parser, though.
< 
< 		switch hint {
< 		case 'M':
< 			// We've already checked the map above.
< 
< 		case '.':
< 			// Not in the map, so maybe a normal float.
< 			floatv, err := strconv.ParseFloat(in, 64)
< 			if err == nil {
< 				return floatTag, floatv
< 			}
< 
< 		case 'D', 'S':
< 			// Int, float, or timestamp.
< 			// Only try values as a timestamp if the value is unquoted or there's an explicit
< 			// !!timestamp tag.
< 			if tag == "" || tag == timestampTag {
< 				t, ok := parseTimestamp(in)
< 				if ok {
< 					return timestampTag, t
< 				}
< 			}
< 
< 			plain := strings.Replace(in, "_", "", -1)
< 			intv, err := strconv.ParseInt(plain, 0, 64)
< 			if err == nil {
< 				if intv == int64(int(intv)) {
< 					return intTag, int(intv)
< 				} else {
< 					return intTag, intv
< 				}
< 			}
< 			uintv, err := strconv.ParseUint(plain, 0, 64)
< 			if err == nil {
< 				return intTag, uintv
< 			}
< 			if yamlStyleFloat.MatchString(plain) {
< 				floatv, err := strconv.ParseFloat(plain, 64)
< 				if err == nil {
< 					return floatTag, floatv
< 				}
< 			}
< 			if strings.HasPrefix(plain, "0b") {
< 				intv, err := strconv.ParseInt(plain[2:], 2, 64)
< 				if err == nil {
< 					if intv == int64(int(intv)) {
< 						return intTag, int(intv)
< 					} else {
< 						return intTag, intv
< 					}
< 				}
< 				uintv, err := strconv.ParseUint(plain[2:], 2, 64)
< 				if err == nil {
< 					return intTag, uintv
< 				}
< 			} else if strings.HasPrefix(plain, "-0b") {
< 				intv, err := strconv.ParseInt("-"+plain[3:], 2, 64)
< 				if err == nil {
< 					if true || intv == int64(int(intv)) {
< 						return intTag, int(intv)
< 					} else {
< 						return intTag, intv
< 					}
< 				}
< 			}
< 			// Octals as introduced in version 1.2 of the spec.
< 			// Octals from the 1.1 spec, spelled as 0777, are still
< 			// decoded by default in v3 as well for compatibility.
< 			// May be dropped in v4 depending on how usage evolves.
< 			if strings.HasPrefix(plain, "0o") {
< 				intv, err := strconv.ParseInt(plain[2:], 8, 64)
< 				if err == nil {
< 					if intv == int64(int(intv)) {
< 						return intTag, int(intv)
< 					} else {
< 						return intTag, intv
< 					}
< 				}
< 				uintv, err := strconv.ParseUint(plain[2:], 8, 64)
< 				if err == nil {
< 					return intTag, uintv
< 				}
< 			} else if strings.HasPrefix(plain, "-0o") {
< 				intv, err := strconv.ParseInt("-"+plain[3:], 8, 64)
< 				if err == nil {
< 					if true || intv == int64(int(intv)) {
< 						return intTag, int(intv)
< 					} else {
< 						return intTag, intv
< 					}
< 				}
< 			}
< 		default:
< 			panic("internal error: missing handler for resolver table: " + string(rune(hint)) + " (with " + in + ")")
< 		}
< 	}
< 	return strTag, in
< }
< 
< // encodeBase64 encodes s as base64 that is broken up into multiple lines
< // as appropriate for the resulting length.
< func encodeBase64(s string) string {
< 	const lineLen = 70
< 	encLen := base64.StdEncoding.EncodedLen(len(s))
< 	lines := encLen/lineLen + 1
< 	buf := make([]byte, encLen*2+lines)
< 	in := buf[0:encLen]
< 	out := buf[encLen:]
< 	base64.StdEncoding.Encode(in, []byte(s))
< 	k := 0
< 	for i := 0; i < len(in); i += lineLen {
< 		j := i + lineLen
< 		if j > len(in) {
< 			j = len(in)
< 		}
< 		k += copy(out[k:], in[i:j])
< 		if lines > 1 {
< 			out[k] = '\n'
< 			k++
< 		}
< 	}
< 	return string(out[:k])
< }
< 
< // This is a subset of the formats allowed by the regular expression
< // defined at http://yaml.org/type/timestamp.html.
< var allowedTimestampFormats = []string{
< 	"2006-1-2T15:4:5.999999999Z07:00", // RCF3339Nano with short date fields.
< 	"2006-1-2t15:4:5.999999999Z07:00", // RFC3339Nano with short date fields and lower-case "t".
< 	"2006-1-2 15:4:5.999999999",       // space separated with no time zone
< 	"2006-1-2",                        // date only
< 	// Notable exception: time.Parse cannot handle: "2001-12-14 21:59:43.10 -5"
< 	// from the set of examples.
< }
< 
< // parseTimestamp parses s as a timestamp string and
< // returns the timestamp and reports whether it succeeded.
< // Timestamp formats are defined at http://yaml.org/type/timestamp.html
< func parseTimestamp(s string) (time.Time, bool) {
< 	// TODO write code to check all the formats supported by
< 	// http://yaml.org/type/timestamp.html instead of using time.Parse.
< 
< 	// Quick check: all date formats start with YYYY-.
< 	i := 0
< 	for ; i < len(s); i++ {
< 		if c := s[i]; c < '0' || c > '9' {
< 			break
< 		}
< 	}
< 	if i != 4 || i == len(s) || s[i] != '-' {
< 		return time.Time{}, false
< 	}
< 	for _, format := range allowedTimestampFormats {
< 		if t, err := time.Parse(format, s); err == nil {
< 			return t, true
< 		}
< 	}
< 	return time.Time{}, false
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/scannerc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/scannerc.go
1,2990d0
< //
< // Copyright (c) 2011-2019 Canonical Ltd
< // Copyright (c) 2006-2010 Kirill Simonov
< //
< // Permission is hereby granted, free of charge, to any person obtaining a copy of
< // this software and associated documentation files (the "Software"), to deal in
< // the Software without restriction, including without limitation the rights to
< // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< // of the Software, and to permit persons to whom the Software is furnished to do
< // so, subject to the following conditions:
< //
< // The above copyright notice and this permission notice shall be included in all
< // copies or substantial portions of the Software.
< //
< // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< // SOFTWARE.
< 
< package yaml
< 
< import (
< 	"bytes"
< 	"fmt"
< )
< 
< // Introduction
< // ************
< //
< // The following notes assume that you are familiar with the YAML specification
< // (http://yaml.org/spec/1.2/spec.html).  We mostly follow it, although in
< // some cases we are less restrictive that it requires.
< //
< // The process of transforming a YAML stream into a sequence of events is
< // divided on two steps: Scanning and Parsing.
< //
< // The Scanner transforms the input stream into a sequence of tokens, while the
< // parser transform the sequence of tokens produced by the Scanner into a
< // sequence of parsing events.
< //
< // The Scanner is rather clever and complicated. The Parser, on the contrary,
< // is a straightforward implementation of a recursive-descendant parser (or,
< // LL(1) parser, as it is usually called).
< //
< // Actually there are two issues of Scanning that might be called "clever", the
< // rest is quite straightforward.  The issues are "block collection start" and
< // "simple keys".  Both issues are explained below in details.
< //
< // Here the Scanning step is explained and implemented.  We start with the list
< // of all the tokens produced by the Scanner together with short descriptions.
< //
< // Now, tokens:
< //
< //      STREAM-START(encoding)          # The stream start.
< //      STREAM-END                      # The stream end.
< //      VERSION-DIRECTIVE(major,minor)  # The '%YAML' directive.
< //      TAG-DIRECTIVE(handle,prefix)    # The '%TAG' directive.
< //      DOCUMENT-START                  # '---'
< //      DOCUMENT-END                    # '...'
< //      BLOCK-SEQUENCE-START            # Indentation increase denoting a block
< //      BLOCK-MAPPING-START             # sequence or a block mapping.
< //      BLOCK-END                       # Indentation decrease.
< //      FLOW-SEQUENCE-START             # '['
< //      FLOW-SEQUENCE-END               # ']'
< //      BLOCK-SEQUENCE-START            # '{'
< //      BLOCK-SEQUENCE-END              # '}'
< //      BLOCK-ENTRY                     # '-'
< //      FLOW-ENTRY                      # ','
< //      KEY                             # '?' or nothing (simple keys).
< //      VALUE                           # ':'
< //      ALIAS(anchor)                   # '*anchor'
< //      ANCHOR(anchor)                  # '&anchor'
< //      TAG(handle,suffix)              # '!handle!suffix'
< //      SCALAR(value,style)             # A scalar.
< //
< // The following two tokens are "virtual" tokens denoting the beginning and the
< // end of the stream:
< //
< //      STREAM-START(encoding)
< //      STREAM-END
< //
< // We pass the information about the input stream encoding with the
< // STREAM-START token.
< //
< // The next two tokens are responsible for tags:
< //
< //      VERSION-DIRECTIVE(major,minor)
< //      TAG-DIRECTIVE(handle,prefix)
< //
< // Example:
< //
< //      %YAML   1.1
< //      %TAG    !   !foo
< //      %TAG    !yaml!  tag:yaml.org,2002:
< //      ---
< //
< // The correspoding sequence of tokens:
< //
< //      STREAM-START(utf-8)
< //      VERSION-DIRECTIVE(1,1)
< //      TAG-DIRECTIVE("!","!foo")
< //      TAG-DIRECTIVE("!yaml","tag:yaml.org,2002:")
< //      DOCUMENT-START
< //      STREAM-END
< //
< // Note that the VERSION-DIRECTIVE and TAG-DIRECTIVE tokens occupy a whole
< // line.
< //
< // The document start and end indicators are represented by:
< //
< //      DOCUMENT-START
< //      DOCUMENT-END
< //
< // Note that if a YAML stream contains an implicit document (without '---'
< // and '...' indicators), no DOCUMENT-START and DOCUMENT-END tokens will be
< // produced.
< //
< // In the following examples, we present whole documents together with the
< // produced tokens.
< //
< //      1. An implicit document:
< //
< //          'a scalar'
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          SCALAR("a scalar",single-quoted)
< //          STREAM-END
< //
< //      2. An explicit document:
< //
< //          ---
< //          'a scalar'
< //          ...
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          DOCUMENT-START
< //          SCALAR("a scalar",single-quoted)
< //          DOCUMENT-END
< //          STREAM-END
< //
< //      3. Several documents in a stream:
< //
< //          'a scalar'
< //          ---
< //          'another scalar'
< //          ---
< //          'yet another scalar'
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          SCALAR("a scalar",single-quoted)
< //          DOCUMENT-START
< //          SCALAR("another scalar",single-quoted)
< //          DOCUMENT-START
< //          SCALAR("yet another scalar",single-quoted)
< //          STREAM-END
< //
< // We have already introduced the SCALAR token above.  The following tokens are
< // used to describe aliases, anchors, tag, and scalars:
< //
< //      ALIAS(anchor)
< //      ANCHOR(anchor)
< //      TAG(handle,suffix)
< //      SCALAR(value,style)
< //
< // The following series of examples illustrate the usage of these tokens:
< //
< //      1. A recursive sequence:
< //
< //          &A [ *A ]
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          ANCHOR("A")
< //          FLOW-SEQUENCE-START
< //          ALIAS("A")
< //          FLOW-SEQUENCE-END
< //          STREAM-END
< //
< //      2. A tagged scalar:
< //
< //          !!float "3.14"  # A good approximation.
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          TAG("!!","float")
< //          SCALAR("3.14",double-quoted)
< //          STREAM-END
< //
< //      3. Various scalar styles:
< //
< //          --- # Implicit empty plain scalars do not produce tokens.
< //          --- a plain scalar
< //          --- 'a single-quoted scalar'
< //          --- "a double-quoted scalar"
< //          --- |-
< //            a literal scalar
< //          --- >-
< //            a folded
< //            scalar
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          DOCUMENT-START
< //          DOCUMENT-START
< //          SCALAR("a plain scalar",plain)
< //          DOCUMENT-START
< //          SCALAR("a single-quoted scalar",single-quoted)
< //          DOCUMENT-START
< //          SCALAR("a double-quoted scalar",double-quoted)
< //          DOCUMENT-START
< //          SCALAR("a literal scalar",literal)
< //          DOCUMENT-START
< //          SCALAR("a folded scalar",folded)
< //          STREAM-END
< //
< // Now it's time to review collection-related tokens. We will start with
< // flow collections:
< //
< //      FLOW-SEQUENCE-START
< //      FLOW-SEQUENCE-END
< //      FLOW-MAPPING-START
< //      FLOW-MAPPING-END
< //      FLOW-ENTRY
< //      KEY
< //      VALUE
< //
< // The tokens FLOW-SEQUENCE-START, FLOW-SEQUENCE-END, FLOW-MAPPING-START, and
< // FLOW-MAPPING-END represent the indicators '[', ']', '{', and '}'
< // correspondingly.  FLOW-ENTRY represent the ',' indicator.  Finally the
< // indicators '?' and ':', which are used for denoting mapping keys and values,
< // are represented by the KEY and VALUE tokens.
< //
< // The following examples show flow collections:
< //
< //      1. A flow sequence:
< //
< //          [item 1, item 2, item 3]
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          FLOW-SEQUENCE-START
< //          SCALAR("item 1",plain)
< //          FLOW-ENTRY
< //          SCALAR("item 2",plain)
< //          FLOW-ENTRY
< //          SCALAR("item 3",plain)
< //          FLOW-SEQUENCE-END
< //          STREAM-END
< //
< //      2. A flow mapping:
< //
< //          {
< //              a simple key: a value,  # Note that the KEY token is produced.
< //              ? a complex key: another value,
< //          }
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          FLOW-MAPPING-START
< //          KEY
< //          SCALAR("a simple key",plain)
< //          VALUE
< //          SCALAR("a value",plain)
< //          FLOW-ENTRY
< //          KEY
< //          SCALAR("a complex key",plain)
< //          VALUE
< //          SCALAR("another value",plain)
< //          FLOW-ENTRY
< //          FLOW-MAPPING-END
< //          STREAM-END
< //
< // A simple key is a key which is not denoted by the '?' indicator.  Note that
< // the Scanner still produce the KEY token whenever it encounters a simple key.
< //
< // For scanning block collections, the following tokens are used (note that we
< // repeat KEY and VALUE here):
< //
< //      BLOCK-SEQUENCE-START
< //      BLOCK-MAPPING-START
< //      BLOCK-END
< //      BLOCK-ENTRY
< //      KEY
< //      VALUE
< //
< // The tokens BLOCK-SEQUENCE-START and BLOCK-MAPPING-START denote indentation
< // increase that precedes a block collection (cf. the INDENT token in Python).
< // The token BLOCK-END denote indentation decrease that ends a block collection
< // (cf. the DEDENT token in Python).  However YAML has some syntax pecularities
< // that makes detections of these tokens more complex.
< //
< // The tokens BLOCK-ENTRY, KEY, and VALUE are used to represent the indicators
< // '-', '?', and ':' correspondingly.
< //
< // The following examples show how the tokens BLOCK-SEQUENCE-START,
< // BLOCK-MAPPING-START, and BLOCK-END are emitted by the Scanner:
< //
< //      1. Block sequences:
< //
< //          - item 1
< //          - item 2
< //          -
< //            - item 3.1
< //            - item 3.2
< //          -
< //            key 1: value 1
< //            key 2: value 2
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 2",plain)
< //          BLOCK-ENTRY
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 3.1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 3.2",plain)
< //          BLOCK-END
< //          BLOCK-ENTRY
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("key 1",plain)
< //          VALUE
< //          SCALAR("value 1",plain)
< //          KEY
< //          SCALAR("key 2",plain)
< //          VALUE
< //          SCALAR("value 2",plain)
< //          BLOCK-END
< //          BLOCK-END
< //          STREAM-END
< //
< //      2. Block mappings:
< //
< //          a simple key: a value   # The KEY token is produced here.
< //          ? a complex key
< //          : another value
< //          a mapping:
< //            key 1: value 1
< //            key 2: value 2
< //          a sequence:
< //            - item 1
< //            - item 2
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("a simple key",plain)
< //          VALUE
< //          SCALAR("a value",plain)
< //          KEY
< //          SCALAR("a complex key",plain)
< //          VALUE
< //          SCALAR("another value",plain)
< //          KEY
< //          SCALAR("a mapping",plain)
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("key 1",plain)
< //          VALUE
< //          SCALAR("value 1",plain)
< //          KEY
< //          SCALAR("key 2",plain)
< //          VALUE
< //          SCALAR("value 2",plain)
< //          BLOCK-END
< //          KEY
< //          SCALAR("a sequence",plain)
< //          VALUE
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 2",plain)
< //          BLOCK-END
< //          BLOCK-END
< //          STREAM-END
< //
< // YAML does not always require to start a new block collection from a new
< // line.  If the current line contains only '-', '?', and ':' indicators, a new
< // block collection may start at the current line.  The following examples
< // illustrate this case:
< //
< //      1. Collections in a sequence:
< //
< //          - - item 1
< //            - item 2
< //          - key 1: value 1
< //            key 2: value 2
< //          - ? complex key
< //            : complex value
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 2",plain)
< //          BLOCK-END
< //          BLOCK-ENTRY
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("key 1",plain)
< //          VALUE
< //          SCALAR("value 1",plain)
< //          KEY
< //          SCALAR("key 2",plain)
< //          VALUE
< //          SCALAR("value 2",plain)
< //          BLOCK-END
< //          BLOCK-ENTRY
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("complex key")
< //          VALUE
< //          SCALAR("complex value")
< //          BLOCK-END
< //          BLOCK-END
< //          STREAM-END
< //
< //      2. Collections in a mapping:
< //
< //          ? a sequence
< //          : - item 1
< //            - item 2
< //          ? a mapping
< //          : key 1: value 1
< //            key 2: value 2
< //
< //      Tokens:
< //
< //          STREAM-START(utf-8)
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("a sequence",plain)
< //          VALUE
< //          BLOCK-SEQUENCE-START
< //          BLOCK-ENTRY
< //          SCALAR("item 1",plain)
< //          BLOCK-ENTRY
< //          SCALAR("item 2",plain)
< //          BLOCK-END
< //          KEY
< //          SCALAR("a mapping",plain)
< //          VALUE
< //          BLOCK-MAPPING-START
< //          KEY
< //          SCALAR("key 1",plain)
< //          VALUE
< //          SCALAR("value 1",plain)
< //          KEY
< //          SCALAR("key 2",plain)
< //          VALUE
< //          SCALAR("value 2",plain)
< //          BLOCK-END
< //          BLOCK-END
< //          STREAM-END
< //
< // YAML also permits non-indented sequences if they are included into a block
< // mapping.  In this case, the token BLOCK-SEQUENCE-START is not produced:
< //
< //      key:
< //      - item 1    # BLOCK-SEQUENCE-START is NOT produced here.
< //      - item 2
< //
< // Tokens:
< //
< //      STREAM-START(utf-8)
< //      BLOCK-MAPPING-START
< //      KEY
< //      SCALAR("key",plain)
< //      VALUE
< //      BLOCK-ENTRY
< //      SCALAR("item 1",plain)
< //      BLOCK-ENTRY
< //      SCALAR("item 2",plain)
< //      BLOCK-END
< //
< 
< // Ensure that the buffer contains the required number of characters.
< // Return true on success, false on failure (reader error or memory error).
< func cache(parser *yaml_parser_t, length int) bool {
< 	// [Go] This was inlined: !cache(A, B) -> unread < B && !update(A, B)
< 	return parser.unread >= length || yaml_parser_update_buffer(parser, length)
< }
< 
< // Advance the buffer pointer.
< func skip(parser *yaml_parser_t) {
< 	if !is_blank(parser.buffer, parser.buffer_pos) {
< 		parser.newlines = 0
< 	}
< 	parser.mark.index++
< 	parser.mark.column++
< 	parser.unread--
< 	parser.buffer_pos += width(parser.buffer[parser.buffer_pos])
< }
< 
< func skip_line(parser *yaml_parser_t) {
< 	if is_crlf(parser.buffer, parser.buffer_pos) {
< 		parser.mark.index += 2
< 		parser.mark.column = 0
< 		parser.mark.line++
< 		parser.unread -= 2
< 		parser.buffer_pos += 2
< 		parser.newlines++
< 	} else if is_break(parser.buffer, parser.buffer_pos) {
< 		parser.mark.index++
< 		parser.mark.column = 0
< 		parser.mark.line++
< 		parser.unread--
< 		parser.buffer_pos += width(parser.buffer[parser.buffer_pos])
< 		parser.newlines++
< 	}
< }
< 
< // Copy a character to a string buffer and advance pointers.
< func read(parser *yaml_parser_t, s []byte) []byte {
< 	if !is_blank(parser.buffer, parser.buffer_pos) {
< 		parser.newlines = 0
< 	}
< 	w := width(parser.buffer[parser.buffer_pos])
< 	if w == 0 {
< 		panic("invalid character sequence")
< 	}
< 	if len(s) == 0 {
< 		s = make([]byte, 0, 32)
< 	}
< 	if w == 1 && len(s)+w <= cap(s) {
< 		s = s[:len(s)+1]
< 		s[len(s)-1] = parser.buffer[parser.buffer_pos]
< 		parser.buffer_pos++
< 	} else {
< 		s = append(s, parser.buffer[parser.buffer_pos:parser.buffer_pos+w]...)
< 		parser.buffer_pos += w
< 	}
< 	parser.mark.index++
< 	parser.mark.column++
< 	parser.unread--
< 	return s
< }
< 
< // Copy a line break character to a string buffer and advance pointers.
< func read_line(parser *yaml_parser_t, s []byte) []byte {
< 	buf := parser.buffer
< 	pos := parser.buffer_pos
< 	switch {
< 	case buf[pos] == '\r' && buf[pos+1] == '\n':
< 		// CR LF . LF
< 		s = append(s, '\n')
< 		parser.buffer_pos += 2
< 		parser.mark.index++
< 		parser.unread--
< 	case buf[pos] == '\r' || buf[pos] == '\n':
< 		// CR|LF . LF
< 		s = append(s, '\n')
< 		parser.buffer_pos += 1
< 	case buf[pos] == '\xC2' && buf[pos+1] == '\x85':
< 		// NEL . LF
< 		s = append(s, '\n')
< 		parser.buffer_pos += 2
< 	case buf[pos] == '\xE2' && buf[pos+1] == '\x80' && (buf[pos+2] == '\xA8' || buf[pos+2] == '\xA9'):
< 		// LS|PS . LS|PS
< 		s = append(s, buf[parser.buffer_pos:pos+3]...)
< 		parser.buffer_pos += 3
< 	default:
< 		return s
< 	}
< 	parser.mark.index++
< 	parser.mark.column = 0
< 	parser.mark.line++
< 	parser.unread--
< 	parser.newlines++
< 	return s
< }
< 
< // Get the next token.
< func yaml_parser_scan(parser *yaml_parser_t, token *yaml_token_t) bool {
< 	// Erase the token object.
< 	*token = yaml_token_t{} // [Go] Is this necessary?
< 
< 	// No tokens after STREAM-END or error.
< 	if parser.stream_end_produced || parser.error != yaml_NO_ERROR {
< 		return true
< 	}
< 
< 	// Ensure that the tokens queue contains enough tokens.
< 	if !parser.token_available {
< 		if !yaml_parser_fetch_more_tokens(parser) {
< 			return false
< 		}
< 	}
< 
< 	// Fetch the next token from the queue.
< 	*token = parser.tokens[parser.tokens_head]
< 	parser.tokens_head++
< 	parser.tokens_parsed++
< 	parser.token_available = false
< 
< 	if token.typ == yaml_STREAM_END_TOKEN {
< 		parser.stream_end_produced = true
< 	}
< 	return true
< }
< 
< // Set the scanner error and return false.
< func yaml_parser_set_scanner_error(parser *yaml_parser_t, context string, context_mark yaml_mark_t, problem string) bool {
< 	parser.error = yaml_SCANNER_ERROR
< 	parser.context = context
< 	parser.context_mark = context_mark
< 	parser.problem = problem
< 	parser.problem_mark = parser.mark
< 	return false
< }
< 
< func yaml_parser_set_scanner_tag_error(parser *yaml_parser_t, directive bool, context_mark yaml_mark_t, problem string) bool {
< 	context := "while parsing a tag"
< 	if directive {
< 		context = "while parsing a %TAG directive"
< 	}
< 	return yaml_parser_set_scanner_error(parser, context, context_mark, problem)
< }
< 
< func trace(args ...interface{}) func() {
< 	pargs := append([]interface{}{"+++"}, args...)
< 	fmt.Println(pargs...)
< 	pargs = append([]interface{}{"---"}, args...)
< 	return func() { fmt.Println(pargs...) }
< }
< 
< // Ensure that the tokens queue contains at least one token which can be
< // returned to the Parser.
< func yaml_parser_fetch_more_tokens(parser *yaml_parser_t) bool {
< 	// While we need more tokens to fetch, do it.
< 	for {
< 		// Check if we really need to fetch more tokens.
< 		need_more_tokens := false
< 
< 		// [Go] The comment parsing logic requires a lookahead of one token
< 		// in block style or two tokens in flow style so that the foot
< 		// comments may be parsed in time of associating them with the tokens
< 		// that are parsed before them.
< 		if parser.tokens_head >= len(parser.tokens)-1 || parser.flow_level > 0 && parser.tokens_head >= len(parser.tokens)-2 {
< 			need_more_tokens = true
< 		} else {
< 			// Check if any potential simple key may occupy the head position.
< 			if !yaml_parser_stale_simple_keys(parser) {
< 				return false
< 			}
< 
< 			for i := range parser.simple_keys {
< 				simple_key := &parser.simple_keys[i]
< 				if simple_key.possible && simple_key.token_number == parser.tokens_parsed {
< 					need_more_tokens = true
< 					break
< 				}
< 			}
< 		}
< 
< 		// We are finished.
< 		if !need_more_tokens {
< 			break
< 		}
< 		// Fetch the next token.
< 		if !yaml_parser_fetch_next_token(parser) {
< 			return false
< 		}
< 	}
< 
< 	parser.token_available = true
< 	return true
< }
< 
< // The dispatcher for token fetchers.
< func yaml_parser_fetch_next_token(parser *yaml_parser_t) (ok bool) {
< 	// Ensure that the buffer is initialized.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	// Check if we just started scanning.  Fetch STREAM-START then.
< 	if !parser.stream_start_produced {
< 		return yaml_parser_fetch_stream_start(parser)
< 	}
< 
< 	scan_mark := parser.mark
< 
< 	// Eat whitespaces and comments until we reach the next token.
< 	if !yaml_parser_scan_to_next_token(parser) {
< 		return false
< 	}
< 
< 	// Remove obsolete potential simple keys.
< 	if !yaml_parser_stale_simple_keys(parser) {
< 		return false
< 	}
< 
< 	// [Go] While unrolling indents, transform the head comments of prior
< 	// indentation levels observed after scan_start into foot comments at
< 	// the respective indexes.
< 
< 	// Check the indentation level against the current column.
< 	if !yaml_parser_unroll_indent(parser, parser.mark.column, scan_mark) {
< 		return false
< 	}
< 
< 	// Ensure that the buffer contains at least 4 characters.  4 is the length
< 	// of the longest indicators ('--- ' and '... ').
< 	if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
< 		return false
< 	}
< 
< 	// Is it the end of the stream?
< 	if is_z(parser.buffer, parser.buffer_pos) {
< 		return yaml_parser_fetch_stream_end(parser)
< 	}
< 
< 	// Is it a directive?
< 	if parser.mark.column == 0 && parser.buffer[parser.buffer_pos] == '%' {
< 		return yaml_parser_fetch_directive(parser)
< 	}
< 
< 	buf := parser.buffer
< 	pos := parser.buffer_pos
< 
< 	// Is it the document start indicator?
< 	if parser.mark.column == 0 && buf[pos] == '-' && buf[pos+1] == '-' && buf[pos+2] == '-' && is_blankz(buf, pos+3) {
< 		return yaml_parser_fetch_document_indicator(parser, yaml_DOCUMENT_START_TOKEN)
< 	}
< 
< 	// Is it the document end indicator?
< 	if parser.mark.column == 0 && buf[pos] == '.' && buf[pos+1] == '.' && buf[pos+2] == '.' && is_blankz(buf, pos+3) {
< 		return yaml_parser_fetch_document_indicator(parser, yaml_DOCUMENT_END_TOKEN)
< 	}
< 
< 	comment_mark := parser.mark
< 	if len(parser.tokens) > 0 && (parser.flow_level == 0 && buf[pos] == ':' || parser.flow_level > 0 && buf[pos] == ',') {
< 		// Associate any following comments with the prior token.
< 		comment_mark = parser.tokens[len(parser.tokens)-1].start_mark
< 	}
< 	defer func() {
< 		if !ok {
< 			return
< 		}
< 		if !yaml_parser_scan_line_comment(parser, comment_mark) {
< 			ok = false
< 			return
< 		}
< 	}()
< 
< 	// Is it the flow sequence start indicator?
< 	if buf[pos] == '[' {
< 		return yaml_parser_fetch_flow_collection_start(parser, yaml_FLOW_SEQUENCE_START_TOKEN)
< 	}
< 
< 	// Is it the flow mapping start indicator?
< 	if parser.buffer[parser.buffer_pos] == '{' {
< 		return yaml_parser_fetch_flow_collection_start(parser, yaml_FLOW_MAPPING_START_TOKEN)
< 	}
< 
< 	// Is it the flow sequence end indicator?
< 	if parser.buffer[parser.buffer_pos] == ']' {
< 		return yaml_parser_fetch_flow_collection_end(parser,
< 			yaml_FLOW_SEQUENCE_END_TOKEN)
< 	}
< 
< 	// Is it the flow mapping end indicator?
< 	if parser.buffer[parser.buffer_pos] == '}' {
< 		return yaml_parser_fetch_flow_collection_end(parser,
< 			yaml_FLOW_MAPPING_END_TOKEN)
< 	}
< 
< 	// Is it the flow entry indicator?
< 	if parser.buffer[parser.buffer_pos] == ',' {
< 		return yaml_parser_fetch_flow_entry(parser)
< 	}
< 
< 	// Is it the block entry indicator?
< 	if parser.buffer[parser.buffer_pos] == '-' && is_blankz(parser.buffer, parser.buffer_pos+1) {
< 		return yaml_parser_fetch_block_entry(parser)
< 	}
< 
< 	// Is it the key indicator?
< 	if parser.buffer[parser.buffer_pos] == '?' && (parser.flow_level > 0 || is_blankz(parser.buffer, parser.buffer_pos+1)) {
< 		return yaml_parser_fetch_key(parser)
< 	}
< 
< 	// Is it the value indicator?
< 	if parser.buffer[parser.buffer_pos] == ':' && (parser.flow_level > 0 || is_blankz(parser.buffer, parser.buffer_pos+1)) {
< 		return yaml_parser_fetch_value(parser)
< 	}
< 
< 	// Is it an alias?
< 	if parser.buffer[parser.buffer_pos] == '*' {
< 		return yaml_parser_fetch_anchor(parser, yaml_ALIAS_TOKEN)
< 	}
< 
< 	// Is it an anchor?
< 	if parser.buffer[parser.buffer_pos] == '&' {
< 		return yaml_parser_fetch_anchor(parser, yaml_ANCHOR_TOKEN)
< 	}
< 
< 	// Is it a tag?
< 	if parser.buffer[parser.buffer_pos] == '!' {
< 		return yaml_parser_fetch_tag(parser)
< 	}
< 
< 	// Is it a literal scalar?
< 	if parser.buffer[parser.buffer_pos] == '|' && parser.flow_level == 0 {
< 		return yaml_parser_fetch_block_scalar(parser, true)
< 	}
< 
< 	// Is it a folded scalar?
< 	if parser.buffer[parser.buffer_pos] == '>' && parser.flow_level == 0 {
< 		return yaml_parser_fetch_block_scalar(parser, false)
< 	}
< 
< 	// Is it a single-quoted scalar?
< 	if parser.buffer[parser.buffer_pos] == '\'' {
< 		return yaml_parser_fetch_flow_scalar(parser, true)
< 	}
< 
< 	// Is it a double-quoted scalar?
< 	if parser.buffer[parser.buffer_pos] == '"' {
< 		return yaml_parser_fetch_flow_scalar(parser, false)
< 	}
< 
< 	// Is it a plain scalar?
< 	//
< 	// A plain scalar may start with any non-blank characters except
< 	//
< 	//      '-', '?', ':', ',', '[', ']', '{', '}',
< 	//      '#', '&', '*', '!', '|', '>', '\'', '\"',
< 	//      '%', '@', '`'.
< 	//
< 	// In the block context (and, for the '-' indicator, in the flow context
< 	// too), it may also start with the characters
< 	//
< 	//      '-', '?', ':'
< 	//
< 	// if it is followed by a non-space character.
< 	//
< 	// The last rule is more restrictive than the specification requires.
< 	// [Go] TODO Make this logic more reasonable.
< 	//switch parser.buffer[parser.buffer_pos] {
< 	//case '-', '?', ':', ',', '?', '-', ',', ':', ']', '[', '}', '{', '&', '#', '!', '*', '>', '|', '"', '\'', '@', '%', '-', '`':
< 	//}
< 	if !(is_blankz(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == '-' ||
< 		parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == ':' ||
< 		parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == '[' ||
< 		parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '{' ||
< 		parser.buffer[parser.buffer_pos] == '}' || parser.buffer[parser.buffer_pos] == '#' ||
< 		parser.buffer[parser.buffer_pos] == '&' || parser.buffer[parser.buffer_pos] == '*' ||
< 		parser.buffer[parser.buffer_pos] == '!' || parser.buffer[parser.buffer_pos] == '|' ||
< 		parser.buffer[parser.buffer_pos] == '>' || parser.buffer[parser.buffer_pos] == '\'' ||
< 		parser.buffer[parser.buffer_pos] == '"' || parser.buffer[parser.buffer_pos] == '%' ||
< 		parser.buffer[parser.buffer_pos] == '@' || parser.buffer[parser.buffer_pos] == '`') ||
< 		(parser.buffer[parser.buffer_pos] == '-' && !is_blank(parser.buffer, parser.buffer_pos+1)) ||
< 		(parser.flow_level == 0 &&
< 			(parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == ':') &&
< 			!is_blankz(parser.buffer, parser.buffer_pos+1)) {
< 		return yaml_parser_fetch_plain_scalar(parser)
< 	}
< 
< 	// If we don't determine the token type so far, it is an error.
< 	return yaml_parser_set_scanner_error(parser,
< 		"while scanning for the next token", parser.mark,
< 		"found character that cannot start any token")
< }
< 
< // Check the list of potential simple keys and remove the positions that
< // cannot contain simple keys anymore.
< func yaml_parser_stale_simple_keys(parser *yaml_parser_t) bool {
< 	// Check for a potential simple key for each flow level.
< 	for i := range parser.simple_keys {
< 		simple_key := &parser.simple_keys[i]
< 
< 		// The specification requires that a simple key
< 		//
< 		//  - is limited to a single line,
< 		//  - is shorter than 1024 characters.
< 		if simple_key.possible && (simple_key.mark.line < parser.mark.line || simple_key.mark.index+1024 < parser.mark.index) {
< 
< 			// Check if the potential simple key to be removed is required.
< 			if simple_key.required {
< 				return yaml_parser_set_scanner_error(parser,
< 					"while scanning a simple key", simple_key.mark,
< 					"could not find expected ':'")
< 			}
< 			simple_key.possible = false
< 		}
< 	}
< 	return true
< }
< 
< // Check if a simple key may start at the current position and add it if
< // needed.
< func yaml_parser_save_simple_key(parser *yaml_parser_t) bool {
< 	// A simple key is required at the current position if the scanner is in
< 	// the block context and the current column coincides with the indentation
< 	// level.
< 
< 	required := parser.flow_level == 0 && parser.indent == parser.mark.column
< 
< 	//
< 	// If the current position may start a simple key, save it.
< 	//
< 	if parser.simple_key_allowed {
< 		simple_key := yaml_simple_key_t{
< 			possible:     true,
< 			required:     required,
< 			token_number: parser.tokens_parsed + (len(parser.tokens) - parser.tokens_head),
< 		}
< 		simple_key.mark = parser.mark
< 
< 		if !yaml_parser_remove_simple_key(parser) {
< 			return false
< 		}
< 		parser.simple_keys[len(parser.simple_keys)-1] = simple_key
< 	}
< 	return true
< }
< 
< // Remove a potential simple key at the current flow level.
< func yaml_parser_remove_simple_key(parser *yaml_parser_t) bool {
< 	i := len(parser.simple_keys) - 1
< 	if parser.simple_keys[i].possible {
< 		// If the key is required, it is an error.
< 		if parser.simple_keys[i].required {
< 			return yaml_parser_set_scanner_error(parser,
< 				"while scanning a simple key", parser.simple_keys[i].mark,
< 				"could not find expected ':'")
< 		}
< 	}
< 	// Remove the key from the stack.
< 	parser.simple_keys[i].possible = false
< 	return true
< }
< 
< // max_flow_level limits the flow_level
< const max_flow_level = 10000
< 
< // Increase the flow level and resize the simple key list if needed.
< func yaml_parser_increase_flow_level(parser *yaml_parser_t) bool {
< 	// Reset the simple key on the next level.
< 	parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
< 
< 	// Increase the flow level.
< 	parser.flow_level++
< 	if parser.flow_level > max_flow_level {
< 		return yaml_parser_set_scanner_error(parser,
< 			"while increasing flow level", parser.simple_keys[len(parser.simple_keys)-1].mark,
< 			fmt.Sprintf("exceeded max depth of %d", max_flow_level))
< 	}
< 	return true
< }
< 
< // Decrease the flow level.
< func yaml_parser_decrease_flow_level(parser *yaml_parser_t) bool {
< 	if parser.flow_level > 0 {
< 		parser.flow_level--
< 		parser.simple_keys = parser.simple_keys[:len(parser.simple_keys)-1]
< 	}
< 	return true
< }
< 
< // max_indents limits the indents stack size
< const max_indents = 10000
< 
< // Push the current indentation level to the stack and set the new level
< // the current column is greater than the indentation level.  In this case,
< // append or insert the specified token into the token queue.
< func yaml_parser_roll_indent(parser *yaml_parser_t, column, number int, typ yaml_token_type_t, mark yaml_mark_t) bool {
< 	// In the flow context, do nothing.
< 	if parser.flow_level > 0 {
< 		return true
< 	}
< 
< 	if parser.indent < column {
< 		// Push the current indentation level to the stack and set the new
< 		// indentation level.
< 		parser.indents = append(parser.indents, parser.indent)
< 		parser.indent = column
< 		if len(parser.indents) > max_indents {
< 			return yaml_parser_set_scanner_error(parser,
< 				"while increasing indent level", parser.simple_keys[len(parser.simple_keys)-1].mark,
< 				fmt.Sprintf("exceeded max depth of %d", max_indents))
< 		}
< 
< 		// Create a token and insert it into the queue.
< 		token := yaml_token_t{
< 			typ:        typ,
< 			start_mark: mark,
< 			end_mark:   mark,
< 		}
< 		if number > -1 {
< 			number -= parser.tokens_parsed
< 		}
< 		yaml_insert_token(parser, number, &token)
< 	}
< 	return true
< }
< 
< // Pop indentation levels from the indents stack until the current level
< // becomes less or equal to the column.  For each indentation level, append
< // the BLOCK-END token.
< func yaml_parser_unroll_indent(parser *yaml_parser_t, column int, scan_mark yaml_mark_t) bool {
< 	// In the flow context, do nothing.
< 	if parser.flow_level > 0 {
< 		return true
< 	}
< 
< 	block_mark := scan_mark
< 	block_mark.index--
< 
< 	// Loop through the indentation levels in the stack.
< 	for parser.indent > column {
< 
< 		// [Go] Reposition the end token before potential following
< 		//      foot comments of parent blocks. For that, search
< 		//      backwards for recent comments that were at the same
< 		//      indent as the block that is ending now.
< 		stop_index := block_mark.index
< 		for i := len(parser.comments) - 1; i >= 0; i-- {
< 			comment := &parser.comments[i]
< 
< 			if comment.end_mark.index < stop_index {
< 				// Don't go back beyond the start of the comment/whitespace scan, unless column < 0.
< 				// If requested indent column is < 0, then the document is over and everything else
< 				// is a foot anyway.
< 				break
< 			}
< 			if comment.start_mark.column == parser.indent+1 {
< 				// This is a good match. But maybe there's a former comment
< 				// at that same indent level, so keep searching.
< 				block_mark = comment.start_mark
< 			}
< 
< 			// While the end of the former comment matches with
< 			// the start of the following one, we know there's
< 			// nothing in between and scanning is still safe.
< 			stop_index = comment.scan_mark.index
< 		}
< 
< 		// Create a token and append it to the queue.
< 		token := yaml_token_t{
< 			typ:        yaml_BLOCK_END_TOKEN,
< 			start_mark: block_mark,
< 			end_mark:   block_mark,
< 		}
< 		yaml_insert_token(parser, -1, &token)
< 
< 		// Pop the indentation level.
< 		parser.indent = parser.indents[len(parser.indents)-1]
< 		parser.indents = parser.indents[:len(parser.indents)-1]
< 	}
< 	return true
< }
< 
< // Initialize the scanner and produce the STREAM-START token.
< func yaml_parser_fetch_stream_start(parser *yaml_parser_t) bool {
< 
< 	// Set the initial indentation.
< 	parser.indent = -1
< 
< 	// Initialize the simple key stack.
< 	parser.simple_keys = append(parser.simple_keys, yaml_simple_key_t{})
< 
< 	// A simple key is allowed at the beginning of the stream.
< 	parser.simple_key_allowed = true
< 
< 	// We have started.
< 	parser.stream_start_produced = true
< 
< 	// Create the STREAM-START token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_STREAM_START_TOKEN,
< 		start_mark: parser.mark,
< 		end_mark:   parser.mark,
< 		encoding:   parser.encoding,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the STREAM-END token and shut down the scanner.
< func yaml_parser_fetch_stream_end(parser *yaml_parser_t) bool {
< 
< 	// Force new line.
< 	if parser.mark.column != 0 {
< 		parser.mark.column = 0
< 		parser.mark.line++
< 	}
< 
< 	// Reset the indentation level.
< 	if !yaml_parser_unroll_indent(parser, -1, parser.mark) {
< 		return false
< 	}
< 
< 	// Reset simple keys.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	parser.simple_key_allowed = false
< 
< 	// Create the STREAM-END token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_STREAM_END_TOKEN,
< 		start_mark: parser.mark,
< 		end_mark:   parser.mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce a VERSION-DIRECTIVE or TAG-DIRECTIVE token.
< func yaml_parser_fetch_directive(parser *yaml_parser_t) bool {
< 	// Reset the indentation level.
< 	if !yaml_parser_unroll_indent(parser, -1, parser.mark) {
< 		return false
< 	}
< 
< 	// Reset simple keys.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	parser.simple_key_allowed = false
< 
< 	// Create the YAML-DIRECTIVE or TAG-DIRECTIVE token.
< 	token := yaml_token_t{}
< 	if !yaml_parser_scan_directive(parser, &token) {
< 		return false
< 	}
< 	// Append the token to the queue.
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the DOCUMENT-START or DOCUMENT-END token.
< func yaml_parser_fetch_document_indicator(parser *yaml_parser_t, typ yaml_token_type_t) bool {
< 	// Reset the indentation level.
< 	if !yaml_parser_unroll_indent(parser, -1, parser.mark) {
< 		return false
< 	}
< 
< 	// Reset simple keys.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	parser.simple_key_allowed = false
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 
< 	skip(parser)
< 	skip(parser)
< 	skip(parser)
< 
< 	end_mark := parser.mark
< 
< 	// Create the DOCUMENT-START or DOCUMENT-END token.
< 	token := yaml_token_t{
< 		typ:        typ,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	// Append the token to the queue.
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the FLOW-SEQUENCE-START or FLOW-MAPPING-START token.
< func yaml_parser_fetch_flow_collection_start(parser *yaml_parser_t, typ yaml_token_type_t) bool {
< 
< 	// The indicators '[' and '{' may start a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Increase the flow level.
< 	if !yaml_parser_increase_flow_level(parser) {
< 		return false
< 	}
< 
< 	// A simple key may follow the indicators '[' and '{'.
< 	parser.simple_key_allowed = true
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the FLOW-SEQUENCE-START of FLOW-MAPPING-START token.
< 	token := yaml_token_t{
< 		typ:        typ,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	// Append the token to the queue.
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the FLOW-SEQUENCE-END or FLOW-MAPPING-END token.
< func yaml_parser_fetch_flow_collection_end(parser *yaml_parser_t, typ yaml_token_type_t) bool {
< 	// Reset any potential simple key on the current flow level.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Decrease the flow level.
< 	if !yaml_parser_decrease_flow_level(parser) {
< 		return false
< 	}
< 
< 	// No simple keys after the indicators ']' and '}'.
< 	parser.simple_key_allowed = false
< 
< 	// Consume the token.
< 
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the FLOW-SEQUENCE-END of FLOW-MAPPING-END token.
< 	token := yaml_token_t{
< 		typ:        typ,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	// Append the token to the queue.
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the FLOW-ENTRY token.
< func yaml_parser_fetch_flow_entry(parser *yaml_parser_t) bool {
< 	// Reset any potential simple keys on the current flow level.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Simple keys are allowed after ','.
< 	parser.simple_key_allowed = true
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the FLOW-ENTRY token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_FLOW_ENTRY_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the BLOCK-ENTRY token.
< func yaml_parser_fetch_block_entry(parser *yaml_parser_t) bool {
< 	// Check if the scanner is in the block context.
< 	if parser.flow_level == 0 {
< 		// Check if we are allowed to start a new entry.
< 		if !parser.simple_key_allowed {
< 			return yaml_parser_set_scanner_error(parser, "", parser.mark,
< 				"block sequence entries are not allowed in this context")
< 		}
< 		// Add the BLOCK-SEQUENCE-START token if needed.
< 		if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_SEQUENCE_START_TOKEN, parser.mark) {
< 			return false
< 		}
< 	} else {
< 		// It is an error for the '-' indicator to occur in the flow context,
< 		// but we let the Parser detect and report about it because the Parser
< 		// is able to point to the context.
< 	}
< 
< 	// Reset any potential simple keys on the current flow level.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Simple keys are allowed after '-'.
< 	parser.simple_key_allowed = true
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the BLOCK-ENTRY token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_BLOCK_ENTRY_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the KEY token.
< func yaml_parser_fetch_key(parser *yaml_parser_t) bool {
< 
< 	// In the block context, additional checks are required.
< 	if parser.flow_level == 0 {
< 		// Check if we are allowed to start a new key (not nessesary simple).
< 		if !parser.simple_key_allowed {
< 			return yaml_parser_set_scanner_error(parser, "", parser.mark,
< 				"mapping keys are not allowed in this context")
< 		}
< 		// Add the BLOCK-MAPPING-START token if needed.
< 		if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_MAPPING_START_TOKEN, parser.mark) {
< 			return false
< 		}
< 	}
< 
< 	// Reset any potential simple keys on the current flow level.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// Simple keys are allowed after '?' in the block context.
< 	parser.simple_key_allowed = parser.flow_level == 0
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the KEY token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_KEY_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the VALUE token.
< func yaml_parser_fetch_value(parser *yaml_parser_t) bool {
< 
< 	simple_key := &parser.simple_keys[len(parser.simple_keys)-1]
< 
< 	// Have we found a simple key?
< 	if simple_key.possible {
< 		// Create the KEY token and insert it into the queue.
< 		token := yaml_token_t{
< 			typ:        yaml_KEY_TOKEN,
< 			start_mark: simple_key.mark,
< 			end_mark:   simple_key.mark,
< 		}
< 		yaml_insert_token(parser, simple_key.token_number-parser.tokens_parsed, &token)
< 
< 		// In the block context, we may need to add the BLOCK-MAPPING-START token.
< 		if !yaml_parser_roll_indent(parser, simple_key.mark.column,
< 			simple_key.token_number,
< 			yaml_BLOCK_MAPPING_START_TOKEN, simple_key.mark) {
< 			return false
< 		}
< 
< 		// Remove the simple key.
< 		simple_key.possible = false
< 
< 		// A simple key cannot follow another simple key.
< 		parser.simple_key_allowed = false
< 
< 	} else {
< 		// The ':' indicator follows a complex key.
< 
< 		// In the block context, extra checks are required.
< 		if parser.flow_level == 0 {
< 
< 			// Check if we are allowed to start a complex value.
< 			if !parser.simple_key_allowed {
< 				return yaml_parser_set_scanner_error(parser, "", parser.mark,
< 					"mapping values are not allowed in this context")
< 			}
< 
< 			// Add the BLOCK-MAPPING-START token if needed.
< 			if !yaml_parser_roll_indent(parser, parser.mark.column, -1, yaml_BLOCK_MAPPING_START_TOKEN, parser.mark) {
< 				return false
< 			}
< 		}
< 
< 		// Simple keys after ':' are allowed in the block context.
< 		parser.simple_key_allowed = parser.flow_level == 0
< 	}
< 
< 	// Consume the token.
< 	start_mark := parser.mark
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create the VALUE token and append it to the queue.
< 	token := yaml_token_t{
< 		typ:        yaml_VALUE_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the ALIAS or ANCHOR token.
< func yaml_parser_fetch_anchor(parser *yaml_parser_t, typ yaml_token_type_t) bool {
< 	// An anchor or an alias could be a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key cannot follow an anchor or an alias.
< 	parser.simple_key_allowed = false
< 
< 	// Create the ALIAS or ANCHOR token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_anchor(parser, &token, typ) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the TAG token.
< func yaml_parser_fetch_tag(parser *yaml_parser_t) bool {
< 	// A tag could be a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key cannot follow a tag.
< 	parser.simple_key_allowed = false
< 
< 	// Create the TAG token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_tag(parser, &token) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the SCALAR(...,literal) or SCALAR(...,folded) tokens.
< func yaml_parser_fetch_block_scalar(parser *yaml_parser_t, literal bool) bool {
< 	// Remove any potential simple keys.
< 	if !yaml_parser_remove_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key may follow a block scalar.
< 	parser.simple_key_allowed = true
< 
< 	// Create the SCALAR token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_block_scalar(parser, &token, literal) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the SCALAR(...,single-quoted) or SCALAR(...,double-quoted) tokens.
< func yaml_parser_fetch_flow_scalar(parser *yaml_parser_t, single bool) bool {
< 	// A plain scalar could be a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key cannot follow a flow scalar.
< 	parser.simple_key_allowed = false
< 
< 	// Create the SCALAR token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_flow_scalar(parser, &token, single) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Produce the SCALAR(...,plain) token.
< func yaml_parser_fetch_plain_scalar(parser *yaml_parser_t) bool {
< 	// A plain scalar could be a simple key.
< 	if !yaml_parser_save_simple_key(parser) {
< 		return false
< 	}
< 
< 	// A simple key cannot follow a flow scalar.
< 	parser.simple_key_allowed = false
< 
< 	// Create the SCALAR token and append it to the queue.
< 	var token yaml_token_t
< 	if !yaml_parser_scan_plain_scalar(parser, &token) {
< 		return false
< 	}
< 	yaml_insert_token(parser, -1, &token)
< 	return true
< }
< 
< // Eat whitespaces and comments until the next token is found.
< func yaml_parser_scan_to_next_token(parser *yaml_parser_t) bool {
< 
< 	scan_mark := parser.mark
< 
< 	// Until the next token is not found.
< 	for {
< 		// Allow the BOM mark to start a line.
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		if parser.mark.column == 0 && is_bom(parser.buffer, parser.buffer_pos) {
< 			skip(parser)
< 		}
< 
< 		// Eat whitespaces.
< 		// Tabs are allowed:
< 		//  - in the flow context
< 		//  - in the block context, but not at the beginning of the line or
< 		//  after '-', '?', or ':' (complex value).
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 
< 		for parser.buffer[parser.buffer_pos] == ' ' || ((parser.flow_level > 0 || !parser.simple_key_allowed) && parser.buffer[parser.buffer_pos] == '\t') {
< 			skip(parser)
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 
< 		// Eat a comment until a line break.
< 		if parser.buffer[parser.buffer_pos] == '#' {
< 			if !yaml_parser_scan_comments(parser, scan_mark) {
< 				return false
< 			}
< 		}
< 
< 		// If it is a line break, eat it.
< 		if is_break(parser.buffer, parser.buffer_pos) {
< 			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 				return false
< 			}
< 			skip_line(parser)
< 
< 			// In the block context, a new line may start a simple key.
< 			if parser.flow_level == 0 {
< 				parser.simple_key_allowed = true
< 			}
< 		} else {
< 			break // We have found a token.
< 		}
< 	}
< 
< 	return true
< }
< 
< // Scan a YAML-DIRECTIVE or TAG-DIRECTIVE token.
< //
< // Scope:
< //      %YAML    1.1    # a comment \n
< //      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
< //      %TAG    !yaml!  tag:yaml.org,2002:  \n
< //      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
< //
< func yaml_parser_scan_directive(parser *yaml_parser_t, token *yaml_token_t) bool {
< 	// Eat '%'.
< 	start_mark := parser.mark
< 	skip(parser)
< 
< 	// Scan the directive name.
< 	var name []byte
< 	if !yaml_parser_scan_directive_name(parser, start_mark, &name) {
< 		return false
< 	}
< 
< 	// Is it a YAML directive?
< 	if bytes.Equal(name, []byte("YAML")) {
< 		// Scan the VERSION directive value.
< 		var major, minor int8
< 		if !yaml_parser_scan_version_directive_value(parser, start_mark, &major, &minor) {
< 			return false
< 		}
< 		end_mark := parser.mark
< 
< 		// Create a VERSION-DIRECTIVE token.
< 		*token = yaml_token_t{
< 			typ:        yaml_VERSION_DIRECTIVE_TOKEN,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			major:      major,
< 			minor:      minor,
< 		}
< 
< 		// Is it a TAG directive?
< 	} else if bytes.Equal(name, []byte("TAG")) {
< 		// Scan the TAG directive value.
< 		var handle, prefix []byte
< 		if !yaml_parser_scan_tag_directive_value(parser, start_mark, &handle, &prefix) {
< 			return false
< 		}
< 		end_mark := parser.mark
< 
< 		// Create a TAG-DIRECTIVE token.
< 		*token = yaml_token_t{
< 			typ:        yaml_TAG_DIRECTIVE_TOKEN,
< 			start_mark: start_mark,
< 			end_mark:   end_mark,
< 			value:      handle,
< 			prefix:     prefix,
< 		}
< 
< 		// Unknown directive.
< 	} else {
< 		yaml_parser_set_scanner_error(parser, "while scanning a directive",
< 			start_mark, "found unknown directive name")
< 		return false
< 	}
< 
< 	// Eat the rest of the line including any comments.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	if parser.buffer[parser.buffer_pos] == '#' {
< 		// [Go] Discard this inline comment for the time being.
< 		//if !yaml_parser_scan_line_comment(parser, start_mark) {
< 		//	return false
< 		//}
< 		for !is_breakz(parser.buffer, parser.buffer_pos) {
< 			skip(parser)
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 	}
< 
< 	// Check if we are at the end of the line.
< 	if !is_breakz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a directive",
< 			start_mark, "did not find expected comment or line break")
< 		return false
< 	}
< 
< 	// Eat a line break.
< 	if is_break(parser.buffer, parser.buffer_pos) {
< 		if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 			return false
< 		}
< 		skip_line(parser)
< 	}
< 
< 	return true
< }
< 
< // Scan the directive name.
< //
< // Scope:
< //      %YAML   1.1     # a comment \n
< //       ^^^^
< //      %TAG    !yaml!  tag:yaml.org,2002:  \n
< //       ^^^
< //
< func yaml_parser_scan_directive_name(parser *yaml_parser_t, start_mark yaml_mark_t, name *[]byte) bool {
< 	// Consume the directive name.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	var s []byte
< 	for is_alpha(parser.buffer, parser.buffer_pos) {
< 		s = read(parser, s)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Check if the name is empty.
< 	if len(s) == 0 {
< 		yaml_parser_set_scanner_error(parser, "while scanning a directive",
< 			start_mark, "could not find expected directive name")
< 		return false
< 	}
< 
< 	// Check for an blank character after the name.
< 	if !is_blankz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a directive",
< 			start_mark, "found unexpected non-alphabetical character")
< 		return false
< 	}
< 	*name = s
< 	return true
< }
< 
< // Scan the value of VERSION-DIRECTIVE.
< //
< // Scope:
< //      %YAML   1.1     # a comment \n
< //           ^^^^^^
< func yaml_parser_scan_version_directive_value(parser *yaml_parser_t, start_mark yaml_mark_t, major, minor *int8) bool {
< 	// Eat whitespaces.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Consume the major version number.
< 	if !yaml_parser_scan_version_directive_number(parser, start_mark, major) {
< 		return false
< 	}
< 
< 	// Eat '.'.
< 	if parser.buffer[parser.buffer_pos] != '.' {
< 		return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
< 			start_mark, "did not find expected digit or '.' character")
< 	}
< 
< 	skip(parser)
< 
< 	// Consume the minor version number.
< 	if !yaml_parser_scan_version_directive_number(parser, start_mark, minor) {
< 		return false
< 	}
< 	return true
< }
< 
< const max_number_length = 2
< 
< // Scan the version number of VERSION-DIRECTIVE.
< //
< // Scope:
< //      %YAML   1.1     # a comment \n
< //              ^
< //      %YAML   1.1     # a comment \n
< //                ^
< func yaml_parser_scan_version_directive_number(parser *yaml_parser_t, start_mark yaml_mark_t, number *int8) bool {
< 
< 	// Repeat while the next character is digit.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	var value, length int8
< 	for is_digit(parser.buffer, parser.buffer_pos) {
< 		// Check if the number is too long.
< 		length++
< 		if length > max_number_length {
< 			return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
< 				start_mark, "found extremely long version number")
< 		}
< 		value = value*10 + int8(as_digit(parser.buffer, parser.buffer_pos))
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Check if the number was present.
< 	if length == 0 {
< 		return yaml_parser_set_scanner_error(parser, "while scanning a %YAML directive",
< 			start_mark, "did not find expected version number")
< 	}
< 	*number = value
< 	return true
< }
< 
< // Scan the value of a TAG-DIRECTIVE token.
< //
< // Scope:
< //      %TAG    !yaml!  tag:yaml.org,2002:  \n
< //          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
< //
< func yaml_parser_scan_tag_directive_value(parser *yaml_parser_t, start_mark yaml_mark_t, handle, prefix *[]byte) bool {
< 	var handle_value, prefix_value []byte
< 
< 	// Eat whitespaces.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Scan a handle.
< 	if !yaml_parser_scan_tag_handle(parser, true, start_mark, &handle_value) {
< 		return false
< 	}
< 
< 	// Expect a whitespace.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	if !is_blank(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a %TAG directive",
< 			start_mark, "did not find expected whitespace")
< 		return false
< 	}
< 
< 	// Eat whitespaces.
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Scan a prefix.
< 	if !yaml_parser_scan_tag_uri(parser, true, nil, start_mark, &prefix_value) {
< 		return false
< 	}
< 
< 	// Expect a whitespace or line break.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	if !is_blankz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a %TAG directive",
< 			start_mark, "did not find expected whitespace or line break")
< 		return false
< 	}
< 
< 	*handle = handle_value
< 	*prefix = prefix_value
< 	return true
< }
< 
< func yaml_parser_scan_anchor(parser *yaml_parser_t, token *yaml_token_t, typ yaml_token_type_t) bool {
< 	var s []byte
< 
< 	// Eat the indicator character.
< 	start_mark := parser.mark
< 	skip(parser)
< 
< 	// Consume the value.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	for is_alpha(parser.buffer, parser.buffer_pos) {
< 		s = read(parser, s)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	end_mark := parser.mark
< 
< 	/*
< 	 * Check if length of the anchor is greater than 0 and it is followed by
< 	 * a whitespace character or one of the indicators:
< 	 *
< 	 *      '?', ':', ',', ']', '}', '%', '@', '`'.
< 	 */
< 
< 	if len(s) == 0 ||
< 		!(is_blankz(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == '?' ||
< 			parser.buffer[parser.buffer_pos] == ':' || parser.buffer[parser.buffer_pos] == ',' ||
< 			parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '}' ||
< 			parser.buffer[parser.buffer_pos] == '%' || parser.buffer[parser.buffer_pos] == '@' ||
< 			parser.buffer[parser.buffer_pos] == '`') {
< 		context := "while scanning an alias"
< 		if typ == yaml_ANCHOR_TOKEN {
< 			context = "while scanning an anchor"
< 		}
< 		yaml_parser_set_scanner_error(parser, context, start_mark,
< 			"did not find expected alphabetic or numeric character")
< 		return false
< 	}
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        typ,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      s,
< 	}
< 
< 	return true
< }
< 
< /*
<  * Scan a TAG token.
<  */
< 
< func yaml_parser_scan_tag(parser *yaml_parser_t, token *yaml_token_t) bool {
< 	var handle, suffix []byte
< 
< 	start_mark := parser.mark
< 
< 	// Check if the tag is in the canonical form.
< 	if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 		return false
< 	}
< 
< 	if parser.buffer[parser.buffer_pos+1] == '<' {
< 		// Keep the handle as ''
< 
< 		// Eat '!<'
< 		skip(parser)
< 		skip(parser)
< 
< 		// Consume the tag value.
< 		if !yaml_parser_scan_tag_uri(parser, false, nil, start_mark, &suffix) {
< 			return false
< 		}
< 
< 		// Check for '>' and eat it.
< 		if parser.buffer[parser.buffer_pos] != '>' {
< 			yaml_parser_set_scanner_error(parser, "while scanning a tag",
< 				start_mark, "did not find the expected '>'")
< 			return false
< 		}
< 
< 		skip(parser)
< 	} else {
< 		// The tag has either the '!suffix' or the '!handle!suffix' form.
< 
< 		// First, try to scan a handle.
< 		if !yaml_parser_scan_tag_handle(parser, false, start_mark, &handle) {
< 			return false
< 		}
< 
< 		// Check if it is, indeed, handle.
< 		if handle[0] == '!' && len(handle) > 1 && handle[len(handle)-1] == '!' {
< 			// Scan the suffix now.
< 			if !yaml_parser_scan_tag_uri(parser, false, nil, start_mark, &suffix) {
< 				return false
< 			}
< 		} else {
< 			// It wasn't a handle after all.  Scan the rest of the tag.
< 			if !yaml_parser_scan_tag_uri(parser, false, handle, start_mark, &suffix) {
< 				return false
< 			}
< 
< 			// Set the handle to '!'.
< 			handle = []byte{'!'}
< 
< 			// A special case: the '!' tag.  Set the handle to '' and the
< 			// suffix to '!'.
< 			if len(suffix) == 0 {
< 				handle, suffix = suffix, handle
< 			}
< 		}
< 	}
< 
< 	// Check the character which ends the tag.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	if !is_blankz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a tag",
< 			start_mark, "did not find expected whitespace or line break")
< 		return false
< 	}
< 
< 	end_mark := parser.mark
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        yaml_TAG_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      handle,
< 		suffix:     suffix,
< 	}
< 	return true
< }
< 
< // Scan a tag handle.
< func yaml_parser_scan_tag_handle(parser *yaml_parser_t, directive bool, start_mark yaml_mark_t, handle *[]byte) bool {
< 	// Check the initial '!' character.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	if parser.buffer[parser.buffer_pos] != '!' {
< 		yaml_parser_set_scanner_tag_error(parser, directive,
< 			start_mark, "did not find expected '!'")
< 		return false
< 	}
< 
< 	var s []byte
< 
< 	// Copy the '!' character.
< 	s = read(parser, s)
< 
< 	// Copy all subsequent alphabetical and numerical characters.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	for is_alpha(parser.buffer, parser.buffer_pos) {
< 		s = read(parser, s)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 
< 	// Check if the trailing character is '!' and copy it.
< 	if parser.buffer[parser.buffer_pos] == '!' {
< 		s = read(parser, s)
< 	} else {
< 		// It's either the '!' tag or not really a tag handle.  If it's a %TAG
< 		// directive, it's an error.  If it's a tag token, it must be a part of URI.
< 		if directive && string(s) != "!" {
< 			yaml_parser_set_scanner_tag_error(parser, directive,
< 				start_mark, "did not find expected '!'")
< 			return false
< 		}
< 	}
< 
< 	*handle = s
< 	return true
< }
< 
< // Scan a tag.
< func yaml_parser_scan_tag_uri(parser *yaml_parser_t, directive bool, head []byte, start_mark yaml_mark_t, uri *[]byte) bool {
< 	//size_t length = head ? strlen((char *)head) : 0
< 	var s []byte
< 	hasTag := len(head) > 0
< 
< 	// Copy the head if needed.
< 	//
< 	// Note that we don't copy the leading '!' character.
< 	if len(head) > 1 {
< 		s = append(s, head[1:]...)
< 	}
< 
< 	// Scan the tag.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	// The set of characters that may appear in URI is as follows:
< 	//
< 	//      '0'-'9', 'A'-'Z', 'a'-'z', '_', '-', ';', '/', '?', ':', '@', '&',
< 	//      '=', '+', '$', ',', '.', '!', '~', '*', '\'', '(', ')', '[', ']',
< 	//      '%'.
< 	// [Go] TODO Convert this into more reasonable logic.
< 	for is_alpha(parser.buffer, parser.buffer_pos) || parser.buffer[parser.buffer_pos] == ';' ||
< 		parser.buffer[parser.buffer_pos] == '/' || parser.buffer[parser.buffer_pos] == '?' ||
< 		parser.buffer[parser.buffer_pos] == ':' || parser.buffer[parser.buffer_pos] == '@' ||
< 		parser.buffer[parser.buffer_pos] == '&' || parser.buffer[parser.buffer_pos] == '=' ||
< 		parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '$' ||
< 		parser.buffer[parser.buffer_pos] == ',' || parser.buffer[parser.buffer_pos] == '.' ||
< 		parser.buffer[parser.buffer_pos] == '!' || parser.buffer[parser.buffer_pos] == '~' ||
< 		parser.buffer[parser.buffer_pos] == '*' || parser.buffer[parser.buffer_pos] == '\'' ||
< 		parser.buffer[parser.buffer_pos] == '(' || parser.buffer[parser.buffer_pos] == ')' ||
< 		parser.buffer[parser.buffer_pos] == '[' || parser.buffer[parser.buffer_pos] == ']' ||
< 		parser.buffer[parser.buffer_pos] == '%' {
< 		// Check if it is a URI-escape sequence.
< 		if parser.buffer[parser.buffer_pos] == '%' {
< 			if !yaml_parser_scan_uri_escapes(parser, directive, start_mark, &s) {
< 				return false
< 			}
< 		} else {
< 			s = read(parser, s)
< 		}
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		hasTag = true
< 	}
< 
< 	if !hasTag {
< 		yaml_parser_set_scanner_tag_error(parser, directive,
< 			start_mark, "did not find expected tag URI")
< 		return false
< 	}
< 	*uri = s
< 	return true
< }
< 
< // Decode an URI-escape sequence corresponding to a single UTF-8 character.
< func yaml_parser_scan_uri_escapes(parser *yaml_parser_t, directive bool, start_mark yaml_mark_t, s *[]byte) bool {
< 
< 	// Decode the required number of characters.
< 	w := 1024
< 	for w > 0 {
< 		// Check for a URI-escaped octet.
< 		if parser.unread < 3 && !yaml_parser_update_buffer(parser, 3) {
< 			return false
< 		}
< 
< 		if !(parser.buffer[parser.buffer_pos] == '%' &&
< 			is_hex(parser.buffer, parser.buffer_pos+1) &&
< 			is_hex(parser.buffer, parser.buffer_pos+2)) {
< 			return yaml_parser_set_scanner_tag_error(parser, directive,
< 				start_mark, "did not find URI escaped octet")
< 		}
< 
< 		// Get the octet.
< 		octet := byte((as_hex(parser.buffer, parser.buffer_pos+1) << 4) + as_hex(parser.buffer, parser.buffer_pos+2))
< 
< 		// If it is the leading octet, determine the length of the UTF-8 sequence.
< 		if w == 1024 {
< 			w = width(octet)
< 			if w == 0 {
< 				return yaml_parser_set_scanner_tag_error(parser, directive,
< 					start_mark, "found an incorrect leading UTF-8 octet")
< 			}
< 		} else {
< 			// Check if the trailing octet is correct.
< 			if octet&0xC0 != 0x80 {
< 				return yaml_parser_set_scanner_tag_error(parser, directive,
< 					start_mark, "found an incorrect trailing UTF-8 octet")
< 			}
< 		}
< 
< 		// Copy the octet and move the pointers.
< 		*s = append(*s, octet)
< 		skip(parser)
< 		skip(parser)
< 		skip(parser)
< 		w--
< 	}
< 	return true
< }
< 
< // Scan a block scalar.
< func yaml_parser_scan_block_scalar(parser *yaml_parser_t, token *yaml_token_t, literal bool) bool {
< 	// Eat the indicator '|' or '>'.
< 	start_mark := parser.mark
< 	skip(parser)
< 
< 	// Scan the additional block scalar indicators.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 
< 	// Check for a chomping indicator.
< 	var chomping, increment int
< 	if parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '-' {
< 		// Set the chomping method and eat the indicator.
< 		if parser.buffer[parser.buffer_pos] == '+' {
< 			chomping = +1
< 		} else {
< 			chomping = -1
< 		}
< 		skip(parser)
< 
< 		// Check for an indentation indicator.
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		if is_digit(parser.buffer, parser.buffer_pos) {
< 			// Check that the indentation is greater than 0.
< 			if parser.buffer[parser.buffer_pos] == '0' {
< 				yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
< 					start_mark, "found an indentation indicator equal to 0")
< 				return false
< 			}
< 
< 			// Get the indentation level and eat the indicator.
< 			increment = as_digit(parser.buffer, parser.buffer_pos)
< 			skip(parser)
< 		}
< 
< 	} else if is_digit(parser.buffer, parser.buffer_pos) {
< 		// Do the same as above, but in the opposite order.
< 
< 		if parser.buffer[parser.buffer_pos] == '0' {
< 			yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
< 				start_mark, "found an indentation indicator equal to 0")
< 			return false
< 		}
< 		increment = as_digit(parser.buffer, parser.buffer_pos)
< 		skip(parser)
< 
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		if parser.buffer[parser.buffer_pos] == '+' || parser.buffer[parser.buffer_pos] == '-' {
< 			if parser.buffer[parser.buffer_pos] == '+' {
< 				chomping = +1
< 			} else {
< 				chomping = -1
< 			}
< 			skip(parser)
< 		}
< 	}
< 
< 	// Eat whitespaces and comments to the end of the line.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	for is_blank(parser.buffer, parser.buffer_pos) {
< 		skip(parser)
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 	}
< 	if parser.buffer[parser.buffer_pos] == '#' {
< 		if !yaml_parser_scan_line_comment(parser, start_mark) {
< 			return false
< 		}
< 	}
< 
< 	// Check if we are at the end of the line.
< 	if !is_breakz(parser.buffer, parser.buffer_pos) {
< 		yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
< 			start_mark, "did not find expected comment or line break")
< 		return false
< 	}
< 
< 	// Eat a line break.
< 	if is_break(parser.buffer, parser.buffer_pos) {
< 		if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 			return false
< 		}
< 		skip_line(parser)
< 	}
< 
< 	end_mark := parser.mark
< 
< 	// Set the indentation level if it was specified.
< 	var indent int
< 	if increment > 0 {
< 		if parser.indent >= 0 {
< 			indent = parser.indent + increment
< 		} else {
< 			indent = increment
< 		}
< 	}
< 
< 	// Scan the leading line breaks and determine the indentation level if needed.
< 	var s, leading_break, trailing_breaks []byte
< 	if !yaml_parser_scan_block_scalar_breaks(parser, &indent, &trailing_breaks, start_mark, &end_mark) {
< 		return false
< 	}
< 
< 	// Scan the block scalar content.
< 	if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 		return false
< 	}
< 	var leading_blank, trailing_blank bool
< 	for parser.mark.column == indent && !is_z(parser.buffer, parser.buffer_pos) {
< 		// We are at the beginning of a non-empty line.
< 
< 		// Is it a trailing whitespace?
< 		trailing_blank = is_blank(parser.buffer, parser.buffer_pos)
< 
< 		// Check if we need to fold the leading line break.
< 		if !literal && !leading_blank && !trailing_blank && len(leading_break) > 0 && leading_break[0] == '\n' {
< 			// Do we need to join the lines by space?
< 			if len(trailing_breaks) == 0 {
< 				s = append(s, ' ')
< 			}
< 		} else {
< 			s = append(s, leading_break...)
< 		}
< 		leading_break = leading_break[:0]
< 
< 		// Append the remaining line breaks.
< 		s = append(s, trailing_breaks...)
< 		trailing_breaks = trailing_breaks[:0]
< 
< 		// Is it a leading whitespace?
< 		leading_blank = is_blank(parser.buffer, parser.buffer_pos)
< 
< 		// Consume the current line.
< 		for !is_breakz(parser.buffer, parser.buffer_pos) {
< 			s = read(parser, s)
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 
< 		// Consume the line break.
< 		if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 			return false
< 		}
< 
< 		leading_break = read_line(parser, leading_break)
< 
< 		// Eat the following indentation spaces and line breaks.
< 		if !yaml_parser_scan_block_scalar_breaks(parser, &indent, &trailing_breaks, start_mark, &end_mark) {
< 			return false
< 		}
< 	}
< 
< 	// Chomp the tail.
< 	if chomping != -1 {
< 		s = append(s, leading_break...)
< 	}
< 	if chomping == 1 {
< 		s = append(s, trailing_breaks...)
< 	}
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        yaml_SCALAR_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      s,
< 		style:      yaml_LITERAL_SCALAR_STYLE,
< 	}
< 	if !literal {
< 		token.style = yaml_FOLDED_SCALAR_STYLE
< 	}
< 	return true
< }
< 
< // Scan indentation spaces and line breaks for a block scalar.  Determine the
< // indentation level if needed.
< func yaml_parser_scan_block_scalar_breaks(parser *yaml_parser_t, indent *int, breaks *[]byte, start_mark yaml_mark_t, end_mark *yaml_mark_t) bool {
< 	*end_mark = parser.mark
< 
< 	// Eat the indentation spaces and line breaks.
< 	max_indent := 0
< 	for {
< 		// Eat the indentation spaces.
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 		for (*indent == 0 || parser.mark.column < *indent) && is_space(parser.buffer, parser.buffer_pos) {
< 			skip(parser)
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 		if parser.mark.column > max_indent {
< 			max_indent = parser.mark.column
< 		}
< 
< 		// Check for a tab character messing the indentation.
< 		if (*indent == 0 || parser.mark.column < *indent) && is_tab(parser.buffer, parser.buffer_pos) {
< 			return yaml_parser_set_scanner_error(parser, "while scanning a block scalar",
< 				start_mark, "found a tab character where an indentation space is expected")
< 		}
< 
< 		// Have we found a non-empty line?
< 		if !is_break(parser.buffer, parser.buffer_pos) {
< 			break
< 		}
< 
< 		// Consume the line break.
< 		if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 			return false
< 		}
< 		// [Go] Should really be returning breaks instead.
< 		*breaks = read_line(parser, *breaks)
< 		*end_mark = parser.mark
< 	}
< 
< 	// Determine the indentation level if needed.
< 	if *indent == 0 {
< 		*indent = max_indent
< 		if *indent < parser.indent+1 {
< 			*indent = parser.indent + 1
< 		}
< 		if *indent < 1 {
< 			*indent = 1
< 		}
< 	}
< 	return true
< }
< 
< // Scan a quoted scalar.
< func yaml_parser_scan_flow_scalar(parser *yaml_parser_t, token *yaml_token_t, single bool) bool {
< 	// Eat the left quote.
< 	start_mark := parser.mark
< 	skip(parser)
< 
< 	// Consume the content of the quoted scalar.
< 	var s, leading_break, trailing_breaks, whitespaces []byte
< 	for {
< 		// Check that there are no document indicators at the beginning of the line.
< 		if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
< 			return false
< 		}
< 
< 		if parser.mark.column == 0 &&
< 			((parser.buffer[parser.buffer_pos+0] == '-' &&
< 				parser.buffer[parser.buffer_pos+1] == '-' &&
< 				parser.buffer[parser.buffer_pos+2] == '-') ||
< 				(parser.buffer[parser.buffer_pos+0] == '.' &&
< 					parser.buffer[parser.buffer_pos+1] == '.' &&
< 					parser.buffer[parser.buffer_pos+2] == '.')) &&
< 			is_blankz(parser.buffer, parser.buffer_pos+3) {
< 			yaml_parser_set_scanner_error(parser, "while scanning a quoted scalar",
< 				start_mark, "found unexpected document indicator")
< 			return false
< 		}
< 
< 		// Check for EOF.
< 		if is_z(parser.buffer, parser.buffer_pos) {
< 			yaml_parser_set_scanner_error(parser, "while scanning a quoted scalar",
< 				start_mark, "found unexpected end of stream")
< 			return false
< 		}
< 
< 		// Consume non-blank characters.
< 		leading_blanks := false
< 		for !is_blankz(parser.buffer, parser.buffer_pos) {
< 			if single && parser.buffer[parser.buffer_pos] == '\'' && parser.buffer[parser.buffer_pos+1] == '\'' {
< 				// Is is an escaped single quote.
< 				s = append(s, '\'')
< 				skip(parser)
< 				skip(parser)
< 
< 			} else if single && parser.buffer[parser.buffer_pos] == '\'' {
< 				// It is a right single quote.
< 				break
< 			} else if !single && parser.buffer[parser.buffer_pos] == '"' {
< 				// It is a right double quote.
< 				break
< 
< 			} else if !single && parser.buffer[parser.buffer_pos] == '\\' && is_break(parser.buffer, parser.buffer_pos+1) {
< 				// It is an escaped line break.
< 				if parser.unread < 3 && !yaml_parser_update_buffer(parser, 3) {
< 					return false
< 				}
< 				skip(parser)
< 				skip_line(parser)
< 				leading_blanks = true
< 				break
< 
< 			} else if !single && parser.buffer[parser.buffer_pos] == '\\' {
< 				// It is an escape sequence.
< 				code_length := 0
< 
< 				// Check the escape character.
< 				switch parser.buffer[parser.buffer_pos+1] {
< 				case '0':
< 					s = append(s, 0)
< 				case 'a':
< 					s = append(s, '\x07')
< 				case 'b':
< 					s = append(s, '\x08')
< 				case 't', '\t':
< 					s = append(s, '\x09')
< 				case 'n':
< 					s = append(s, '\x0A')
< 				case 'v':
< 					s = append(s, '\x0B')
< 				case 'f':
< 					s = append(s, '\x0C')
< 				case 'r':
< 					s = append(s, '\x0D')
< 				case 'e':
< 					s = append(s, '\x1B')
< 				case ' ':
< 					s = append(s, '\x20')
< 				case '"':
< 					s = append(s, '"')
< 				case '\'':
< 					s = append(s, '\'')
< 				case '\\':
< 					s = append(s, '\\')
< 				case 'N': // NEL (#x85)
< 					s = append(s, '\xC2')
< 					s = append(s, '\x85')
< 				case '_': // #xA0
< 					s = append(s, '\xC2')
< 					s = append(s, '\xA0')
< 				case 'L': // LS (#x2028)
< 					s = append(s, '\xE2')
< 					s = append(s, '\x80')
< 					s = append(s, '\xA8')
< 				case 'P': // PS (#x2029)
< 					s = append(s, '\xE2')
< 					s = append(s, '\x80')
< 					s = append(s, '\xA9')
< 				case 'x':
< 					code_length = 2
< 				case 'u':
< 					code_length = 4
< 				case 'U':
< 					code_length = 8
< 				default:
< 					yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
< 						start_mark, "found unknown escape character")
< 					return false
< 				}
< 
< 				skip(parser)
< 				skip(parser)
< 
< 				// Consume an arbitrary escape code.
< 				if code_length > 0 {
< 					var value int
< 
< 					// Scan the character value.
< 					if parser.unread < code_length && !yaml_parser_update_buffer(parser, code_length) {
< 						return false
< 					}
< 					for k := 0; k < code_length; k++ {
< 						if !is_hex(parser.buffer, parser.buffer_pos+k) {
< 							yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
< 								start_mark, "did not find expected hexdecimal number")
< 							return false
< 						}
< 						value = (value << 4) + as_hex(parser.buffer, parser.buffer_pos+k)
< 					}
< 
< 					// Check the value and write the character.
< 					if (value >= 0xD800 && value <= 0xDFFF) || value > 0x10FFFF {
< 						yaml_parser_set_scanner_error(parser, "while parsing a quoted scalar",
< 							start_mark, "found invalid Unicode character escape code")
< 						return false
< 					}
< 					if value <= 0x7F {
< 						s = append(s, byte(value))
< 					} else if value <= 0x7FF {
< 						s = append(s, byte(0xC0+(value>>6)))
< 						s = append(s, byte(0x80+(value&0x3F)))
< 					} else if value <= 0xFFFF {
< 						s = append(s, byte(0xE0+(value>>12)))
< 						s = append(s, byte(0x80+((value>>6)&0x3F)))
< 						s = append(s, byte(0x80+(value&0x3F)))
< 					} else {
< 						s = append(s, byte(0xF0+(value>>18)))
< 						s = append(s, byte(0x80+((value>>12)&0x3F)))
< 						s = append(s, byte(0x80+((value>>6)&0x3F)))
< 						s = append(s, byte(0x80+(value&0x3F)))
< 					}
< 
< 					// Advance the pointer.
< 					for k := 0; k < code_length; k++ {
< 						skip(parser)
< 					}
< 				}
< 			} else {
< 				// It is a non-escaped non-blank character.
< 				s = read(parser, s)
< 			}
< 			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 				return false
< 			}
< 		}
< 
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 
< 		// Check if we are at the end of the scalar.
< 		if single {
< 			if parser.buffer[parser.buffer_pos] == '\'' {
< 				break
< 			}
< 		} else {
< 			if parser.buffer[parser.buffer_pos] == '"' {
< 				break
< 			}
< 		}
< 
< 		// Consume blank characters.
< 		for is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos) {
< 			if is_blank(parser.buffer, parser.buffer_pos) {
< 				// Consume a space or a tab character.
< 				if !leading_blanks {
< 					whitespaces = read(parser, whitespaces)
< 				} else {
< 					skip(parser)
< 				}
< 			} else {
< 				if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 					return false
< 				}
< 
< 				// Check if it is a first line break.
< 				if !leading_blanks {
< 					whitespaces = whitespaces[:0]
< 					leading_break = read_line(parser, leading_break)
< 					leading_blanks = true
< 				} else {
< 					trailing_breaks = read_line(parser, trailing_breaks)
< 				}
< 			}
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 
< 		// Join the whitespaces or fold line breaks.
< 		if leading_blanks {
< 			// Do we need to fold line breaks?
< 			if len(leading_break) > 0 && leading_break[0] == '\n' {
< 				if len(trailing_breaks) == 0 {
< 					s = append(s, ' ')
< 				} else {
< 					s = append(s, trailing_breaks...)
< 				}
< 			} else {
< 				s = append(s, leading_break...)
< 				s = append(s, trailing_breaks...)
< 			}
< 			trailing_breaks = trailing_breaks[:0]
< 			leading_break = leading_break[:0]
< 		} else {
< 			s = append(s, whitespaces...)
< 			whitespaces = whitespaces[:0]
< 		}
< 	}
< 
< 	// Eat the right quote.
< 	skip(parser)
< 	end_mark := parser.mark
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        yaml_SCALAR_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      s,
< 		style:      yaml_SINGLE_QUOTED_SCALAR_STYLE,
< 	}
< 	if !single {
< 		token.style = yaml_DOUBLE_QUOTED_SCALAR_STYLE
< 	}
< 	return true
< }
< 
< // Scan a plain scalar.
< func yaml_parser_scan_plain_scalar(parser *yaml_parser_t, token *yaml_token_t) bool {
< 
< 	var s, leading_break, trailing_breaks, whitespaces []byte
< 	var leading_blanks bool
< 	var indent = parser.indent + 1
< 
< 	start_mark := parser.mark
< 	end_mark := parser.mark
< 
< 	// Consume the content of the plain scalar.
< 	for {
< 		// Check for a document indicator.
< 		if parser.unread < 4 && !yaml_parser_update_buffer(parser, 4) {
< 			return false
< 		}
< 		if parser.mark.column == 0 &&
< 			((parser.buffer[parser.buffer_pos+0] == '-' &&
< 				parser.buffer[parser.buffer_pos+1] == '-' &&
< 				parser.buffer[parser.buffer_pos+2] == '-') ||
< 				(parser.buffer[parser.buffer_pos+0] == '.' &&
< 					parser.buffer[parser.buffer_pos+1] == '.' &&
< 					parser.buffer[parser.buffer_pos+2] == '.')) &&
< 			is_blankz(parser.buffer, parser.buffer_pos+3) {
< 			break
< 		}
< 
< 		// Check for a comment.
< 		if parser.buffer[parser.buffer_pos] == '#' {
< 			break
< 		}
< 
< 		// Consume non-blank characters.
< 		for !is_blankz(parser.buffer, parser.buffer_pos) {
< 
< 			// Check for indicators that may end a plain scalar.
< 			if (parser.buffer[parser.buffer_pos] == ':' && is_blankz(parser.buffer, parser.buffer_pos+1)) ||
< 				(parser.flow_level > 0 &&
< 					(parser.buffer[parser.buffer_pos] == ',' ||
< 						parser.buffer[parser.buffer_pos] == '?' || parser.buffer[parser.buffer_pos] == '[' ||
< 						parser.buffer[parser.buffer_pos] == ']' || parser.buffer[parser.buffer_pos] == '{' ||
< 						parser.buffer[parser.buffer_pos] == '}')) {
< 				break
< 			}
< 
< 			// Check if we need to join whitespaces and breaks.
< 			if leading_blanks || len(whitespaces) > 0 {
< 				if leading_blanks {
< 					// Do we need to fold line breaks?
< 					if leading_break[0] == '\n' {
< 						if len(trailing_breaks) == 0 {
< 							s = append(s, ' ')
< 						} else {
< 							s = append(s, trailing_breaks...)
< 						}
< 					} else {
< 						s = append(s, leading_break...)
< 						s = append(s, trailing_breaks...)
< 					}
< 					trailing_breaks = trailing_breaks[:0]
< 					leading_break = leading_break[:0]
< 					leading_blanks = false
< 				} else {
< 					s = append(s, whitespaces...)
< 					whitespaces = whitespaces[:0]
< 				}
< 			}
< 
< 			// Copy the character.
< 			s = read(parser, s)
< 
< 			end_mark = parser.mark
< 			if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 				return false
< 			}
< 		}
< 
< 		// Is it the end?
< 		if !(is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos)) {
< 			break
< 		}
< 
< 		// Consume blank characters.
< 		if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 			return false
< 		}
< 
< 		for is_blank(parser.buffer, parser.buffer_pos) || is_break(parser.buffer, parser.buffer_pos) {
< 			if is_blank(parser.buffer, parser.buffer_pos) {
< 
< 				// Check for tab characters that abuse indentation.
< 				if leading_blanks && parser.mark.column < indent && is_tab(parser.buffer, parser.buffer_pos) {
< 					yaml_parser_set_scanner_error(parser, "while scanning a plain scalar",
< 						start_mark, "found a tab character that violates indentation")
< 					return false
< 				}
< 
< 				// Consume a space or a tab character.
< 				if !leading_blanks {
< 					whitespaces = read(parser, whitespaces)
< 				} else {
< 					skip(parser)
< 				}
< 			} else {
< 				if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 					return false
< 				}
< 
< 				// Check if it is a first line break.
< 				if !leading_blanks {
< 					whitespaces = whitespaces[:0]
< 					leading_break = read_line(parser, leading_break)
< 					leading_blanks = true
< 				} else {
< 					trailing_breaks = read_line(parser, trailing_breaks)
< 				}
< 			}
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 		}
< 
< 		// Check indentation level.
< 		if parser.flow_level == 0 && parser.mark.column < indent {
< 			break
< 		}
< 	}
< 
< 	// Create a token.
< 	*token = yaml_token_t{
< 		typ:        yaml_SCALAR_TOKEN,
< 		start_mark: start_mark,
< 		end_mark:   end_mark,
< 		value:      s,
< 		style:      yaml_PLAIN_SCALAR_STYLE,
< 	}
< 
< 	// Note that we change the 'simple_key_allowed' flag.
< 	if leading_blanks {
< 		parser.simple_key_allowed = true
< 	}
< 	return true
< }
< 
< func yaml_parser_scan_line_comment(parser *yaml_parser_t, token_mark yaml_mark_t) bool {
< 	if parser.newlines > 0 {
< 		return true
< 	}
< 
< 	parser.comments = append(parser.comments, yaml_comment_t{token_mark: token_mark})
< 	comment := &parser.comments[len(parser.comments)-1].line
< 
< 	for peek := 0; peek < 512; peek++ {
< 		if parser.unread < peek+1 && !yaml_parser_update_buffer(parser, peek+1) {
< 			break
< 		}
< 		if is_blank(parser.buffer, parser.buffer_pos+peek) {
< 			continue
< 		}
< 		if parser.buffer[parser.buffer_pos+peek] == '#' {
< 			if len(*comment) > 0 {
< 				*comment = append(*comment, '\n')
< 			}
< 
< 			// Consume until after the consumed comment line.
< 			seen := parser.mark.index+peek
< 			for {
< 				if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 					return false
< 				}
< 				if is_breakz(parser.buffer, parser.buffer_pos) {
< 					if parser.mark.index >= seen {
< 						break
< 					}
< 					if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 						return false
< 					}
< 					skip_line(parser)
< 				} else {
< 					if parser.mark.index >= seen {
< 						*comment = append(*comment, parser.buffer[parser.buffer_pos])
< 					}
< 					skip(parser)
< 				}
< 			}
< 		}
< 		break
< 	}
< 	return true
< }
< 
< func yaml_parser_scan_comments(parser *yaml_parser_t, scan_mark yaml_mark_t) bool {
< 	token := parser.tokens[len(parser.tokens)-1]
< 
< 	if token.typ == yaml_FLOW_ENTRY_TOKEN && len(parser.tokens) > 1 {
< 		token = parser.tokens[len(parser.tokens)-2]
< 	}
< 
< 	var token_mark = token.start_mark
< 	var start_mark yaml_mark_t
< 
< 	var recent_empty = false
< 	var first_empty = parser.newlines <= 1
< 
< 	var line = parser.mark.line
< 	var column = parser.mark.column
< 
< 	var text []byte
< 
< 	// The foot line is the place where a comment must start to
< 	// still be considered as a foot of the prior content.
< 	// If there's some content in the currently parsed line, then
< 	// the foot is the line below it.
< 	var foot_line = -1
< 	if scan_mark.line > 0 {
< 		foot_line = parser.mark.line-parser.newlines+1
< 		if parser.newlines == 0 && parser.mark.column > 1 {
< 			foot_line++
< 		}
< 	}
< 
< 	var peek = 0
< 	for ; peek < 512; peek++ {
< 		if parser.unread < peek+1 && !yaml_parser_update_buffer(parser, peek+1) {
< 			break
< 		}
< 		column++
< 		if is_blank(parser.buffer, parser.buffer_pos+peek) {
< 			continue
< 		}
< 		c := parser.buffer[parser.buffer_pos+peek]
< 		if is_breakz(parser.buffer, parser.buffer_pos+peek) || parser.flow_level > 0 && (c == ']' || c == '}') {
< 			// Got line break or terminator.
< 			if !recent_empty {
< 				if first_empty && (start_mark.line == foot_line || start_mark.column-1 < parser.indent) {
< 					// This is the first empty line and there were no empty lines before,
< 					// so this initial part of the comment is a foot of the prior token
< 					// instead of being a head for the following one. Split it up.
< 					if len(text) > 0 {
< 						if start_mark.column-1 < parser.indent {
< 							// If dedented it's unrelated to the prior token.
< 							token_mark = start_mark
< 						}
< 						parser.comments = append(parser.comments, yaml_comment_t{
< 							scan_mark:  scan_mark,
< 							token_mark: token_mark,
< 							start_mark: start_mark,
< 							end_mark:   yaml_mark_t{parser.mark.index + peek, line, column},
< 							foot:       text,
< 						})
< 						scan_mark = yaml_mark_t{parser.mark.index + peek, line, column}
< 						token_mark = scan_mark
< 						text = nil
< 					}
< 				} else {
< 					if len(text) > 0 && parser.buffer[parser.buffer_pos+peek] != 0 {
< 						text = append(text, '\n')
< 					}
< 				}
< 			}
< 			if !is_break(parser.buffer, parser.buffer_pos+peek) {
< 				break
< 			}
< 			first_empty = false
< 			recent_empty = true
< 			column = 0
< 			line++
< 			continue
< 		}
< 
< 		if len(text) > 0 && column < parser.indent+1 && column != start_mark.column {
< 			// The comment at the different indentation is a foot of the
< 			// preceding data rather than a head of the upcoming one.
< 			parser.comments = append(parser.comments, yaml_comment_t{
< 				scan_mark:  scan_mark,
< 				token_mark: token_mark,
< 				start_mark: start_mark,
< 				end_mark:   yaml_mark_t{parser.mark.index + peek, line, column},
< 				foot:       text,
< 			})
< 			scan_mark = yaml_mark_t{parser.mark.index + peek, line, column}
< 			token_mark = scan_mark
< 			text = nil
< 		}
< 
< 		if parser.buffer[parser.buffer_pos+peek] != '#' {
< 			break
< 		}
< 
< 		if len(text) == 0 {
< 			start_mark = yaml_mark_t{parser.mark.index + peek, line, column}
< 		} else {
< 			text = append(text, '\n')
< 		}
< 
< 		recent_empty = false
< 
< 		// Consume until after the consumed comment line.
< 		seen := parser.mark.index+peek
< 		for {
< 			if parser.unread < 1 && !yaml_parser_update_buffer(parser, 1) {
< 				return false
< 			}
< 			if is_breakz(parser.buffer, parser.buffer_pos) {
< 				if parser.mark.index >= seen {
< 					break
< 				}
< 				if parser.unread < 2 && !yaml_parser_update_buffer(parser, 2) {
< 					return false
< 				}
< 				skip_line(parser)
< 			} else {
< 				if parser.mark.index >= seen {
< 					text = append(text, parser.buffer[parser.buffer_pos])
< 				}
< 				skip(parser)
< 			}
< 		}
< 
< 		peek = 0
< 		column = 0
< 		line = parser.mark.line
< 	}
< 
< 	if len(text) > 0 {
< 		parser.comments = append(parser.comments, yaml_comment_t{
< 			scan_mark:  scan_mark,
< 			token_mark: start_mark,
< 			start_mark: start_mark,
< 			end_mark:   yaml_mark_t{parser.mark.index + peek - 1, line, column},
< 			head:       text,
< 		})
< 	}
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/sorter.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/sorter.go
1,134d0
< //
< // Copyright (c) 2011-2019 Canonical Ltd
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< package yaml
< 
< import (
< 	"reflect"
< 	"unicode"
< )
< 
< type keyList []reflect.Value
< 
< func (l keyList) Len() int      { return len(l) }
< func (l keyList) Swap(i, j int) { l[i], l[j] = l[j], l[i] }
< func (l keyList) Less(i, j int) bool {
< 	a := l[i]
< 	b := l[j]
< 	ak := a.Kind()
< 	bk := b.Kind()
< 	for (ak == reflect.Interface || ak == reflect.Ptr) && !a.IsNil() {
< 		a = a.Elem()
< 		ak = a.Kind()
< 	}
< 	for (bk == reflect.Interface || bk == reflect.Ptr) && !b.IsNil() {
< 		b = b.Elem()
< 		bk = b.Kind()
< 	}
< 	af, aok := keyFloat(a)
< 	bf, bok := keyFloat(b)
< 	if aok && bok {
< 		if af != bf {
< 			return af < bf
< 		}
< 		if ak != bk {
< 			return ak < bk
< 		}
< 		return numLess(a, b)
< 	}
< 	if ak != reflect.String || bk != reflect.String {
< 		return ak < bk
< 	}
< 	ar, br := []rune(a.String()), []rune(b.String())
< 	digits := false
< 	for i := 0; i < len(ar) && i < len(br); i++ {
< 		if ar[i] == br[i] {
< 			digits = unicode.IsDigit(ar[i])
< 			continue
< 		}
< 		al := unicode.IsLetter(ar[i])
< 		bl := unicode.IsLetter(br[i])
< 		if al && bl {
< 			return ar[i] < br[i]
< 		}
< 		if al || bl {
< 			if digits {
< 				return al
< 			} else {
< 				return bl
< 			}
< 		}
< 		var ai, bi int
< 		var an, bn int64
< 		if ar[i] == '0' || br[i] == '0' {
< 			for j := i - 1; j >= 0 && unicode.IsDigit(ar[j]); j-- {
< 				if ar[j] != '0' {
< 					an = 1
< 					bn = 1
< 					break
< 				}
< 			}
< 		}
< 		for ai = i; ai < len(ar) && unicode.IsDigit(ar[ai]); ai++ {
< 			an = an*10 + int64(ar[ai]-'0')
< 		}
< 		for bi = i; bi < len(br) && unicode.IsDigit(br[bi]); bi++ {
< 			bn = bn*10 + int64(br[bi]-'0')
< 		}
< 		if an != bn {
< 			return an < bn
< 		}
< 		if ai != bi {
< 			return ai < bi
< 		}
< 		return ar[i] < br[i]
< 	}
< 	return len(ar) < len(br)
< }
< 
< // keyFloat returns a float value for v if it is a number/bool
< // and whether it is a number/bool or not.
< func keyFloat(v reflect.Value) (f float64, ok bool) {
< 	switch v.Kind() {
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return float64(v.Int()), true
< 	case reflect.Float32, reflect.Float64:
< 		return v.Float(), true
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return float64(v.Uint()), true
< 	case reflect.Bool:
< 		if v.Bool() {
< 			return 1, true
< 		}
< 		return 0, true
< 	}
< 	return 0, false
< }
< 
< // numLess returns whether a < b.
< // a and b must necessarily have the same kind.
< func numLess(a, b reflect.Value) bool {
< 	switch a.Kind() {
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return a.Int() < b.Int()
< 	case reflect.Float32, reflect.Float64:
< 		return a.Float() < b.Float()
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return a.Uint() < b.Uint()
< 	case reflect.Bool:
< 		return !a.Bool() && b.Bool()
< 	}
< 	panic("not a number")
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/writerc.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/writerc.go
1,48d0
< // 
< // Copyright (c) 2011-2019 Canonical Ltd
< // Copyright (c) 2006-2010 Kirill Simonov
< // 
< // Permission is hereby granted, free of charge, to any person obtaining a copy of
< // this software and associated documentation files (the "Software"), to deal in
< // the Software without restriction, including without limitation the rights to
< // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< // of the Software, and to permit persons to whom the Software is furnished to do
< // so, subject to the following conditions:
< // 
< // The above copyright notice and this permission notice shall be included in all
< // copies or substantial portions of the Software.
< // 
< // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< // SOFTWARE.
< 
< package yaml
< 
< // Set the writer error and return false.
< func yaml_emitter_set_writer_error(emitter *yaml_emitter_t, problem string) bool {
< 	emitter.error = yaml_WRITER_ERROR
< 	emitter.problem = problem
< 	return false
< }
< 
< // Flush the output buffer.
< func yaml_emitter_flush(emitter *yaml_emitter_t) bool {
< 	if emitter.write_handler == nil {
< 		panic("write handler not set")
< 	}
< 
< 	// Check if the buffer is empty.
< 	if emitter.buffer_pos == 0 {
< 		return true
< 	}
< 
< 	if err := emitter.write_handler(emitter, emitter.buffer[:emitter.buffer_pos]); err != nil {
< 		return yaml_emitter_set_writer_error(emitter, "write error: "+err.Error())
< 	}
< 	emitter.buffer_pos = 0
< 	return true
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/yaml.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/yaml.go
1,662d0
< //
< // Copyright (c) 2011-2019 Canonical Ltd
< //
< // Licensed under the Apache License, Version 2.0 (the "License");
< // you may not use this file except in compliance with the License.
< // You may obtain a copy of the License at
< //
< //     http://www.apache.org/licenses/LICENSE-2.0
< //
< // Unless required by applicable law or agreed to in writing, software
< // distributed under the License is distributed on an "AS IS" BASIS,
< // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
< // See the License for the specific language governing permissions and
< // limitations under the License.
< 
< // Package yaml implements YAML support for the Go language.
< //
< // Source code and other details for the project are available at GitHub:
< //
< //   https://github.com/go-yaml/yaml
< //
< package yaml
< 
< import (
< 	"errors"
< 	"fmt"
< 	"io"
< 	"reflect"
< 	"strings"
< 	"sync"
< 	"unicode/utf8"
< )
< 
< // The Unmarshaler interface may be implemented by types to customize their
< // behavior when being unmarshaled from a YAML document.
< type Unmarshaler interface {
< 	UnmarshalYAML(value *Node) error
< }
< 
< type obsoleteUnmarshaler interface {
< 	UnmarshalYAML(unmarshal func(interface{}) error) error
< }
< 
< // The Marshaler interface may be implemented by types to customize their
< // behavior when being marshaled into a YAML document. The returned value
< // is marshaled in place of the original value implementing Marshaler.
< //
< // If an error is returned by MarshalYAML, the marshaling procedure stops
< // and returns with the provided error.
< type Marshaler interface {
< 	MarshalYAML() (interface{}, error)
< }
< 
< // Unmarshal decodes the first document found within the in byte slice
< // and assigns decoded values into the out value.
< //
< // Maps and pointers (to a struct, string, int, etc) are accepted as out
< // values. If an internal pointer within a struct is not initialized,
< // the yaml package will initialize it if necessary for unmarshalling
< // the provided data. The out parameter must not be nil.
< //
< // The type of the decoded values should be compatible with the respective
< // values in out. If one or more values cannot be decoded due to a type
< // mismatches, decoding continues partially until the end of the YAML
< // content, and a *yaml.TypeError is returned with details for all
< // missed values.
< //
< // Struct fields are only unmarshalled if they are exported (have an
< // upper case first letter), and are unmarshalled using the field name
< // lowercased as the default key. Custom keys may be defined via the
< // "yaml" name in the field tag: the content preceding the first comma
< // is used as the key, and the following comma-separated options are
< // used to tweak the marshalling process (see Marshal).
< // Conflicting names result in a runtime error.
< //
< // For example:
< //
< //     type T struct {
< //         F int `yaml:"a,omitempty"`
< //         B int
< //     }
< //     var t T
< //     yaml.Unmarshal([]byte("a: 1\nb: 2"), &t)
< //
< // See the documentation of Marshal for the format of tags and a list of
< // supported tag options.
< //
< func Unmarshal(in []byte, out interface{}) (err error) {
< 	return unmarshal(in, out, false)
< }
< 
< // A Decorder reads and decodes YAML values from an input stream.
< type Decoder struct {
< 	parser      *parser
< 	knownFields bool
< }
< 
< // NewDecoder returns a new decoder that reads from r.
< //
< // The decoder introduces its own buffering and may read
< // data from r beyond the YAML values requested.
< func NewDecoder(r io.Reader) *Decoder {
< 	return &Decoder{
< 		parser: newParserFromReader(r),
< 	}
< }
< 
< // KnownFields ensures that the keys in decoded mappings to
< // exist as fields in the struct being decoded into.
< func (dec *Decoder) KnownFields(enable bool) {
< 	dec.knownFields = enable
< }
< 
< // Decode reads the next YAML-encoded value from its input
< // and stores it in the value pointed to by v.
< //
< // See the documentation for Unmarshal for details about the
< // conversion of YAML into a Go value.
< func (dec *Decoder) Decode(v interface{}) (err error) {
< 	d := newDecoder()
< 	d.knownFields = dec.knownFields
< 	defer handleErr(&err)
< 	node := dec.parser.parse()
< 	if node == nil {
< 		return io.EOF
< 	}
< 	out := reflect.ValueOf(v)
< 	if out.Kind() == reflect.Ptr && !out.IsNil() {
< 		out = out.Elem()
< 	}
< 	d.unmarshal(node, out)
< 	if len(d.terrors) > 0 {
< 		return &TypeError{d.terrors}
< 	}
< 	return nil
< }
< 
< // Decode decodes the node and stores its data into the value pointed to by v.
< //
< // See the documentation for Unmarshal for details about the
< // conversion of YAML into a Go value.
< func (n *Node) Decode(v interface{}) (err error) {
< 	d := newDecoder()
< 	defer handleErr(&err)
< 	out := reflect.ValueOf(v)
< 	if out.Kind() == reflect.Ptr && !out.IsNil() {
< 		out = out.Elem()
< 	}
< 	d.unmarshal(n, out)
< 	if len(d.terrors) > 0 {
< 		return &TypeError{d.terrors}
< 	}
< 	return nil
< }
< 
< func unmarshal(in []byte, out interface{}, strict bool) (err error) {
< 	defer handleErr(&err)
< 	d := newDecoder()
< 	p := newParser(in)
< 	defer p.destroy()
< 	node := p.parse()
< 	if node != nil {
< 		v := reflect.ValueOf(out)
< 		if v.Kind() == reflect.Ptr && !v.IsNil() {
< 			v = v.Elem()
< 		}
< 		d.unmarshal(node, v)
< 	}
< 	if len(d.terrors) > 0 {
< 		return &TypeError{d.terrors}
< 	}
< 	return nil
< }
< 
< // Marshal serializes the value provided into a YAML document. The structure
< // of the generated document will reflect the structure of the value itself.
< // Maps and pointers (to struct, string, int, etc) are accepted as the in value.
< //
< // Struct fields are only marshalled if they are exported (have an upper case
< // first letter), and are marshalled using the field name lowercased as the
< // default key. Custom keys may be defined via the "yaml" name in the field
< // tag: the content preceding the first comma is used as the key, and the
< // following comma-separated options are used to tweak the marshalling process.
< // Conflicting names result in a runtime error.
< //
< // The field tag format accepted is:
< //
< //     `(...) yaml:"[<key>][,<flag1>[,<flag2>]]" (...)`
< //
< // The following flags are currently supported:
< //
< //     omitempty    Only include the field if it's not set to the zero
< //                  value for the type or to empty slices or maps.
< //                  Zero valued structs will be omitted if all their public
< //                  fields are zero, unless they implement an IsZero
< //                  method (see the IsZeroer interface type), in which
< //                  case the field will be included if that method returns true.
< //
< //     flow         Marshal using a flow style (useful for structs,
< //                  sequences and maps).
< //
< //     inline       Inline the field, which must be a struct or a map,
< //                  causing all of its fields or keys to be processed as if
< //                  they were part of the outer struct. For maps, keys must
< //                  not conflict with the yaml keys of other struct fields.
< //
< // In addition, if the key is "-", the field is ignored.
< //
< // For example:
< //
< //     type T struct {
< //         F int `yaml:"a,omitempty"`
< //         B int
< //     }
< //     yaml.Marshal(&T{B: 2}) // Returns "b: 2\n"
< //     yaml.Marshal(&T{F: 1}} // Returns "a: 1\nb: 0\n"
< //
< func Marshal(in interface{}) (out []byte, err error) {
< 	defer handleErr(&err)
< 	e := newEncoder()
< 	defer e.destroy()
< 	e.marshalDoc("", reflect.ValueOf(in))
< 	e.finish()
< 	out = e.out
< 	return
< }
< 
< // An Encoder writes YAML values to an output stream.
< type Encoder struct {
< 	encoder *encoder
< }
< 
< // NewEncoder returns a new encoder that writes to w.
< // The Encoder should be closed after use to flush all data
< // to w.
< func NewEncoder(w io.Writer) *Encoder {
< 	return &Encoder{
< 		encoder: newEncoderWithWriter(w),
< 	}
< }
< 
< // Encode writes the YAML encoding of v to the stream.
< // If multiple items are encoded to the stream, the
< // second and subsequent document will be preceded
< // with a "---" document separator, but the first will not.
< //
< // See the documentation for Marshal for details about the conversion of Go
< // values to YAML.
< func (e *Encoder) Encode(v interface{}) (err error) {
< 	defer handleErr(&err)
< 	e.encoder.marshalDoc("", reflect.ValueOf(v))
< 	return nil
< }
< 
< // SetIndent changes the used indentation used when encoding.
< func (e *Encoder) SetIndent(spaces int) {
< 	if spaces < 0 {
< 		panic("yaml: cannot indent to a negative number of spaces")
< 	}
< 	e.encoder.indent = spaces
< }
< 
< // Close closes the encoder by writing any remaining data.
< // It does not write a stream terminating string "...".
< func (e *Encoder) Close() (err error) {
< 	defer handleErr(&err)
< 	e.encoder.finish()
< 	return nil
< }
< 
< func handleErr(err *error) {
< 	if v := recover(); v != nil {
< 		if e, ok := v.(yamlError); ok {
< 			*err = e.err
< 		} else {
< 			panic(v)
< 		}
< 	}
< }
< 
< type yamlError struct {
< 	err error
< }
< 
< func fail(err error) {
< 	panic(yamlError{err})
< }
< 
< func failf(format string, args ...interface{}) {
< 	panic(yamlError{fmt.Errorf("yaml: "+format, args...)})
< }
< 
< // A TypeError is returned by Unmarshal when one or more fields in
< // the YAML document cannot be properly decoded into the requested
< // types. When this error is returned, the value is still
< // unmarshaled partially.
< type TypeError struct {
< 	Errors []string
< }
< 
< func (e *TypeError) Error() string {
< 	return fmt.Sprintf("yaml: unmarshal errors:\n  %s", strings.Join(e.Errors, "\n  "))
< }
< 
< type Kind uint32
< 
< const (
< 	DocumentNode Kind = 1 << iota
< 	SequenceNode
< 	MappingNode
< 	ScalarNode
< 	AliasNode
< )
< 
< type Style uint32
< 
< const (
< 	TaggedStyle Style = 1 << iota
< 	DoubleQuotedStyle
< 	SingleQuotedStyle
< 	LiteralStyle
< 	FoldedStyle
< 	FlowStyle
< )
< 
< // Node represents an element in the YAML document hierarchy. While documents
< // are typically encoded and decoded into higher level types, such as structs
< // and maps, Node is an intermediate representation that allows detailed
< // control over the content being decoded or encoded.
< //
< // Values that make use of the Node type interact with the yaml package in the
< // same way any other type would do, by encoding and decoding yaml data
< // directly or indirectly into them.
< //
< // For example:
< //
< //     var person struct {
< //             Name    string
< //             Address yaml.Node
< //     }
< //     err := yaml.Unmarshal(data, &person)
< // 
< // Or by itself:
< //
< //     var person Node
< //     err := yaml.Unmarshal(data, &person)
< //
< type Node struct {
< 	// Kind defines whether the node is a document, a mapping, a sequence,
< 	// a scalar value, or an alias to another node. The specific data type of
< 	// scalar nodes may be obtained via the ShortTag and LongTag methods.
< 	Kind  Kind
< 
< 	// Style allows customizing the apperance of the node in the tree.
< 	Style Style
< 
< 	// Tag holds the YAML tag defining the data type for the value.
< 	// When decoding, this field will always be set to the resolved tag,
< 	// even when it wasn't explicitly provided in the YAML content.
< 	// When encoding, if this field is unset the value type will be
< 	// implied from the node properties, and if it is set, it will only
< 	// be serialized into the representation if TaggedStyle is used or
< 	// the implicit tag diverges from the provided one.
< 	Tag string
< 
< 	// Value holds the unescaped and unquoted represenation of the value.
< 	Value string
< 
< 	// Anchor holds the anchor name for this node, which allows aliases to point to it.
< 	Anchor string
< 
< 	// Alias holds the node that this alias points to. Only valid when Kind is AliasNode.
< 	Alias *Node
< 
< 	// Content holds contained nodes for documents, mappings, and sequences.
< 	Content []*Node
< 
< 	// HeadComment holds any comments in the lines preceding the node and
< 	// not separated by an empty line.
< 	HeadComment string
< 
< 	// LineComment holds any comments at the end of the line where the node is in.
< 	LineComment string
< 
< 	// FootComment holds any comments following the node and before empty lines.
< 	FootComment string
< 
< 	// Line and Column hold the node position in the decoded YAML text.
< 	// These fields are not respected when encoding the node.
< 	Line   int
< 	Column int
< }
< 
< // LongTag returns the long form of the tag that indicates the data type for
< // the node. If the Tag field isn't explicitly defined, one will be computed
< // based on the node properties.
< func (n *Node) LongTag() string {
< 	return longTag(n.ShortTag())
< }
< 
< // ShortTag returns the short form of the YAML tag that indicates data type for
< // the node. If the Tag field isn't explicitly defined, one will be computed
< // based on the node properties.
< func (n *Node) ShortTag() string {
< 	if n.indicatedString() {
< 		return strTag
< 	}
< 	if n.Tag == "" || n.Tag == "!" {
< 		switch n.Kind {
< 		case MappingNode:
< 			return mapTag
< 		case SequenceNode:
< 			return seqTag
< 		case AliasNode:
< 			if n.Alias != nil {
< 				return n.Alias.ShortTag()
< 			}
< 		case ScalarNode:
< 			tag, _ := resolve("", n.Value)
< 			return tag
< 		}
< 		return ""
< 	}
< 	return shortTag(n.Tag)
< }
< 
< func (n *Node) indicatedString() bool {
< 	return n.Kind == ScalarNode &&
< 		(shortTag(n.Tag) == strTag ||
< 			(n.Tag == "" || n.Tag == "!") && n.Style&(SingleQuotedStyle|DoubleQuotedStyle|LiteralStyle|FoldedStyle) != 0)
< }
< 
< // SetString is a convenience function that sets the node to a string value
< // and defines its style in a pleasant way depending on its content.
< func (n *Node) SetString(s string) {
< 	n.Kind = ScalarNode
< 	if utf8.ValidString(s) {
< 		n.Value = s
< 		n.Tag = strTag
< 	} else {
< 		n.Value = encodeBase64(s)
< 		n.Tag = binaryTag
< 	}
< 	if strings.Contains(n.Value, "\n") {
< 		n.Style = LiteralStyle
< 	}
< }
< 
< // --------------------------------------------------------------------------
< // Maintain a mapping of keys to structure field indexes
< 
< // The code in this section was copied from mgo/bson.
< 
< // structInfo holds details for the serialization of fields of
< // a given struct.
< type structInfo struct {
< 	FieldsMap  map[string]fieldInfo
< 	FieldsList []fieldInfo
< 
< 	// InlineMap is the number of the field in the struct that
< 	// contains an ,inline map, or -1 if there's none.
< 	InlineMap int
< 
< 	// InlineUnmarshalers holds indexes to inlined fields that
< 	// contain unmarshaler values.
< 	InlineUnmarshalers [][]int
< }
< 
< type fieldInfo struct {
< 	Key       string
< 	Num       int
< 	OmitEmpty bool
< 	Flow      bool
< 	// Id holds the unique field identifier, so we can cheaply
< 	// check for field duplicates without maintaining an extra map.
< 	Id int
< 
< 	// Inline holds the field index if the field is part of an inlined struct.
< 	Inline []int
< }
< 
< var structMap = make(map[reflect.Type]*structInfo)
< var fieldMapMutex sync.RWMutex
< var unmarshalerType reflect.Type
< 
< func init() {
< 	var v Unmarshaler
< 	unmarshalerType = reflect.ValueOf(&v).Elem().Type()
< }
< 
< func getStructInfo(st reflect.Type) (*structInfo, error) {
< 	fieldMapMutex.RLock()
< 	sinfo, found := structMap[st]
< 	fieldMapMutex.RUnlock()
< 	if found {
< 		return sinfo, nil
< 	}
< 
< 	n := st.NumField()
< 	fieldsMap := make(map[string]fieldInfo)
< 	fieldsList := make([]fieldInfo, 0, n)
< 	inlineMap := -1
< 	inlineUnmarshalers := [][]int(nil)
< 	for i := 0; i != n; i++ {
< 		field := st.Field(i)
< 		if field.PkgPath != "" && !field.Anonymous {
< 			continue // Private field
< 		}
< 
< 		info := fieldInfo{Num: i}
< 
< 		tag := field.Tag.Get("yaml")
< 		if tag == "" && strings.Index(string(field.Tag), ":") < 0 {
< 			tag = string(field.Tag)
< 		}
< 		if tag == "-" {
< 			continue
< 		}
< 
< 		inline := false
< 		fields := strings.Split(tag, ",")
< 		if len(fields) > 1 {
< 			for _, flag := range fields[1:] {
< 				switch flag {
< 				case "omitempty":
< 					info.OmitEmpty = true
< 				case "flow":
< 					info.Flow = true
< 				case "inline":
< 					inline = true
< 				default:
< 					return nil, errors.New(fmt.Sprintf("unsupported flag %q in tag %q of type %s", flag, tag, st))
< 				}
< 			}
< 			tag = fields[0]
< 		}
< 
< 		if inline {
< 			switch field.Type.Kind() {
< 			case reflect.Map:
< 				if inlineMap >= 0 {
< 					return nil, errors.New("multiple ,inline maps in struct " + st.String())
< 				}
< 				if field.Type.Key() != reflect.TypeOf("") {
< 					return nil, errors.New("option ,inline needs a map with string keys in struct " + st.String())
< 				}
< 				inlineMap = info.Num
< 			case reflect.Struct, reflect.Ptr:
< 				ftype := field.Type
< 				for ftype.Kind() == reflect.Ptr {
< 					ftype = ftype.Elem()
< 				}
< 				if ftype.Kind() != reflect.Struct {
< 					return nil, errors.New("option ,inline may only be used on a struct or map field")
< 				}
< 				if reflect.PtrTo(ftype).Implements(unmarshalerType) {
< 					inlineUnmarshalers = append(inlineUnmarshalers, []int{i})
< 				} else {
< 					sinfo, err := getStructInfo(ftype)
< 					if err != nil {
< 						return nil, err
< 					}
< 					for _, index := range sinfo.InlineUnmarshalers {
< 						inlineUnmarshalers = append(inlineUnmarshalers, append([]int{i}, index...))
< 					}
< 					for _, finfo := range sinfo.FieldsList {
< 						if _, found := fieldsMap[finfo.Key]; found {
< 							msg := "duplicated key '" + finfo.Key + "' in struct " + st.String()
< 							return nil, errors.New(msg)
< 						}
< 						if finfo.Inline == nil {
< 							finfo.Inline = []int{i, finfo.Num}
< 						} else {
< 							finfo.Inline = append([]int{i}, finfo.Inline...)
< 						}
< 						finfo.Id = len(fieldsList)
< 						fieldsMap[finfo.Key] = finfo
< 						fieldsList = append(fieldsList, finfo)
< 					}
< 				}
< 			default:
< 				return nil, errors.New("option ,inline may only be used on a struct or map field")
< 			}
< 			continue
< 		}
< 
< 		if tag != "" {
< 			info.Key = tag
< 		} else {
< 			info.Key = strings.ToLower(field.Name)
< 		}
< 
< 		if _, found = fieldsMap[info.Key]; found {
< 			msg := "duplicated key '" + info.Key + "' in struct " + st.String()
< 			return nil, errors.New(msg)
< 		}
< 
< 		info.Id = len(fieldsList)
< 		fieldsList = append(fieldsList, info)
< 		fieldsMap[info.Key] = info
< 	}
< 
< 	sinfo = &structInfo{
< 		FieldsMap:          fieldsMap,
< 		FieldsList:         fieldsList,
< 		InlineMap:          inlineMap,
< 		InlineUnmarshalers: inlineUnmarshalers,
< 	}
< 
< 	fieldMapMutex.Lock()
< 	structMap[st] = sinfo
< 	fieldMapMutex.Unlock()
< 	return sinfo, nil
< }
< 
< // IsZeroer is used to check whether an object is zero to
< // determine whether it should be omitted when marshaling
< // with the omitempty flag. One notable implementation
< // is time.Time.
< type IsZeroer interface {
< 	IsZero() bool
< }
< 
< func isZero(v reflect.Value) bool {
< 	kind := v.Kind()
< 	if z, ok := v.Interface().(IsZeroer); ok {
< 		if (kind == reflect.Ptr || kind == reflect.Interface) && v.IsNil() {
< 			return true
< 		}
< 		return z.IsZero()
< 	}
< 	switch kind {
< 	case reflect.String:
< 		return len(v.String()) == 0
< 	case reflect.Interface, reflect.Ptr:
< 		return v.IsNil()
< 	case reflect.Slice:
< 		return v.Len() == 0
< 	case reflect.Map:
< 		return v.Len() == 0
< 	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
< 		return v.Int() == 0
< 	case reflect.Float32, reflect.Float64:
< 		return v.Float() == 0
< 	case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
< 		return v.Uint() == 0
< 	case reflect.Bool:
< 		return !v.Bool()
< 	case reflect.Struct:
< 		vt := v.Type()
< 		for i := v.NumField() - 1; i >= 0; i-- {
< 			if vt.Field(i).PkgPath != "" {
< 				continue // Private field
< 			}
< 			if !isZero(v.Field(i)) {
< 				return false
< 			}
< 		}
< 		return true
< 	}
< 	return false
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/yamlh.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/yamlh.go
1,803d0
< //
< // Copyright (c) 2011-2019 Canonical Ltd
< // Copyright (c) 2006-2010 Kirill Simonov
< //
< // Permission is hereby granted, free of charge, to any person obtaining a copy of
< // this software and associated documentation files (the "Software"), to deal in
< // the Software without restriction, including without limitation the rights to
< // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< // of the Software, and to permit persons to whom the Software is furnished to do
< // so, subject to the following conditions:
< //
< // The above copyright notice and this permission notice shall be included in all
< // copies or substantial portions of the Software.
< //
< // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< // SOFTWARE.
< 
< package yaml
< 
< import (
< 	"fmt"
< 	"io"
< )
< 
< // The version directive data.
< type yaml_version_directive_t struct {
< 	major int8 // The major version number.
< 	minor int8 // The minor version number.
< }
< 
< // The tag directive data.
< type yaml_tag_directive_t struct {
< 	handle []byte // The tag handle.
< 	prefix []byte // The tag prefix.
< }
< 
< type yaml_encoding_t int
< 
< // The stream encoding.
< const (
< 	// Let the parser choose the encoding.
< 	yaml_ANY_ENCODING yaml_encoding_t = iota
< 
< 	yaml_UTF8_ENCODING    // The default UTF-8 encoding.
< 	yaml_UTF16LE_ENCODING // The UTF-16-LE encoding with BOM.
< 	yaml_UTF16BE_ENCODING // The UTF-16-BE encoding with BOM.
< )
< 
< type yaml_break_t int
< 
< // Line break types.
< const (
< 	// Let the parser choose the break type.
< 	yaml_ANY_BREAK yaml_break_t = iota
< 
< 	yaml_CR_BREAK   // Use CR for line breaks (Mac style).
< 	yaml_LN_BREAK   // Use LN for line breaks (Unix style).
< 	yaml_CRLN_BREAK // Use CR LN for line breaks (DOS style).
< )
< 
< type yaml_error_type_t int
< 
< // Many bad things could happen with the parser and emitter.
< const (
< 	// No error is produced.
< 	yaml_NO_ERROR yaml_error_type_t = iota
< 
< 	yaml_MEMORY_ERROR   // Cannot allocate or reallocate a block of memory.
< 	yaml_READER_ERROR   // Cannot read or decode the input stream.
< 	yaml_SCANNER_ERROR  // Cannot scan the input stream.
< 	yaml_PARSER_ERROR   // Cannot parse the input stream.
< 	yaml_COMPOSER_ERROR // Cannot compose a YAML document.
< 	yaml_WRITER_ERROR   // Cannot write to the output stream.
< 	yaml_EMITTER_ERROR  // Cannot emit a YAML stream.
< )
< 
< // The pointer position.
< type yaml_mark_t struct {
< 	index  int // The position index.
< 	line   int // The position line.
< 	column int // The position column.
< }
< 
< // Node Styles
< 
< type yaml_style_t int8
< 
< type yaml_scalar_style_t yaml_style_t
< 
< // Scalar styles.
< const (
< 	// Let the emitter choose the style.
< 	yaml_ANY_SCALAR_STYLE yaml_scalar_style_t = 0
< 
< 	yaml_PLAIN_SCALAR_STYLE         yaml_scalar_style_t = 1 << iota // The plain scalar style.
< 	yaml_SINGLE_QUOTED_SCALAR_STYLE                                 // The single-quoted scalar style.
< 	yaml_DOUBLE_QUOTED_SCALAR_STYLE                                 // The double-quoted scalar style.
< 	yaml_LITERAL_SCALAR_STYLE                                       // The literal scalar style.
< 	yaml_FOLDED_SCALAR_STYLE                                        // The folded scalar style.
< )
< 
< type yaml_sequence_style_t yaml_style_t
< 
< // Sequence styles.
< const (
< 	// Let the emitter choose the style.
< 	yaml_ANY_SEQUENCE_STYLE yaml_sequence_style_t = iota
< 
< 	yaml_BLOCK_SEQUENCE_STYLE // The block sequence style.
< 	yaml_FLOW_SEQUENCE_STYLE  // The flow sequence style.
< )
< 
< type yaml_mapping_style_t yaml_style_t
< 
< // Mapping styles.
< const (
< 	// Let the emitter choose the style.
< 	yaml_ANY_MAPPING_STYLE yaml_mapping_style_t = iota
< 
< 	yaml_BLOCK_MAPPING_STYLE // The block mapping style.
< 	yaml_FLOW_MAPPING_STYLE  // The flow mapping style.
< )
< 
< // Tokens
< 
< type yaml_token_type_t int
< 
< // Token types.
< const (
< 	// An empty token.
< 	yaml_NO_TOKEN yaml_token_type_t = iota
< 
< 	yaml_STREAM_START_TOKEN // A STREAM-START token.
< 	yaml_STREAM_END_TOKEN   // A STREAM-END token.
< 
< 	yaml_VERSION_DIRECTIVE_TOKEN // A VERSION-DIRECTIVE token.
< 	yaml_TAG_DIRECTIVE_TOKEN     // A TAG-DIRECTIVE token.
< 	yaml_DOCUMENT_START_TOKEN    // A DOCUMENT-START token.
< 	yaml_DOCUMENT_END_TOKEN      // A DOCUMENT-END token.
< 
< 	yaml_BLOCK_SEQUENCE_START_TOKEN // A BLOCK-SEQUENCE-START token.
< 	yaml_BLOCK_MAPPING_START_TOKEN  // A BLOCK-SEQUENCE-END token.
< 	yaml_BLOCK_END_TOKEN            // A BLOCK-END token.
< 
< 	yaml_FLOW_SEQUENCE_START_TOKEN // A FLOW-SEQUENCE-START token.
< 	yaml_FLOW_SEQUENCE_END_TOKEN   // A FLOW-SEQUENCE-END token.
< 	yaml_FLOW_MAPPING_START_TOKEN  // A FLOW-MAPPING-START token.
< 	yaml_FLOW_MAPPING_END_TOKEN    // A FLOW-MAPPING-END token.
< 
< 	yaml_BLOCK_ENTRY_TOKEN // A BLOCK-ENTRY token.
< 	yaml_FLOW_ENTRY_TOKEN  // A FLOW-ENTRY token.
< 	yaml_KEY_TOKEN         // A KEY token.
< 	yaml_VALUE_TOKEN       // A VALUE token.
< 
< 	yaml_ALIAS_TOKEN  // An ALIAS token.
< 	yaml_ANCHOR_TOKEN // An ANCHOR token.
< 	yaml_TAG_TOKEN    // A TAG token.
< 	yaml_SCALAR_TOKEN // A SCALAR token.
< )
< 
< func (tt yaml_token_type_t) String() string {
< 	switch tt {
< 	case yaml_NO_TOKEN:
< 		return "yaml_NO_TOKEN"
< 	case yaml_STREAM_START_TOKEN:
< 		return "yaml_STREAM_START_TOKEN"
< 	case yaml_STREAM_END_TOKEN:
< 		return "yaml_STREAM_END_TOKEN"
< 	case yaml_VERSION_DIRECTIVE_TOKEN:
< 		return "yaml_VERSION_DIRECTIVE_TOKEN"
< 	case yaml_TAG_DIRECTIVE_TOKEN:
< 		return "yaml_TAG_DIRECTIVE_TOKEN"
< 	case yaml_DOCUMENT_START_TOKEN:
< 		return "yaml_DOCUMENT_START_TOKEN"
< 	case yaml_DOCUMENT_END_TOKEN:
< 		return "yaml_DOCUMENT_END_TOKEN"
< 	case yaml_BLOCK_SEQUENCE_START_TOKEN:
< 		return "yaml_BLOCK_SEQUENCE_START_TOKEN"
< 	case yaml_BLOCK_MAPPING_START_TOKEN:
< 		return "yaml_BLOCK_MAPPING_START_TOKEN"
< 	case yaml_BLOCK_END_TOKEN:
< 		return "yaml_BLOCK_END_TOKEN"
< 	case yaml_FLOW_SEQUENCE_START_TOKEN:
< 		return "yaml_FLOW_SEQUENCE_START_TOKEN"
< 	case yaml_FLOW_SEQUENCE_END_TOKEN:
< 		return "yaml_FLOW_SEQUENCE_END_TOKEN"
< 	case yaml_FLOW_MAPPING_START_TOKEN:
< 		return "yaml_FLOW_MAPPING_START_TOKEN"
< 	case yaml_FLOW_MAPPING_END_TOKEN:
< 		return "yaml_FLOW_MAPPING_END_TOKEN"
< 	case yaml_BLOCK_ENTRY_TOKEN:
< 		return "yaml_BLOCK_ENTRY_TOKEN"
< 	case yaml_FLOW_ENTRY_TOKEN:
< 		return "yaml_FLOW_ENTRY_TOKEN"
< 	case yaml_KEY_TOKEN:
< 		return "yaml_KEY_TOKEN"
< 	case yaml_VALUE_TOKEN:
< 		return "yaml_VALUE_TOKEN"
< 	case yaml_ALIAS_TOKEN:
< 		return "yaml_ALIAS_TOKEN"
< 	case yaml_ANCHOR_TOKEN:
< 		return "yaml_ANCHOR_TOKEN"
< 	case yaml_TAG_TOKEN:
< 		return "yaml_TAG_TOKEN"
< 	case yaml_SCALAR_TOKEN:
< 		return "yaml_SCALAR_TOKEN"
< 	}
< 	return "<unknown token>"
< }
< 
< // The token structure.
< type yaml_token_t struct {
< 	// The token type.
< 	typ yaml_token_type_t
< 
< 	// The start/end of the token.
< 	start_mark, end_mark yaml_mark_t
< 
< 	// The stream encoding (for yaml_STREAM_START_TOKEN).
< 	encoding yaml_encoding_t
< 
< 	// The alias/anchor/scalar value or tag/tag directive handle
< 	// (for yaml_ALIAS_TOKEN, yaml_ANCHOR_TOKEN, yaml_SCALAR_TOKEN, yaml_TAG_TOKEN, yaml_TAG_DIRECTIVE_TOKEN).
< 	value []byte
< 
< 	// The tag suffix (for yaml_TAG_TOKEN).
< 	suffix []byte
< 
< 	// The tag directive prefix (for yaml_TAG_DIRECTIVE_TOKEN).
< 	prefix []byte
< 
< 	// The scalar style (for yaml_SCALAR_TOKEN).
< 	style yaml_scalar_style_t
< 
< 	// The version directive major/minor (for yaml_VERSION_DIRECTIVE_TOKEN).
< 	major, minor int8
< }
< 
< // Events
< 
< type yaml_event_type_t int8
< 
< // Event types.
< const (
< 	// An empty event.
< 	yaml_NO_EVENT yaml_event_type_t = iota
< 
< 	yaml_STREAM_START_EVENT   // A STREAM-START event.
< 	yaml_STREAM_END_EVENT     // A STREAM-END event.
< 	yaml_DOCUMENT_START_EVENT // A DOCUMENT-START event.
< 	yaml_DOCUMENT_END_EVENT   // A DOCUMENT-END event.
< 	yaml_ALIAS_EVENT          // An ALIAS event.
< 	yaml_SCALAR_EVENT         // A SCALAR event.
< 	yaml_SEQUENCE_START_EVENT // A SEQUENCE-START event.
< 	yaml_SEQUENCE_END_EVENT   // A SEQUENCE-END event.
< 	yaml_MAPPING_START_EVENT  // A MAPPING-START event.
< 	yaml_MAPPING_END_EVENT    // A MAPPING-END event.
< 	yaml_TAIL_COMMENT_EVENT
< )
< 
< var eventStrings = []string{
< 	yaml_NO_EVENT:             "none",
< 	yaml_STREAM_START_EVENT:   "stream start",
< 	yaml_STREAM_END_EVENT:     "stream end",
< 	yaml_DOCUMENT_START_EVENT: "document start",
< 	yaml_DOCUMENT_END_EVENT:   "document end",
< 	yaml_ALIAS_EVENT:          "alias",
< 	yaml_SCALAR_EVENT:         "scalar",
< 	yaml_SEQUENCE_START_EVENT: "sequence start",
< 	yaml_SEQUENCE_END_EVENT:   "sequence end",
< 	yaml_MAPPING_START_EVENT:  "mapping start",
< 	yaml_MAPPING_END_EVENT:    "mapping end",
< 	yaml_TAIL_COMMENT_EVENT:   "tail comment",
< }
< 
< func (e yaml_event_type_t) String() string {
< 	if e < 0 || int(e) >= len(eventStrings) {
< 		return fmt.Sprintf("unknown event %d", e)
< 	}
< 	return eventStrings[e]
< }
< 
< // The event structure.
< type yaml_event_t struct {
< 
< 	// The event type.
< 	typ yaml_event_type_t
< 
< 	// The start and end of the event.
< 	start_mark, end_mark yaml_mark_t
< 
< 	// The document encoding (for yaml_STREAM_START_EVENT).
< 	encoding yaml_encoding_t
< 
< 	// The version directive (for yaml_DOCUMENT_START_EVENT).
< 	version_directive *yaml_version_directive_t
< 
< 	// The list of tag directives (for yaml_DOCUMENT_START_EVENT).
< 	tag_directives []yaml_tag_directive_t
< 
< 	// The comments
< 	head_comment []byte
< 	line_comment []byte
< 	foot_comment []byte
< 	tail_comment []byte
< 
< 	// The anchor (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_ALIAS_EVENT).
< 	anchor []byte
< 
< 	// The tag (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
< 	tag []byte
< 
< 	// The scalar value (for yaml_SCALAR_EVENT).
< 	value []byte
< 
< 	// Is the document start/end indicator implicit, or the tag optional?
< 	// (for yaml_DOCUMENT_START_EVENT, yaml_DOCUMENT_END_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT, yaml_SCALAR_EVENT).
< 	implicit bool
< 
< 	// Is the tag optional for any non-plain style? (for yaml_SCALAR_EVENT).
< 	quoted_implicit bool
< 
< 	// The style (for yaml_SCALAR_EVENT, yaml_SEQUENCE_START_EVENT, yaml_MAPPING_START_EVENT).
< 	style yaml_style_t
< }
< 
< func (e *yaml_event_t) scalar_style() yaml_scalar_style_t     { return yaml_scalar_style_t(e.style) }
< func (e *yaml_event_t) sequence_style() yaml_sequence_style_t { return yaml_sequence_style_t(e.style) }
< func (e *yaml_event_t) mapping_style() yaml_mapping_style_t   { return yaml_mapping_style_t(e.style) }
< 
< // Nodes
< 
< const (
< 	yaml_NULL_TAG      = "tag:yaml.org,2002:null"      // The tag !!null with the only possible value: null.
< 	yaml_BOOL_TAG      = "tag:yaml.org,2002:bool"      // The tag !!bool with the values: true and false.
< 	yaml_STR_TAG       = "tag:yaml.org,2002:str"       // The tag !!str for string values.
< 	yaml_INT_TAG       = "tag:yaml.org,2002:int"       // The tag !!int for integer values.
< 	yaml_FLOAT_TAG     = "tag:yaml.org,2002:float"     // The tag !!float for float values.
< 	yaml_TIMESTAMP_TAG = "tag:yaml.org,2002:timestamp" // The tag !!timestamp for date and time values.
< 
< 	yaml_SEQ_TAG = "tag:yaml.org,2002:seq" // The tag !!seq is used to denote sequences.
< 	yaml_MAP_TAG = "tag:yaml.org,2002:map" // The tag !!map is used to denote mapping.
< 
< 	// Not in original libyaml.
< 	yaml_BINARY_TAG = "tag:yaml.org,2002:binary"
< 	yaml_MERGE_TAG  = "tag:yaml.org,2002:merge"
< 
< 	yaml_DEFAULT_SCALAR_TAG   = yaml_STR_TAG // The default scalar tag is !!str.
< 	yaml_DEFAULT_SEQUENCE_TAG = yaml_SEQ_TAG // The default sequence tag is !!seq.
< 	yaml_DEFAULT_MAPPING_TAG  = yaml_MAP_TAG // The default mapping tag is !!map.
< )
< 
< type yaml_node_type_t int
< 
< // Node types.
< const (
< 	// An empty node.
< 	yaml_NO_NODE yaml_node_type_t = iota
< 
< 	yaml_SCALAR_NODE   // A scalar node.
< 	yaml_SEQUENCE_NODE // A sequence node.
< 	yaml_MAPPING_NODE  // A mapping node.
< )
< 
< // An element of a sequence node.
< type yaml_node_item_t int
< 
< // An element of a mapping node.
< type yaml_node_pair_t struct {
< 	key   int // The key of the element.
< 	value int // The value of the element.
< }
< 
< // The node structure.
< type yaml_node_t struct {
< 	typ yaml_node_type_t // The node type.
< 	tag []byte           // The node tag.
< 
< 	// The node data.
< 
< 	// The scalar parameters (for yaml_SCALAR_NODE).
< 	scalar struct {
< 		value  []byte              // The scalar value.
< 		length int                 // The length of the scalar value.
< 		style  yaml_scalar_style_t // The scalar style.
< 	}
< 
< 	// The sequence parameters (for YAML_SEQUENCE_NODE).
< 	sequence struct {
< 		items_data []yaml_node_item_t    // The stack of sequence items.
< 		style      yaml_sequence_style_t // The sequence style.
< 	}
< 
< 	// The mapping parameters (for yaml_MAPPING_NODE).
< 	mapping struct {
< 		pairs_data  []yaml_node_pair_t   // The stack of mapping pairs (key, value).
< 		pairs_start *yaml_node_pair_t    // The beginning of the stack.
< 		pairs_end   *yaml_node_pair_t    // The end of the stack.
< 		pairs_top   *yaml_node_pair_t    // The top of the stack.
< 		style       yaml_mapping_style_t // The mapping style.
< 	}
< 
< 	start_mark yaml_mark_t // The beginning of the node.
< 	end_mark   yaml_mark_t // The end of the node.
< 
< }
< 
< // The document structure.
< type yaml_document_t struct {
< 
< 	// The document nodes.
< 	nodes []yaml_node_t
< 
< 	// The version directive.
< 	version_directive *yaml_version_directive_t
< 
< 	// The list of tag directives.
< 	tag_directives_data  []yaml_tag_directive_t
< 	tag_directives_start int // The beginning of the tag directives list.
< 	tag_directives_end   int // The end of the tag directives list.
< 
< 	start_implicit int // Is the document start indicator implicit?
< 	end_implicit   int // Is the document end indicator implicit?
< 
< 	// The start/end of the document.
< 	start_mark, end_mark yaml_mark_t
< }
< 
< // The prototype of a read handler.
< //
< // The read handler is called when the parser needs to read more bytes from the
< // source. The handler should write not more than size bytes to the buffer.
< // The number of written bytes should be set to the size_read variable.
< //
< // [in,out]   data        A pointer to an application data specified by
< //                        yaml_parser_set_input().
< // [out]      buffer      The buffer to write the data from the source.
< // [in]       size        The size of the buffer.
< // [out]      size_read   The actual number of bytes read from the source.
< //
< // On success, the handler should return 1.  If the handler failed,
< // the returned value should be 0. On EOF, the handler should set the
< // size_read to 0 and return 1.
< type yaml_read_handler_t func(parser *yaml_parser_t, buffer []byte) (n int, err error)
< 
< // This structure holds information about a potential simple key.
< type yaml_simple_key_t struct {
< 	possible     bool        // Is a simple key possible?
< 	required     bool        // Is a simple key required?
< 	token_number int         // The number of the token.
< 	mark         yaml_mark_t // The position mark.
< }
< 
< // The states of the parser.
< type yaml_parser_state_t int
< 
< const (
< 	yaml_PARSE_STREAM_START_STATE yaml_parser_state_t = iota
< 
< 	yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE           // Expect the beginning of an implicit document.
< 	yaml_PARSE_DOCUMENT_START_STATE                    // Expect DOCUMENT-START.
< 	yaml_PARSE_DOCUMENT_CONTENT_STATE                  // Expect the content of a document.
< 	yaml_PARSE_DOCUMENT_END_STATE                      // Expect DOCUMENT-END.
< 	yaml_PARSE_BLOCK_NODE_STATE                        // Expect a block node.
< 	yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE // Expect a block node or indentless sequence.
< 	yaml_PARSE_FLOW_NODE_STATE                         // Expect a flow node.
< 	yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE        // Expect the first entry of a block sequence.
< 	yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE              // Expect an entry of a block sequence.
< 	yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE         // Expect an entry of an indentless sequence.
< 	yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE           // Expect the first key of a block mapping.
< 	yaml_PARSE_BLOCK_MAPPING_KEY_STATE                 // Expect a block mapping key.
< 	yaml_PARSE_BLOCK_MAPPING_VALUE_STATE               // Expect a block mapping value.
< 	yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE         // Expect the first entry of a flow sequence.
< 	yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE               // Expect an entry of a flow sequence.
< 	yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE   // Expect a key of an ordered mapping.
< 	yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE // Expect a value of an ordered mapping.
< 	yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE   // Expect the and of an ordered mapping entry.
< 	yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE            // Expect the first key of a flow mapping.
< 	yaml_PARSE_FLOW_MAPPING_KEY_STATE                  // Expect a key of a flow mapping.
< 	yaml_PARSE_FLOW_MAPPING_VALUE_STATE                // Expect a value of a flow mapping.
< 	yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE          // Expect an empty value of a flow mapping.
< 	yaml_PARSE_END_STATE                               // Expect nothing.
< )
< 
< func (ps yaml_parser_state_t) String() string {
< 	switch ps {
< 	case yaml_PARSE_STREAM_START_STATE:
< 		return "yaml_PARSE_STREAM_START_STATE"
< 	case yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE:
< 		return "yaml_PARSE_IMPLICIT_DOCUMENT_START_STATE"
< 	case yaml_PARSE_DOCUMENT_START_STATE:
< 		return "yaml_PARSE_DOCUMENT_START_STATE"
< 	case yaml_PARSE_DOCUMENT_CONTENT_STATE:
< 		return "yaml_PARSE_DOCUMENT_CONTENT_STATE"
< 	case yaml_PARSE_DOCUMENT_END_STATE:
< 		return "yaml_PARSE_DOCUMENT_END_STATE"
< 	case yaml_PARSE_BLOCK_NODE_STATE:
< 		return "yaml_PARSE_BLOCK_NODE_STATE"
< 	case yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE:
< 		return "yaml_PARSE_BLOCK_NODE_OR_INDENTLESS_SEQUENCE_STATE"
< 	case yaml_PARSE_FLOW_NODE_STATE:
< 		return "yaml_PARSE_FLOW_NODE_STATE"
< 	case yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE:
< 		return "yaml_PARSE_BLOCK_SEQUENCE_FIRST_ENTRY_STATE"
< 	case yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE:
< 		return "yaml_PARSE_BLOCK_SEQUENCE_ENTRY_STATE"
< 	case yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE:
< 		return "yaml_PARSE_INDENTLESS_SEQUENCE_ENTRY_STATE"
< 	case yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE:
< 		return "yaml_PARSE_BLOCK_MAPPING_FIRST_KEY_STATE"
< 	case yaml_PARSE_BLOCK_MAPPING_KEY_STATE:
< 		return "yaml_PARSE_BLOCK_MAPPING_KEY_STATE"
< 	case yaml_PARSE_BLOCK_MAPPING_VALUE_STATE:
< 		return "yaml_PARSE_BLOCK_MAPPING_VALUE_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_FIRST_ENTRY_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_KEY_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_VALUE_STATE"
< 	case yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE:
< 		return "yaml_PARSE_FLOW_SEQUENCE_ENTRY_MAPPING_END_STATE"
< 	case yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE:
< 		return "yaml_PARSE_FLOW_MAPPING_FIRST_KEY_STATE"
< 	case yaml_PARSE_FLOW_MAPPING_KEY_STATE:
< 		return "yaml_PARSE_FLOW_MAPPING_KEY_STATE"
< 	case yaml_PARSE_FLOW_MAPPING_VALUE_STATE:
< 		return "yaml_PARSE_FLOW_MAPPING_VALUE_STATE"
< 	case yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE:
< 		return "yaml_PARSE_FLOW_MAPPING_EMPTY_VALUE_STATE"
< 	case yaml_PARSE_END_STATE:
< 		return "yaml_PARSE_END_STATE"
< 	}
< 	return "<unknown parser state>"
< }
< 
< // This structure holds aliases data.
< type yaml_alias_data_t struct {
< 	anchor []byte      // The anchor.
< 	index  int         // The node id.
< 	mark   yaml_mark_t // The anchor mark.
< }
< 
< // The parser structure.
< //
< // All members are internal. Manage the structure using the
< // yaml_parser_ family of functions.
< type yaml_parser_t struct {
< 
< 	// Error handling
< 
< 	error yaml_error_type_t // Error type.
< 
< 	problem string // Error description.
< 
< 	// The byte about which the problem occurred.
< 	problem_offset int
< 	problem_value  int
< 	problem_mark   yaml_mark_t
< 
< 	// The error context.
< 	context      string
< 	context_mark yaml_mark_t
< 
< 	// Reader stuff
< 
< 	read_handler yaml_read_handler_t // Read handler.
< 
< 	input_reader io.Reader // File input data.
< 	input        []byte    // String input data.
< 	input_pos    int
< 
< 	eof bool // EOF flag
< 
< 	buffer     []byte // The working buffer.
< 	buffer_pos int    // The current position of the buffer.
< 
< 	unread int // The number of unread characters in the buffer.
< 
< 	newlines int // The number of line breaks since last non-break/non-blank character
< 
< 	raw_buffer     []byte // The raw buffer.
< 	raw_buffer_pos int    // The current position of the buffer.
< 
< 	encoding yaml_encoding_t // The input encoding.
< 
< 	offset int         // The offset of the current position (in bytes).
< 	mark   yaml_mark_t // The mark of the current position.
< 
< 	// Comments
< 
< 	head_comment []byte // The current head comments
< 	line_comment []byte // The current line comments
< 	foot_comment []byte // The current foot comments
< 	tail_comment []byte // Foot comment that happens at the end of a block.
< 
< 	comments      []yaml_comment_t // The folded comments for all parsed tokens
< 	comments_head int
< 
< 	// Scanner stuff
< 
< 	stream_start_produced bool // Have we started to scan the input stream?
< 	stream_end_produced   bool // Have we reached the end of the input stream?
< 
< 	flow_level int // The number of unclosed '[' and '{' indicators.
< 
< 	tokens          []yaml_token_t // The tokens queue.
< 	tokens_head     int            // The head of the tokens queue.
< 	tokens_parsed   int            // The number of tokens fetched from the queue.
< 	token_available bool           // Does the tokens queue contain a token ready for dequeueing.
< 
< 	indent  int   // The current indentation level.
< 	indents []int // The indentation levels stack.
< 
< 	simple_key_allowed bool                // May a simple key occur at the current position?
< 	simple_keys        []yaml_simple_key_t // The stack of simple keys.
< 
< 	// Parser stuff
< 
< 	state          yaml_parser_state_t    // The current parser state.
< 	states         []yaml_parser_state_t  // The parser states stack.
< 	marks          []yaml_mark_t          // The stack of marks.
< 	tag_directives []yaml_tag_directive_t // The list of TAG directives.
< 
< 	// Dumper stuff
< 
< 	aliases []yaml_alias_data_t // The alias data.
< 
< 	document *yaml_document_t // The currently parsed document.
< }
< 
< type yaml_comment_t struct {
< 
< 	scan_mark  yaml_mark_t // Position where scanning for comments started
< 	token_mark yaml_mark_t // Position after which tokens will be associated with this comment
< 	start_mark yaml_mark_t // Position of '#' comment mark
< 	end_mark   yaml_mark_t // Position where comment terminated
< 
< 	head []byte
< 	line []byte
< 	foot []byte
< }
< 
< // Emitter Definitions
< 
< // The prototype of a write handler.
< //
< // The write handler is called when the emitter needs to flush the accumulated
< // characters to the output.  The handler should write @a size bytes of the
< // @a buffer to the output.
< //
< // @param[in,out]   data        A pointer to an application data specified by
< //                              yaml_emitter_set_output().
< // @param[in]       buffer      The buffer with bytes to be written.
< // @param[in]       size        The size of the buffer.
< //
< // @returns On success, the handler should return @c 1.  If the handler failed,
< // the returned value should be @c 0.
< //
< type yaml_write_handler_t func(emitter *yaml_emitter_t, buffer []byte) error
< 
< type yaml_emitter_state_t int
< 
< // The emitter states.
< const (
< 	// Expect STREAM-START.
< 	yaml_EMIT_STREAM_START_STATE yaml_emitter_state_t = iota
< 
< 	yaml_EMIT_FIRST_DOCUMENT_START_STATE       // Expect the first DOCUMENT-START or STREAM-END.
< 	yaml_EMIT_DOCUMENT_START_STATE             // Expect DOCUMENT-START or STREAM-END.
< 	yaml_EMIT_DOCUMENT_CONTENT_STATE           // Expect the content of a document.
< 	yaml_EMIT_DOCUMENT_END_STATE               // Expect DOCUMENT-END.
< 	yaml_EMIT_FLOW_SEQUENCE_FIRST_ITEM_STATE   // Expect the first item of a flow sequence.
< 	yaml_EMIT_FLOW_SEQUENCE_TRAIL_ITEM_STATE   // Expect the next item of a flow sequence, with the comma already written out
< 	yaml_EMIT_FLOW_SEQUENCE_ITEM_STATE         // Expect an item of a flow sequence.
< 	yaml_EMIT_FLOW_MAPPING_FIRST_KEY_STATE     // Expect the first key of a flow mapping.
< 	yaml_EMIT_FLOW_MAPPING_TRAIL_KEY_STATE     // Expect the next key of a flow mapping, with the comma already written out
< 	yaml_EMIT_FLOW_MAPPING_KEY_STATE           // Expect a key of a flow mapping.
< 	yaml_EMIT_FLOW_MAPPING_SIMPLE_VALUE_STATE  // Expect a value for a simple key of a flow mapping.
< 	yaml_EMIT_FLOW_MAPPING_VALUE_STATE         // Expect a value of a flow mapping.
< 	yaml_EMIT_BLOCK_SEQUENCE_FIRST_ITEM_STATE  // Expect the first item of a block sequence.
< 	yaml_EMIT_BLOCK_SEQUENCE_ITEM_STATE        // Expect an item of a block sequence.
< 	yaml_EMIT_BLOCK_MAPPING_FIRST_KEY_STATE    // Expect the first key of a block mapping.
< 	yaml_EMIT_BLOCK_MAPPING_KEY_STATE          // Expect the key of a block mapping.
< 	yaml_EMIT_BLOCK_MAPPING_SIMPLE_VALUE_STATE // Expect a value for a simple key of a block mapping.
< 	yaml_EMIT_BLOCK_MAPPING_VALUE_STATE        // Expect a value of a block mapping.
< 	yaml_EMIT_END_STATE                        // Expect nothing.
< )
< 
< // The emitter structure.
< //
< // All members are internal.  Manage the structure using the @c yaml_emitter_
< // family of functions.
< type yaml_emitter_t struct {
< 
< 	// Error handling
< 
< 	error   yaml_error_type_t // Error type.
< 	problem string            // Error description.
< 
< 	// Writer stuff
< 
< 	write_handler yaml_write_handler_t // Write handler.
< 
< 	output_buffer *[]byte   // String output data.
< 	output_writer io.Writer // File output data.
< 
< 	buffer     []byte // The working buffer.
< 	buffer_pos int    // The current position of the buffer.
< 
< 	raw_buffer     []byte // The raw buffer.
< 	raw_buffer_pos int    // The current position of the buffer.
< 
< 	encoding yaml_encoding_t // The stream encoding.
< 
< 	// Emitter stuff
< 
< 	canonical   bool         // If the output is in the canonical style?
< 	best_indent int          // The number of indentation spaces.
< 	best_width  int          // The preferred width of the output lines.
< 	unicode     bool         // Allow unescaped non-ASCII characters?
< 	line_break  yaml_break_t // The preferred line break.
< 
< 	state  yaml_emitter_state_t   // The current emitter state.
< 	states []yaml_emitter_state_t // The stack of states.
< 
< 	events      []yaml_event_t // The event queue.
< 	events_head int            // The head of the event queue.
< 
< 	indents []int // The stack of indentation levels.
< 
< 	tag_directives []yaml_tag_directive_t // The list of tag directives.
< 
< 	indent int // The current indentation level.
< 
< 	flow_level int // The current flow level.
< 
< 	root_context       bool // Is it the document root context?
< 	sequence_context   bool // Is it a sequence context?
< 	mapping_context    bool // Is it a mapping context?
< 	simple_key_context bool // Is it a simple mapping key context?
< 
< 	line       int  // The current line.
< 	column     int  // The current column.
< 	whitespace bool // If the last character was a whitespace?
< 	indention  bool // If the last character was an indentation character (' ', '-', '?', ':')?
< 	open_ended bool // If an explicit document end is required?
< 
< 	space_above bool // Is there's an empty line above?
< 	foot_indent int  // The indent used to write the foot comment above, or -1 if none.
< 
< 	// Anchor analysis.
< 	anchor_data struct {
< 		anchor []byte // The anchor value.
< 		alias  bool   // Is it an alias?
< 	}
< 
< 	// Tag analysis.
< 	tag_data struct {
< 		handle []byte // The tag handle.
< 		suffix []byte // The tag suffix.
< 	}
< 
< 	// Scalar analysis.
< 	scalar_data struct {
< 		value                 []byte              // The scalar value.
< 		multiline             bool                // Does the scalar contain line breaks?
< 		flow_plain_allowed    bool                // Can the scalar be expessed in the flow plain style?
< 		block_plain_allowed   bool                // Can the scalar be expressed in the block plain style?
< 		single_quoted_allowed bool                // Can the scalar be expressed in the single quoted style?
< 		block_allowed         bool                // Can the scalar be expressed in the literal or folded styles?
< 		style                 yaml_scalar_style_t // The output style.
< 	}
< 
< 	// Comments
< 	head_comment []byte
< 	line_comment []byte
< 	foot_comment []byte
< 	tail_comment []byte
< 
< 	// Dumper stuff
< 
< 	opened bool // If the stream was already opened?
< 	closed bool // If the stream was already closed?
< 
< 	// The information associated with the document nodes.
< 	anchors *struct {
< 		references int  // The number of references.
< 		anchor     int  // The anchor id.
< 		serialized bool // If the node has been emitted?
< 	}
< 
< 	last_anchor_id int // The last assigned anchor id.
< 
< 	document *yaml_document_t // The currently emitted document.
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/yamlprivateh.go updated/vendor/github.com/coreos/fcct/vendor/gopkg.in/yaml.v3/yamlprivateh.go
1,198d0
< // 
< // Copyright (c) 2011-2019 Canonical Ltd
< // Copyright (c) 2006-2010 Kirill Simonov
< // 
< // Permission is hereby granted, free of charge, to any person obtaining a copy of
< // this software and associated documentation files (the "Software"), to deal in
< // the Software without restriction, including without limitation the rights to
< // use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
< // of the Software, and to permit persons to whom the Software is furnished to do
< // so, subject to the following conditions:
< // 
< // The above copyright notice and this permission notice shall be included in all
< // copies or substantial portions of the Software.
< // 
< // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
< // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
< // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
< // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
< // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
< // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
< // SOFTWARE.
< 
< package yaml
< 
< const (
< 	// The size of the input raw buffer.
< 	input_raw_buffer_size = 512
< 
< 	// The size of the input buffer.
< 	// It should be possible to decode the whole raw buffer.
< 	input_buffer_size = input_raw_buffer_size * 3
< 
< 	// The size of the output buffer.
< 	output_buffer_size = 128
< 
< 	// The size of the output raw buffer.
< 	// It should be possible to encode the whole output buffer.
< 	output_raw_buffer_size = (output_buffer_size*2 + 2)
< 
< 	// The size of other stacks and queues.
< 	initial_stack_size  = 16
< 	initial_queue_size  = 16
< 	initial_string_size = 16
< )
< 
< // Check if the character at the specified position is an alphabetical
< // character, a digit, '_', or '-'.
< func is_alpha(b []byte, i int) bool {
< 	return b[i] >= '0' && b[i] <= '9' || b[i] >= 'A' && b[i] <= 'Z' || b[i] >= 'a' && b[i] <= 'z' || b[i] == '_' || b[i] == '-'
< }
< 
< // Check if the character at the specified position is a digit.
< func is_digit(b []byte, i int) bool {
< 	return b[i] >= '0' && b[i] <= '9'
< }
< 
< // Get the value of a digit.
< func as_digit(b []byte, i int) int {
< 	return int(b[i]) - '0'
< }
< 
< // Check if the character at the specified position is a hex-digit.
< func is_hex(b []byte, i int) bool {
< 	return b[i] >= '0' && b[i] <= '9' || b[i] >= 'A' && b[i] <= 'F' || b[i] >= 'a' && b[i] <= 'f'
< }
< 
< // Get the value of a hex-digit.
< func as_hex(b []byte, i int) int {
< 	bi := b[i]
< 	if bi >= 'A' && bi <= 'F' {
< 		return int(bi) - 'A' + 10
< 	}
< 	if bi >= 'a' && bi <= 'f' {
< 		return int(bi) - 'a' + 10
< 	}
< 	return int(bi) - '0'
< }
< 
< // Check if the character is ASCII.
< func is_ascii(b []byte, i int) bool {
< 	return b[i] <= 0x7F
< }
< 
< // Check if the character at the start of the buffer can be printed unescaped.
< func is_printable(b []byte, i int) bool {
< 	return ((b[i] == 0x0A) || // . == #x0A
< 		(b[i] >= 0x20 && b[i] <= 0x7E) || // #x20 <= . <= #x7E
< 		(b[i] == 0xC2 && b[i+1] >= 0xA0) || // #0xA0 <= . <= #xD7FF
< 		(b[i] > 0xC2 && b[i] < 0xED) ||
< 		(b[i] == 0xED && b[i+1] < 0xA0) ||
< 		(b[i] == 0xEE) ||
< 		(b[i] == 0xEF && // #xE000 <= . <= #xFFFD
< 			!(b[i+1] == 0xBB && b[i+2] == 0xBF) && // && . != #xFEFF
< 			!(b[i+1] == 0xBF && (b[i+2] == 0xBE || b[i+2] == 0xBF))))
< }
< 
< // Check if the character at the specified position is NUL.
< func is_z(b []byte, i int) bool {
< 	return b[i] == 0x00
< }
< 
< // Check if the beginning of the buffer is a BOM.
< func is_bom(b []byte, i int) bool {
< 	return b[0] == 0xEF && b[1] == 0xBB && b[2] == 0xBF
< }
< 
< // Check if the character at the specified position is space.
< func is_space(b []byte, i int) bool {
< 	return b[i] == ' '
< }
< 
< // Check if the character at the specified position is tab.
< func is_tab(b []byte, i int) bool {
< 	return b[i] == '\t'
< }
< 
< // Check if the character at the specified position is blank (space or tab).
< func is_blank(b []byte, i int) bool {
< 	//return is_space(b, i) || is_tab(b, i)
< 	return b[i] == ' ' || b[i] == '\t'
< }
< 
< // Check if the character at the specified position is a line break.
< func is_break(b []byte, i int) bool {
< 	return (b[i] == '\r' || // CR (#xD)
< 		b[i] == '\n' || // LF (#xA)
< 		b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9) // PS (#x2029)
< }
< 
< func is_crlf(b []byte, i int) bool {
< 	return b[i] == '\r' && b[i+1] == '\n'
< }
< 
< // Check if the character is a line break or NUL.
< func is_breakz(b []byte, i int) bool {
< 	//return is_break(b, i) || is_z(b, i)
< 	return (
< 		// is_break:
< 		b[i] == '\r' || // CR (#xD)
< 		b[i] == '\n' || // LF (#xA)
< 		b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
< 		// is_z:
< 		b[i] == 0)
< }
< 
< // Check if the character is a line break, space, or NUL.
< func is_spacez(b []byte, i int) bool {
< 	//return is_space(b, i) || is_breakz(b, i)
< 	return (
< 		// is_space:
< 		b[i] == ' ' ||
< 		// is_breakz:
< 		b[i] == '\r' || // CR (#xD)
< 		b[i] == '\n' || // LF (#xA)
< 		b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
< 		b[i] == 0)
< }
< 
< // Check if the character is a line break, space, tab, or NUL.
< func is_blankz(b []byte, i int) bool {
< 	//return is_blank(b, i) || is_breakz(b, i)
< 	return (
< 		// is_blank:
< 		b[i] == ' ' || b[i] == '\t' ||
< 		// is_breakz:
< 		b[i] == '\r' || // CR (#xD)
< 		b[i] == '\n' || // LF (#xA)
< 		b[i] == 0xC2 && b[i+1] == 0x85 || // NEL (#x85)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA8 || // LS (#x2028)
< 		b[i] == 0xE2 && b[i+1] == 0x80 && b[i+2] == 0xA9 || // PS (#x2029)
< 		b[i] == 0)
< }
< 
< // Determine the width of the character.
< func width(b byte) int {
< 	// Don't replace these by a switch without first
< 	// confirming that it is being inlined.
< 	if b&0x80 == 0x00 {
< 		return 1
< 	}
< 	if b&0xE0 == 0xC0 {
< 		return 2
< 	}
< 	if b&0xF0 == 0xE0 {
< 		return 3
< 	}
< 	if b&0xF8 == 0xF0 {
< 		return 4
< 	}
< 	return 0
< 
< }
diff --no-dereference -N -r current/vendor/github.com/coreos/fcct/vendor/modules.txt updated/vendor/github.com/coreos/fcct/vendor/modules.txt
1,41d0
< # github.com/clarketm/json v1.14.1
< github.com/clarketm/json
< # github.com/coreos/go-json v0.0.0-20170920214419-6a2fe990e083
< github.com/coreos/go-json
< # github.com/coreos/go-semver v0.3.0
< github.com/coreos/go-semver/semver
< # github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e
< github.com/coreos/go-systemd/unit
< # github.com/coreos/go-systemd/v22 v22.0.0
< github.com/coreos/go-systemd/v22/unit
< # github.com/coreos/ignition/v2 v2.8.1
< github.com/coreos/ignition/v2/config/merge
< github.com/coreos/ignition/v2/config/shared/errors
< github.com/coreos/ignition/v2/config/shared/validations
< github.com/coreos/ignition/v2/config/util
< github.com/coreos/ignition/v2/config/v3_0/types
< github.com/coreos/ignition/v2/config/v3_1/types
< github.com/coreos/ignition/v2/config/v3_2/types
< github.com/coreos/ignition/v2/config/v3_3_experimental/types
< github.com/coreos/ignition/v2/config/validate
< # github.com/coreos/vcontext v0.0.0-20201120045928-b0e13dab675c
< github.com/coreos/vcontext/json
< github.com/coreos/vcontext/path
< github.com/coreos/vcontext/report
< github.com/coreos/vcontext/tree
< github.com/coreos/vcontext/validate
< github.com/coreos/vcontext/yaml
< # github.com/davecgh/go-spew v1.1.1
< github.com/davecgh/go-spew/spew
< # github.com/pmezard/go-difflib v1.0.0
< github.com/pmezard/go-difflib/difflib
< # github.com/spf13/pflag v1.0.5
< github.com/spf13/pflag
< # github.com/stretchr/testify v1.5.1
< github.com/stretchr/testify/assert
< # github.com/vincent-petithory/dataurl v0.0.0-20160330182126-9a301d65acbb
< github.com/vincent-petithory/dataurl
< # gopkg.in/yaml.v2 v2.2.2
< gopkg.in/yaml.v2
< # gopkg.in/yaml.v3 v3.0.0-20191010095647-fc94e3f71652
< gopkg.in/yaml.v3
